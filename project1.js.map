)]}'
{"version":3,"file":"project1.js","sources":["../pas2js-win64-x86_64-3.0.1/packages/rtl/src/rtl.js","../pas2js-win64-x86_64-3.0.1/packages/rtl/src/system.pas","../pas2js-win64-x86_64-3.0.1/packages/rtl/src/rtlconsts.pas","../pas2js-win64-x86_64-3.0.1/packages/rtl/src/types.pas","../pas2js-win64-x86_64-3.0.1/packages/rtl/src/js.pas","../pas2js-win64-x86_64-3.0.1/packages/rtl/src/sysutils.pas","../pas2js-win64-x86_64-3.0.1/packages/rtl/src/classes.pas","../pas2js-win64-x86_64-3.0.1/packages/rtl/src/weborworker.pas","../pas2js-win64-x86_64-3.0.1/packages/rtl/src/web.pas","../pas2js-win64-x86_64-3.0.1/packages/fcl-base/src/custapp.pas","../pas2js-win64-x86_64-3.0.1/packages/fcl-base/src/browserapp.pas","../pas2js-win64-x86_64-3.0.1/packages/rtl/src/strutils.pas","../pas2js-win64-x86_64-3.0.1/packages/webwidget/src/webwidget.pas","../pas2js-win64-x86_64-3.0.1/packages/webwidget/src/htmlwidgets.pp","project1.lpr"],"sourcesContent":["var pas = { $libimports: {}};\r\n\r\nvar rtl = {\r\n\r\n  version: 30001,\r\n\r\n  quiet: false,\r\n  debug_load_units: false,\r\n  debug_rtti: false,\r\n\r\n  $res : {},\r\n\r\n  debug: function(){\r\n    if (rtl.quiet || !console || !console.log) return;\r\n    console.log(arguments);\r\n  },\r\n\r\n  error: function(s){\r\n    rtl.debug('Error: ',s);\r\n    throw s;\r\n  },\r\n\r\n  warn: function(s){\r\n    rtl.debug('Warn: ',s);\r\n  },\r\n\r\n  checkVersion: function(v){\r\n    if (rtl.version != v) throw \"expected rtl version \"+v+\", but found \"+rtl.version;\r\n  },\r\n\r\n  hiInt: Math.pow(2,53),\r\n\r\n  hasString: function(s){\r\n    return rtl.isString(s) && (s.length>0);\r\n  },\r\n\r\n  isArray: function(a) {\r\n    return Array.isArray(a);\r\n  },\r\n\r\n  isFunction: function(f){\r\n    return typeof(f)===\"function\";\r\n  },\r\n\r\n  isModule: function(m){\r\n    return rtl.isObject(m) && rtl.hasString(m.$name) && (pas[m.$name]===m);\r\n  },\r\n\r\n  isImplementation: function(m){\r\n    return rtl.isObject(m) && rtl.isModule(m.$module) && (m.$module.$impl===m);\r\n  },\r\n\r\n  isNumber: function(n){\r\n    return typeof(n)===\"number\";\r\n  },\r\n\r\n  isObject: function(o){\r\n    var s=typeof(o);\r\n    return (typeof(o)===\"object\") && (o!=null);\r\n  },\r\n\r\n  isString: function(s){\r\n    return typeof(s)===\"string\";\r\n  },\r\n\r\n  getNumber: function(n){\r\n    return typeof(n)===\"number\"?n:NaN;\r\n  },\r\n\r\n  getChar: function(c){\r\n    return ((typeof(c)===\"string\") && (c.length===1)) ? c : \"\";\r\n  },\r\n\r\n  getObject: function(o){\r\n    return ((typeof(o)===\"object\") || (typeof(o)==='function')) ? o : null;\r\n  },\r\n\r\n  isTRecord: function(type){\r\n    return (rtl.isObject(type) && type.hasOwnProperty('$new') && (typeof(type.$new)==='function'));\r\n  },\r\n\r\n  isPasClass: function(type){\r\n    return (rtl.isObject(type) && type.hasOwnProperty('$classname') && rtl.isObject(type.$module));\r\n  },\r\n\r\n  isPasClassInstance: function(type){\r\n    return (rtl.isObject(type) && rtl.isPasClass(type.$class));\r\n  },\r\n\r\n  hexStr: function(n,digits){\r\n    return (\"000000000000000\"+n.toString(16).toUpperCase()).slice(-digits);\r\n  },\r\n\r\n  m_loading: 0,\r\n  m_loading_intf: 1,\r\n  m_intf_loaded: 2,\r\n  m_loading_impl: 3, // loading all used unit\r\n  m_initializing: 4, // running initialization\r\n  m_initialized: 5,\r\n\r\n  module: function(module_name, intfuseslist, intfcode, impluseslist){\r\n    if (rtl.debug_load_units) rtl.debug('rtl.module name=\"'+module_name+'\" intfuses='+intfuseslist+' impluses='+impluseslist);\r\n    if (!rtl.hasString(module_name)) rtl.error('invalid module name \"'+module_name+'\"');\r\n    if (!rtl.isArray(intfuseslist)) rtl.error('invalid interface useslist of \"'+module_name+'\"');\r\n    if (!rtl.isFunction(intfcode)) rtl.error('invalid interface code of \"'+module_name+'\"');\r\n    if (!(impluseslist==undefined) && !rtl.isArray(impluseslist)) rtl.error('invalid implementation useslist of \"'+module_name+'\"');\r\n\r\n    if (pas[module_name])\r\n      rtl.error('module \"'+module_name+'\" is already registered');\r\n\r\n    var r = Object.create(rtl.tSectionRTTI);\r\n    var module = r.$module = pas[module_name] = {\r\n      $name: module_name,\r\n      $intfuseslist: intfuseslist,\r\n      $impluseslist: impluseslist,\r\n      $state: rtl.m_loading,\r\n      $intfcode: intfcode,\r\n      $implcode: null,\r\n      $impl: null,\r\n      $rtti: r\r\n    };\r\n    if (impluseslist) module.$impl = {\r\n          $module: module,\r\n          $rtti: r\r\n        };\r\n  },\r\n\r\n  exitcode: 0,\r\n\r\n  run: function(module_name){\r\n    try {\r\n      if (!rtl.hasString(module_name)) module_name='program';\r\n      if (rtl.debug_load_units) rtl.debug('rtl.run module=\"'+module_name+'\"');\r\n      rtl.initRTTI();\r\n      var module = pas[module_name];\r\n      if (!module) rtl.error('rtl.run module \"'+module_name+'\" missing');\r\n      rtl.loadintf(module);\r\n      rtl.loadimpl(module);\r\n      if ((module_name=='program') || (module_name=='library')){\r\n        if (rtl.debug_load_units) rtl.debug('running $main');\r\n        var r = pas[module_name].$main();\r\n        if (rtl.isNumber(r)) rtl.exitcode = r;\r\n      }\r\n    } catch(re) {\r\n      if (!rtl.showUncaughtExceptions) {\r\n        throw re\r\n      } else {  \r\n        if (!rtl.handleUncaughtException(re)) {\r\n          rtl.showException(re);\r\n          rtl.exitcode = 216;\r\n        }  \r\n      }\r\n    } \r\n    return rtl.exitcode;\r\n  },\r\n  \r\n  showException : function (re) {\r\n    var errMsg = rtl.hasString(re.$classname) ? re.$classname : '';\r\n    errMsg +=  ((errMsg) ? ': ' : '') + (re.hasOwnProperty('fMessage') ? re.fMessage : re);\r\n    alert('Uncaught Exception : '+errMsg);\r\n  },\r\n\r\n  handleUncaughtException: function (e) {\r\n    if (rtl.onUncaughtException) {\r\n      try {\r\n        rtl.onUncaughtException(e);\r\n        return true;\r\n      } catch (ee) {\r\n        return false; \r\n      }\r\n    } else {\r\n      return false;\r\n    }\r\n  },\r\n\r\n  loadintf: function(module){\r\n    if (module.$state>rtl.m_loading_intf) return; // already finished\r\n    if (rtl.debug_load_units) rtl.debug('loadintf: \"'+module.$name+'\"');\r\n    if (module.$state===rtl.m_loading_intf)\r\n      rtl.error('unit cycle detected \"'+module.$name+'\"');\r\n    module.$state=rtl.m_loading_intf;\r\n    // load interfaces of interface useslist\r\n    rtl.loaduseslist(module,module.$intfuseslist,rtl.loadintf);\r\n    // run interface\r\n    if (rtl.debug_load_units) rtl.debug('loadintf: run intf of \"'+module.$name+'\"');\r\n    module.$intfcode(module.$intfuseslist);\r\n    // success\r\n    module.$state=rtl.m_intf_loaded;\r\n    // Note: units only used in implementations are not yet loaded (not even their interfaces)\r\n  },\r\n\r\n  loaduseslist: function(module,useslist,f){\r\n    if (useslist==undefined) return;\r\n    var len = useslist.length;\r\n    for (var i = 0; i<len; i++) {\r\n      var unitname=useslist[i];\r\n      if (rtl.debug_load_units) rtl.debug('loaduseslist of \"'+module.$name+'\" uses=\"'+unitname+'\"');\r\n      if (pas[unitname]==undefined)\r\n        rtl.error('module \"'+module.$name+'\" misses \"'+unitname+'\"');\r\n      f(pas[unitname]);\r\n    }\r\n  },\r\n\r\n  loadimpl: function(module){\r\n    if (module.$state>=rtl.m_loading_impl) return; // already processing\r\n    if (module.$state<rtl.m_intf_loaded) rtl.error('loadimpl: interface not loaded of \"'+module.$name+'\"');\r\n    if (rtl.debug_load_units) rtl.debug('loadimpl: load uses of \"'+module.$name+'\"');\r\n    module.$state=rtl.m_loading_impl;\r\n    // load interfaces of implementation useslist\r\n    rtl.loaduseslist(module,module.$impluseslist,rtl.loadintf);\r\n    // load implementation of interfaces useslist\r\n    rtl.loaduseslist(module,module.$intfuseslist,rtl.loadimpl);\r\n    // load implementation of implementation useslist\r\n    rtl.loaduseslist(module,module.$impluseslist,rtl.loadimpl);\r\n    // Note: At this point all interfaces used by this unit are loaded. If\r\n    //   there are implementation uses cycles some used units might not yet be\r\n    //   initialized. This is by design.\r\n    // run implementation\r\n    if (rtl.debug_load_units) rtl.debug('loadimpl: run impl of \"'+module.$name+'\"');\r\n    if (rtl.isFunction(module.$implcode)) module.$implcode(module.$impluseslist);\r\n    // run initialization\r\n    if (rtl.debug_load_units) rtl.debug('loadimpl: run init of \"'+module.$name+'\"');\r\n    module.$state=rtl.m_initializing;\r\n    if (rtl.isFunction(module.$init)) module.$init();\r\n    // unit initialized\r\n    module.$state=rtl.m_initialized;\r\n  },\r\n\r\n  createCallback: function(scope, fn){\r\n    var cb;\r\n    if (typeof(fn)==='string'){\r\n      if (!scope.hasOwnProperty('$events')) scope.$events = {};\r\n      cb = scope.$events[fn];\r\n      if (cb) return cb;\r\n      scope.$events[fn] = cb = function(){\r\n        return scope[fn].apply(scope,arguments);\r\n      };\r\n    } else {\r\n      cb = function(){\r\n        return fn.apply(scope,arguments);\r\n      };\r\n    };\r\n    cb.scope = scope;\r\n    cb.fn = fn;\r\n    return cb;\r\n  },\r\n\r\n  createSafeCallback: function(scope, fn){\r\n    var cb;\r\n    if (typeof(fn)==='string'){\r\n      if (!scope[fn]) return null;\r\n      if (!scope.hasOwnProperty('$events')) scope.$events = {};\r\n      cb = scope.$events[fn];\r\n      if (cb) return cb;\r\n      scope.$events[fn] = cb = function(){\r\n        try{\r\n          return scope[fn].apply(scope,arguments);\r\n        } catch (err) {\r\n          if (!rtl.handleUncaughtException(err)) throw err;\r\n        }\r\n      };\r\n    } else if(!fn) {\r\n      return null;\r\n    } else {\r\n      cb = function(){\r\n        try{\r\n          return fn.apply(scope,arguments);\r\n        } catch (err) {\r\n          if (!rtl.handleUncaughtException(err)) throw err;\r\n        }\r\n      };\r\n    };\r\n    cb.scope = scope;\r\n    cb.fn = fn;\r\n    return cb;\r\n  },\r\n\r\n  eqCallback: function(a,b){\r\n    // can be a function or a function wrapper\r\n    if (a===b){\r\n      return true;\r\n    } else {\r\n      return (a!=null) && (b!=null) && (a.fn) && (a.scope===b.scope) && (a.fn===b.fn);\r\n    }\r\n  },\r\n\r\n  initStruct: function(c,parent,name){\r\n    if ((parent.$module) && (parent.$module.$impl===parent)) parent=parent.$module;\r\n    c.$parent = parent;\r\n    if (rtl.isModule(parent)){\r\n      c.$module = parent;\r\n      c.$name = name;\r\n    } else {\r\n      c.$module = parent.$module;\r\n      c.$name = parent.$name+'.'+name;\r\n    };\r\n    return parent;\r\n  },\r\n\r\n  initClass: function(c,parent,name,initfn,rttiname){\r\n    parent[name] = c;\r\n    c.$class = c; // Note: o.$class === Object.getPrototypeOf(o)\r\n    c.$classname = rttiname?rttiname:name;\r\n    parent = rtl.initStruct(c,parent,name);\r\n    c.$fullname = parent.$name+'.'+name;\r\n    // rtti\r\n    if (rtl.debug_rtti) rtl.debug('initClass '+c.$fullname);\r\n    var t = c.$module.$rtti.$Class(c.$classname,{ \"class\": c });\r\n    c.$rtti = t;\r\n    if (rtl.isObject(c.$ancestor)) t.ancestor = c.$ancestor.$rtti;\r\n    if (!t.ancestor) t.ancestor = null;\r\n    // init members\r\n    initfn.call(c);\r\n  },\r\n\r\n  createClass: function(parent,name,ancestor,initfn,rttiname){\r\n    // create a normal class,\r\n    // ancestor must be null or a normal class,\r\n    // the root ancestor can be an external class\r\n    var c = null;\r\n    if (ancestor != null){\r\n      c = Object.create(ancestor);\r\n      c.$ancestor = ancestor;\r\n      // Note:\r\n      // if root is an \"object\" then c.$ancestor === Object.getPrototypeOf(c)\r\n      // if root is a \"function\" then c.$ancestor === c.__proto__, Object.getPrototypeOf(c) returns the root\r\n    } else {\r\n      c = { $ancestor: null };\r\n      c.$create = function(fn,args){\r\n        if (args == undefined) args = [];\r\n        var o = Object.create(this);\r\n        o.$init();\r\n        try{\r\n          if (typeof(fn)===\"string\"){\r\n            o[fn].apply(o,args);\r\n          } else {\r\n            fn.apply(o,args);\r\n          };\r\n          o.AfterConstruction();\r\n        } catch($e){\r\n          // do not call BeforeDestruction\r\n          if (o.Destroy) o.Destroy();\r\n          o.$final();\r\n          throw $e;\r\n        }\r\n        return o;\r\n      };\r\n      c.$destroy = function(fnname){\r\n        this.BeforeDestruction();\r\n        if (this[fnname]) this[fnname]();\r\n        this.$final();\r\n      };\r\n    };\r\n    rtl.initClass(c,parent,name,initfn,rttiname);\r\n  },\r\n\r\n  createClassExt: function(parent,name,ancestor,newinstancefnname,initfn,rttiname){\r\n    // Create a class using an external ancestor.\r\n    // If newinstancefnname is given, use that function to create the new object.\r\n    // If exist call BeforeDestruction and AfterConstruction.\r\n    var isFunc = rtl.isFunction(ancestor);\r\n    var c = null;\r\n    if (isFunc){\r\n      // create pascal class descendent from JS function\r\n      c = Object.create(ancestor.prototype);\r\n      c.$ancestorfunc = ancestor;\r\n      c.$ancestor = null; // no pascal ancestor\r\n    } else if (ancestor.$func){\r\n      // create pascal class descendent from a pascal class descendent of a JS function\r\n      isFunc = true;\r\n      c = Object.create(ancestor);\r\n      c.$ancestor = ancestor;\r\n    } else {\r\n      c = Object.create(ancestor);\r\n      c.$ancestor = null; // no pascal ancestor\r\n    }\r\n    c.$create = function(fn,args){\r\n      if (args == undefined) args = [];\r\n      var o = null;\r\n      if (newinstancefnname.length>0){\r\n        o = this[newinstancefnname](fn,args);\r\n      } else if(isFunc) {\r\n        o = new this.$func(args);\r\n      } else {\r\n        o = Object.create(c);\r\n      }\r\n      if (o.$init) o.$init();\r\n      try{\r\n        if (typeof(fn)===\"string\"){\r\n          this[fn].apply(o,args);\r\n        } else {\r\n          fn.apply(o,args);\r\n        };\r\n        if (o.AfterConstruction) o.AfterConstruction();\r\n      } catch($e){\r\n        // do not call BeforeDestruction\r\n        if (o.Destroy) o.Destroy();\r\n        if (o.$final) o.$final();\r\n        throw $e;\r\n      }\r\n      return o;\r\n    };\r\n    c.$destroy = function(fnname){\r\n      if (this.BeforeDestruction) this.BeforeDestruction();\r\n      if (this[fnname]) this[fnname]();\r\n      if (this.$final) this.$final();\r\n    };\r\n    rtl.initClass(c,parent,name,initfn,rttiname);\r\n    if (isFunc){\r\n      function f(){}\r\n      f.prototype = c;\r\n      c.$func = f;\r\n    }\r\n  },\r\n\r\n  createHelper: function(parent,name,ancestor,initfn,rttiname){\r\n    // create a helper,\r\n    // ancestor must be null or a helper,\r\n    var c = null;\r\n    if (ancestor != null){\r\n      c = Object.create(ancestor);\r\n      c.$ancestor = ancestor;\r\n      // c.$ancestor === Object.getPrototypeOf(c)\r\n    } else {\r\n      c = { $ancestor: null };\r\n    };\r\n    parent[name] = c;\r\n    c.$class = c; // Note: o.$class === Object.getPrototypeOf(o)\r\n    c.$classname = rttiname?rttiname:name;\r\n    parent = rtl.initStruct(c,parent,name);\r\n    c.$fullname = parent.$name+'.'+name;\r\n    // rtti\r\n    var t = c.$module.$rtti.$Helper(c.$classname,{ \"helper\": c });\r\n    c.$rtti = t;\r\n    if (rtl.isObject(ancestor)) t.ancestor = ancestor.$rtti;\r\n    if (!t.ancestor) t.ancestor = null;\r\n    // init members\r\n    initfn.call(c);\r\n  },\r\n\r\n  tObjectDestroy: \"Destroy\",\r\n\r\n  free: function(obj,name){\r\n    if (obj[name]==null) return null;\r\n    obj[name].$destroy(rtl.tObjectDestroy);\r\n    obj[name]=null;\r\n  },\r\n\r\n  freeLoc: function(obj){\r\n    if (obj==null) return null;\r\n    obj.$destroy(rtl.tObjectDestroy);\r\n    return null;\r\n  },\r\n\r\n  hideProp: function(o,p,v){\r\n    Object.defineProperty(o,p, {\r\n      enumerable: false,\r\n      configurable: true,\r\n      writable: true\r\n    });\r\n    if(arguments.length>2){ o[p]=v; }\r\n  },\r\n\r\n  recNewT: function(parent,name,initfn,full){\r\n    // create new record type\r\n    var t = {};\r\n    if (parent) parent[name] = t;\r\n    var h = rtl.hideProp;\r\n    if (full){\r\n      rtl.initStruct(t,parent,name);\r\n      t.$record = t;\r\n      h(t,'$record');\r\n      h(t,'$name');\r\n      h(t,'$parent');\r\n      h(t,'$module');\r\n      h(t,'$initSpec');\r\n    }\r\n    initfn.call(t);\r\n    if (!t.$new){\r\n      t.$new = function(){ return Object.create(t); };\r\n    }\r\n    t.$clone = function(r){ return t.$new().$assign(r); };\r\n    h(t,'$new');\r\n    h(t,'$clone');\r\n    h(t,'$eq');\r\n    h(t,'$assign');\r\n    return t;\r\n  },\r\n\r\n  is: function(instance,type){\r\n    return type.isPrototypeOf(instance) || (instance===type);\r\n  },\r\n\r\n  isExt: function(instance,type,mode){\r\n    // mode===1 means instance must be a Pascal class instance\r\n    // mode===2 means instance must be a Pascal class\r\n    // Notes:\r\n    // isPrototypeOf and instanceof return false on equal\r\n    // isPrototypeOf does not work for Date.isPrototypeOf(new Date())\r\n    //   so if isPrototypeOf is false test with instanceof\r\n    // instanceof needs a function on right side\r\n    if (instance == null) return false; // Note: ==null checks for undefined too\r\n    if ((typeof(type) !== 'object') && (typeof(type) !== 'function')) return false;\r\n    if (instance === type){\r\n      if (mode===1) return false;\r\n      if (mode===2) return rtl.isPasClass(instance);\r\n      return true;\r\n    }\r\n    if (type.isPrototypeOf && type.isPrototypeOf(instance)){\r\n      if (mode===1) return rtl.isPasClassInstance(instance);\r\n      if (mode===2) return rtl.isPasClass(instance);\r\n      return true;\r\n    }\r\n    if ((typeof type == 'function') && (instance instanceof type)) return true;\r\n    return false;\r\n  },\r\n\r\n  Exception: null,\r\n  EInvalidCast: null,\r\n  EAbstractError: null,\r\n  ERangeError: null,\r\n  EIntOverflow: null,\r\n  EPropWriteOnly: null,\r\n\r\n  raiseE: function(typename){\r\n    var t = rtl[typename];\r\n    if (t==null){\r\n      var mod = pas.SysUtils;\r\n      if (!mod) mod = pas.sysutils;\r\n      if (mod){\r\n        t = mod[typename];\r\n        if (!t) t = mod[typename.toLowerCase()];\r\n        if (!t) t = mod['Exception'];\r\n        if (!t) t = mod['exception'];\r\n      }\r\n    }\r\n    if (t){\r\n      if (t.Create){\r\n        throw t.$create(\"Create\");\r\n      } else if (t.create){\r\n        throw t.$create(\"create\");\r\n      }\r\n    }\r\n    if (typename === \"EInvalidCast\") throw \"invalid type cast\";\r\n    if (typename === \"EAbstractError\") throw \"Abstract method called\";\r\n    if (typename === \"ERangeError\") throw \"range error\";\r\n    throw typename;\r\n  },\r\n\r\n  as: function(instance,type){\r\n    if((instance === null) || rtl.is(instance,type)) return instance;\r\n    rtl.raiseE(\"EInvalidCast\");\r\n  },\r\n\r\n  asExt: function(instance,type,mode){\r\n    if((instance === null) || rtl.isExt(instance,type,mode)) return instance;\r\n    rtl.raiseE(\"EInvalidCast\");\r\n  },\r\n\r\n  createInterface: function(module, name, guid, fnnames, ancestor, initfn, rttiname){\r\n    //console.log('createInterface name=\"'+name+'\" guid=\"'+guid+'\" names='+fnnames);\r\n    var i = ancestor?Object.create(ancestor):{};\r\n    module[name] = i;\r\n    i.$module = module;\r\n    i.$name = rttiname?rttiname:name;\r\n    i.$fullname = module.$name+'.'+i.$name;\r\n    i.$guid = guid;\r\n    i.$guidr = null;\r\n    i.$names = fnnames?fnnames:[];\r\n    if (rtl.isFunction(initfn)){\r\n      // rtti\r\n      if (rtl.debug_rtti) rtl.debug('createInterface '+i.$fullname);\r\n      var t = i.$module.$rtti.$Interface(i.$name,{ \"interface\": i, module: module });\r\n      i.$rtti = t;\r\n      if (ancestor) t.ancestor = ancestor.$rtti;\r\n      if (!t.ancestor) t.ancestor = null;\r\n      initfn.call(i);\r\n    }\r\n    return i;\r\n  },\r\n\r\n  strToGUIDR: function(s,g){\r\n    var p = 0;\r\n    function n(l){\r\n      var h = s.substr(p,l);\r\n      p+=l;\r\n      return parseInt(h,16);\r\n    }\r\n    p+=1; // skip {\r\n    g.D1 = n(8);\r\n    p+=1; // skip -\r\n    g.D2 = n(4);\r\n    p+=1; // skip -\r\n    g.D3 = n(4);\r\n    p+=1; // skip -\r\n    if (!g.D4) g.D4=[];\r\n    g.D4[0] = n(2);\r\n    g.D4[1] = n(2);\r\n    p+=1; // skip -\r\n    for(var i=2; i<8; i++) g.D4[i] = n(2);\r\n    return g;\r\n  },\r\n\r\n  guidrToStr: function(g){\r\n    if (g.$intf) return g.$intf.$guid;\r\n    var h = rtl.hexStr;\r\n    var s='{'+h(g.D1,8)+'-'+h(g.D2,4)+'-'+h(g.D3,4)+'-'+h(g.D4[0],2)+h(g.D4[1],2)+'-';\r\n    for (var i=2; i<8; i++) s+=h(g.D4[i],2);\r\n    s+='}';\r\n    return s;\r\n  },\r\n\r\n  createTGUID: function(guid){\r\n    var TGuid = (pas.System)?pas.System.TGuid:pas.system.tguid;\r\n    var g = rtl.strToGUIDR(guid,TGuid.$new());\r\n    return g;\r\n  },\r\n\r\n  getIntfGUIDR: function(intfTypeOrVar){\r\n    if (!intfTypeOrVar) return null;\r\n    if (!intfTypeOrVar.$guidr){\r\n      var g = rtl.createTGUID(intfTypeOrVar.$guid);\r\n      if (!intfTypeOrVar.hasOwnProperty('$guid')) intfTypeOrVar = Object.getPrototypeOf(intfTypeOrVar);\r\n      g.$intf = intfTypeOrVar;\r\n      intfTypeOrVar.$guidr = g;\r\n    }\r\n    return intfTypeOrVar.$guidr;\r\n  },\r\n\r\n  addIntf: function (aclass, intf, map){\r\n    function jmp(fn){\r\n      if (typeof(fn)===\"function\"){\r\n        return function(){ return fn.apply(this.$o,arguments); };\r\n      } else {\r\n        return function(){ rtl.raiseE('EAbstractError'); };\r\n      }\r\n    }\r\n    if(!map) map = {};\r\n    var t = intf;\r\n    var item = Object.create(t);\r\n    if (!aclass.hasOwnProperty('$intfmaps')) aclass.$intfmaps = {};\r\n    aclass.$intfmaps[intf.$guid] = item;\r\n    do{\r\n      var names = t.$names;\r\n      if (!names) break;\r\n      for (var i=0; i<names.length; i++){\r\n        var intfname = names[i];\r\n        var fnname = map[intfname];\r\n        if (!fnname) fnname = intfname;\r\n        //console.log('addIntf: intftype='+t.$name+' index='+i+' intfname=\"'+intfname+'\" fnname=\"'+fnname+'\" old='+typeof(item[intfname]));\r\n        item[intfname] = jmp(aclass[fnname]);\r\n      }\r\n      t = Object.getPrototypeOf(t);\r\n    }while(t!=null);\r\n  },\r\n\r\n  getIntfG: function (obj, guid, query){\r\n    if (!obj) return null;\r\n    //console.log('getIntfG: obj='+obj.$classname+' guid='+guid+' query='+query);\r\n    // search\r\n    var maps = obj.$intfmaps;\r\n    if (!maps) return null;\r\n    var item = maps[guid];\r\n    if (!item) return null;\r\n    // check delegation\r\n    //console.log('getIntfG: obj='+obj.$classname+' guid='+guid+' query='+query+' item='+typeof(item));\r\n    if (typeof item === 'function') return item.call(obj); // delegate. Note: COM contains _AddRef\r\n    // check cache\r\n    var intf = null;\r\n    if (obj.$interfaces){\r\n      intf = obj.$interfaces[guid];\r\n      //console.log('getIntfG: obj='+obj.$classname+' guid='+guid+' cache='+typeof(intf));\r\n    }\r\n    if (!intf){ // intf can be undefined!\r\n      intf = Object.create(item);\r\n      intf.$o = obj;\r\n      if (!obj.$interfaces) obj.$interfaces = {};\r\n      obj.$interfaces[guid] = intf;\r\n    }\r\n    if (typeof(query)==='object'){\r\n      // called by queryIntfT\r\n      var o = null;\r\n      if (intf.QueryInterface(rtl.getIntfGUIDR(query),\r\n          {get:function(){ return o; }, set:function(v){ o=v; }}) === 0){\r\n        return o;\r\n      } else {\r\n        return null;\r\n      }\r\n    } else if(query===2){\r\n      // called by TObject.GetInterfaceByStr\r\n      if (intf.$kind === 'com') intf._AddRef();\r\n    }\r\n    return intf;\r\n  },\r\n\r\n  getIntfT: function(obj,intftype){\r\n    return rtl.getIntfG(obj,intftype.$guid);\r\n  },\r\n\r\n  queryIntfT: function(obj,intftype){\r\n    return rtl.getIntfG(obj,intftype.$guid,intftype);\r\n  },\r\n\r\n  queryIntfIsT: function(obj,intftype){\r\n    var i = rtl.getIntfG(obj,intftype.$guid);\r\n    if (!i) return false;\r\n    if (i.$kind === 'com') i._Release();\r\n    return true;\r\n  },\r\n\r\n  asIntfT: function (obj,intftype){\r\n    var i = rtl.getIntfG(obj,intftype.$guid);\r\n    if (i!==null) return i;\r\n    rtl.raiseEInvalidCast();\r\n  },\r\n\r\n  intfIsIntfT: function(intf,intftype){\r\n    return (intf!==null) && rtl.queryIntfIsT(intf.$o,intftype);\r\n  },\r\n\r\n  intfAsIntfT: function (intf,intftype){\r\n    if (!intf) return null;\r\n    var i = rtl.getIntfG(intf.$o,intftype.$guid);\r\n    if (i) return i;\r\n    rtl.raiseEInvalidCast();\r\n  },\r\n\r\n  intfIsClass: function(intf,classtype){\r\n    return (intf!=null) && (rtl.is(intf.$o,classtype));\r\n  },\r\n\r\n  intfAsClass: function(intf,classtype){\r\n    if (intf==null) return null;\r\n    return rtl.as(intf.$o,classtype);\r\n  },\r\n\r\n  intfToClass: function(intf,classtype){\r\n    if ((intf!==null) && rtl.is(intf.$o,classtype)) return intf.$o;\r\n    return null;\r\n  },\r\n\r\n  // interface reference counting\r\n  intfRefs: { // base object for temporary interface variables\r\n    ref: function(id,intf){\r\n      // called for temporary interface references needing delayed release\r\n      var old = this[id];\r\n      //console.log('rtl.intfRefs.ref: id='+id+' old=\"'+(old?old.$name:'null')+'\" intf=\"'+(intf?intf.$name:'null')+' $o='+(intf?intf.$o:'null'));\r\n      if (old){\r\n        // called again, e.g. in a loop\r\n        delete this[id];\r\n        old._Release(); // may fail\r\n      }\r\n      if(intf) {\r\n        this[id]=intf;\r\n      }\r\n      return intf;\r\n    },\r\n    free: function(){\r\n      //console.log('rtl.intfRefs.free...');\r\n      for (var id in this){\r\n        if (this.hasOwnProperty(id)){\r\n          var intf = this[id];\r\n          if (intf){\r\n            //console.log('rtl.intfRefs.free: id='+id+' '+intf.$name+' $o='+intf.$o.$classname);\r\n            intf._Release();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  createIntfRefs: function(){\r\n    //console.log('rtl.createIntfRefs');\r\n    return Object.create(rtl.intfRefs);\r\n  },\r\n\r\n  setIntfP: function(path,name,value,skipAddRef){\r\n    var old = path[name];\r\n    //console.log('rtl.setIntfP path='+path+' name='+name+' old=\"'+(old?old.$name:'null')+'\" value=\"'+(value?value.$name:'null')+'\"');\r\n    if (old === value) return;\r\n    if (old !== null){\r\n      path[name]=null;\r\n      old._Release();\r\n    }\r\n    if (value !== null){\r\n      if (!skipAddRef) value._AddRef();\r\n      path[name]=value;\r\n    }\r\n  },\r\n\r\n  setIntfL: function(old,value,skipAddRef){\r\n    //console.log('rtl.setIntfL old=\"'+(old?old.$name:'null')+'\" value=\"'+(value?value.$name:'null')+'\"');\r\n    if (old !== value){\r\n      if (value!==null){\r\n        if (!skipAddRef) value._AddRef();\r\n      }\r\n      if (old!==null){\r\n        old._Release();  // Release after AddRef, to avoid double Release if Release creates an exception\r\n      }\r\n    } else if (skipAddRef){\r\n      if (old!==null){\r\n        old._Release();  // value has an AddRef\r\n      }\r\n    }\r\n    return value;\r\n  },\r\n\r\n  _AddRef: function(intf){\r\n    //if (intf) console.log('rtl._AddRef intf=\"'+(intf?intf.$name:'null')+'\"');\r\n    if (intf) intf._AddRef();\r\n    return intf;\r\n  },\r\n\r\n  _Release: function(intf){\r\n    //if (intf) console.log('rtl._Release intf=\"'+(intf?intf.$name:'null')+'\"');\r\n    if (intf) intf._Release();\r\n    return intf;\r\n  },\r\n\r\n  _ReleaseArray: function(a,dim){\r\n    if (!a) return null;\r\n    for (var i=0; i<a.length; i++){\r\n      if (dim<=1){\r\n        if (a[i]) a[i]._Release();\r\n      } else {\r\n        rtl._ReleaseArray(a[i],dim-1);\r\n      }\r\n    }\r\n    return null;\r\n  },\r\n\r\n  trunc: function(a){\r\n    return a<0 ? Math.ceil(a) : Math.floor(a);\r\n  },\r\n\r\n  checkMethodCall: function(obj,type){\r\n    if (rtl.isObject(obj) && rtl.is(obj,type)) return;\r\n    rtl.raiseE(\"EInvalidCast\");\r\n  },\r\n\r\n  oc: function(i){\r\n    // overflow check integer\r\n    if ((Math.floor(i)===i) && (i>=-0x1fffffffffffff) && (i<=0x1fffffffffffff)) return i;\r\n    rtl.raiseE('EIntOverflow');\r\n  },\r\n\r\n  rc: function(i,minval,maxval){\r\n    // range check integer\r\n    if ((Math.floor(i)===i) && (i>=minval) && (i<=maxval)) return i;\r\n    rtl.raiseE('ERangeError');\r\n  },\r\n\r\n  rcc: function(c,minval,maxval){\r\n    // range check char\r\n    if ((typeof(c)==='string') && (c.length===1)){\r\n      var i = c.charCodeAt(0);\r\n      if ((i>=minval) && (i<=maxval)) return c;\r\n    }\r\n    rtl.raiseE('ERangeError');\r\n  },\r\n\r\n  rcSetCharAt: function(s,index,c){\r\n    // range check setCharAt\r\n    if ((typeof(s)!=='string') || (index<0) || (index>=s.length)) rtl.raiseE('ERangeError');\r\n    return rtl.setCharAt(s,index,c);\r\n  },\r\n\r\n  rcCharAt: function(s,index){\r\n    // range check charAt\r\n    if ((typeof(s)!=='string') || (index<0) || (index>=s.length)) rtl.raiseE('ERangeError');\r\n    return s.charAt(index);\r\n  },\r\n\r\n  rcArrR: function(arr,index){\r\n    // range check read array\r\n    if (Array.isArray(arr) && (typeof(index)==='number') && (index>=0) && (index<arr.length)){\r\n      if (arguments.length>2){\r\n        // arr,index1,index2,...\r\n        arr=arr[index];\r\n        for (var i=2; i<arguments.length; i++) arr=rtl.rcArrR(arr,arguments[i]);\r\n        return arr;\r\n      }\r\n      return arr[index];\r\n    }\r\n    rtl.raiseE('ERangeError');\r\n  },\r\n\r\n  rcArrW: function(arr,index,value){\r\n    // range check write array\r\n    // arr,index1,index2,...,value\r\n    for (var i=3; i<arguments.length; i++){\r\n      arr=rtl.rcArrR(arr,index);\r\n      index=arguments[i-1];\r\n      value=arguments[i];\r\n    }\r\n    if (Array.isArray(arr) && (typeof(index)==='number') && (index>=0) && (index<arr.length)){\r\n      return arr[index]=value;\r\n    }\r\n    rtl.raiseE('ERangeError');\r\n  },\r\n\r\n  length: function(arr){\r\n    return (arr == null) ? 0 : arr.length;\r\n  },\r\n\r\n  arrayRef: function(a){\r\n    if (a!=null) rtl.hideProp(a,'$pas2jsrefcnt',1);\r\n    return a;\r\n  },\r\n\r\n  arraySetLength: function(arr,defaultvalue,newlength){\r\n    var stack = [];\r\n    var s = 9999;\r\n    for (var i=2; i<arguments.length; i++){\r\n      var j = arguments[i];\r\n      if (j==='s'){ s = i-2; }\r\n      else {\r\n        stack.push({ dim:j+0, a:null, i:0, src:null });\r\n      }\r\n    }\r\n    var dimmax = stack.length-1;\r\n    var depth = 0;\r\n    var lastlen = 0;\r\n    var item = null;\r\n    var a = null;\r\n    var src = arr;\r\n    var srclen = 0, oldlen = 0;\r\n    do{\r\n      if (depth>0){\r\n        item=stack[depth-1];\r\n        src = (item.src && item.src.length>item.i)?item.src[item.i]:null;\r\n      }\r\n      if (!src){\r\n        a = [];\r\n        srclen = 0;\r\n        oldlen = 0;\r\n      } else if (src.$pas2jsrefcnt>0 || depth>=s){\r\n        a = [];\r\n        srclen = src.length;\r\n        oldlen = srclen;\r\n      } else {\r\n        a = src;\r\n        srclen = 0;\r\n        oldlen = a.length;\r\n      }\r\n      lastlen = stack[depth].dim;\r\n      a.length = lastlen;\r\n      if (depth>0){\r\n        item.a[item.i]=a;\r\n        item.i++;\r\n        if ((lastlen===0) && (item.i<item.a.length)) continue;\r\n      }\r\n      if (lastlen>0){\r\n        if (depth<dimmax){\r\n          item = stack[depth];\r\n          item.a = a;\r\n          item.i = 0;\r\n          item.src = src;\r\n          depth++;\r\n          continue;\r\n        } else {\r\n          if (srclen>lastlen) srclen=lastlen;\r\n          if (rtl.isArray(defaultvalue)){\r\n            // array of dyn array\r\n            for (var i=0; i<srclen; i++) a[i]=src[i];\r\n            for (var i=oldlen; i<lastlen; i++) a[i]=[];\r\n          } else if (rtl.isObject(defaultvalue)) {\r\n            if (rtl.isTRecord(defaultvalue)){\r\n              // array of record\r\n              for (var i=0; i<srclen; i++) a[i]=defaultvalue.$clone(src[i]);\r\n              for (var i=oldlen; i<lastlen; i++) a[i]=defaultvalue.$new();\r\n            } else {\r\n              // array of set\r\n              for (var i=0; i<srclen; i++) a[i]=rtl.refSet(src[i]);\r\n              for (var i=oldlen; i<lastlen; i++) a[i]={};\r\n            }\r\n          } else {\r\n            for (var i=0; i<srclen; i++) a[i]=src[i];\r\n            for (var i=oldlen; i<lastlen; i++) a[i]=defaultvalue;\r\n          }\r\n        }\r\n      }\r\n      // backtrack\r\n      while ((depth>0) && (stack[depth-1].i>=stack[depth-1].dim)){\r\n        depth--;\r\n      };\r\n      if (depth===0){\r\n        if (dimmax===0) return a;\r\n        return stack[0].a;\r\n      }\r\n    }while (true);\r\n  },\r\n\r\n  arrayEq: function(a,b){\r\n    if (a===null) return b===null;\r\n    if (b===null) return false;\r\n    if (a.length!==b.length) return false;\r\n    for (var i=0; i<a.length; i++) if (a[i]!==b[i]) return false;\r\n    return true;\r\n  },\r\n\r\n  arrayClone: function(type,src,srcpos,endpos,dst,dstpos){\r\n    // type: 0 for references, \"refset\" for calling refSet(), a function for new type()\r\n    // src must not be null\r\n    // This function does not range check.\r\n    if(type === 'refSet') {\r\n      for (; srcpos<endpos; srcpos++) dst[dstpos++] = rtl.refSet(src[srcpos]); // ref set\r\n    } else if (type === 'slice'){\r\n      for (; srcpos<endpos; srcpos++) dst[dstpos++] = src[srcpos].slice(0); // clone static array of simple types\r\n    } else if (typeof(type)==='function'){\r\n      for (; srcpos<endpos; srcpos++) dst[dstpos++] = type(src[srcpos]); // clone function\r\n    } else if (rtl.isTRecord(type)){\r\n      for (; srcpos<endpos; srcpos++) dst[dstpos++] = type.$clone(src[srcpos]); // clone record\r\n    }  else {\r\n      for (; srcpos<endpos; srcpos++) dst[dstpos++] = src[srcpos]; // reference\r\n    };\r\n  },\r\n\r\n  arrayConcat: function(type){\r\n    // type: see rtl.arrayClone\r\n    var a = [];\r\n    var l = 0;\r\n    for (var i=1; i<arguments.length; i++){\r\n      var src = arguments[i];\r\n      if (src !== null) l+=src.length;\r\n    };\r\n    a.length = l;\r\n    l=0;\r\n    for (var i=1; i<arguments.length; i++){\r\n      var src = arguments[i];\r\n      if (src === null) continue;\r\n      rtl.arrayClone(type,src,0,src.length,a,l);\r\n      l+=src.length;\r\n    };\r\n    return a;\r\n  },\r\n\r\n  arrayConcatN: function(){\r\n    var a = null;\r\n    for (var i=0; i<arguments.length; i++){\r\n      var src = arguments[i];\r\n      if (src === null) continue;\r\n      if (a===null){\r\n        a=rtl.arrayRef(src); // Note: concat(a) does not clone\r\n      } else if (a['$pas2jsrefcnt']){\r\n        a=a.concat(src); // clone a and append src\r\n      } else {\r\n        for (var i=0; i<src.length; i++){\r\n          a.push(src[i]);\r\n        }\r\n      }\r\n    };\r\n    return a;\r\n  },\r\n\r\n  arrayPush: function(type,a){\r\n    if(a===null){\r\n      a=[];\r\n    } else if (a['$pas2jsrefcnt']){\r\n      a=rtl.arrayCopy(type,a,0,a.length);\r\n    }\r\n    rtl.arrayClone(type,arguments,2,arguments.length,a,a.length);\r\n    return a;\r\n  },\r\n\r\n  arrayPushN: function(a){\r\n    if(a===null){\r\n      a=[];\r\n    } else if (a['$pas2jsrefcnt']){\r\n      a=a.concat();\r\n    }\r\n    for (var i=1; i<arguments.length; i++){\r\n      a.push(arguments[i]);\r\n    }\r\n    return a;\r\n  },\r\n\r\n  arrayCopy: function(type, srcarray, index, count){\r\n    // type: see rtl.arrayClone\r\n    // if count is missing, use srcarray.length\r\n    if (srcarray === null) return [];\r\n    if (index < 0) index = 0;\r\n    if (count === undefined) count=srcarray.length;\r\n    var end = index+count;\r\n    if (end>srcarray.length) end = srcarray.length;\r\n    if (index>=end) return [];\r\n    if (type===0){\r\n      return srcarray.slice(index,end);\r\n    } else {\r\n      var a = [];\r\n      a.length = end-index;\r\n      rtl.arrayClone(type,srcarray,index,end,a,0);\r\n      return a;\r\n    }\r\n  },\r\n\r\n  arrayInsert: function(item, arr, index){\r\n    if (arr){\r\n      arr.splice(index,0,item);\r\n      return arr;\r\n    } else {\r\n      return [item];\r\n    }\r\n  },\r\n\r\n  setCharAt: function(s,index,c){\r\n    return s.substr(0,index)+c+s.substr(index+1);\r\n  },\r\n\r\n  getResStr: function(mod,name){\r\n    var rs = mod.$resourcestrings[name];\r\n    return rs.current?rs.current:rs.org;\r\n  },\r\n\r\n  createSet: function(){\r\n    var s = {};\r\n    for (var i=0; i<arguments.length; i++){\r\n      if (arguments[i]!=null){\r\n        s[arguments[i]]=true;\r\n      } else {\r\n        var first=arguments[i+=1];\r\n        var last=arguments[i+=1];\r\n        for(var j=first; j<=last; j++) s[j]=true;\r\n      }\r\n    }\r\n    return s;\r\n  },\r\n\r\n  cloneSet: function(s){\r\n    var r = {};\r\n    for (var key in s) r[key]=true;\r\n    return r;\r\n  },\r\n\r\n  refSet: function(s){\r\n    rtl.hideProp(s,'$shared',true);\r\n    return s;\r\n  },\r\n\r\n  includeSet: function(s,enumvalue){\r\n    if (s.$shared) s = rtl.cloneSet(s);\r\n    s[enumvalue] = true;\r\n    return s;\r\n  },\r\n\r\n  excludeSet: function(s,enumvalue){\r\n    if (s.$shared) s = rtl.cloneSet(s);\r\n    delete s[enumvalue];\r\n    return s;\r\n  },\r\n\r\n  diffSet: function(s,t){\r\n    var r = {};\r\n    for (var key in s) if (!t[key]) r[key]=true;\r\n    return r;\r\n  },\r\n\r\n  unionSet: function(s,t){\r\n    var r = {};\r\n    for (var key in s) r[key]=true;\r\n    for (var key in t) r[key]=true;\r\n    return r;\r\n  },\r\n\r\n  intersectSet: function(s,t){\r\n    var r = {};\r\n    for (var key in s) if (t[key]) r[key]=true;\r\n    return r;\r\n  },\r\n\r\n  symDiffSet: function(s,t){\r\n    var r = {};\r\n    for (var key in s) if (!t[key]) r[key]=true;\r\n    for (var key in t) if (!s[key]) r[key]=true;\r\n    return r;\r\n  },\r\n\r\n  eqSet: function(s,t){\r\n    for (var key in s) if (!t[key]) return false;\r\n    for (var key in t) if (!s[key]) return false;\r\n    return true;\r\n  },\r\n\r\n  neSet: function(s,t){\r\n    return !rtl.eqSet(s,t);\r\n  },\r\n\r\n  leSet: function(s,t){\r\n    for (var key in s) if (!t[key]) return false;\r\n    return true;\r\n  },\r\n\r\n  geSet: function(s,t){\r\n    for (var key in t) if (!s[key]) return false;\r\n    return true;\r\n  },\r\n\r\n  strSetLength: function(s,newlen){\r\n    var oldlen = s.length;\r\n    if (oldlen > newlen){\r\n      return s.substring(0,newlen);\r\n    } else if (s.repeat){\r\n      // Note: repeat needs ECMAScript6!\r\n      return s+' '.repeat(newlen-oldlen);\r\n    } else {\r\n       while (oldlen<newlen){\r\n         s+=' ';\r\n         oldlen++;\r\n       };\r\n       return s;\r\n    }\r\n  },\r\n\r\n  spaceLeft: function(s,width){\r\n    var l=s.length;\r\n    if (l>=width) return s;\r\n    if (s.repeat){\r\n      // Note: repeat needs ECMAScript6!\r\n      return ' '.repeat(width-l) + s;\r\n    } else {\r\n      while (l<width){\r\n        s=' '+s;\r\n        l++;\r\n      };\r\n      return s;\r\n    };\r\n  },\r\n\r\n  floatToStr: function(d,w,p){\r\n    // input 1-3 arguments: double, width, precision\r\n    if (arguments.length>2){\r\n      return rtl.spaceLeft(d.toFixed(p),w);\r\n    } else {\r\n\t  // exponent width\r\n\t  var pad = \"\";\r\n\t  var ad = Math.abs(d);\r\n\t  if (((ad>1) && (ad<1.0e+10)) ||  ((ad>1.e-10) && (ad<1))) {\r\n\t\tpad='00';\r\n\t  } else if ((ad>1) && (ad<1.0e+100) || (ad<1.e-10)) {\r\n\t\tpad='0';\r\n      }  \t\r\n\t  if (arguments.length<2) {\r\n\t    w=24;\t\t\r\n      } else if (w<9) {\r\n\t\tw=9;\r\n      }\t\t  \r\n      var p = w-8;\r\n      var s=(d>0 ? \" \" : \"\" ) + d.toExponential(p);\r\n      s=s.replace(/e(.)/,'E$1'+pad);\r\n      return rtl.spaceLeft(s,w);\r\n    }\r\n  },\r\n\r\n  valEnum: function(s, enumType, setCodeFn){\r\n    s = s.toLowerCase();\r\n    for (var key in enumType){\r\n      if((typeof(key)==='string') && (key.toLowerCase()===s)){\r\n        setCodeFn(0);\r\n        return enumType[key];\r\n      }\r\n    }\r\n    setCodeFn(1);\r\n    return 0;\r\n  },\r\n\r\n  lw: function(l){\r\n    // fix longword bitwise operation\r\n    return l<0?l+0x100000000:l;\r\n  },\r\n\r\n  and: function(a,b){\r\n    var hi = 0x80000000;\r\n    var low = 0x7fffffff;\r\n    var h = (a / hi) & (b / hi);\r\n    var l = (a & low) & (b & low);\r\n    return h*hi + l;\r\n  },\r\n\r\n  or: function(a,b){\r\n    var hi = 0x80000000;\r\n    var low = 0x7fffffff;\r\n    var h = (a / hi) | (b / hi);\r\n    var l = (a & low) | (b & low);\r\n    return h*hi + l;\r\n  },\r\n\r\n  xor: function(a,b){\r\n    var hi = 0x80000000;\r\n    var low = 0x7fffffff;\r\n    var h = (a / hi) ^ (b / hi);\r\n    var l = (a & low) ^ (b & low);\r\n    return h*hi + l;\r\n  },\r\n\r\n  shr: function(a,b){\r\n    if (a<0) a += rtl.hiInt;\r\n    if (a<0x80000000) return a >> b;\r\n    if (b<=0) return a;\r\n    if (b>54) return 0;\r\n    return Math.floor(a / Math.pow(2,b));\r\n  },\r\n\r\n  shl: function(a,b){\r\n    if (a<0) a += rtl.hiInt;\r\n    if (b<=0) return a;\r\n    if (b>54) return 0;\r\n    var r = a * Math.pow(2,b);\r\n    if (r <= rtl.hiInt) return r;\r\n    return r % rtl.hiInt;\r\n  },\r\n\r\n  initRTTI: function(){\r\n    if (rtl.debug_rtti) rtl.debug('initRTTI');\r\n\r\n    // base types\r\n    rtl.tTypeInfo = { name: \"tTypeInfo\", kind: 0, $module: null, attr: null };\r\n    function newBaseTI(name,kind,ancestor){\r\n      if (!ancestor) ancestor = rtl.tTypeInfo;\r\n      if (rtl.debug_rtti) rtl.debug('initRTTI.newBaseTI \"'+name+'\" '+kind+' (\"'+ancestor.name+'\")');\r\n      var t = Object.create(ancestor);\r\n      t.name = name;\r\n      t.kind = kind;\r\n      rtl[name] = t;\r\n      return t;\r\n    };\r\n    function newBaseInt(name,minvalue,maxvalue,ordtype){\r\n      var t = newBaseTI(name,1 /* tkInteger */,rtl.tTypeInfoInteger);\r\n      t.minvalue = minvalue;\r\n      t.maxvalue = maxvalue;\r\n      t.ordtype = ordtype;\r\n      return t;\r\n    };\r\n    newBaseTI(\"tTypeInfoInteger\",1 /* tkInteger */);\r\n    newBaseInt(\"shortint\",-0x80,0x7f,0);\r\n    newBaseInt(\"byte\",0,0xff,1);\r\n    newBaseInt(\"smallint\",-0x8000,0x7fff,2);\r\n    newBaseInt(\"word\",0,0xffff,3);\r\n    newBaseInt(\"longint\",-0x80000000,0x7fffffff,4);\r\n    newBaseInt(\"longword\",0,0xffffffff,5);\r\n    newBaseInt(\"nativeint\",-0x10000000000000,0xfffffffffffff,6);\r\n    newBaseInt(\"nativeuint\",0,0xfffffffffffff,7);\r\n    newBaseTI(\"char\",2 /* tkChar */);\r\n    newBaseTI(\"string\",3 /* tkString */);\r\n    newBaseTI(\"tTypeInfoEnum\",4 /* tkEnumeration */,rtl.tTypeInfoInteger);\r\n    newBaseTI(\"tTypeInfoSet\",5 /* tkSet */);\r\n    newBaseTI(\"double\",6 /* tkDouble */);\r\n    newBaseTI(\"boolean\",7 /* tkBool */);\r\n    newBaseTI(\"tTypeInfoProcVar\",8 /* tkProcVar */);\r\n    newBaseTI(\"tTypeInfoMethodVar\",9 /* tkMethod */,rtl.tTypeInfoProcVar);\r\n    newBaseTI(\"tTypeInfoArray\",10 /* tkArray */);\r\n    newBaseTI(\"tTypeInfoDynArray\",11 /* tkDynArray */);\r\n    newBaseTI(\"tTypeInfoPointer\",15 /* tkPointer */);\r\n    var t = newBaseTI(\"pointer\",15 /* tkPointer */,rtl.tTypeInfoPointer);\r\n    t.reftype = null;\r\n    newBaseTI(\"jsvalue\",16 /* tkJSValue */);\r\n    newBaseTI(\"tTypeInfoRefToProcVar\",17 /* tkRefToProcVar */,rtl.tTypeInfoProcVar);\r\n\r\n    // member kinds\r\n    rtl.tTypeMember = { attr: null };\r\n    function newMember(name,kind){\r\n      var m = Object.create(rtl.tTypeMember);\r\n      m.name = name;\r\n      m.kind = kind;\r\n      rtl[name] = m;\r\n    };\r\n    newMember(\"tTypeMemberField\",1); // tmkField\r\n    newMember(\"tTypeMemberMethod\",2); // tmkMethod\r\n    newMember(\"tTypeMemberProperty\",3); // tmkProperty\r\n\r\n    // base object for storing members: a simple object\r\n    rtl.tTypeMembers = {};\r\n\r\n    // tTypeInfoStruct - base object for tTypeInfoClass, tTypeInfoRecord, tTypeInfoInterface\r\n    var tis = newBaseTI(\"tTypeInfoStruct\",0);\r\n    tis.$addMember = function(name,ancestor,options){\r\n      if (rtl.debug_rtti){\r\n        if (!rtl.hasString(name) || (name.charAt()==='$')) throw 'invalid member \"'+name+'\", this=\"'+this.name+'\"';\r\n        if (!rtl.is(ancestor,rtl.tTypeMember)) throw 'invalid ancestor \"'+ancestor+':'+ancestor.name+'\", \"'+this.name+'.'+name+'\"';\r\n        if ((options!=undefined) && (typeof(options)!='object')) throw 'invalid options \"'+options+'\", \"'+this.name+'.'+name+'\"';\r\n      };\r\n      var t = Object.create(ancestor);\r\n      t.name = name;\r\n      this.members[name] = t;\r\n      this.names.push(name);\r\n      if (rtl.isObject(options)){\r\n        for (var key in options) if (options.hasOwnProperty(key)) t[key] = options[key];\r\n      };\r\n      return t;\r\n    };\r\n    tis.addField = function(name,type,options){\r\n      var t = this.$addMember(name,rtl.tTypeMemberField,options);\r\n      if (rtl.debug_rtti){\r\n        if (!rtl.is(type,rtl.tTypeInfo)) throw 'invalid type \"'+type+'\", \"'+this.name+'.'+name+'\"';\r\n      };\r\n      t.typeinfo = type;\r\n      this.fields.push(name);\r\n      return t;\r\n    };\r\n    tis.addFields = function(){\r\n      var i=0;\r\n      while(i<arguments.length){\r\n        var name = arguments[i++];\r\n        var type = arguments[i++];\r\n        if ((i<arguments.length) && (typeof(arguments[i])==='object')){\r\n          this.addField(name,type,arguments[i++]);\r\n        } else {\r\n          this.addField(name,type);\r\n        };\r\n      };\r\n    };\r\n    tis.addMethod = function(name,methodkind,params,result,flags,options){\r\n      var t = this.$addMember(name,rtl.tTypeMemberMethod,options);\r\n      t.methodkind = methodkind;\r\n      t.procsig = rtl.newTIProcSig(params,result,flags);\r\n      this.methods.push(name);\r\n      return t;\r\n    };\r\n    tis.addProperty = function(name,flags,result,getter,setter,options){\r\n      var t = this.$addMember(name,rtl.tTypeMemberProperty,options);\r\n      t.flags = flags;\r\n      t.typeinfo = result;\r\n      t.getter = getter;\r\n      t.setter = setter;\r\n      // Note: in options: params, stored, defaultvalue\r\n      t.params = rtl.isArray(t.params) ? rtl.newTIParams(t.params) : null;\r\n      this.properties.push(name);\r\n      if (!rtl.isString(t.stored)) t.stored = \"\";\r\n      return t;\r\n    };\r\n    tis.getField = function(index){\r\n      return this.members[this.fields[index]];\r\n    };\r\n    tis.getMethod = function(index){\r\n      return this.members[this.methods[index]];\r\n    };\r\n    tis.getProperty = function(index){\r\n      return this.members[this.properties[index]];\r\n    };\r\n\r\n    newBaseTI(\"tTypeInfoRecord\",12 /* tkRecord */,rtl.tTypeInfoStruct);\r\n    newBaseTI(\"tTypeInfoClass\",13 /* tkClass */,rtl.tTypeInfoStruct);\r\n    newBaseTI(\"tTypeInfoClassRef\",14 /* tkClassRef */);\r\n    newBaseTI(\"tTypeInfoInterface\",18 /* tkInterface */,rtl.tTypeInfoStruct);\r\n    newBaseTI(\"tTypeInfoHelper\",19 /* tkHelper */,rtl.tTypeInfoStruct);\r\n    newBaseTI(\"tTypeInfoExtClass\",20 /* tkExtClass */,rtl.tTypeInfoClass);\r\n  },\r\n\r\n  tSectionRTTI: {\r\n    $module: null,\r\n    $inherited: function(name,ancestor,o){\r\n      if (rtl.debug_rtti){\r\n        rtl.debug('tSectionRTTI.newTI \"'+(this.$module?this.$module.$name:\"(no module)\")\r\n          +'\".\"'+name+'\" ('+ancestor.name+') '+(o?'init':'forward'));\r\n      };\r\n      var t = this[name];\r\n      if (t){\r\n        if (!t.$forward) throw 'duplicate type \"'+name+'\"';\r\n        if (!ancestor.isPrototypeOf(t)) throw 'typeinfo ancestor mismatch \"'+name+'\" ancestor=\"'+ancestor.name+'\" t.name=\"'+t.name+'\"';\r\n      } else {\r\n        t = Object.create(ancestor);\r\n        t.name = name;\r\n        t.$module = this.$module;\r\n        this[name] = t;\r\n      }\r\n      if (o){\r\n        delete t.$forward;\r\n        for (var key in o) if (o.hasOwnProperty(key)) t[key]=o[key];\r\n      } else {\r\n        t.$forward = true;\r\n      }\r\n      return t;\r\n    },\r\n    $Scope: function(name,ancestor,o){\r\n      var t=this.$inherited(name,ancestor,o);\r\n      t.members = {};\r\n      t.names = [];\r\n      t.fields = [];\r\n      t.methods = [];\r\n      t.properties = [];\r\n      return t;\r\n    },\r\n    $TI: function(name,kind,o){ var t=this.$inherited(name,rtl.tTypeInfo,o); t.kind = kind; return t; },\r\n    $Int: function(name,o){ return this.$inherited(name,rtl.tTypeInfoInteger,o); },\r\n    $Enum: function(name,o){ return this.$inherited(name,rtl.tTypeInfoEnum,o); },\r\n    $Set: function(name,o){ return this.$inherited(name,rtl.tTypeInfoSet,o); },\r\n    $StaticArray: function(name,o){ return this.$inherited(name,rtl.tTypeInfoArray,o); },\r\n    $DynArray: function(name,o){ return this.$inherited(name,rtl.tTypeInfoDynArray,o); },\r\n    $ProcVar: function(name,o){ return this.$inherited(name,rtl.tTypeInfoProcVar,o); },\r\n    $RefToProcVar: function(name,o){ return this.$inherited(name,rtl.tTypeInfoRefToProcVar,o); },\r\n    $MethodVar: function(name,o){ return this.$inherited(name,rtl.tTypeInfoMethodVar,o); },\r\n    $Record: function(name,o){ return this.$Scope(name,rtl.tTypeInfoRecord,o); },\r\n    $Class: function(name,o){ return this.$Scope(name,rtl.tTypeInfoClass,o); },\r\n    $ClassRef: function(name,o){ return this.$inherited(name,rtl.tTypeInfoClassRef,o); },\r\n    $Pointer: function(name,o){ return this.$inherited(name,rtl.tTypeInfoPointer,o); },\r\n    $Interface: function(name,o){ return this.$Scope(name,rtl.tTypeInfoInterface,o); },\r\n    $Helper: function(name,o){ return this.$Scope(name,rtl.tTypeInfoHelper,o); },\r\n    $ExtClass: function(name,o){ return this.$Scope(name,rtl.tTypeInfoExtClass,o); }\r\n  },\r\n\r\n  newTIParam: function(param){\r\n    // param is an array, 0=name, 1=type, 2=optional flags\r\n    var t = {\r\n      name: param[0],\r\n      typeinfo: param[1],\r\n      flags: (rtl.isNumber(param[2]) ? param[2] : 0)\r\n    };\r\n    return t;\r\n  },\r\n\r\n  newTIParams: function(list){\r\n    // list: optional array of [paramname,typeinfo,optional flags]\r\n    var params = [];\r\n    if (rtl.isArray(list)){\r\n      for (var i=0; i<list.length; i++) params.push(rtl.newTIParam(list[i]));\r\n    };\r\n    return params;\r\n  },\r\n\r\n  newTIProcSig: function(params,result,flags){\r\n    var s = {\r\n      params: rtl.newTIParams(params),\r\n      resulttype: result?result:null,\r\n      flags: flags?flags:0\r\n    };\r\n    return s;\r\n  },\r\n\r\n  addResource: function(aRes){\r\n    rtl.$res[aRes.name]=aRes;\r\n  },\r\n\r\n  getResource: function(aName){\r\n    var res = rtl.$res[aName];\r\n    if (res !== undefined) {\r\n      return res;\r\n    } else {\r\n      return null;\r\n    }\r\n  },\r\n\r\n  getResourceList: function(){\r\n    return Object.keys(rtl.$res);\r\n  }\r\n}\r\n\r\n","{\r\n    This file is part of the Pas2JS run time library.\r\n    Copyright (c) 2018 by Mattias Gaertner\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\nunit System;\r\n\r\n{$mode objfpc}\r\n{$modeswitch externalclass}\r\n\r\ninterface\r\n\r\n{$IFDEF NodeJS}\r\nvar\r\n  LineEnding: string = #10;\r\n  sLineBreak: string = #10;\r\n{$ELSE}\r\nconst\r\n  LineEnding = #10;\r\n  sLineBreak = LineEnding;\r\n{$ENDIF}\r\n\r\nVar\r\n  PathDelim : Char = '/';\r\n  AllowDirectorySeparators : Set of Char = ['/'];\r\n  AllowDriveSeparators : Set of Char = [':'];\r\n  ExtensionSeparator : Char = '.';\r\n\r\nconst\r\n  MaxSmallint = 32767;\r\n  MinSmallint = -32768;\r\n  MaxShortInt = 127;\r\n  MinShortInt = -128;\r\n  MaxByte = $FF;\r\n  MaxWord = $FFFF;\r\n  MaxLongint  = $7fffffff;\r\n  MaxCardinal = LongWord($ffffffff);\r\n\r\n  Maxint = MaxLongint;\r\n  IsMultiThread = false;\r\n\r\n{*****************************************************************************\r\n                               Base types\r\n*****************************************************************************}\r\ntype\r\n  HRESULT = Longint; // For Delphi compatibility\r\n  Int8 = ShortInt;\r\n  UInt8 = Byte;\r\n  Int16 = SmallInt;\r\n  UInt16 = Word;\r\n  Int32 = Longint;\r\n  UInt32 = LongWord;\r\n\r\n  Integer = LongInt;\r\n  Cardinal = LongWord;\r\n  DWord = LongWord;\r\n  SizeInt = NativeInt;\r\n  SizeUInt = NativeUInt;\r\n  PtrInt = NativeInt;\r\n  PtrUInt = NativeUInt;\r\n  ValSInt = NativeInt;\r\n  ValUInt = NativeUInt;\r\n  CodePointer = Pointer;\r\n  ValReal = Double;\r\n  Real = type Double;\r\n  Extended = type Double;\r\n\r\n  TDateTime = type double;\r\n  TTime = type TDateTime;\r\n  TDate = type TDateTime;\r\n\r\n  Int64 = type NativeInt unimplemented; // only 53 bits at runtime\r\n  UInt64 = type NativeUInt unimplemented; // only 52 bits at runtime\r\n  QWord = type NativeUInt unimplemented; // only 52 bits at runtime\r\n  Single = type Double unimplemented;\r\n  Comp = type NativeInt unimplemented;\r\n  NativeLargeInt = NativeInt;\r\n  NativeLargeUInt = NativeUInt;\r\n\r\n  UnicodeChar = Char;\r\n  UnicodeString = type String;\r\n  WideString = type String;\r\n  WideChar = Char;\r\n\r\n  TDynArrayIndex = NativeInt;\r\n  TTextLineBreakStyle = (tlbsLF,tlbsCRLF,tlbsCR);\r\n\r\n  TCompareOption = ({coLingIgnoreCase, coLingIgnoreDiacritic, }coIgnoreCase{,\r\n                    coIgnoreKanaType, coIgnoreNonSpace, coIgnoreSymbols, coIgnoreWidth,\r\n                    coLingCasing, coDigitAsNumbers, coStringSort});\r\n  TCompareOptions = set of TCompareOption;\r\n\r\n  generic TArray<T> = array of T;\r\n\r\n{*****************************************************************************\r\n            TObject, TClass, IUnknown, IInterface, TInterfacedObject\r\n*****************************************************************************}\r\ntype\r\n  TGuid = record\r\n    D1: DWord;\r\n    D2: word;\r\n    D3: word;\r\n    D4: array[0..7] of byte;\r\n  end;\r\n  TGUIDString = type string;\r\n\r\n  TMethod = record\r\n    Code : CodePointer;\r\n    Data : Pointer;\r\n  end;\r\n\r\n  PMethod = ^TMethod;\r\n\r\n  TClass = class of TObject;\r\n\r\n  { TObject }\r\n\r\n  {$DispatchField Msg} // enable checking message methods for record field name \"Msg\"\r\n  {$DispatchStrField MsgStr}\r\n  TObject = class\r\n  private\r\n    class var FClassName: String; external name '$classname';\r\n    class var FClassParent: TClass; external name '$ancestor';\r\n    class var FUnitName: String; external name '$module.$name';\r\n  public\r\n    constructor Create;\r\n    destructor Destroy; virtual;\r\n\r\n    // Free is using compiler magic.\r\n    // Reasons:\r\n    // 1. In JS calling obj.Free when obj=nil would crash.\r\n    // 2. In JS freeing memory requires to set all references to nil.\r\n    // Therefore any obj.free call is replaced by the compiler with some rtl magic.\r\n    procedure Free;\r\n\r\n    class function ClassType: TClass; assembler;\r\n    class property ClassName: String read FClassName;\r\n    class function ClassNameIs(const Name: string): boolean;\r\n    class property ClassParent: TClass read FClassParent;\r\n    class function InheritsFrom(aClass: TClass): boolean; assembler;\r\n    class property UnitName: String read FUnitName;\r\n    Class function MethodName(aCode : Pointer) : String;\r\n    Class function MethodAddress(aName : String) : Pointer;\r\n    Class Function FieldAddress(aName : String) : Pointer;\r\n    Class Function ClassInfo : Pointer;\r\n    class function QualifiedClassName: String;\r\n\r\n    procedure AfterConstruction; virtual;\r\n    procedure BeforeDestruction; virtual;\r\n\r\n    // message handling routines\r\n    procedure Dispatch(var aMessage); virtual;\r\n    procedure DispatchStr(var aMessage); virtual;\r\n    procedure DefaultHandler(var aMessage); virtual;\r\n    procedure DefaultHandlerStr(var aMessage); virtual;\r\n\r\n    function GetInterface(const iid: TGuid; out obj): boolean;\r\n    function GetInterface(const iidstr: String; out obj): boolean; inline;\r\n    function GetInterfaceByStr(const iidstr: String; out obj): boolean;\r\n    function GetInterfaceWeak(const iid: TGuid; out obj): boolean; // equal to GetInterface but the interface returned is not referenced\r\n\r\n    function Equals(Obj: TObject): boolean; virtual;\r\n    function ToString: String; virtual;\r\n  end;\r\n\r\n  { TCustomAttribute - base class of all user defined attributes. }\r\n\r\n  TCustomAttribute = class\r\n  end;\r\n  TCustomAttributeClass = class of TCustomAttribute;\r\n  TCustomAttributeArray = array of TCustomAttribute;\r\n\r\nconst\r\n  { IInterface }\r\n  S_OK          = 0;\r\n  S_FALSE       = 1;\r\n  E_NOINTERFACE = -2147467262; // FPC: longint($80004002)\r\n  E_UNEXPECTED  = -2147418113; // FPC: longint($8000FFFF)\r\n  E_NOTIMPL     = -2147467263; // FPC: longint($80004001)\r\n\r\ntype\r\n  {$Interfaces COM}\r\n  IUnknown = interface\r\n    ['{00000000-0000-0000-C000-000000000046}']\r\n    function QueryInterface(const iid: TGuid; out obj): Integer;\r\n    function _AddRef: Integer;\r\n    function _Release: Integer;\r\n  end;\r\n  IInterface = IUnknown;\r\n\r\n  {$M+}\r\n  IInvokable = interface(IInterface)\r\n  end;\r\n  {$M-}\r\n\r\n  { Enumerator support }\r\n  IEnumerator = interface(IInterface)\r\n    function GetCurrent: TObject;\r\n    function MoveNext: Boolean;\r\n    procedure Reset;\r\n    property Current: TObject read GetCurrent;\r\n  end;\r\n\r\n  IEnumerable = interface(IInterface)\r\n    function GetEnumerator: IEnumerator;\r\n  end;\r\n\r\n  { TInterfacedObject }\r\n\r\n  TInterfacedObject = class(TObject,IUnknown)\r\n  protected\r\n    fRefCount: Integer;\r\n    { implement methods of IUnknown }\r\n    function QueryInterface(const iid: TGuid; out obj): Integer; virtual;\r\n    function _AddRef: Integer; virtual;\r\n    function _Release: Integer; virtual;\r\n  public\r\n    procedure BeforeDestruction; override;\r\n    property RefCount: Integer read fRefCount;\r\n  end;\r\n  TInterfacedClass = class of TInterfacedObject;\r\n\r\n  { TAggregatedObject - sub or satellite object using same interface as controller }\r\n\r\n  TAggregatedObject = class(TObject)\r\n  private\r\n    fController: Pointer;\r\n    function GetController: IUnknown;\r\n  protected\r\n    { implement methods of IUnknown }\r\n    function QueryInterface(const iid: TGuid; out obj): Integer; virtual;\r\n    function _AddRef: Integer; virtual;\r\n    function _Release: Integer; virtual;\r\n  public\r\n    constructor Create(const aController: IUnknown); reintroduce;\r\n    property Controller: IUnknown read GetController;\r\n  end;\r\n\r\n  { TContainedObject }\r\n\r\n  TContainedObject = class(TAggregatedObject,IInterface)\r\n  protected\r\n    function QueryInterface(const iid: TGuid; out obj): Integer; override;\r\n  end;\r\n\r\nconst\r\n  { for safe as operator support }\r\n  IObjectInstance: TGuid = '{D91C9AF4-3C93-420F-A303-BF5BA82BFD23}';\r\n\r\nfunction GUIDToString(const GUID: TGUID): string; external name 'rtl.guidrToStr';\r\n\r\n{*****************************************************************************\r\n                                  RTTI support\r\n*****************************************************************************}\r\ntype\r\n  // if you change the following enumeration type in any way\r\n  // you also have to change the rtl.js in an appropriate way !\r\n  TTypeKind = (\r\n    tkUnknown,  // 0\r\n    tkInteger,  // 1\r\n    tkChar,     // 2 in Delphi/FPC tkWChar, tkUChar\r\n    tkString,   // 3 in Delphi/FPC tkSString, tkWString or tkUString\r\n    tkEnumeration, // 4\r\n    tkSet,      // 5\r\n    tkDouble,   // 6\r\n    tkBool,     // 7\r\n    tkProcVar,  // 8  function or procedure\r\n    tkMethod,   // 9  proc var of object\r\n    tkArray,    // 10 static array\r\n    tkDynArray, // 11\r\n    tkRecord,   // 12\r\n    tkClass,    // 13\r\n    tkClassRef, // 14\r\n    tkPointer,  // 15\r\n    tkJSValue,  // 16\r\n    tkRefToProcVar, // 17  variable of procedure type\r\n    tkInterface, // 18\r\n    //tkObject,\r\n    //tkSString,tkLString,tkAString,tkWString,\r\n    //tkVariant,\r\n    //tkWChar,\r\n    //tkInt64,\r\n    //tkQWord,\r\n    //tkInterfaceRaw,\r\n    //tkUString,tkUChar,\r\n    tkHelper,   // 19\r\n    //tkFile,\r\n    tkExtClass  // 20\r\n    );\r\n  TTypeKinds = set of TTypeKind;\r\n\r\nconst\r\n  tkFloat = tkDouble; // for compatibility with Delphi/FPC\r\n  tkProcedure = tkProcVar; // for compatibility with Delphi\r\n  tkAny = [Low(TTypeKind)..High(TTypeKind)];\r\n  tkMethods = [tkMethod];\r\n  tkProperties = tkAny-tkMethods-[tkUnknown];\r\n\r\n{*****************************************************************************\r\n                              Array of const support\r\n*****************************************************************************}\r\n\r\nconst\r\n  vtInteger       = 0;\r\n  vtBoolean       = 1;\r\n  //vtChar          = 2; // Delphi/FPC: ansichar\r\n  vtExtended      = 3; // Note: double in pas2js, PExtended in Delphi/FPC\r\n  //vtString        = 4; // Delphi/FPC: PShortString\r\n  vtPointer       = 5;\r\n  //vtPChar         = 6;\r\n  vtObject        = 7;\r\n  vtClass         = 8;\r\n  vtWideChar      = 9;\r\n  //vtPWideChar     = 10;\r\n  //vtAnsiString    = 11;\r\n  vtCurrency      = 12; // Note: currency in pas2js, PCurrency in Delphi/FPC\r\n  //vtVariant       = 13;\r\n  vtInterface     = 14;\r\n  //vtWideString    = 15;\r\n  //vtInt64         = 16;\r\n  //vtQWord         = 17;\r\n  vtUnicodeString = 18;\r\n  // only pas2js, not in Delphi/FPC:\r\n  vtNativeInt     = 19;\r\n  vtJSValue       = 20;\r\n\r\ntype\r\n  PVarRec = ^TVarRec;\r\n  TVarRec = record\r\n    VType: byte;\r\n    VJSValue: JSValue;\r\n    VInteger: LongInt external name 'VJSValue';\r\n    VBoolean: Boolean external name 'VJSValue';\r\n    VExtended: Double external name 'VJSValue';\r\n    VPointer: Pointer external name 'VJSValue';\r\n    VObject: TObject external name 'VJSValue';\r\n    VClass: TClass external name 'VJSValue';\r\n    VWideChar: WideChar external name 'VJSValue';\r\n    VCurrency: Currency external name 'VJSValue';\r\n    VInterface: Pointer external name 'VJSValue';\r\n    VUnicodeString: UnicodeString external name 'VJSValue';\r\n    VNativeInt: NativeInt external name 'VJSValue';\r\n  end;\r\n  TVarRecArray = array of TVarRec;\r\n\r\nfunction VarRecs: TVarRecArray; varargs;\r\n\r\n{*****************************************************************************\r\n                            Init / Exit / ExitProc\r\n*****************************************************************************}\r\nvar\r\n  ExitCode: Integer; external name 'rtl.exitcode';\r\n  IsConsole: Boolean = {$IFDEF NodeJS}true{$ELSE}false{$ENDIF};\r\n  FirstDotAtFileNameStartIsExtension : Boolean = False;\r\n\r\ntype\r\n  TOnParamCount = function: Longint;\r\n  TOnParamStr = function(Index: Longint): String;\r\nvar\r\n  OnParamCount: TOnParamCount;\r\n  OnParamStr: TOnParamStr;\r\n\r\nfunction ParamCount: Longint;\r\nfunction ParamStr(Index: Longint): String;\r\n\r\n{*****************************************************************************\r\n                                 Math\r\n*****************************************************************************}\r\nconst\r\n  PI: Double; external name 'Math.PI';\r\n  MathE: Double; external name 'Math.E'; // Euler's number\r\n  MathLN10: Double; external name 'Math.LN10'; // ln(10)\r\n  MathLN2: Double; external name 'Math.LN2'; // ln(2)\r\n  MathLog10E: Double; external name 'Math.Log10E'; // log10(e)\r\n  MathLog2E: Double; external name 'Math.LOG2E'; // log2(e)\r\n  MathSQRT1_2: Double; external name 'Math.SQRT1_2'; // sqrt(0.5)\r\n  MathSQRT2: Double; external name 'Math.SQRT2'; // sqrt(2)\r\n\r\nfunction Abs(const A: integer): integer; overload; external name 'Math.abs';\r\nfunction Abs(const A: NativeInt): integer; overload; external name 'Math.abs';\r\nfunction Abs(const A: Double): Double; overload; external name 'Math.abs';\r\nfunction ArcTan(const A: Double): Double; external name 'Math.atan';\r\nfunction ArcTan2(const A,B: Double): Double; external name 'Math.atan2';\r\nfunction Cos(const A: Double): Double; external name 'Math.cos';\r\nfunction Exp(const A: Double): Double; external name 'Math.exp';\r\nfunction Frac(const A: Double): Double; assembler;\r\nfunction Ln(const A: Double): Double; external name 'Math.log';\r\nfunction Odd(const A: Integer): Boolean; assembler;\r\nfunction Random(const Range: Integer): Integer; overload; assembler;\r\nfunction Random: Double; overload; external name 'Math.random';\r\nfunction Round(const A: Double): NativeInt; external name 'Math.round';\r\nfunction Sin(const A: Double): Double; external name 'Math.sin';\r\nfunction Sqr(const A: Integer): Integer; assembler; overload;\r\nfunction Sqr(const A: Double): Double; assembler; overload;\r\nfunction sqrt(const A: Double): Double; external name 'Math.sqrt';\r\nfunction Trunc(const A: Double): NativeInt;\r\n\r\n{*****************************************************************************\r\n                          String functions\r\n*****************************************************************************}\r\nconst\r\n  DefaultTextLineBreakStyle : TTextLineBreakStyle = tlbsLF;\r\n\r\nfunction Int(const A: Double): double;\r\nfunction Copy(const S: string; Index, Size: Integer): String; assembler; overload;\r\nfunction Copy(const S: string; Index: Integer): String; assembler; overload;\r\nprocedure Delete(var S: String; Index, Size: Integer); overload;\r\nfunction Pos(const Search, InString: String): Integer; assembler; overload;\r\nfunction Pos(const Search, InString: String; StartAt : Integer): Integer; assembler; overload;\r\nprocedure Insert(const Insertion: String; var Target: String; Index: Integer); overload;\r\nfunction upcase(c : char) : char; assembler;\r\nfunction HexStr(Val: NativeInt; cnt: byte): string; external name 'rtl.hexStr'; overload;\r\nfunction binstr(val : NativeUInt; cnt : byte) : string;\r\n\r\nprocedure val(const S: String; out NI : NativeInt; out Code: Integer); overload;\r\nprocedure val(const S: String; out NI : NativeUInt; out Code: Integer); overload;\r\nprocedure val(const S: String; out SI : ShortInt; out Code: Integer); overload;\r\nprocedure val(const S: String; out B : Byte; out Code: Integer); overload;\r\nprocedure val(const S: String; out SI : smallint; out Code: Integer); overload;\r\nprocedure val(const S: String; out W : word; out Code : Integer); overload;\r\nprocedure val(const S: String; out I : integer; out Code : Integer); overload;\r\nprocedure val(const S: String; out C : Cardinal; out Code: Integer); overload;\r\nprocedure val(const S: String; out d : double; out Code : Integer); overload;\r\nprocedure val(const S: String; out b : boolean; out Code: Integer); overload;\r\nfunction StringOfChar(c: Char; l: NativeInt): String;\r\n\r\n{*****************************************************************************\r\n                          Other functions\r\n*****************************************************************************}\r\nprocedure Write; varargs; // ToDo: should be compiler built-in function\r\nprocedure Writeln; varargs; // ToDo: should be compiler built-in function\r\n\r\nType\r\n  TConsoleHandler = Reference to Procedure (S : JSValue; NewLine : Boolean);\r\nFunction SetWriteCallBack(H : TConsoleHandler) : TConsoleHandler;\r\n\r\nfunction Assigned(const V: JSValue): boolean; assembler; overload;\r\nfunction StrictEqual(const A: JSValue; const B): boolean; assembler;\r\nfunction StrictInequal(const A: JSValue; const B): boolean; assembler;\r\n\r\nimplementation\r\n\r\ntype\r\n\r\n  { TJSObj - simple access to JS Object }\r\n\r\n  TJSObj = class external name 'Object'\r\n  private\r\n    function GetProperties(Name: String): JSValue; external name '[]';\r\n    procedure SetProperties(Name: String; const AValue: JSValue); external name '[]';\r\n  public\r\n    //constructor new;\r\n    //function hasOwnProperty(prop: String): boolean;\r\n    property Properties[Name: String]: JSValue read GetProperties write SetProperties; default;\r\n  end;\r\n\r\n  TJSArray = class external name 'Array'\r\n  public\r\n    //length: nativeint;\r\n    //constructor new; overload;\r\n    function push(aElement : JSValue) : NativeInt; varargs;\r\n  end;\r\n\r\n  TJSArguments = class external name 'arguments'\r\n  private\r\n    FLength: NativeInt; external name 'length';\r\n    function GetElements(Index: NativeInt): JSValue; external name '[]';\r\n  public\r\n    property Length: NativeInt read FLength;\r\n    property Elements[Index: NativeInt]: JSValue read GetElements; default;\r\n  end;\r\nvar\r\n  JSArguments: TJSArguments; external name 'arguments';\r\n\r\nfunction isNumber(const v: JSValue): boolean; external name 'rtl.isNumber';\r\nfunction isObject(const v: JSValue): boolean; external name 'rtl.isObject'; // true if not null and a JS Object\r\nfunction isString(const v: JSValue): boolean; external name 'rtl.isString';\r\nfunction isNaN(i: JSValue): boolean; external name 'isNaN'; // may result NaN\r\n\r\n// needed by ClassNameIs, the real SameText is in SysUtils\r\nfunction SameText(const s1, s2: String): Boolean; assembler;\r\nasm\r\n  return s1.toLowerCase() == s2.toLowerCase();\r\nend;\r\n\r\nfunction VarRecs: TVarRecArray;\r\nvar\r\n  i: nativeint;\r\n  v: PVarRec;\r\nbegin\r\n  Result:=nil;\r\n  while i<JSArguments.Length do\r\n    begin\r\n    new(v);\r\n    v^.VType:=byte(JSArguments[i]);\r\n    inc(i);\r\n    v^.VJSValue:=JSArguments[i];\r\n    inc(i);\r\n    TJSArray(Result).push(v^);\r\n    end;\r\nend;\r\n\r\nfunction ParamCount: Longint;\r\nbegin\r\n  if Assigned(OnParamCount) then\r\n    Result:=OnParamCount()\r\n  else\r\n    Result:=0;\r\nend;\r\n\r\nfunction ParamStr(Index: Longint): String;\r\nbegin\r\n  if Assigned(OnParamStr) then\r\n    Result:=OnParamStr(Index)\r\n  else if Index=0 then\r\n    Result:='js'\r\n  else\r\n    Result:='';\r\nend;\r\n\r\nfunction Frac(const A: Double): Double; assembler;\r\nasm\r\n  return A % 1;\r\nend;\r\n\r\nfunction Odd(const A: Integer): Boolean; assembler;\r\nasm\r\n  return A&1 != 0;\r\nend;\r\n\r\nfunction Random(const Range: Integer): Integer; assembler;\r\nasm\r\n  return Math.floor(Math.random()*Range);\r\nend;\r\n\r\nfunction Sqr(const A: Integer): Integer; assembler;\r\nasm\r\n  return A*A;\r\nend;\r\n\r\nfunction Sqr(const A: Double): Double; assembler;\r\nasm\r\n  return A*A;\r\nend;\r\n\r\nfunction Trunc(const A: Double): NativeInt; assembler;\r\nasm\r\n  if (!Math.trunc) {\r\n    Math.trunc = function(v) {\r\n      v = +v;\r\n      if (!isFinite(v)) return v;\r\n      return (v - v % 1) || (v < 0 ? -0 : v === 0 ? v : 0);\r\n    };\r\n  }\r\n  $mod.Trunc = Math.trunc;\r\n  return Math.trunc(A);\r\nend;\r\n\r\nfunction Copy(const S: string; Index, Size: Integer): String; assembler;\r\nasm\r\n  if (Index<1) Index = 1;\r\n  return (Size>0) ? S.substring(Index-1,Index+Size-1) : \"\";\r\nend;\r\n\r\nfunction Copy(const S: string; Index: Integer): String; assembler;\r\nasm\r\n  if (Index<1) Index = 1;\r\n  return S.substr(Index-1);\r\nend;\r\n\r\nprocedure Delete(var S: String; Index, Size: Integer);\r\nvar\r\n  h: String;\r\nbegin\r\n  if (Index<1) or (Index>length(S)) or (Size<=0) then exit;\r\n  h:=S;\r\n  S:=copy(h,1,Index-1)+copy(h,Index+Size);\r\nend;\r\n\r\nfunction Pos(const Search, InString: String): Integer; assembler;\r\nasm\r\n  return InString.indexOf(Search)+1;\r\nend;\r\n\r\nfunction Pos(const Search, InString: String; StartAt : Integer): Integer; assembler; overload;\r\nasm\r\n  return InString.indexOf(Search,StartAt-1)+1;\r\nend;\r\n\r\nprocedure Insert(const Insertion: String; var Target: String; Index: Integer);\r\nvar\r\n  t: String;\r\nbegin\r\n  if Insertion='' then exit;\r\n  t:=Target;\r\n  if Index<1 then\r\n    Target:=Insertion+t\r\n  else if Index>length(t) then\r\n    Target:=t+Insertion\r\n  else\r\n    Target:=copy(t,1,Index-1)+Insertion+copy(t,Index,length(t));\r\nend;\r\n\r\nvar\r\n  WriteBuf: String;\r\n  WriteCallBack : TConsoleHandler;\r\n\r\nFunction SetWriteCallBack(H : TConsoleHandler) : TConsoleHandler;\r\n\r\nbegin\r\n  Result:=WriteCallBack;\r\n  WriteCallBack:=H;\r\nend;\r\n\r\nprocedure Write;\r\nvar\r\n  i: Integer;\r\nbegin\r\n  for i:=0 to JSArguments.Length-1 do\r\n    if Assigned(WriteCallBack) then\r\n      WriteCallBack(JSArguments[i],False)\r\n    else\r\n      WriteBuf:=WriteBuf+String(JSArguments[i]);\r\nend;\r\n\r\nprocedure Writeln;\r\n\r\nvar\r\n  i,l: Integer;\r\n  s: String;\r\n\r\nbegin\r\n  L:=JSArguments.Length-1;\r\n  if Assigned(WriteCallBack) then\r\n    begin\r\n    for i:=0 to L do\r\n      WriteCallBack(JSArguments[i],I=L);\r\n    end\r\n  else\r\n    begin\r\n    s:=WriteBuf;\r\n    for i:=0 to L do\r\n      s:=s+String(JSArguments[i]);\r\n    asm\r\n      console.log(s);\r\n    end;\r\n    WriteBuf:='';\r\n    end;\r\nend;\r\n\r\nfunction Int(const A: Double): double;\r\n\r\nbegin\r\n  // trunc contains fix for missing Math.trunc in IE\r\n  Result:=Trunc(A);\r\nend;\r\n\r\nfunction Number(S: String): Double; external name 'Number';\r\n\r\nfunction valint(const S: String; MinVal, MaxVal: NativeInt; out Code: Integer): NativeInt;\r\nvar\r\n  x: double;\r\nbegin\r\n  if S='' then\r\n    begin\r\n    code:=1;\r\n    exit;\r\n    end;\r\n  x:=Number(S);\r\n  if isNaN(x) then\r\n    case copy(s,1,1) of\r\n    '$': x:=Number('0x'+copy(S,2));\r\n    '&': x:=Number('0o'+copy(S,2));\r\n    '%': x:=Number('0b'+copy(S,2));\r\n    else\r\n      Code:=1;\r\n      exit;\r\n    end;\r\n  if isNaN(x) or (X<>Int(X)) then\r\n    Code:=1\r\n  else if (x<MinVal) or (x>MaxVal) then\r\n    Code:=2\r\n  else\r\n    begin\r\n    Result:=Trunc(x);\r\n    Code:=0;\r\n    end;\r\nend;\r\n\r\nprocedure val(const S: String; out NI : NativeInt; out Code: Integer);\r\nbegin\r\n  NI:=valint(S,low(NI),high(NI),Code);\r\nend;\r\n\r\nprocedure val(const S: String; out NI: NativeUInt; out Code: Integer);\r\nvar\r\n  x : double;\r\nbegin\r\n  if S='' then\r\n    begin\r\n    code:=1;\r\n    exit;\r\n    end;\r\n  x:=Number(S);\r\n  if isNaN(x) or (X<>Int(X)) or (X<0) then\r\n    Code:=1\r\n  else\r\n    begin\r\n    Code:=0;\r\n    NI:=Trunc(x);\r\n    end;\r\nend;\r\n\r\nprocedure val(const S: String; out SI : ShortInt; out Code: Integer);\r\nbegin\r\n  SI:=valint(S,low(SI),high(SI),Code);\r\nend;\r\n\r\nprocedure val(const S: String; out SI: smallint; out Code: Integer);\r\nbegin\r\n  SI:=valint(S,low(SI),high(SI),Code);\r\nend;\r\n\r\nprocedure val(const S: String; out C: Cardinal; out Code: Integer);\r\nbegin\r\n  C:=valint(S,low(C),high(C),Code);\r\nend;\r\n\r\nprocedure val(const S: String; out B: Byte; out Code: Integer);\r\nbegin\r\n  B:=valint(S,low(B),high(B),Code);\r\nend;\r\n\r\nprocedure val(const S: String; out W: word; out Code: Integer);\r\nbegin\r\n  W:=valint(S,low(W),high(W),Code);\r\nend;\r\n\r\nprocedure val(const S : String; out I : integer; out Code : Integer);\r\nbegin\r\n  I:=valint(S,low(I),high(I),Code);\r\nend;\r\n\r\nprocedure val(const S : String; out d : double; out Code : Integer);\r\nVar\r\n  x: double;\r\nbegin\r\n  if S='' then\r\n    begin\r\n    code:=1;\r\n    exit;\r\n    end;\r\n  x:=Number(S);\r\n  if isNaN(x) then\r\n    Code:=1\r\n  else\r\n    begin\r\n    Code:=0;\r\n    d:=x;\r\n    end;\r\nend;\r\n\r\nprocedure val(const S: String; out b: boolean; out Code: Integer);\r\nbegin\r\n  if SameText(S,'true') then\r\n    begin\r\n    Code:=0;\r\n    b:=true;\r\n    end\r\n  else if SameText(S,'false') then\r\n    begin\r\n    Code:=0;\r\n    b:=false;\r\n    end\r\n  else\r\n    Code:=1;\r\nend;\r\n\r\nfunction binstr(val : NativeUInt;cnt : byte) : string;\r\nvar\r\n  i : Integer;\r\nbegin\r\n  SetLength(Result,cnt);\r\n  for i:=cnt downto 1 do\r\n   begin\r\n     Result[i]:=char(48+val and 1);\r\n     val:=val shr 1;\r\n   end;\r\nend;\r\n\r\nfunction upcase(c : char) : char; assembler;\r\nasm\r\n  return c.toUpperCase();\r\nend;\r\n\r\nfunction StringOfChar(c: Char; l: NativeInt): String;\r\nvar\r\n  i: Integer;\r\nbegin\r\n  asm\r\n    if ((l>0) && c.repeat) return c.repeat(l);\r\n  end;\r\n  Result:='';\r\n  for i:=1 to l do Result:=Result+c;\r\nend;\r\n\r\nfunction Assigned(const V: JSValue): boolean; assembler;\r\nasm\r\n  return (V!=undefined) && (V!=null) && (!rtl.isArray(V) || (V.length > 0));\r\nend;\r\n\r\nfunction StrictEqual(const A: JSValue; const B): boolean; assembler;\r\nasm\r\n  return A === B;\r\nend;\r\n\r\nfunction StrictInequal(const A: JSValue; const B): boolean; assembler;\r\nasm\r\n  return A !== B;\r\nend;\r\n\r\n{ TContainedObject }\r\n\r\nfunction TContainedObject.QueryInterface(const iid: TGuid; out obj): Integer;\r\nbegin\r\n  if GetInterface(iid,obj) then\r\n    Result:=S_OK\r\n  else\r\n    Result:=Integer(E_NOINTERFACE);\r\nend;\r\n\r\n{ TAggregatedObject }\r\n\r\nfunction TAggregatedObject.GetController: IUnknown;\r\nbegin\r\n  Result := IUnknown(fController);\r\nend;\r\n\r\nfunction TAggregatedObject.QueryInterface(const iid: TGuid; out obj): Integer;\r\nbegin\r\n  Result := IUnknown(fController).QueryInterface(iid, obj);\r\nend;\r\n\r\nfunction TAggregatedObject._AddRef: Integer;\r\nbegin\r\n  Result := IUnknown(fController)._AddRef;\r\nend;\r\n\r\nfunction TAggregatedObject._Release: Integer;\r\nbegin\r\n  Result := IUnknown(fController)._Release;\r\nend;\r\n\r\nconstructor TAggregatedObject.Create(const aController: IUnknown);\r\nbegin\r\n  inherited Create;\r\n  { do not keep a counted reference to the controller! }\r\n  fController := Pointer(aController);\r\nend;\r\n\r\n{ TInterfacedObject }\r\n\r\nfunction TInterfacedObject.QueryInterface(const iid: TGuid; out obj): Integer;\r\nbegin\r\n  if GetInterface(iid,obj) then\r\n    Result:=S_OK\r\n  else\r\n    Result:=Integer(E_NOINTERFACE);\r\nend;\r\n\r\nfunction TInterfacedObject._AddRef: Integer;\r\nbegin\r\n  inc(fRefCount);\r\n  Result:=fRefCount;\r\nend;\r\n\r\nfunction TInterfacedObject._Release: Integer;\r\nbegin\r\n  dec(fRefCount);\r\n  Result:=fRefCount;\r\n  if fRefCount=0 then\r\n    Destroy;\r\nend;\r\n\r\nprocedure TInterfacedObject.BeforeDestruction;\r\nbegin\r\n  if fRefCount<>0 then\r\n    asm\r\n    rtl.raiseE('EHeapMemoryError');\r\n    end;\r\nend;\r\n\r\n{ TObject }\r\n\r\nconstructor TObject.Create;\r\nbegin\r\n\r\nend;\r\n\r\ndestructor TObject.Destroy;\r\nbegin\r\n\r\nend;\r\n\r\nprocedure TObject.Free;\r\nbegin\r\n  Destroy;\r\nend;\r\n\r\nclass function TObject.ClassType: TClass; assembler;\r\nasm\r\n  return this;\r\nend;\r\n\r\nclass function TObject.ClassNameIs(const Name: string): boolean;\r\nbegin\r\n  Result:=SameText(Name,ClassName);\r\nend;\r\n\r\nclass function TObject.InheritsFrom(aClass: TClass): boolean; assembler;\r\nasm\r\n  return (aClass!=null) && ((this==aClass) || aClass.isPrototypeOf(this));\r\nend;\r\n\r\nClass function TObject.MethodName(aCode : Pointer) : String;\r\n\r\nbegin\r\n  Result:='';\r\n  if aCode=Nil then\r\n    exit;\r\nasm\r\n  if (typeof(aCode)!=='function') return \"\";\r\n  var i = 0;\r\n  var TI = this.$rtti;\r\n  if (rtl.isObject(aCode.scope)){\r\n    // callback\r\n    if (typeof aCode.fn === \"string\") return aCode.fn;\r\n    aCode = aCode.fn;\r\n  }\r\n  // Not a callback, check rtti\r\n  while ((Result === \"\") && (TI != null)) {\r\n    i = 0;\r\n    while ((Result === \"\") && (i < TI.methods.length)) {\r\n      if (this[TI.getMethod(i).name] === aCode)\r\n        Result=TI.getMethod(i).name;\r\n      i += 1;\r\n    };\r\n    if (Result === \"\") TI = TI.ancestor;\r\n  };\r\n  // return Result;\r\nend;\r\nend;\r\n\r\nClass function TObject.MethodAddress(aName : String) : Pointer;\r\n\r\n// We must do this in asm, because the typinfo unit is not available.\r\nbegin\r\n  Result:=Nil;\r\n  if AName='' then\r\n    exit;\r\nasm\r\n  var i = 0;\r\n  var TI = this.$rtti;\r\n  var N = \"\";\r\n  var MN = \"\";\r\n  N = aName.toLowerCase();\r\n  while ((MN === \"\") && (TI != null)) {\r\n    i = 0;\r\n    while ((MN === \"\") && (i < TI.methods.length)) {\r\n      if (TI.getMethod(i).name.toLowerCase() === N) MN = TI.getMethod(i).name;\r\n      i += 1;\r\n    };\r\n    if (MN === \"\") TI = TI.ancestor;\r\n  };\r\n  if (MN !== \"\") Result = this[MN];\r\n//  return Result;\r\nend;\r\nend;\r\n\r\nclass function TObject.FieldAddress(aName: String): Pointer;\r\n\r\nbegin\r\n  Result:=Nil;\r\n  if aName='' then exit;\r\n  asm\r\n    var aClass = this.$class;\r\n    var ClassTI = null;\r\n    var myName = aName.toLowerCase();\r\n    var MemberTI = null;\r\n    while (aClass !== null) {\r\n      ClassTI = aClass.$rtti;\r\n      for (var i = 0, $end2 = ClassTI.fields.length - 1; i <= $end2; i++) {\r\n        MemberTI = ClassTI.getField(i);\r\n        if (MemberTI.name.toLowerCase() === myName) {\r\n           return MemberTI;\r\n        };\r\n      };\r\n      aClass = aClass.$ancestor ? aClass.$ancestor : null;\r\n    };\r\n  end;\r\nend;\r\n\r\nClass Function TObject.ClassInfo : Pointer;\r\n\r\nbegin\r\n  // This works different from FPC/Delphi.\r\n  // We get the actual type info.\r\n  Result:=TypeInfo(Self);\r\nend;\r\n\r\nprocedure TObject.AfterConstruction;\r\nbegin\r\n\r\nend;\r\n\r\nprocedure TObject.BeforeDestruction;\r\nbegin\r\n\r\nend;\r\n\r\nprocedure TObject.Dispatch(var aMessage);\r\n// aMessage is a record with an integer field 'Msg'\r\nvar\r\n  aClass: TClass;\r\n  Msg: TJSObj absolute aMessage;\r\n  Id: jsvalue;\r\nbegin\r\n  if not isObject(Msg) then exit;\r\n  Id:=Msg['Msg'];\r\n  if not isNumber(Id) then exit;\r\n  aClass:=ClassType;\r\n  while aClass<>nil do\r\n    begin\r\n    asm\r\n      var Handlers = aClass.$msgint;\r\n      if (rtl.isObject(Handlers) && Handlers.hasOwnProperty(Id)){\r\n        this[Handlers[Id]](aMessage);\r\n        return;\r\n      }\r\n    end;\r\n    aClass:=aClass.ClassParent;\r\n    end;\r\n  DefaultHandler(aMessage);\r\nend;\r\n\r\nprocedure TObject.DispatchStr(var aMessage);\r\n// aMessage is a record with a string field 'MsgStr'\r\nvar\r\n  aClass: TClass;\r\n  Msg: TJSObj absolute aMessage;\r\n  Id: jsvalue;\r\nbegin\r\n  if not isObject(Msg) then exit;\r\n  Id:=Msg['MsgStr'];\r\n  if not isString(Id) then exit;\r\n  aClass:=ClassType;\r\n  while (aClass<>Nil) do\r\n    begin\r\n    asm\r\n      var Handlers = aClass.$msgstr;\r\n      if (rtl.isObject(Handlers) && Handlers.hasOwnProperty(Id)){\r\n        this[Handlers[Id]](aMessage);\r\n        return;\r\n      }\r\n    end;\r\n    aClass:=aClass.ClassParent;\r\n    end;\r\n  DefaultHandlerStr(aMessage);\r\nend;\r\n\r\nprocedure TObject.DefaultHandler(var aMessage);\r\nbegin\r\n  if jsvalue(TMethod(aMessage)) then ;\r\nend;\r\n\r\nprocedure TObject.DefaultHandlerStr(var aMessage);\r\nbegin\r\n  if jsvalue(TMethod(aMessage)) then ;\r\nend;\r\n\r\nfunction TObject.GetInterface(const iid: TGuid; out obj): boolean;\r\nbegin\r\n  asm\r\n    var i = iid.$intf;\r\n    if (i){\r\n      // iid is the private TGuid of an interface\r\n      i = rtl.getIntfG(this,i.$guid,2);\r\n      if (i){\r\n        obj.set(i);\r\n        return true;\r\n      }\r\n    }\r\n  end;\r\n  Result := GetInterfaceByStr(GUIDToString(iid),obj);\r\nend;\r\n\r\nfunction TObject.GetInterface(const iidstr: String; out obj): boolean;\r\nbegin\r\n  Result := GetInterfaceByStr(iidstr,obj);\r\nend;\r\n\r\nfunction TObject.GetInterfaceByStr(const iidstr: String; out obj): boolean;\r\nbegin\r\n  Result:=false;\r\n  if not TJSObj(IObjectInstance)['$str'] then\r\n    TJSObj(IObjectInstance)['$str']:=GUIDToString(IObjectInstance);\r\n  if iidstr = TJSObj(IObjectInstance)['$str'] then\r\n    begin\r\n    obj:=Self;\r\n    exit(true);\r\n    end;\r\n  asm\r\n    var i = rtl.getIntfG(this,iidstr,2);\r\n    obj.set(i);\r\n    Result=(i!==null);\r\n  end;\r\nend;\r\n\r\nfunction TObject.GetInterfaceWeak(const iid: TGuid; out obj): boolean;\r\nbegin\r\n  Result:=GetInterface(iid,obj);\r\n  asm\r\n    if (Result){\r\n      var o = obj.get();\r\n      if (o.$kind==='com'){\r\n        o._Release();\r\n      }\r\n    }\r\n  end;\r\nend;\r\n\r\nfunction TObject.Equals(Obj: TObject): boolean;\r\nbegin\r\n  Result:=Obj=Self;\r\nend;\r\n\r\nfunction TObject.ToString: String;\r\nbegin\r\n  Result:=ClassName;\r\nend;\r\n\r\nclass function TObject.QualifiedClassName: String;\r\nbegin\r\n  Result := UnitName + '.' + ClassName;\r\nend;\r\n\r\ninitialization\r\n  ExitCode:=0; // set it here, so that WPO does not remove it\r\n\r\nend.\r\n\r\n","{\r\n    This file is part of the Pas2JS run time library.\r\n    Copyright (c) 2017 by Mattias Gaertner\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n{$IFNDEF FPC_DOTTEDUNITS}\r\nunit RTLConsts;\r\n{$ENDIF}\r\n\r\ninterface\r\n\r\nResourcestring\r\n  SArgumentMissing              = 'Missing argument in format \"%s\"';\r\n  SInvalidFormat                = 'Invalid format specifier : \"%s\"';\r\n  SInvalidArgIndex              = 'Invalid argument index in format: \"%s\"';\r\n  SListCapacityError            = 'List capacity (%s) exceeded.';\r\n  SListCountError               = 'List count (%s) out of bounds.';\r\n  SMapKeyError                  = 'Key not found : %s';\r\n  SListIndexError               = 'List index (%s) out of bounds';\r\n  SSortedListError              = 'Operation not allowed on sorted list';\r\n  SDuplicateString              = 'String list does not allow duplicates';\r\n  SDuplicateItem                = 'ThreadList does not allow duplicates';\r\n  SErrFindNeedsSortedList       = 'Cannot use find on unsorted list';\r\n\r\n  SInvalidName                  = 'Invalid component name: \"%s\"';\r\n  SInvalidBoolean               = '\"%s\" is not a valid boolean.';\r\n  SDuplicateName                = 'Duplicate component name: \"%s\"';\r\n\r\n  SErrInvalidDate               = 'Invalid date: \"%s\"';\r\n  SErrInvalidTimeFormat         = 'Invalid time format: \"%s\"';\r\n  SInvalidDateFormat            = 'Invalid date format: \"%s\"';\r\n\r\n  SCantReadPropertyS            = 'Cannot read property \"%s\"';\r\n  SCantWritePropertyS           = 'Cannot write property \"%s\"';\r\n  SErrPropertyNotFound          = 'Unknown property: \"%s\"';\r\n  SIndexedPropertyNeedsParams   = 'Indexed property \"%s\" needs parameters';\r\n  SErrInvalidTypecast           = 'Invalid class typecast';\r\n\r\n  SErrInvalidInteger            = 'Invalid integer value: \"%s\"';\r\n  SErrInvalidFloat              = 'Invalid floating-point value: \"%s\"';\r\n  SInvalidDateTime              = 'Invalid date-time value: %s';\r\n  SInvalidCurrency              = 'Invalid currency value: %s';\r\n  SErrInvalidDayOfWeek          = '%d is not a valid day of the week';\r\n  SErrInvalidTimeStamp          = 'Invalid date/timestamp : \"%s\"';\r\n  SErrInvalidDateWeek           = '%d %d %d is not a valid dateweek';\r\n  SErrInvalidDayOfYear          = 'Year %d does not have a day number %d';\r\n  SErrInvalidDateMonthWeek      = 'Year %d, month %d, Week %d and day %d is not a valid date.';\r\n  SErrInvalidDayOfWeekInMonth   = 'Year %d Month %d NDow %d DOW %d is not a valid date';\r\n  SInvalidJulianDate            = '%f Julian cannot be represented as a DateTime';\r\n  SErrInvalidHourMinuteSecMsec  = '%d:%d:%d.%d is not a valid time specification';\r\n\r\n  SInvalidGUID                  = '\"%s\" is not a valid GUID value';\r\n\r\n  SEmptyStreamIllegalReader       = 'Illegal Nil stream for TReader constructor';\r\n  SInvalidPropertyValue           = 'Invalid value for property';\r\n  SInvalidImage                   = 'Invalid stream format';\r\n  SUnknownProperty                = 'Unknown property: \"%s\"';\r\n  SUnknownPropertyType            = 'Unknown property type %s';\r\n  SAncestorNotFound               = 'Ancestor class for \"%s\" not found.';\r\n  SUnsupportedPropertyVariantType = 'Unsupported property variant type %d';\r\n  SPropertyException              = 'Error reading %s%s%s: %s';\r\n  SInvalidPropertyPath            = 'Invalid property path';\r\n  SReadOnlyProperty               = 'Property is read-only';\r\n  SClassNotFound                  = 'Class \"%s\" not found';\r\n\r\n  SEmptyStreamIllegalWriter       = 'Illegal Nil stream for TWriter constructor';\r\n  SErrInvalidPropertyType         = 'Invalid property type from streamed property: %d';\r\n  SParserExpected                 = 'Wrong token type: %s expected';\r\n  SParserInvalidFloat             = 'Invalid floating point number: %s';\r\n  SParserInvalidInteger           = 'Invalid integer number: %s';\r\n  SParserUnterminatedString       = 'Unterminated string';\r\n  SParserWrongTokenType           = 'Wrong token type: %s expected but %s found';\r\n  SParserWrongTokenSymbol         = 'Wrong token symbol: %s expected but %s found';\r\n  SParserLocInfo                  = ' (at %d,%d, stream offset %.8x)';\r\n  SParserUnterminatedBinValue     = 'Unterminated byte value';\r\n  SParserInvalidProperty          = 'Invalid property';\r\n  SRangeError                     = 'Range error';\r\n\r\n  SParamIsNegative                = 'Parameter \"%s\" cannot be negative.';\r\n\r\n  SErrNoStreaming                 = 'Failed to initialize component class \"%s\": No streaming method available.';\r\n  SResNotFound                    = 'Resource %s not found';\r\n  SErrResourceStreamNoWrite       = 'Cannot write to resource stream';\r\n  SErrResourceNotBase64           = 'Resource %s is not base64 encoded';\r\n  SErrUnknownResourceEncoding     = 'Unknown encoding for resource: \"%s\"';\r\n\r\nimplementation\r\n\r\nend.\r\n\r\n","{\r\n    This file is part of the Pas2JS run time library.\r\n    Copyright (c) 2018 by Mattias Gaertner\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n{$IFNDEF FPC_DOTTEDUNITS}\r\nunit Types;\r\n{$ENDIF}\r\n\r\n{$mode objfpc}\r\n\r\ninterface\r\n\r\ntype\r\n  THandle = NativeInt;\r\n  TDirection = (FromBeginning, FromEnd);\r\n\r\n  TBooleanDynArray = array of Boolean;\r\n  TWordDynArray = array of Word;\r\n  TIntegerDynArray = array of Integer;\r\n  TNativeIntDynArray = array of NativeInt;\r\n  TStringDynArray = array of String;\r\n  TDoubleDynArray = array of Double;\r\n  TJSValueDynArray = array of JSValue;\r\n  TObjectDynArray = array of TObject;\r\n  TByteDynArray = array of Byte;\r\n\r\n  TDuplicates = (dupIgnore, dupAccept, dupError);\r\n  TProc = Reference to Procedure;\r\n  TProcString = Reference to Procedure(Const aString : String);\r\n\r\n  TListCallback = procedure(data, arg: JSValue) of object;\r\n  TListStaticCallback = procedure(data, arg: JSValue);\r\n\r\n  TSize  = record\r\n    cx, cy: integer;\r\n  end;\r\n\r\n  TPoint  = record\r\n    x, y: integer;\r\n  end;\r\n\r\n  TRect  = record\r\n    Left, Top, Right, Bottom: Integer;\r\n  end;\r\n  \r\nfunction EqualRect(const r1,r2 : TRect) : Boolean;\r\nfunction Rect(Left, Top, Right, Bottom : Integer) : TRect;\r\nfunction Bounds(ALeft, ATop, AWidth, AHeight : Integer) : TRect;\r\nfunction Point(x,y : Integer): TPoint; {$IFDEF Has_Inline}inline;{$ENDIF}\r\nfunction PtInRect(const aRect: TRect; const p: TPoint) : Boolean;\r\nfunction IntersectRect(out aRect: TRect; const R1,R2: TRect) : Boolean;\r\nfunction UnionRect(out aRect: TRect; const R1,R2: TRect) : Boolean;\r\nfunction IsRectEmpty(const aRect: TRect) : Boolean;\r\nfunction OffsetRect(var aRect: TRect; DX, DY: Integer) : Boolean;\r\nfunction CenterPoint(const aRect: TRect): TPoint;\r\nfunction InflateRect(var aRect: TRect; dx, dy: Integer): Boolean;\r\nfunction Size(AWidth, AHeight: Integer): TSize;\r\nfunction Size(const aRect: TRect): TSize;\r\n\r\nimplementation\r\n\r\nfunction EqualRect(const r1, r2: TRect): Boolean;\r\nbegin\r\n  Result:=(r1.left=r2.left) and (r1.right=r2.right) and (r1.top=r2.top) and (r1.bottom=r2.bottom);\r\nend;\r\n\r\nfunction Rect(Left, Top, Right, Bottom: Integer): TRect;\r\nbegin\r\n  Result.Left:=Left;\r\n  Result.Top:=Top;\r\n  Result.Right:=Right;\r\n  Result.Bottom:=Bottom;\r\nend;\r\n\r\nfunction Bounds(ALeft, ATop, AWidth, AHeight: Integer): TRect;\r\nbegin\r\n  Result.Left:=ALeft;\r\n  Result.Top:=ATop;\r\n  Result.Right:=ALeft+AWidth;\r\n  Result.Bottom:=ATop+AHeight;\r\nend;\r\n\r\nfunction Point(x, y: Integer): TPoint;\r\nbegin\r\n  Result.x:=x;\r\n  Result.y:=y;\r\nend;\r\n\r\nfunction PtInRect(const aRect: TRect; const p: TPoint): Boolean;\r\nbegin\r\n  Result:=(p.y>=aRect.Top) and\r\n          (p.y<aRect.Bottom) and\r\n          (p.x>=aRect.Left) and\r\n          (p.x<aRect.Right);\r\nend;\r\n\r\nfunction IntersectRect(out aRect: TRect; const R1, R2: TRect): Boolean;\r\nvar\r\n  lRect: TRect;\r\nbegin\r\n  lRect := R1;\r\n  if R2.Left > R1.Left then\r\n    lRect.Left := R2.Left;\r\n  if R2.Top > R1.Top then\r\n    lRect.Top := R2.Top;\r\n  if R2.Right < R1.Right then\r\n    lRect.Right := R2.Right;\r\n  if R2.Bottom < R1.Bottom then\r\n    lRect.Bottom := R2.Bottom;\r\n\r\n  // The var parameter is only assigned in the end to avoid problems\r\n  // when passing the same rectangle in the var and const parameters.\r\n  if IsRectEmpty(lRect) then\r\n  begin\r\n    aRect:=Rect(0,0,0,0);\r\n    Result:=false;\r\n  end\r\n  else\r\n  begin\r\n    Result:=true;\r\n    aRect := lRect;\r\n  end;\r\nend;\r\n\r\nfunction UnionRect(out aRect: TRect; const R1, R2: TRect): Boolean;\r\nvar\r\n  lRect: TRect;\r\nbegin\r\n  lRect:=R1;\r\n  if R2.Left<R1.Left then\r\n    lRect.Left:=R2.Left;\r\n  if R2.Top<R1.Top then\r\n    lRect.Top:=R2.Top;\r\n  if R2.Right>R1.Right then\r\n    lRect.Right:=R2.Right;\r\n  if R2.Bottom>R1.Bottom then\r\n    lRect.Bottom:=R2.Bottom;\r\n\r\n  if IsRectEmpty(lRect) then\r\n  begin\r\n    aRect:=Rect(0,0,0,0);\r\n    Result:=false;\r\n  end\r\n  else\r\n  begin\r\n    aRect:=lRect;\r\n    Result:=true;\r\n  end;\r\nend;\r\n\r\nfunction IsRectEmpty(const aRect: TRect): Boolean;\r\nbegin\r\n  Result:=(aRect.Right<=aRect.Left) or (aRect.Bottom<=aRect.Top);\r\nend;\r\n\r\nfunction OffsetRect(var aRect: TRect; DX, DY: Integer): Boolean;\r\nbegin\r\n  with aRect do\r\n    begin\r\n    inc(Left,dx);\r\n    inc(Top,dy);\r\n    inc(Right,dx);\r\n    inc(Bottom,dy);\r\n    end;\r\n  Result:=true;\r\nend;\r\n\r\nfunction CenterPoint(const aRect: TRect): TPoint;\r\n\r\n  function Avg(a, b: Longint): Longint;\r\n  begin\r\n    if a < b then\r\n      Result := a + ((b - a) shr 1)\r\n    else\r\n      Result := b + ((a - b) shr 1);\r\n  end;\r\n\r\nbegin\r\n  with aRect do\r\n    begin\r\n      Result.X := Avg(Left, Right);\r\n      Result.Y := Avg(Top, Bottom);\r\n    end;\r\nend;\r\n\r\nfunction InflateRect(var aRect: TRect; dx, dy: Integer): Boolean;\r\nbegin\r\n  with aRect do\r\n  begin\r\n    dec(Left, dx);\r\n    dec(Top, dy);\r\n    inc(Right, dx);\r\n    inc(Bottom, dy);\r\n  end;\r\n  Result := True;\r\nend;\r\n\r\nfunction Size(AWidth, AHeight: Integer): TSize;\r\nbegin\r\n  Result.cx := AWidth;\r\n  Result.cy := AHeight;\r\nend;\r\n\r\nfunction Size(const aRect: TRect): TSize;\r\nbegin\r\n  Result.cx := aRect.Right - aRect.Left;\r\n  Result.cy := aRect.Bottom - aRect.Top;\r\nend;\r\n\r\nend.\r\n\r\n","{\r\n    This file is part of the Pas2JS run time library.\r\n    Copyright (c) 2017-2020 by the Pas2JS development team.\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n{$IFNDEF FPC_DOTTEDUNITS}\r\nunit JS;\r\n{$ENDIF}\r\n\r\n{$mode objfpc}\r\n{$modeswitch externalclass}\r\n\r\ninterface\r\n\r\nuses\r\n{$IFDEF FPC_DOTTEDUNITS}\r\n  System.Types;\r\n{$ELSE}\r\n  Types;\r\n{$ENDIF}\r\n\r\ntype\r\n  // We cannot use EConvertError or Exception, this would result in a circular dependency.\r\n  TJSArray = class;\r\n  TJSMap = class;\r\n  { EJS }\r\n\r\n  EJS = class(TObject)\r\n  private\r\n    FMessage: string;\r\n  Public\r\n    constructor Create(const Msg: String); reintroduce;\r\n    property Message : string Read FMessage Write FMessage;\r\n  end;\r\n\r\n  TJSObjectPropertyDescriptor = JSValue;\r\n  Float32 = Double;\r\n  Float64 = Double;\r\n\r\n  { TJSObject }\r\n\r\n  TJSObject = class external name 'Object'\r\n  private\r\n    function GetProperties(Name: String): JSValue; external name '[]';\r\n    procedure SetProperties(Name: String; const AValue: JSValue); external name '[]';\r\n  public\r\n    constructor new;\r\n    class function create(const proto: TJSObject): TJSObject;\r\n    class function create(const proto, propertiesObject: TJSObject): TJSObject;\r\n    class function assign(const Target, Source1: TJSObject): TJSObject; varargs;\r\n    class procedure defineProperty(const obj: TJSObject; propname: String; const descriptor: TJSObjectPropertyDescriptor);\r\n    //class procedure defineProperties\r\n    class function freeze(const obj: TJSObject): TJSObject;\r\n    class function getOwnPropertyDescriptor(const obj: TJSObject; propname: String): TJSObjectPropertyDescriptor;\r\n    //class function getOwnPropertyDescriptors\r\n    class function getOwnPropertyNames(const obj: TJSObject): TStringDynArray;\r\n    class function values(const obj: JSValue): TJSObject;\r\n    {$IFDEF FIREFOX}\r\n    class function getOwnPropertySymbols(const obj: TJSObject): TJSValueDynArray;\r\n    {$ENDIF}\r\n    class function getPrototypeOf(const obj: TJSObject): TJSObject;\r\n    {$IFDEF FIREFOX}\r\n    class function _is(const value1, value2: JSValue): boolean;\r\n    {$ENDIF}\r\n    class function fromEntries(const obj: TJSObject): TJSObject;\r\n    class function fromEntries(const obj: TJSArray): TJSObject;\r\n    class function fromEntries(const obj: TJSMap): TJSObject;\r\n    class function isExtensible(const obj: TJSObject): boolean;\r\n    class function isFrozen(const obj: TJSObject): boolean;\r\n    class function isSealed(const obj: TJSObject): boolean;\r\n    class function keys(const obj: TJSObject): TStringDynArray;\r\n    class function preventExtensions(const obj: TJSObject): TJSObject;\r\n    class function seal(const obj: TJSObject): TJSObject;\r\n    class function setPrototypeOf(const obj, prototype: TJSObject): TJSObject;\r\n    function hasOwnProperty(prop: String): boolean;\r\n    function isPrototypeOf(const obj: TJSObject): boolean;\r\n    function propertyIsEnumerable(propname: String): boolean;\r\n    function toLocaleString: String;\r\n    function toString: String;\r\n    function valueOf: JSValue;\r\n    property Properties[Name: String]: JSValue read GetProperties write SetProperties; default;\r\n  end;\r\n  TJSObjectClass = class of TJSObject;\r\n\r\n  TJSObjectDynArray = Array of TJSObject;\r\n  TJSObjectDynArrayArray = Array of TJSObjectDynArray;\r\n  TJSStringDynArray = Array of String;\r\n\r\n\r\n  { TJSIteratorValue }\r\n  TJSIteratorValue = class external name 'IteratorValue'\r\n  public\r\n    value : JSValue; external name 'value';\r\n    done : boolean; external name 'done';\r\n  end;\r\n\r\n  { TJSIterator }\r\n  TJSIterator = class external name 'Iterator'\r\n  Public\r\n    function next: TJSIteratorValue;\r\n  end;\r\n\r\n\r\n  TJSSet = class;\r\n\r\n  TJSSetEventProc = reference to procedure(value : JSValue; key: NativeInt; set_: TJSSet);\r\n  TJSSetProcCallBack = reference  to procedure(value: JSValue; key: JSValue);\r\n\r\n  { TJSSet }\r\n  TJSSet = class external name 'Set'\r\n  private\r\n    FSize : NativeInt; external name 'size';\r\n  public\r\n    constructor new; overload;\r\n    constructor new(aElement1 : JSValue); varargs; overload;\r\n    function add(value: JSValue): TJSSet;\r\n    function has(value: JSValue): Boolean;\r\n    function delete(value: JSValue): Boolean;\r\n    procedure clear;\r\n    function values: TJSIterator;\r\n    procedure forEach(const aCallBack: TJSSetEventProc); overload;\r\n    procedure forEach(const aCallBack: TJSSetProcCallBack); overload;\r\n    procedure forEach(const aCallBack: TJSSetEventProc; thisArg: JSValue); overload;\r\n    function entries: TJSIterator;\r\n    function keys: TJSIterator;\r\n    Property size : NativeInt Read FSize;\r\n  end;\r\n\r\n  TJSMapFunctionCallBack = reference  to function(arg : JSValue): JSValue;\r\n  TJSMapProcCallBack = reference  to procedure(value: JSValue; key: JSValue);\r\n\r\n  { TJSMap }\r\n\r\n  TJSMap = class external name 'Map'\r\n  Private\r\n    FSize : NativeInt; external name 'size';\r\n  public\r\n    constructor new; varargs; overload;\r\n    constructor new(aElement1 : JSValue); varargs; overload;\r\n    function &set(key: JSValue; value: JSValue) :TJSMap;\r\n    function get(key : JSValue): JSValue;\r\n    function has(key: JSValue): Boolean;\r\n    function delete(key: JSValue): Boolean;\r\n    procedure clear;\r\n    function entries: TJSIterator;\r\n    procedure forEach(const aCallBack: TJSMapFunctionCallBack); overload;\r\n    procedure forEach(const aCallBack: TJSMapFunctionCallBack; thisArg: JSValue); overload;\r\n    procedure forEach(const aCallBack: TJSMapProcCallBack); overload;\r\n    function keys: TJSIterator;\r\n    function values: TJSIterator;\r\n    property size : NativeInt Read FSize;\r\n  end;\r\n\r\n  { TJSFunction }\r\n\r\n  TJSFunction = class external name 'Function'(TJSObject)\r\n  private\r\n    Flength: NativeInt external name 'length';\r\n    Fprototyp: TJSFunction external name 'prototyp';\r\n  public\r\n    name: String;\r\n    property prototyp: TJSFunction read Fprototyp;\r\n    property length: NativeInt read Flength;\r\n    function apply(thisArg: TJSObject; const ArgArray: TJSValueDynArray): JSValue; varargs;\r\n    function bind(thisArg: TJSObject): JSValue; varargs;\r\n    function call(thisArg: TJSObject): JSValue; varargs;\r\n  end;\r\n\r\n  { TJSDate - wrapper for JavaScript Date }\r\n\r\n  TJSDate = class external name 'Date'(TJSFunction)\r\n  private\r\n    function getDate: NativeInt;\r\n    function getFullYear: NativeInt;\r\n    function getHours: NativeInt;\r\n    function getMilliseconds: NativeInt;\r\n    function getMinutes: NativeInt;\r\n    function getMonth: NativeInt;\r\n    function getSeconds: NativeInt;\r\n    function getYear: NativeInt;\r\n    function getTime: NativeInt;\r\n    function getUTCDate: NativeInt;\r\n    function getUTCFullYear: NativeInt;\r\n    function getUTCHours: NativeInt;\r\n    function getUTCMilliseconds: NativeInt;\r\n    function getUTCMinutes: NativeInt;\r\n    function getUTCMonth: NativeInt;\r\n    function getUTCSeconds: NativeInt;\r\n    procedure setDate(const AValue: NativeInt);\r\n    procedure setFullYear(const AValue: NativeInt);\r\n    procedure setHours(const AValue: NativeInt);\r\n    procedure setMilliseconds(const AValue: NativeInt);\r\n    procedure setMinutes(const AValue: NativeInt);\r\n    procedure setMonth(const AValue: NativeInt);\r\n    procedure setSeconds(const AValue: NativeInt);\r\n    procedure setYear(const AValue: NativeInt);\r\n    procedure setTime(const AValue: NativeInt);\r\n    procedure setUTCDate(const AValue: NativeInt);\r\n    procedure setUTCFullYear(const AValue: NativeInt);\r\n    procedure setUTCHours(const AValue: NativeInt);\r\n    procedure setUTCMilliseconds(const AValue: NativeInt);\r\n    procedure setUTCMinutes(const AValue: NativeInt);\r\n    procedure setUTCMonth(const AValue: NativeInt);\r\n    procedure setUTCSeconds(const AValue: NativeInt);\r\n  public\r\n    constructor New; reintroduce;\r\n    constructor New(const MilliSecsSince1970: NativeInt); // milliseconds since 1 January 1970 00:00:00 UTC, with leap seconds ignored\r\n    constructor New(const aDateString: String); // RFC 2822, ISO8601\r\n    constructor New(aYear: NativeInt; aMonth: NativeInt; aDayOfMonth: NativeInt = 1;\r\n      TheHours: NativeInt = 0; TheMinutes: NativeInt = 0; TheSeconds: NativeInt = 0;\r\n      TheMilliseconds: NativeInt = 0);\r\n    class function now: NativeInt; // current date and time in milliseconds since 1 January 1970 00:00:00 UTC, with leap seconds ignored\r\n    class function parse(const aDateString: string): NativeInt; // format depends on browser\r\n    class function UTC(aYear: NativeInt; aMonth: NativeInt = 0; aDayOfMonth: NativeInt = 1;\r\n      TheHours: NativeInt = 0; TheMinutes: NativeInt = 0; TheSeconds: NativeInt = 0;\r\n      TheMilliseconds: NativeInt = 0): NativeInt;\r\n    function getDay: NativeInt;\r\n    function getTimezoneOffset: NativeInt;\r\n    function getUTCDay: NativeInt; // day of the week\r\n    function toDateString: string; // human readable date, without time\r\n    function toISOString: string; // ISO 8601 Extended Format\r\n    function toJSON: string;\r\n    function toGMTString: string; // in GMT timezone\r\n    function toLocaleDateString: string; overload; // date in locale timezone, no time\r\n    function toLocaleDateString(const aLocale : string) : string; overload; // date in locale timezone, no time\r\n    function toLocaleDateString(const aLocale : string; aOptions : TJSObject) : string; overload; // date in locale timezone, no time\r\n    function toLocaleString: string; reintroduce; // date and time in locale timezone\r\n    function toLocaleTimeString: string; // time in locale timezone, no date\r\n    function toTimeString: string; // time human readable, no date\r\n    function toUTCString: string; // date and time using UTC timezone\r\n    property Year: NativeInt read getYear write setYear;\r\n    property Time: NativeInt read getTime write setTime; // milliseconds since 1 January 1970 00:00:00 UTC, with leap seconds ignored\r\n    property FullYear: NativeInt read getFullYear write setFullYear;\r\n    property UTCDate: NativeInt read getUTCDate write setUTCDate; // day of month\r\n    property UTCFullYear: NativeInt read getUTCFullYear write setUTCFullYear;\r\n    property UTCHours: NativeInt read getUTCHours write setUTCHours;\r\n    property UTCMilliseconds: NativeInt read getUTCMilliseconds write setUTCMilliseconds;\r\n    property UTCMinutes: NativeInt read getUTCMinutes write setUTCMinutes;\r\n    property UTCMonth: NativeInt read getUTCMonth write setUTCMonth;\r\n    property UTCSeconds: NativeInt read getUTCSeconds write setUTCSeconds;\r\n    property Month: NativeInt read getMonth write setMonth;\r\n    property Date: NativeInt read getDate write setDate; // day of the month, starting at 1\r\n    property Hours: NativeInt read getHours write setHours;\r\n    property Minutes: NativeInt read getMinutes write setMinutes;\r\n    property Seconds: NativeInt read getSeconds write setSeconds;\r\n    property Milliseconds: NativeInt read getMilliseconds write setMilliseconds;\r\n  end;\r\n\r\n  { TJSSymbol }\r\n\r\n  TJSSymbol = class external name 'Symbol' (TJSFunction)\r\n  private\r\n  Private\r\n    FDescription: String; external name 'description';\r\n  Public\r\n    constructor new (aValue : JSValue);\r\n    class function for_ (key : string) : TJSSymbol;\r\n    class function keyFor (aSymbol : TJSSymbol) : string;\r\n    property Description : String Read FDescription;\r\n  end;\r\n\r\n  TLocaleCompareOptions = record\r\n    localematched : string;\r\n    usage: string;\r\n    sensitivity : string;\r\n    ignorePunctuation : Boolean;\r\n    numeric : boolean;\r\n    caseFirst : string;\r\n  end;\r\n\r\n  TJSRegexp = class external name 'RegExp'\r\n  private\r\n  {$IFDEF FIREFOX}\r\n    // not on all browsers:\r\n    FFlags : string; external name 'flags';\r\n    FSticky : boolean; external name 'sticky';\r\n  {$endif}\r\n    fglobal: boolean; external name 'global';\r\n    fignoreCase : boolean; external name 'ignoreCase';\r\n    fmultiline : boolean; external name 'multiline';\r\n    fsource : string; external name 'source';\r\n    funicode : boolean; external name 'unicode';\r\n  public\r\n    Constructor New(Pattern : string);\r\n    Constructor New(Pattern, Flags : string);\r\n    lastIndex: NativeInt;\r\n    function exec(aString : string): TStringDynArray;\r\n    function test(aString : string) : boolean;\r\n    function toString : String;\r\n    property Global : boolean read fglobal;\r\n    property IgnoreCase : Boolean read FIgnoreCase;\r\n    property Multiline : Boolean Read FMultiLine;\r\n    Property Source : string Read FSource;\r\n    Property Unicode : boolean Read FUnicode;\r\n    {$IFDEF FIREFOX}\r\n    // not on all browsers:\r\n    property Flags : string read FFlags;\r\n    property Sticky : boolean read FSticky;\r\n    {$endif}\r\n  end;\r\n\r\n\r\n  TReplaceCallBack = reference to Function (Const match : string) : string; varargs;\r\n  TReplaceCallBack0 = reference to Function (Const match : string; offset : Integer; AString : String) : string;\r\n  TReplaceCallBack1 = reference to Function (Const match,p1 : string; offset : Integer; AString : String) : string;\r\n  TReplaceCallBack2 = reference to Function (Const match,p1,p2 : string; offset : Integer; AString : String) : string;\r\n\r\n  TJSString = class external name 'String'\r\n  private\r\n    flength : NativeInt; external name 'length';\r\n  public \r\n    constructor New(Const S : String);\r\n    constructor New(Const I : NativeInt);\r\n    constructor New(Const D : double);\r\n    property length : NativeInt read flength; \r\n    class function fromCharCode() : string; varargs;\r\n    class function fromCodePoint() : string; varargs;\r\n    function anchor(const aName : string) : string; deprecated;\r\n    function at(const index: Integer): String;\r\n    function charAt(aIndex : NativeInt) : string;\r\n    function charCodeAt(aIndex : NativeInt) : NativeInt;\r\n    function codePointAt(aIndex : NativeInt) : NativeInt;\r\n    function concat(s : string) : string; varargs;\r\n    function endsWith(aSearchString : string) : boolean; overload;\r\n    function endsWith(aSearchString : string; Pos : NativeInt) : boolean; overload;\r\n    function includes(aSearchString : string; Pos : NativeInt = 0) : boolean;\r\n    function indexOf(aSearchString : String; Pos : NativeInt = 0) : Integer;\r\n    function isWellFormed: Boolean;\r\n    function lastIndexOf(aSearchString : String) : NativeInt;overload;\r\n    function lastIndexOf(aSearchString : String; Pos : NativeInt) : Integer;overload;\r\n    function link(aUrl : string) : String; deprecated;\r\n    function localeCompare(aCompareString : string) : NativeInt; overload;\r\n    function localeCompare(aCompareString : string; aLocales: string) : integer; overload;\r\n    function localeCompare(compareString : string; locales: string; Options : TlocaleCompareOptions) : integer; overload;\r\n    function match(aRegexp : TJSRegexp) : TStringDynArray; overload;\r\n    function match(aRegexp : String) : TStringDynArray; overload;\r\n    function matchAll(aRegexp : TJSRegexp) : TJSIterator; overload;\r\n    function matchAll(aRegexp : String) : TJSIterator; overload;\r\n    {$IFDEF ECMAScript6}\r\n    function normalize : string;\r\n    function normalize(aForm : string) : string;\r\n    {$ENDIF}\r\n    function padEnd(targetLength: Integer): String; overload;\r\n    function padEnd(targetLength: Integer; padString: String): String; overload;\r\n    function padStart(targetLength: Integer): String; overload;\r\n    function padStart(targetLength: Integer; padString: String): String; overload;\r\n    function _repeat(aCount : NativeInt) : Integer; external name 'repeat';\r\n    function replace(aRegexp : String; NewString : String) : String; overload;\r\n    function replace(aRegexp : TJSRegexp; NewString : String) : String; overload;\r\n    function replace(Regexp : String; aCallback : TReplaceCallBack) : String; overload;\r\n    function replace(Regexp : TJSRegexp; aCallback : TReplaceCallBack) : String; overload;\r\n    function replace(Regexp : String; aCallback : TReplaceCallBack0) : String; overload;\r\n    function replace(Regexp : TJSRegexp; aCallback : TReplaceCallBack0) : String; overload;\r\n    function replace(Regexp : String; aCallback : TReplaceCallBack1) : String; overload;\r\n    function replace(Regexp : TJSRegexp; aCallback : TReplaceCallBack1) : String; overload;\r\n    function replace(Regexp : String; aCallback : TReplaceCallBack2) : String; overload;\r\n    function replace(Regexp : TJSRegexp; aCallback : TReplaceCallBack2) : String; overload;\r\n    function replaceAll(aRegexp : String; NewString : String) : String; overload;\r\n    function replaceAll(aRegexp : TJSRegexp; NewString : String) : String; overload;\r\n    function replaceAll(Regexp : String; aCallback : TReplaceCallBack) : String; overload;\r\n    function replaceAll(Regexp : TJSRegexp; aCallback : TReplaceCallBack) : String; overload;\r\n    function replaceAll(Regexp : String; aCallback : TReplaceCallBack0) : String; overload;\r\n    function replaceAll(Regexp : TJSRegexp; aCallback : TReplaceCallBack0) : String; overload;\r\n    function replaceAll(Regexp : String; aCallback : TReplaceCallBack1) : String; overload;\r\n    function replaceAll(Regexp : TJSRegexp; aCallback : TReplaceCallBack1) : String; overload;\r\n    function replaceAll(Regexp : String; aCallback : TReplaceCallBack2) : String; overload;\r\n    function replaceAll(Regexp : TJSRegexp; aCallback : TReplaceCallBack2) : String; overload;\r\n    function search(Regexp : TJSRegexp) : NativeInt; overload;\r\n    function search(Regexp : JSValue) : NativeInt; overload;\r\n    function slice(aBeginIndex : NativeInt) : String; overload;\r\n    function slice(aBeginIndex, aEndIndex : NativeInt) : String; overload;\r\n    function split : TStringDynArray; overload;\r\n    function split(aRegexp : TJSRegexp) : TStringDynArray; overload;\r\n    function split(aSeparator : string) : TStringDynArray; overload;\r\n    function split(aSeparator : string; aLimit : NativeInt) : TStringDynArray; overload;\r\n    function split(aSeparator : array of string) : TStringDynArray; overload;\r\n    function split(aSeparator : array of string; aLimit : NativeInt) : TStringDynArray; overload;\r\n    function startsWith(aSearchString : String) : Boolean; overload;\r\n    function startsWith(aSearchString : String; aPosition : NativeInt) : Boolean; overload;\r\n    function substr(aStartIndex : NativeInt) : String; overload; deprecated;\r\n    function substr(aStartIndex,aLength : NativeInt) : String; overload; deprecated;\r\n    function substring(aStartIndex : NativeInt) : String; overload;\r\n    function substring(aStartIndex,aEndIndex : NativeInt) : String; overload;\r\n    function toLocaleLowerCase : String;\r\n    function toLocaleUpperCase : String;\r\n    function toLowerCase : String;\r\n    function toString : string;\r\n    function toUpperCase : String;\r\n    function toWellFormed: String;\r\n    function trim : string;\r\n    function trimEnd: String;\r\n    function trimStart: String;\r\n    function valueOf : string;\r\n  end;\r\n\r\n  \r\n  TJSArrayEventProc = reference to procedure(element : JSValue; index: NativeInt; anArray : TJSArray);\r\n  TJSArrayEvent = reference to function (element : JSValue; index: NativeInt; anArray : TJSArray) : Boolean;\r\n  TJSArrayMapEvent = reference to function (element : JSValue; index: NativeInt; anArray : TJSArray) : JSValue;\r\n  TJSArrayReduceEvent = reference to function (accumulator, currentValue : JSValue; currentIndex : NativeInt; anArray : TJSArray) : JSValue;\r\n  TJSArrayCompareEvent = reference to function (a,b : JSValue) : NativeInt;\r\n  TJSArrayCallback = TJSArrayEvent;\r\n  TJSArrayMapCallback = TJSArrayMapEvent;\r\n  TJSArrayReduceCallBack = TJSArrayReduceEvent;\r\n  TJSArrayCompareCallBack = TJSArrayCompareEvent;\r\n\r\n  { TJSArray }\r\n\r\n  TJSArray = Class external name 'Array'\r\n  private\r\n    function GetElements(Index: NativeInt): JSValue; external name '[]';\r\n    procedure SetElements(Index: NativeInt; const AValue: JSValue); external name '[]';\r\n  public\r\n    FLength : NativeInt; external name 'length';\r\n    constructor new; overload;\r\n    constructor new(aLength : NativeInt); overload;\r\n    constructor new(aElement1 : JSValue); varargs; overload;\r\n    class function _of() : TJSArray; varargs; external name 'of'; \r\n    class function isArray(a: JSValue) : Boolean;\r\n{$IFDEF JAVASCRIPT2015}    \r\n    class function from(a : JSValue) : TJSArray;\r\n    class function from(arrayLike : JSValue; mapFunction : TJSMapFunctionCallBack): TJSArray; overload;\r\n    class function from(arrayLike : JSValue; mapFunction : TJSMapFunctionCallBack; thisArg : JSValue): TJSArray; overload;\r\n{$ENDIF}\r\n    function concat(el : JSValue) : TJSArray; varargs;\r\n    function copyWithin(aTarget : NativeInt) : TJSArray;overload; // not in IE\r\n    function copyWithin(aTarget, aStart : NativeInt) : TJSArray;overload; // not in IE\r\n    function copyWithin(aTarget, aStart, aEnd : NativeInt) : TJSArray;overload; // not in IE\r\n    function entries: TJSIterator;\r\n    Function every(const aCallback : TJSArrayCallBack) : boolean;overload;\r\n    Function every(const aCallback : TJSArrayEvent; aThis : TObject) : boolean;overload;\r\n    Function filter(const aCallBack : TJSArrayCallBack) : TJSArray; overload;\r\n    Function filter(const aCallBack : TJSArrayEvent; aThis : TObject) : TJSArray;overload;\r\n    Function fill(aValue : JSValue) : TJSArray; overload;\r\n    Function fill(aValue : JSValue; aStartIndex : NativeInt) : TJSArray; overload;\r\n    Function fill(aValue : JSValue; aStartIndex,aEndIndex : NativeInt) : TJSArray; overload;\r\n    Function find(const aCallBack : TJSArrayCallBack) : JSValue; overload;\r\n    Function find(const aCallBack : TJSArrayEvent; aThis : TObject) : JSValue; overload;\r\n    Function findIndex(const aCallBack : TJSArrayCallBack) : NativeInt; overload;\r\n    Function findIndex(const aCallBack : TJSArrayEvent; aThis : TObject) : NativeInt; overload;\r\n    procedure forEach(const aCallBack : TJSArrayEventProc); overload;\r\n    procedure forEach(const aCallBack : TJSArrayEvent); overload;\r\n    procedure forEach(const aCallBack : TJSArrayEvent; aThis : TObject); overload;\r\n    function includes(aElement : JSValue) : Boolean; overload;\r\n    function includes(aElement : JSValue; FromIndex : NativeInt) : Boolean; overload;\r\n    function indexOf(aElement : JSValue) : NativeInt; overload;\r\n    function indexOf(aElement : JSValue; FromIndex : NativeInt) : NativeInt; overload;\r\n    function join : String; overload;\r\n    function join (aSeparator : string) : String; overload;\r\n    function keys: TJSIterator;\r\n    function lastIndexOf(aElement : JSValue) : NativeInt; overload;\r\n    function lastIndexOf(aElement : JSValue; FromIndex : NativeInt) : NativeInt; overload;\r\n//    Function map(const aCallBack : TJSArrayMapEventArray) : JSValue; overload;\r\n    Function map(const aCallBack : TJSArrayMapCallBack) : TJSArray; overload;\r\n    Function map(const aCallBack : TJSArrayMapEvent; aThis : TObject) : TJSArray; overload;\r\n    function pop : JSValue; \r\n    function push(aElement : JSValue) : NativeInt; varargs;\r\n    function reduce(const aCallBack : TJSArrayReduceCallBack) : JSValue; overload;\r\n    function reduce(const aCallBack : TJSArrayReduceCallBack; initialValue : JSValue) : JSValue; overload;\r\n    function reduceRight(const aCallBack : TJSArrayReduceCallBack) : JSValue; overload;\r\n    function reduceRight(const aCallBack : TJSArrayReduceCallBack; initialValue : JSValue) : JSValue; overload;\r\n    Function reverse : TJSArray;\r\n    Function shift : JSValue;\r\n    Function slice : TJSArray; overload;\r\n    function slice(aBegin : NativeInt) : TJSArray; overload;\r\n    function slice(aBegin,aEnd : NativeInt) : TJSArray; overload;\r\n    Function some(const aCallback : TJSArrayCallBack) : boolean; overload;\r\n    Function some(const aCallback : TJSArrayEvent; aThis : TObject) : boolean; overload;\r\n    Function sort(const aCallback : TJSArrayCompareCallBack) : TJSArray; overload;\r\n    Function sort() : TJSArray; overload;\r\n    function splice(aStart : NativeInt) : TJSArray; overload;\r\n    function splice(aStart,aDeleteCount : NativeInt) : TJSArray; varargs; overload;\r\n    function toLocaleString: String; overload;\r\n    function toLocaleString(locales : string) : String; overload;\r\n    function toLocaleString(locales : string; const Options : TLocaleCompareOptions) : String; overload;\r\n    function toString : String;\r\n    function unshift : NativeInt; varargs;\r\n    function values: TJSIterator;\r\n    Property Length : NativeInt Read FLength Write FLength;\r\n    property Elements[Index: NativeInt]: JSValue read GetElements write SetElements; default;\r\n  end;\r\n\r\n  TJSArrayBuffer = Class external name 'ArrayBuffer' (TJSObject)\r\n  private\r\n    fLength : NativeInt; external name 'byteLength';\r\n  public\r\n    constructor new(aByteLength : NativeInt);\r\n    class function isView(aValue : JSValue) : Boolean;   \r\n    function slice(aBegin : NativeInt) : TJSArrayBuffer; overload;\r\n    function slice(aBegin,aEnd : NativeInt) : TJSArrayBuffer; overload;\r\n    Property byteLength : NativeInt Read fLength;\r\n  end;\r\n\r\n  TJSBufferSource = class external name 'BufferSource'\r\n  end;\r\n\r\n  { TJSTypedArray }\r\n  TJSTypedArray = Class;\r\n\r\n  TJSTypedArrayCallBack = reference to function (element : JSValue; index: NativeInt; anArray : TJSTypedArray) : Boolean;\r\n  TJSTypedArrayEvent = TJSTypedArrayCallBack; // function (element : JSValue; index: NativeInt; anArray : TJSTypedArray) : Boolean of object;\r\n  TJSTypedArrayMapCallBack = reference to function (element : JSValue; index: NativeInt; anArray : TJSTypedArray) : JSValue;\r\n  TJSTypedArrayMapEvent = TJSTypedArrayMapCallBack; // reference to function (element : JSValue; index: NativeInt; anArray : TJSTypedArray) : JSValue of object;\r\n  TJSTypedArrayReduceCallBack = reference to function (accumulator, currentValue : JSValue; currentIndex : NativeInt; anArray : TJSTypedArray) : JSValue;\r\n  TJSTypedArrayCompareCallBack = reference to function (a,b : JSValue) : NativeInt;\r\n\r\n  TJSTypedArray = class external name 'TypedArray' (TJSBufferSource)\r\n  Private\r\n    FBuffer: TJSArrayBuffer; external name 'buffer';\r\n    FByteLength: NativeInt; external name 'byteLength';\r\n    FLength: NativeInt; external name 'length';\r\n    FByteOffset: NativeInt; external name 'byteOffset';\r\n    FBytesPerElement : NativeInt; external name 'BYTES_PER_ELEMENT';\r\n    function getValue(Index : NativeInt) : JSValue; external name '[]';\r\n    procedure setValue(Index : NativeInt;AValue : JSValue); external name '[]';\r\n  Public\r\n    property BYTES_PER_ELEMENT : NativeInt Read FBytesPerElement;\r\n    class var name : string;\r\n//    class function from(aValue : jsValue) : TJSTypedArray;\r\n//    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSTypedArray;\r\n//    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSTypedArray;\r\n    class function _of(aValue : jsValue) : TJSTypedArray; varargs; external name 'of';\r\n    function copyWithin(aTarget : NativeInt) : TJSTypedArray;overload;\r\n    function copyWithin(aTarget, aStart : NativeInt) : TJSTypedArray;overload;\r\n    function copyWithin(aTarget, aStart, aEnd : NativeInt) : TJSTypedArray;overload;\r\n    Function every(const aCallback : TJSTypedArrayCallBack) : boolean;overload;\r\n    Function every(const aCallback : TJSTypedArrayEvent; aThis : TObject) : boolean;overload;\r\n    Function fill(aValue : JSValue) : TJSTypedArray; overload;\r\n    Function fill(aValue : JSValue; aStartIndex : NativeInt) : TJSTypedArray; overload;\r\n    Function fill(aValue : JSValue; aStartIndex,aEndIndex : NativeInt) : TJSTypedArray; overload;\r\n    Function filter(const aCallBack : TJSTypedArrayCallBack) : TJSTypedArray; overload;\r\n    Function filter(const aCallBack : TJSTypedArrayEvent; aThis : TObject) : TJSTypedArray;overload;\r\n    Function find(const aCallBack : TJSTypedArrayCallBack) : JSValue; overload;\r\n    Function find(const aCallBack : TJSTypedArrayEvent; aThis : TObject) : JSValue; overload;\r\n    Function findIndex(const aCallBack : TJSTypedArrayCallBack) : NativeInt; overload;\r\n    Function findIndex(const aCallBack : TJSTypedArrayEvent; aThis : TObject) : NativeInt; overload;\r\n    procedure forEach(const aCallBack : TJSTypedArrayCallBack); overload;\r\n    procedure forEach(const aCallBack : TJSTypedArrayEvent; aThis : TObject); overload;\r\n    function includes(aElement : JSValue) : Boolean; overload;\r\n    function includes(aElement : JSValue; FromIndex : NativeInt) : Boolean; overload;\r\n    function indexOf(aElement : JSValue) : NativeInt; overload;\r\n    function indexOf(aElement : JSValue; FromIndex : NativeInt) : NativeInt; overload;\r\n    function join : String; overload;\r\n    function join (aSeparator : string) : String; overload;\r\n    function lastIndexOf(aElement : JSValue) : NativeInt; overload;\r\n    function lastIndexOf(aElement : JSValue; FromIndex : NativeInt) : NativeInt; overload;\r\n    Function map(const aCallBack : TJSTypedArrayCallBack) : TJSTypedArray; overload;\r\n    Function map(const aCallBack : TJSTypedArrayEvent; aThis : TObject) : TJSTypedArray; overload;\r\n    function reduce(const aCallBack : TJSTypedArrayReduceCallBack) : JSValue; overload;\r\n    function reduce(const aCallBack : TJSTypedArrayReduceCallBack; initialValue : JSValue) : JSValue; overload;\r\n    function reduceRight(const aCallBack : TJSTypedArrayReduceCallBack) : JSValue; overload;\r\n    function reduceRight(const aCallBack : TJSTypedArrayReduceCallBack; initialValue : JSValue) : JSValue; overload;\r\n    Function reverse : TJSTypedArray;\r\n    procedure _set(anArray : TJSArray); external name 'set';\r\n    procedure _set(anArray : TJSArray; anOffset : NativeInt); external name 'set';\r\n    procedure _set(anArray : TJSTypedArray); external name 'set';\r\n    procedure _set(anArray : TJSTypedArray; anOffset : NativeInt); external name 'set';\r\n    Function slice : TJSTypedArray; overload;\r\n    function slice(aBegin : NativeInt) : TJSTypedArray; overload;\r\n    function slice(aBegin,aEnd : NativeInt) : TJSTypedArray; overload;\r\n    Function some(const aCallback : TJSTypedArrayCallBack) : boolean; overload;\r\n    Function some(const aCallback : TJSTypedArrayEvent; aThis : TObject) : boolean; overload;\r\n    Function sort(const aCallback : TJSTypedArrayCompareCallBack) : TJSTypedArray; overload;\r\n    Function sort() : TJSTypedArray; overload;\r\n    function splice(aStart : NativeInt) : TJSTypedArray; overload;\r\n    function splice(aStart,aDeleteCount : NativeInt) : TJSTypedArray; varargs; overload;\r\n    function toLocaleString: String; overload;\r\n    function toLocaleString(locales : string) : String; overload;\r\n    function toLocaleString(locales : string; const Options : TLocaleCompareOptions) : String; overload;\r\n    function toString : String;\r\n    function unshift : NativeInt; varargs;\r\n    property buffer : TJSArrayBuffer read FBuffer;\r\n    property byteLength : NativeInt Read FByteLength;\r\n    property byteOffset : NativeInt Read FByteOffset;\r\n    property length : NativeInt Read FLength;\r\n    property values[Index : NativeInt] : JSValue Read getValue Write SetValue; default;\r\n  end;\r\n\r\n  { TJSInt8Array }\r\n\r\n  TJSInt8Array = class external name 'Int8Array' (TJSTypedArray)\r\n  private\r\n    function getTypedValue(Index : NativeInt): Shortint; external name '[]';\r\n    procedure setTypedValue(Index : NativeInt; AValue: Shortint);external name '[]';\r\n  public\r\n{$IFDEF JAVASCRIPT2017}\r\n    constructor new; // new in ES2017\r\n{$ENDIF}\r\n    constructor new (length : NativeInt);\r\n    constructor new (atypedArray : TJSTypedArray);\r\n    constructor new (aObject : TJSObject);\r\n    constructor new (buffer : TJSArrayBuffer);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\r\n    class function from(aValue : jsValue) : TJSInt8Array; reintroduce;\r\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSInt8Array; reintroduce;\r\n//    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSInt8Array; reintroduce;\r\n    class function _of(aValue : jsValue) : TJSInt8Array; varargs; external name 'of'; reintroduce;overload;\r\n    class function _of(aValue : TJSValueDynArray) : TJSInt8Array; varargs; external name 'of'; reintroduce; overload;\r\n    function subarray(aBegin, aEnd: Integer): TJSInt8Array;  overload;\r\n    function subarray(aBegin: Integer): TJSInt8Array; overload;\r\n    procedure _set(anArray : Array of ShortInt); external name 'set'; reintroduce; overload;\r\n    procedure _set(anArray : Array of ShortInt; anOffset : NativeInt); external name 'set';\r\n    property values[Index : NativeInt] : Shortint Read getTypedValue Write setTypedValue; default;\r\n  end;\r\n\r\n  TJSUint8Array  = class external name 'Uint8Array' (TJSTypedArray)\r\n  private\r\n    function getTypedValue(Index : NativeInt): Byte; external name '[]';\r\n    procedure setTypedValue(Index : NativeInt; AValue: Byte);external name '[]';\r\n  public\r\n    constructor new (length : NativeInt);\r\n    constructor new (atypedArray : TJSTypedArray);\r\n    constructor new (aObject : TJSObject);\r\n    constructor new (buffer : TJSArrayBuffer);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\r\n    class function from(aValue : jsValue) : TJSUInt8Array; reintroduce; overload;\r\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSUInt8Array; reintroduce;overload;\r\n    // class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSUInt8Array; reintroduce;overload;\r\n    class function _of(aValue : jsValue) : TJSUInt8Array; varargs; external name 'of'; reintroduce; overload;\r\n    function subarray(aBegin, aEnd: Integer): TJSUInt8Array;  overload;\r\n    function subarray(aBegin: Integer): TJSUInt8Array; overload;\r\n    procedure _set(anArray : Array of Byte); external name 'set'; reintroduce; overload;\r\n    procedure _set(anArray : Array of Byte; anOffset : NativeInt); external name 'set'; overload;\r\n    Property values[Index : NativeInt] : Byte Read getTypedValue Write setTypedValue; default;\r\n  end;\r\n\r\n  TJSUint8ClampedArray  = class external name 'Uint8ClampedArray' (TJSTypedArray)\r\n  private\r\n    function getTypedValue(Index : NativeInt): Byte; external name '[]';\r\n    procedure setTypedValue(Index : NativeInt; AValue: Byte);external name '[]';\r\n  public\r\n    constructor new (length : NativeInt);\r\n    constructor new (atypedArray : TJSTypedArray);\r\n    constructor new (aObject : TJSObject);\r\n    constructor new (buffer : TJSArrayBuffer);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\r\n    class function from(aValue : jsValue) : TJSUInt8ClampedArray; reintroduce;\r\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSUInt8ClampedArray; reintroduce;overload;\r\n//    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSUInt8ClampedArray; reintroduce;overload;\r\n    class function _of(aValue : jsValue) : TJSUInt8ClampedArray; varargs; external name 'of'; reintroduce;\r\n    procedure _set(anArray : Array of Byte); external name 'set'; reintroduce;overload;\r\n    procedure _set(anArray : Array of Byte; anOffset : NativeInt); external name 'set';overload;\r\n    function subarray(aBegin, aEnd: Integer): TJSUInt8ClampedArray;  overload;\r\n    function subarray(aBegin: Integer): TJSUInt8ClampedArray; overload;\r\n    Property values[Index : NativeInt] : Byte Read getTypedValue Write setTypedValue; default;\r\n  end;\r\n\r\n  TJSInt16Array = class external name 'Int16Array' (TJSTypedArray)\r\n  private\r\n    function getTypedValue(Index : NativeInt): smallint; external name '[]';\r\n    procedure setTypedValue(Index : NativeInt; AValue: Smallint);external name '[]';\r\n  public\r\n    constructor new (length : NativeInt);\r\n    constructor new (atypedArray : TJSTypedArray);\r\n    constructor new (aObject : TJSObject);\r\n    constructor new (buffer : TJSArrayBuffer);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\r\n    class function from(aValue : jsValue) : TJSInt16Array; reintroduce;\r\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSInt16Array; reintroduce;overload;\r\n//    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSInt16Array; reintroduce;overload;\r\n    class function _of(aValue : jsValue) : TJSInt16Array; varargs; external name 'of'; reintroduce;overload;\r\n    procedure _set(anArray : Array of SmallInt); external name 'set'; reintroduce;overload;\r\n    procedure _set(anArray : Array of SmallInt; anOffset : NativeInt); external name 'set';overload;\r\n    function subarray(aBegin, aEnd: Integer): TJSInt16Array;  overload;\r\n    function subarray(aBegin: Integer): TJSInt16Array; overload;\r\n    Property values[Index : NativeInt] : SmallInt Read getTypedValue Write setTypedValue; default;\r\n  end;\r\n\r\n  TJSUint16Array = class external name 'Uint16Array' (TJSTypedArray)\r\n  private\r\n    function getTypedValue(Index : NativeInt): Word; external name '[]';\r\n    procedure setTypedValue(Index : NativeInt; AValue: Word);external name '[]';\r\n  public\r\n    constructor new (length : NativeInt);\r\n    constructor new (atypedArray : TJSTypedArray);\r\n    constructor new (aObject : TJSObject);\r\n    constructor new (buffer : TJSArrayBuffer);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\r\n    class function from(aValue : jsValue) : TJSUInt16Array; reintroduce;\r\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSUInt16Array; reintroduce;\r\n//    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSUInt16Array; reintroduce;\r\n    class function _of(aValue : jsValue) : TJSUInt16Array; varargs; external name 'of'; reintroduce;\r\n    procedure _set(anArray : Array of Word); external name 'set'; reintroduce; overload;\r\n    procedure _set(anArray : Array of Word; anOffset : NativeInt); external name 'set'; overload;\r\n    function subarray(aBegin, aEnd: Integer): TJSUInt16Array;  overload;\r\n    function subarray(aBegin: Integer): TJSUInt16Array; overload;\r\n    Property values[Index : NativeInt] : Word Read getTypedValue Write setTypedValue; default;\r\n  end;\r\n\r\n  TJSInt32Array = class external name 'Int32Array' (TJSTypedArray)\r\n  private\r\n    function getTypedValue(Index : NativeInt): longint; external name '[]';\r\n    procedure setTypedValue(Index : NativeInt; AValue: longint);external name '[]';\r\n  public\r\n    constructor new (length : NativeInt);\r\n    constructor new (atypedArray : TJSTypedArray);\r\n    constructor new (aObject : TJSObject);\r\n    constructor new (buffer : TJSArrayBuffer);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\r\n    class function from(aValue : jsValue) : TJSInt32Array; reintroduce;\r\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSInt32Array; reintroduce;\r\n//    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSInt32Array; reintroduce;\r\n    class function _of(aValue : jsValue) : TJSInt32Array; varargs;external name 'of'; reintroduce;\r\n    procedure _set(anArray : Array of LongInt); external name 'set'; reintroduce; overload;\r\n    procedure _set(anArray : Array of LongInt; anOffset : NativeInt); external name 'set'; overload;\r\n    function subarray(aBegin, aEnd: Integer): TJSInt32Array;  overload;\r\n    function subarray(aBegin: Integer): TJSInt32Array; overload;\r\n    Property values[Index : NativeInt] : longint Read getTypedValue Write setTypedValue; default;\r\n  end;\r\n\r\n  TJSUint32Array = class external name 'Uint32Array' (TJSTypedArray)\r\n  private\r\n    function getTypedValue(Index : NativeInt): LongWord; external name '[]';\r\n    procedure setTypedValue(Index : NativeInt; AValue: LongWord);external name '[]';\r\n  public\r\n    constructor new (length : NativeInt);\r\n    constructor new (atypedArray : TJSTypedArray);\r\n    constructor new (aObject : TJSObject);\r\n    constructor new (buffer : TJSArrayBuffer);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\r\n    class function from(aValue : jsValue) : TJSUInt32Array; reintroduce;\r\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSUInt32Array; reintroduce;\r\n//    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSUInt32Array; reintroduce;\r\n    class function _of(aValue : jsValue) : TJSUInt32Array; varargs; external name 'of'; reintroduce;\r\n    procedure _set(anArray : Array of Cardinal); external name 'set'; reintroduce; overload;\r\n    procedure _set(anArray : Array of Cardinal; anOffset : NativeInt); external name 'set'; overload;\r\n    function subarray(aBegin, aEnd: Integer): TJSUInt32Array;  overload;\r\n    function subarray(aBegin: Integer): TJSUInt32Array; overload;\r\n    Property values[Index : NativeInt] : LongWord Read getTypedValue Write setTypedValue; default;\r\n  end;\r\n\r\n  TJSFloat32Array = class external name 'Float32Array' (TJSTypedArray)\r\n  private\r\n    function getTypedValue(Index : NativeInt): Float32; external name '[]';\r\n    procedure setTypedValue(Index : NativeInt; AValue: Float32);external name '[]';\r\n  public\r\n    constructor new (length : NativeInt);\r\n    constructor new (atypedArray : TJSTypedArray);\r\n    constructor new (aObject : TJSObject);\r\n    constructor new (buffer : TJSArrayBuffer);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\r\n    class function from(aValue : jsValue) : TJSFloat32Array; reintroduce;\r\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSFloat32Array; reintroduce;\r\n//    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSFloat32Array; reintroduce;\r\n    class function _of(aValue : jsValue) : TJSFloat32Array; varargs; reintroduce;\r\n    procedure _set(anArray : Array of Double); external name 'set'; reintroduce; overload;\r\n    procedure _set(anArray : Array of Double; anOffset : NativeInt); external name 'set'; reintroduce; overload;\r\n    function subarray(aBegin, aEnd: Integer): TJSFloat32Array;  overload;\r\n    function subarray(aBegin: Integer): TJSFloat32Array; overload;\r\n    Property values[Index : NativeInt] : Float32 Read getTypedValue Write setTypedValue; default;\r\n  end;\r\n\r\n  TJSFloat64Array = class external name 'Float64Array' (TJSTypedArray)\r\n  private\r\n    function getTypedValue(Index : NativeInt): Float64; external name '[]';\r\n    procedure setTypedValue(Index : NativeInt; AValue: Float64);external name '[]';\r\n  public\r\n    constructor new (length : NativeInt);\r\n    constructor new (atypedArray : TJSTypedArray);\r\n    constructor new (aObject : TJSObject);\r\n    constructor new (buffer : TJSArrayBuffer);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\r\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\r\n    class function from(aValue : jsValue) : TJSFloat64Array; reintroduce;\r\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSFloat64Array; reintroduce;\r\n//    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSFloat64Array; reintroduce;\r\n    class function _of(aValue : jsValue) : TJSFloat64Array; varargs; reintroduce;\r\n    procedure _set(anArray : Array of Double); external name 'set'; reintroduce; overload;\r\n    procedure _set(anArray : Array of Double; anOffset : NativeInt); external name 'set'; reintroduce; overload;\r\n    function subarray(aBegin, aEnd: Integer): TJSFloat64Array;  overload;\r\n    function subarray(aBegin: Integer): TJSFloat64Array; overload;\r\n    Property values[Index : NativeInt] : Float64 Read getTypedValue Write setTypedValue; default;\r\n  end;\r\n\r\n  TJSDataView = Class external name 'DataView' (TJSBufferSource)\r\n  private\r\n    fBuffer : TJSArrayBuffer; external name 'buffer';\r\n    fLength : NativeInt; external name 'byteLength';\r\n    fOffset : NativeInt; external name 'byteOffset';\r\n  public\r\n    constructor new(aBuffer : TJSArrayBuffer); overload;\r\n    constructor new(aBuffer : TJSArrayBuffer; aOffset : NativeInt); overload;\r\n    constructor new(aBuffer : TJSArrayBuffer; aOffset,aByteLength : NativeInt); overload;\r\n    function getFloat32(aByteOffset : NativeInt) : double; overload;\r\n    function getFloat32(aByteOffset : NativeInt; aLittleEndian: Boolean) : double; overload;\r\n    function getFloat64(aByteOffset : NativeInt) : double; overload;\r\n    function getFloat64(aByteOffset : NativeInt; aLittleEndian: Boolean) : double; overload;\r\n    function getInt8(aByteOffset : NativeInt) : ShortInt; \r\n    function getInt16(aByteOffset : NativeInt) : SmallInt; overload;\r\n    function getInt16(aByteOffset : NativeInt; aLittleEndian : Boolean) : SmallInt; overload;\r\n    function getInt32(aByteOffset : NativeInt) : Longint; overload;\r\n    function getInt32(aByteOffset : NativeInt; aLittleEndian : Boolean) : Longint; overload;\r\n    function getUint8(aByteOffset : NativeInt) : Byte; overload;\r\n    function getUint16(aByteOffset : NativeInt) : Word; overload;\r\n    function getUint16(aByteOffset : NativeInt; aLittleEndian : Boolean) : Word; overload;\r\n    function getUint32(aByteOffset : NativeInt) : LongWord; overload;\r\n    function getUint32(aByteOffset : NativeInt; aLittleEndian : Boolean) : LongWord; overload;\r\n\r\n    procedure setFloat32(aByteOffset : NativeInt; aValue : double); overload;\r\n    procedure setFloat32(aByteOffset : NativeInt; aValue : double; aLittleEndian: Boolean); overload;\r\n    procedure setFloat64(aByteOffset : NativeInt; aValue : double); overload;\r\n    procedure setFloat64(aByteOffset : NativeInt; aValue : double; aLittleEndian: Boolean); overload;\r\n    procedure setInt8(aByteOffset : NativeInt; aValue : ShortInt); \r\n    procedure setInt16(aByteOffset : NativeInt; aValue : SmallInt); overload;\r\n    procedure setInt16(aByteOffset : NativeInt; aValue : SmallInt; aLittleEndian : Boolean); overload;\r\n    procedure setInt32(aByteOffset : NativeInt; aValue : Longint); overload;\r\n    procedure setInt32(aByteOffset : NativeInt; aValue : Longint; aLittleEndian : Boolean); overload;\r\n    procedure setUint8(aByteOffset : NativeInt; aValue : Byte); overload;\r\n    procedure setUint16(aByteOffset : NativeInt; aValue : Word); overload;\r\n    procedure setUint16(aByteOffset : NativeInt; aValue : Word; aLittleEndian : Boolean); overload;\r\n    procedure setUint32(aByteOffset : NativeInt; aValue : LongWord); overload;\r\n    procedure setUint32(aByteOffset : NativeInt; aValue: LongWord; aLittleEndian : Boolean); overload;\r\n    Property byteLength : NativeInt Read fLength;\r\n    Property byteOffset : NativeInt read fOffset;\r\n    property buffer : TJSArrayBuffer Read fBuffer;\r\n  end;\r\n\r\n  TJSJSON = class external name 'JSON' (TJSObject)\r\n  Public\r\n    class function parse(aJSON : String) : JSValue;\r\n    // Use this only when you are sure you will get an object, no checking is done.\r\n    class function parseObject(aJSON : String) : TJSObject; external name 'parse';\r\n    class function stringify(aValue : JSValue) : string;\r\n    class function stringify(aValue,aReplacer : JSValue) : string;\r\n    class function stringify(aValue,aReplacer : JSValue; space:  NativeInt) : string;\r\n    class function stringify(aValue,aReplacer : JSValue; space:  String) : string;\r\n  end;\r\n\r\n  { TJSError }\r\n\r\n  TJSError = Class external name 'Error'   (TJSObject)\r\n  private\r\n    FMessage: String; external name 'message';\r\n    {$ifdef NodeJS}\r\n    FStack: JSValue; external name 'stack';\r\n    {$endif}\r\n  Public\r\n    Constructor new;\r\n    Constructor new(Const aMessage : string);\r\n    Constructor new(Const aMessage,aFileName : string);\r\n    Constructor new(Const aMessage,aFileName : string; aLineNumber : NativeInt);\r\n    Property Message : String Read FMessage;\r\n    {$ifdef NodeJS}\r\n    Property Stack: JSValue read FStack;\r\n    {$endif}\r\n  end;\r\n\r\n\r\n  TJSPromiseResolver = reference to function (aValue : JSValue) : JSValue;\r\n  TJSPromiseExecutor = reference to procedure (resolve,reject : TJSPromiseResolver);\r\n  TJSPromiseFinallyHandler = reference to procedure;\r\n  TJSPromise = Class;\r\n  TJSPromiseArray = array of TJSPromise;\r\n\r\n  TJSPromise = class external name 'Promise'\r\n    constructor new(Executor : TJSPromiseExecutor);\r\n    class function all(arg : Array of JSValue) : TJSPromise; overload;\r\n    class function all(arg : JSValue) : TJSPromise; overload;\r\n    class function all(arg : TJSPromiseArray) : TJSPromise; overload;\r\n    class function allSettled(arg : Array of JSValue) : TJSPromise; overload;\r\n    class function allSettled(arg : JSValue) : TJSPromise; overload;\r\n    class function allSettled(arg : TJSPromiseArray) : TJSPromise; overload;\r\n    class function race(arg : Array of JSValue) : TJSPromise; overload;\r\n    class function race(arg : JSValue) : TJSPromise; overload;\r\n    class function race(arg : TJSPromiseArray) : TJSPromise; overload;\r\n    class function reject(reason : JSValue) : TJSPromise;\r\n    class function resolve(value : JSValue): TJSPromise; overload;\r\n    class function resolve : TJSPromise; overload;\r\n    function _then (onAccepted : TJSPromiseResolver) : TJSPromise; external name 'then';\r\n    function _then (onAccepted,OnRejected: TJSPromiseResolver) : TJSPromise; external name 'then';\r\n    function catch (onRejected : TJSPromiseResolver) : TJSPromise;\r\n    function _finally(value : TJSPromiseFinallyHandler): TJSPromise; external name 'finally';\r\n  end;\r\n\r\n  generic TGPromise<T> = class external name 'Promise'\r\n  Type\r\n    TResolve = reference to function (aValue : T) : JSValue;\r\n    TReject = reference to function (aValue : JSValue) : JSValue;\r\n    TExecute = reference to procedure (resolve: TResolve; reject : TReject);\r\n    TFinallyHandler = reference to procedure;\r\n  Public\r\n    constructor new(Executor : TExecute);\r\n    function then_ (onAccepted : TResolve) : TJSPromise; external name 'then';\r\n    function then_ (onAccepted : TResolve; onRejected : TReject) : TJSPromise; external name 'then';\r\n    function finally_(value : TFinallyHandler): TJSPromise; external name 'finally';\r\n    function catch (onRejected : TReject) : TJSPromise;\r\n  end;\r\n\r\n  generic TGPromiseEx<T,E> = class external name 'Promise'\r\n  Type\r\n    TResolve = reference to function (aValue : T) : JSValue;\r\n    TReject = reference to function (aValue : E) : JSValue;\r\n    TExecute = reference to procedure (resolve: TResolve; reject : TReject);\r\n    TFinallyHandler = reference to procedure;\r\n  Public\r\n    constructor new(Executor : TExecute);\r\n    function then_ (onAccepted : TResolve) : TJSPromise; external name 'then';\r\n    function then_ (onAccepted : TResolve; onRejected : TReject) : TJSPromise; external name 'then';\r\n    function catch (onRejected : TReject) : TJSPromise;\r\n    function finally_(value : TFinallyHandler): TJSPromise; external name 'finally';\r\n  end;\r\n\r\n\r\n\r\n\r\n  TJSFunctionArguments = class external name 'arguments'\r\n  private\r\n    FLength: NativeInt; external name 'length';\r\n    function GetElements(Index: NativeInt): JSValue; external name '[]';\r\n    procedure SetElements(Index: NativeInt; const AValue: JSValue); external name '[]';\r\n  public\r\n    property Length: NativeInt read FLength;\r\n    property Elements[Index: NativeInt]: JSValue read GetElements write SetElements; default;\r\n  end;\r\n\r\n  TJSIteratorResult = Class external name 'IteratorResult' (TJSObject)\r\n  Private\r\n    fDone : Boolean; external name 'done';\r\n    fValue : JSValue; external name 'value';\r\n  Public\r\n    property done : boolean Read FDone;\r\n    property value : JSValue read FValue;\r\n  end;\r\n\r\n  TJSAsyncIterator = Class external name 'AsyncIterator' (TJSObject)\r\n    function next: TJSIteratorResult;\r\n  end;\r\n\r\n  TJSSyntaxError = class external name 'SyntaxError' (TJSError);\r\n\r\n  TJSTextDecoderOptions = class external name 'Object' (TJSObject)\r\n    fatal : Boolean;\r\n    ignoreBOM : Boolean;\r\n  end;\r\n\r\n  TJSTextDecodeOptions = class external name 'Object' (TJSObject)\r\n    stream : Boolean;\r\n  end;\r\n\r\n  TJSTextDecoder = class external name 'TextDecoder' (TJSObject)\r\n  Private\r\n    FEncoding : String; external name 'encoding';\r\n    FFatal : Boolean; external name 'fatal';\r\n    FIgnoreBOM : Boolean; external name 'ignoreBOM';\r\n  Public\r\n    Constructor New(utfLabel : String); overload;\r\n    Constructor New(utfLabel : String; Options : TJSTextDecoderOptions); overload;\r\n    Function decode(arr : TJSTypedArray) : String; overload;\r\n    Function decode(arr : TJSArrayBuffer) : String; overload;\r\n    Function decode(arr : TJSTypedArray; opts : TJSTextDecodeOptions) : String; overload;\r\n    Function decode(arr : TJSArrayBuffer; opts : TJSTextDecodeOptions) : String; overload;\r\n    property Encoding : string Read FEncoding;\r\n    Property Fatal : Boolean Read FFatal;\r\n    Property IgnoreBOM : Boolean Read FIgnoreBOM;\r\n  end;\r\n\r\n  TJSTextEncoderEncodeIntoResult = class external name 'Object' (TJSObject)\r\n    read : Nativeint;\r\n    written : NativeInt;\r\n  end;\r\n\r\n  TJSTextEncoder = class external name 'TextEncoder' (TJSObject)\r\n  Private\r\n    FEncoding : String; external name 'encoding';\r\n  Public\r\n    Constructor New;\r\n    function encode(aString : String) : TJSUInt8Array;\r\n    Function encodeInto(aString : String; aArray : TJSUInt8Array) : TJSTextEncoderEncodeIntoResult;\r\n    Property Encoding : string Read FEncoding;\r\n  end;\r\n\r\n  generic TGGenerator<T> = class external name 'Generator' (TJSObject)\r\n  private type\r\n    TGGeneratorValue = class external name 'Generator' (TJSObject)\r\n    public\r\n      done: Boolean;\r\n      value: T;\r\n    end;\r\n  public\r\n    function next: TGGeneratorValue; overload;\r\n    function next(Value: T): TGGeneratorValue; overload;\r\n    function return: TGGeneratorValue; overload;\r\n    function return(Value: T): TGGeneratorValue; overload;\r\n    function throw(Error: TJSError): TGGeneratorValue;\r\n  end;\r\n  \r\n  TJSGenerator = specialize TGGenerator<JSValue>;\r\n\r\n  TJSProxy = class external name 'Proxy' (TJSObject)\r\n  public\r\n    constructor New(Target, Handler: TJSObject);\r\n  end;\r\n\r\n  TJSNumber = class external name 'Number' (TJSFunction)\r\n  private\r\n    class var FEPSILON: Double; external name 'EPSILON';\r\n    class var FMAX_SAFE_INTEGER: Int64; external name 'MAX_SAFE_INTEGER';\r\n    class var FMAX_VALUE: Double; external name 'MAX_VALUE';\r\n    class var FMIN_SAFE_INTEGER: Int64; external name 'MIN_SAFE_INTEGER';\r\n    class var FMIN_VALUE: Double; external name 'MIN_VALUE';\r\n    class var FNaN: Double; external name 'NaN';\r\n    class var FNEGATIVE_INFINITY: TJSNumber; external name 'NEGATIVE_INFINITY';\r\n    class var FPOSITIVE_INFINITY: TJSNumber; external name 'POSITIVE_INFINITY';\r\n  public\r\n    constructor New(const value: Double);\r\n\r\n    class function isFinite(const value: Double): Boolean; overload;\r\n    class function isFinite(const value: Integer): Boolean; overload;\r\n    class function isFinite(const value: TJSNumber): Boolean; overload;\r\n    class function isInteger(const value: Double): Boolean; overload;\r\n    class function isInteger(const value: Integer): Boolean; overload;\r\n    class function isInteger(const value: TJSNumber): Boolean; overload;\r\n    class function isNaN(const value: Double): Boolean; overload;\r\n    class function isNaN(const value: Integer): Boolean; overload;\r\n    class function isNaN(const value: TJSNumber): Boolean; overload;\r\n    class function isSafeInteger(const value: Double): Boolean; overload;\r\n    class function isSafeInteger(const value: Integer): Boolean; overload;\r\n    class function isSafeInteger(const value: TJSNumber): Boolean; overload;\r\n    class function parseFloat(const value: String): TJSNumber; overload;\r\n    class function parseInt(const value: String): TJSNumber; overload;\r\n\r\n    function toExponential: TJSString; overload;\r\n    function toExponential(const fractionDigits: Integer): TJSString; overload;\r\n    function toFixed: TJSString; overload;\r\n    function toFixed(const digits: Integer): TJSString; overload;\r\n    function toLocaleString: TJSString; overload;\r\n    function toLocaleString(const locale: String): TJSString; overload;\r\n    function toPrecision: TJSString; overload;\r\n    function toPrecision(const precision: Integer): TJSString; overload;\r\n    function toString: TJSString; overload;\r\n    function toString(const radix: Integer): TJSString; overload;\r\n    function valueOf: Double;\r\n\r\n    class property EPSILON: Double read FEPSILON;\r\n    class property MAX_SAFE_INTEGER: Int64 read FMAX_SAFE_INTEGER;\r\n    class property MAX_VALUE: Double read FMAX_VALUE;\r\n    class property MIN_SAFE_INTEGER: Int64 read FMIN_SAFE_INTEGER;\r\n    class property MIN_VALUE: Double read FMIN_VALUE;\r\n    class property NaN: Double read FNaN;\r\n    class property NEGATIVE_INFINITY: TJSNumber read FNEGATIVE_INFINITY;\r\n    class property POSITIVE_INFINITY: TJSNumber read FPOSITIVE_INFINITY;\r\n  end;\r\n\r\nvar\r\n  // JSArguments can be used in procedures/functions to provide access to the 'arguments' array.\r\n  JSArguments: TJSFunctionArguments; external name 'arguments';\r\n  // JSThis can be used in all code to access the javascript 'this' object.\r\n  JSThis: TJSObject; external name 'this';\r\n  // JSExceptValue can be used in catch blocks to access the JS throw value\r\n  JSExceptValue: JSValue; external name '$e';\r\n\r\nfunction Symbol : TJSSymbol;\r\nfunction Symbol(Description : String) : TJSSymbol;\r\n\r\nFunction JSValueArrayOf(Args : Array of const) : TJSValueDynArray;\r\nfunction new(aElements: TJSValueDynArray) : TJSObject; overload;\r\nfunction JSDelete(const Obj: JSValue; const PropName: string): boolean; assembler; overload;\r\n\r\nfunction decodeURIComponent(encodedURI : String) : String; external name 'decodeURIComponent';\r\nfunction encodeURIComponent(str : String) : String; external name 'encodeURIComponent';\r\n\r\nfunction parseInt(s: String; Radix: NativeInt): NativeInt; overload; external name 'parseInt'; // may result NaN\r\nfunction parseInt(s: String): NativeInt; overload; external name 'parseInt'; // may result NaN\r\nfunction parseFloat(s: String): double; overload; external name 'parseFloat'; // may result NaN\r\n\r\nfunction hasString(const v: JSValue): boolean; external name 'rtl.hasString';// isString(v) and v<>''\r\nfunction hasValue(const v: JSValue): boolean; assembler; // returns the JS definition of if(v): v is not false, undefined, null, 0, NaN, or the empty string. Note: JS if(new Boolean(false)) returns true.\r\nfunction jsIn(const keyName: String; const &object: TJSObject): Boolean; assembler;\r\nfunction isArray(const v: JSValue): boolean; external name 'rtl.isArray';\r\nfunction isBoolean(const v: JSValue): boolean; assembler;\r\nfunction isDate(const v: JSValue): boolean; assembler;\r\nfunction isCallback(const v: JSValue): boolean; assembler;\r\nfunction isChar(const v: JSValue): boolean; assembler;\r\nfunction isClass(const v: JSValue): boolean; assembler; // is a Pascal class, e.g. a TClass\r\nfunction isClassInstance(const v: JSValue): boolean; assembler;// is a Pascal class instance, e.g. a TObject\r\nfunction isFunction(const v: JSValue): boolean; external name 'rtl.isFunction';\r\nfunction isInteger(const v: JSValue): boolean; assembler;\r\nfunction isModule(const v: JSValue): boolean; external name 'rtl.isModule';\r\nfunction isNull(const v: JSValue): boolean; assembler;\r\nfunction isNumber(const v: JSValue): boolean; external name 'rtl.isNumber';\r\nfunction isObject(const v: JSValue): boolean; external name 'rtl.isObject'; // true if not null and a JS Object\r\nfunction isRecord(const v: JSValue): boolean; assembler;\r\nfunction isString(const v: JSValue): boolean; external name 'rtl.isString';\r\nfunction isUndefined(const v: JSValue): boolean; assembler;\r\nfunction isDefined(const v: JSValue): boolean; assembler;\r\nfunction isUTF16Char(const v: JSValue): boolean; assembler;\r\nfunction isExt(const InstanceOrClass, aClass: JSValue): boolean; external name 'rtl.isExt'; // aClass can be a JS object or function\r\nfunction jsInstanceOf(const aFunction, aFunctionWithPrototype: JSValue): Boolean; assembler;\r\nfunction jsTypeOf(const v: JSValue): String; external name 'typeof';\r\nfunction jsIsNaN(const v: JSValue): boolean; external name 'isNaN';// true if value cannot be converted to a number. e.g. True on NaN, undefined, {}, '123'. False on true, null, '', ' ', '1A'\r\nfunction jsIsFinite(const v: JSValue): boolean; external name 'isFinite';// true if value is a Finite number\r\nfunction toNumber(const v: JSValue): double; assembler; // if not possible, returns NaN\r\nfunction toInteger(const v: JSValue): NativeInt; // if v is not an integer, returns 0\r\nfunction toObject(Value: JSValue): TJSObject; // If Value is not a Javascript object, returns Nil\r\nfunction toArray(Value: JSValue): TJSArray; // If Value is not a Javascript array, returns Nil\r\nfunction toBoolean(Value: JSValue): Boolean; // If Value is not a Boolean, returns False\r\nfunction toString(Value: JSValue): String; // If Value is not a string, returns ''\r\n\r\nType\r\n  TJSValueType = (jvtNull,jvtBoolean,jvtInteger,jvtFloat,jvtString,jvtObject,jvtArray);\r\n\r\nFunction GetValueType(JS : JSValue) : TJSValueType;\r\n\r\nConst\r\n  Null : JSValue; external name 'null';\r\n  Undefined : JSValue; external name 'undefined';\r\n\r\nimplementation\r\n\r\nFunction JSValueArrayOf(Args : Array of const) : TJSValueDynArray;\r\n\r\nvar\r\n  I : Integer;\r\n\r\nbegin\r\n  SetLength(Result,Length(Args));\r\n  for I:=0 to Length(Args)-1 do\r\n    Result[i]:=Args[i].VJSValue\r\nend;\r\n\r\n\r\nfunction new(aElements: TJSValueDynArray): TJSObject;\r\n\r\n  function toString(I : Integer): string; external name 'String';\r\n\r\nVar\r\n  L,I : integer;\r\n  S : String;\r\n\r\nbegin\r\n  L:=length(aElements);\r\n  if (L mod 2)=1 then\r\n    raise EJS.Create('Number of arguments must be even');\r\n  I:=0;\r\n  // Check all arguments;\r\n  While (i<L) do\r\n    begin\r\n    if Not isString(aElements[i]) then\r\n      begin\r\n      S:=ToString(I);\r\n      raise EJS.Create('Argument '+S+' must be a string.');\r\n      end;\r\n    inc(I,2);\r\n    end;\r\n  I:=0;\r\n  Result:=TJSObject.New;\r\n  While (i<L) do\r\n    begin\r\n    S:=String(aElements[i]);\r\n    Result.Properties[S]:=aElements[i+1];\r\n    inc(I,2);\r\n    end;\r\nend;\r\n\r\nfunction JSDelete(const Obj: JSValue; const PropName: string): boolean; assembler;\r\nasm\r\n  return delete Obj[PropName];\r\nend;\r\n\r\nfunction hasValue(const v: JSValue): boolean; assembler;\r\nasm\r\n  if(v){ return true; } else { return false; };\r\nend;\r\n\r\nfunction jsIn(const keyName: String; const &object: TJSObject): Boolean; assembler;\r\nasm\r\n  return keyName in object;\r\nend;\r\n\r\nfunction isBoolean(const v: JSValue): boolean; assembler;\r\nasm\r\n  return typeof(v) == 'boolean';\r\nend;\r\n\r\nfunction isDate(const v: JSValue): boolean; assembler;\r\nasm\r\n  return (v instanceof Date);\r\nend;\r\n\r\nfunction isCallback(const v: JSValue): boolean; assembler;\r\nasm\r\n  return rtl.isObject(v) && rtl.isObject(v.scope) && (rtl.isString(v.fn) || rtl.isFunction(v.fn));\r\nend;\r\n\r\nfunction isChar(const v: JSValue): boolean; assembler;\r\nasm\r\n  return (typeof(v)!=\"string\") && (v.length==1);\r\nend;\r\n\r\nfunction isClass(const v: JSValue): boolean; assembler;\r\nasm\r\n  return (typeof(v)==\"object\") && (v!=null) && (v.$class == v);\r\nend;\r\n\r\nfunction isClassInstance(const v: JSValue): boolean; assembler;\r\nasm\r\n  return (typeof(v)==\"object\") && (v!=null) && (v.$class == Object.getPrototypeOf(v));\r\nend;\r\n\r\nfunction isInteger(const v: JSValue): boolean; assembler;\r\nasm\r\n  return Math.floor(v)===v;\r\nend;\r\n\r\nfunction isNull(const v: JSValue): boolean; assembler;\r\n// Note: use identity, \"==\" would fit undefined\r\nasm\r\n  return v === null;\r\nend;\r\n\r\nfunction isRecord(const v: JSValue): boolean; assembler;\r\nasm\r\n  return (typeof(v)===\"object\")\r\n      && (typeof(v.$new)===\"function\")\r\n      && (typeof(v.$clone)===\"function\")\r\n      && (typeof(v.$eq)===\"function\")\r\n      && (typeof(v.$assign)===\"function\");\r\nend;\r\n\r\nfunction isUndefined(const v: JSValue): boolean; assembler;\r\nasm\r\n  return v == undefined;\r\nend;\r\n\r\nfunction isDefined(const v: JSValue): boolean; assembler;\r\nasm\r\n  return !(v == undefined);\r\nend;\r\n\r\nfunction isUTF16Char(const v: JSValue): boolean; assembler;\r\nasm\r\n  if (typeof(v)!=\"string\") return false;\r\n  if ((v.length==0) || (v.length>2)) return false;\r\n  var code = v.charCodeAt(0);\r\n  if (code < 0xD800){\r\n    if (v.length == 1) return true;\r\n  } else if (code <= 0xDBFF){\r\n    if (v.length==2){\r\n      code = v.charCodeAt(1);\r\n      if (code >= 0xDC00 && code <= 0xDFFF) return true;\r\n    };\r\n  };\r\n  return false;\r\nend;\r\n\r\nfunction jsInstanceOf(const aFunction, aFunctionWithPrototype: JSValue\r\n  ): Boolean; assembler;\r\nasm\r\n  return aFunction instanceof aFunctionWithPrototype;\r\nend;\r\n\r\nfunction toNumber(const v: JSValue): double; assembler;\r\nasm\r\n  return v-0;\r\nend;\r\n\r\nfunction toInteger(const v: JSValue): NativeInt;\r\nbegin\r\n  if IsInteger(v) then\r\n    Result:=NativeInt(v)\r\n  else\r\n    Result:=0;\r\nend;\r\n\r\nfunction toObject(Value: JSValue): TJSObject;\r\n\r\nbegin\r\n  if IsObject(Value) then\r\n    Result:=TJSObject(Value)\r\n  else\r\n    Result:=Nil;\r\nend;\r\n\r\nfunction toArray(Value: JSValue): TJSArray; // If not possible, returns Nil\r\n\r\nbegin\r\n  if IsArray(Value) then\r\n    Result:=TJSArray(Value)\r\n  else\r\n    Result:=Nil;\r\nend;\r\n\r\nfunction toBoolean(Value: JSValue): Boolean; // If not possible, returns False\r\n\r\nbegin\r\n  if isBoolean(Value) then\r\n    Result:=Boolean(Value)\r\n  else\r\n    Result:=False;\r\nend;\r\n\r\nfunction toString(Value: JSValue): String; // If not possible, returns ''\r\n\r\nbegin\r\n  if IsString(Value) then\r\n    Result:=String(Value)\r\n  else\r\n    Result:='';\r\nend;\r\n\r\n{ EJS }\r\n\r\nconstructor EJS.Create(const Msg: String);\r\nbegin\r\n  FMessage:=Msg;\r\nend;\r\n\r\n\r\nfunction GetValueType(JS: JSValue): TJSValueType;\r\n\r\nVar\r\n  t : string;\r\n\r\nbegin\r\n  if isNull(js) then   // null reported as object\r\n    result:=jvtNull\r\n  else\r\n    begin\r\n    t:=jsTypeOf(js);\r\n    if (t='string') then\r\n      Result:=jvtString\r\n    else if (t='boolean') then\r\n      Result:=jvtBoolean\r\n    else if (t='object') then\r\n      begin\r\n      if IsArray(JS) then\r\n        Result:=jvtArray\r\n      else\r\n        Result:=jvtObject;\r\n      end\r\n    else if (t='number') then\r\n      if isInteger(JS) then\r\n        result:=jvtInteger\r\n      else\r\n        result:=jvtFloat\r\n    end;\r\nend;\r\n\r\nfunction Symbol : TJSSymbol; assembler;\r\nasm\r\n  return Symbol();\r\nend;\r\n\r\nfunction Symbol(Description : String) : TJSSymbol; assembler;\r\n\r\nasm\r\n  return Symbol(Description);\r\nend;\r\n\r\nend.\r\n\r\n","{\r\n    This file is part of the Pas2JS run time library.\r\n    Copyright (c) 2017 by Mattias Gaertner\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n{$IFNDEF FPC_DOTTEDUNITS}\r\nunit SysUtils;\r\n{$ENDIF}\r\n\r\n{$mode objfpc}\r\n{$modeswitch typehelpers}\r\n{$modeswitch advancedrecords}\r\n{$WARN 5078 off}\r\n\r\ninterface\r\n\r\n\r\nuses\r\n{$IFDEF FPC_DOTTEDUNITS}\r\n  System.RTLConsts, JSApi.JS;\r\n{$ELSE}\r\n  RTLConsts, js;\r\n{$ENDIF}\r\n\r\nprocedure FreeAndNil(var Obj);\r\n\r\ntype\r\n  TProcedure = procedure;\r\n\r\n {*****************************************************************************\r\n                              Various types\r\n  *****************************************************************************}\r\nConst\r\n  FloatRecDigits = 19;\r\n\r\ntype\r\n  TSysCharSet = Set of Char;\r\n\r\n  { TFloatRec }\r\n  TFloatRec = Record\r\n    Exponent: Integer;\r\n    Negative: Boolean;\r\n    Digits: Array[0..FloatRecDigits-1] of Char;\r\n  End;\r\n  TEndian = (Little,Big);\r\n  TFileName = String;\r\n  TByteArray = array [0..32767] of Byte;\r\n  TWordArray = array [0..16383] of Word;\r\n  TBytes = Array of byte;\r\n  TStringArray = array of string;\r\n\r\n  TMonthNameArray = array [1..12] of string;\r\n  TDayTable = array [1..12] of Word;\r\n  TWeekNameArray = array [1..7] of string;\r\n  TMonthNames = TMonthNameArray;\r\n  TDayNames = array[1..7] of string;\r\n\r\ntype\r\n\r\n  { TFormatSettings }\r\n\r\n  TFormatSettings = record\r\n  strict private\r\n    class function GetJSLocale: string; assembler; static;\r\n    class function GetLocaleShortDayName(const ADayOfWeek: Integer; const ALocale: string): string; static;\r\n    class function GetLocaleDecimalSeparator(const ALocale: string): string; assembler; static;\r\n    class function GetLocaleLongMonthName(const AMonth: Integer; const ALocale: string): string; assembler; static;\r\n    class function GetLocaleLongDayName(const ADayOfWeek: Integer; const ALocale: string): string; assembler; static;\r\n    class function GetLocaleShortMonthName(const AMonth: Integer; const ALocale: string): string; static;\r\n  public\r\n    CurrencyDecimals: Byte;\r\n    CurrencyFormat: Byte;\r\n    CurrencyString: string;\r\n    DateSeparator: Char;\r\n    DateTimeToStrFormat: array[Boolean] of string;\r\n    DecimalSeparator: string;\r\n    LongDateFormat: string;\r\n    LongDayNames: TDayNames;\r\n    LongMonthNames: TMonthNames;\r\n    LongTimeFormat: string;\r\n    NegCurrFormat: Byte;\r\n    ShortDateFormat: string;\r\n    ShortDayNames: TDayNames;\r\n    ShortMonthNames: TMonthNames;\r\n    ShortTimeFormat: string;\r\n    ThousandSeparator: string;\r\n    TimeAMString: string;\r\n    TimePMString: string;\r\n    TimeSeparator: Char;\r\n    TwoDigitYearCenturyWindow: Word;\r\n  public\r\n    Type\r\n       TLocaleInitCallback = Procedure(const aLocale : String; aInstance : TFormatSettings);\r\n    class var InitLocaleHandler : TLocaleInitCallback;\r\n    class function Create: TFormatSettings; overload; static;\r\n    class function Create(const ALocale: string): TFormatSettings; overload; static;\r\n    class function Invariant: TFormatSettings; static;\r\n    class constructor Init;\r\n  end;\r\n\r\n\r\n{*****************************************************************************\r\n                            Exception handling\r\n*****************************************************************************}\r\n\r\n  { Exception }\r\n\r\n  Exception = class(TObject)\r\n  private\r\n    fMessage: String;\r\n    fHelpContext: Integer;\r\n    {$ifdef NodeJS}\r\n    FNodeJSError: TJSError;\r\n    {$endif}\r\n  public\r\n    class var\r\n      LogMessageOnCreate : Boolean;\r\n  Public\r\n    constructor Create(const Msg: String); reintroduce;\r\n    constructor CreateFmt(const Msg: string; const Args: array of const);\r\n    constructor CreateHelp(const Msg: String; AHelpContext: Integer);\r\n    constructor CreateFmtHelp(const Msg: string; const Args: array of const; AHelpContext: Integer);\r\n    function ToString: String; override;\r\n    property HelpContext: Integer read fHelpContext write fHelpContext;\r\n    property Message: String read fMessage write fMessage;\r\n    {$ifdef NodeJS}\r\n    property NodeJSError: TJSError read FNodeJSError write FNodeJSError;\r\n    {$endif}\r\n  end;\r\n\r\n  ExceptClass = class of Exception;\r\n\r\n  EExternal = class(Exception);\r\n\r\n  { General math errors }\r\n  EMathError  = class(EExternal);\r\n  EInvalidOp  = class(EMathError);\r\n  EZeroDivide = class(EMathError);\r\n  EOverflow   = class(EMathError);\r\n  EUnderflow  = class(EMathError);\r\n\r\n  EAbort           = class(Exception);\r\n  EInvalidCast     = class(Exception);\r\n  EAssertionFailed = class(Exception);\r\n  EObjectCheck     = class(Exception);\r\n\r\n  { String conversion errors }\r\n  EConvertError = class(Exception);\r\n  EFormatError = class(Exception);\r\n\r\n\r\n  { integer math exceptions }\r\n  EIntError    = Class(EExternal);\r\n  EDivByZero   = Class(EIntError);\r\n  ERangeError  = Class(EIntError);\r\n  EIntOverflow = Class(EIntError);\r\n\r\n  { General math errors }\r\n\r\n  { Run-time and I/O Errors }\r\n  EInOutError = class(Exception)\r\n  public\r\n    ErrorCode : Integer;\r\n  end;\r\n\r\n  EHeapMemoryError = class(Exception);\r\n  EHeapException = EHeapMemoryError;\r\n\r\n  EExternalException = class(EExternal);\r\n  EInvalidPointer  = Class(EHeapMemoryError);\r\n  EOutOfMemory     = Class(EHeapMemoryError);\r\n\r\n  { EVariantError }\r\n\r\n  EVariantError = Class(Exception)\r\n    ErrCode : longint;\r\n    Constructor CreateCode(Code : Longint);\r\n  end;\r\n\r\n  EAccessViolation = Class(EExternal);\r\n  EBusError = Class(EAccessViolation);\r\n  EPrivilege = class(EExternal);\r\n  EStackOverflow = class(EExternal);\r\n  EControlC = class(EExternal);\r\n\r\n  { String conversion errors }\r\n\r\n  { Other errors }\r\n  EAbstractError   = Class(Exception);\r\n\r\n  EPropReadOnly = class(Exception);\r\n  EPropWriteOnly = class(Exception);\r\n\r\n  EIntfCastError = class(Exception);\r\n  EInvalidContainer = class(Exception);\r\n  EInvalidInsert = class(Exception);\r\n\r\n  EPackageError = class(Exception);\r\n\r\n  EOSError = class(Exception)\r\n  public\r\n    ErrorCode: Longint;\r\n  end;\r\n\r\n  ESafecallException = class(Exception);\r\n  ENoThreadSupport = Class(Exception);\r\n  ENoWideStringSupport = Class(Exception);\r\n  ENotImplemented = class(Exception);\r\n\r\n  EArgumentException = class(Exception);\r\n  EArgumentOutOfRangeException = class(EArgumentException);\r\n  EArgumentNilException = class(EArgumentException);\r\n\r\n  EPathTooLongException = class(Exception);\r\n  ENotSupportedException = class(Exception);\r\n  EDirectoryNotFoundException = class(Exception);\r\n  EFileNotFoundException = class(Exception);\r\n  EPathNotFoundException = class(Exception);\r\n\r\n  ENoConstructException = class(Exception);\r\n\r\n//function GetTickCount: Integer;\r\n\r\n\r\n{*****************************************************************************\r\n                            String function\r\n*****************************************************************************}\r\n\r\nConst\r\n  EmptyStr = '';\r\n  EmptyWideStr = ''; // No difference here.\r\n  HexDisplayPrefix: string = '$';\r\n  LeadBytes = [] unimplemented;\r\n\r\nFunction CharInSet(Ch: Char;Const CSet : array of char) : Boolean; overload;\r\n\r\nfunction LeftStr(const S: string; Count: Integer): String; assembler;\r\nfunction RightStr(const S: string; Count: Integer): String; assembler;\r\n\r\nfunction Trim(const S: String): String; assembler;\r\nfunction TrimLeft(const S: String): String; assembler;\r\nfunction TrimRight(const S: String): String; assembler;\r\n\r\nfunction UpperCase(const s: String): String; assembler; overload;\r\nfunction LowerCase(const s: String): String; assembler; overload;\r\n\r\nfunction CompareStr(const s1, s2: String): Integer; assembler;\r\nfunction SameStr(const s1, s2: String): Boolean; assembler;\r\nfunction CompareText(const s1, s2: String): Integer; assembler;\r\nfunction SameText(const s1, s2: String): Boolean; assembler;\r\nfunction AnsiCompareText(const s1, s2: String): Integer; assembler;\r\nfunction AnsiSameText(const s1, s2: String): Boolean; assembler;\r\nfunction AnsiCompareStr(const s1, s2: String): Integer;\r\nprocedure AppendStr(var Dest: String; const S: string);\r\n\r\nfunction Format(const Fmt: String; const Args: array of const): String;\r\nfunction Format(const Fmt: String; const Args: array of const; const aSettings : TFormatSettings): String;\r\n\r\nfunction BytesOf(const AVal: string): TBytes;\r\nfunction StringOf(const ABytes: TBytes): string;\r\n\r\n// JavaScript built-in functions\r\nfunction LocaleCompare(const s1, s2, locales: String): Boolean; assembler; overload;\r\nfunction NormalizeStr(const S: String; const Norm: String = 'NFC'): String; assembler; overload; // not in IE\r\n\r\nfunction IsValidIdent(const Ident: string; AllowDots: Boolean = False; StrictDots: Boolean = False): Boolean;\r\n\r\nType\r\n  TStringReplaceFlag = (rfReplaceAll, rfIgnoreCase);\r\n  TReplaceFlag = TStringReplaceFlag;\r\n  TStringReplaceFlags = set of TStringReplaceFlag;\r\n  TReplaceFlags = TStringReplaceFlags;\r\n\r\nfunction StringReplace(aOriginal, aSearch, aReplace: string; Flags: TStringReplaceFlags): String;\r\nfunction QuoteString(aOriginal: String; AQuote: Char): String;\r\nfunction QuotedStr(const s: string; QuoteChar: Char = ''''): string;\r\nfunction DeQuoteString(aQuoted: String; AQuote: Char): String;\r\nFunction LastDelimiter(const Delimiters, S: string): SizeInt;\r\nfunction IsDelimiter(const Delimiters, S: string; Index: Integer): Boolean;\r\nfunction AdjustLineBreaks(const S: string): string;\r\nfunction AdjustLineBreaks(const S: string; Style: TTextLineBreakStyle): string;\r\nfunction WrapText(const Line, BreakStr: string; const BreakChars: Array of char;  MaxCol: Integer): string;\r\nfunction WrapText(const Line: string; MaxCol: Integer): string;\r\n\r\n{ *****************************************************************************\r\n  Integer conversions\r\n  *****************************************************************************}\r\n\r\nFunction SwapEndian(W : Word) : Word;\r\nFunction SwapEndian(C : Cardinal) : Cardinal;\r\nfunction IntToStr(const Value: Integer): string;\r\nFunction TryStrToInt(const S : String; Out res : Integer) : Boolean;\r\nFunction TryStrToInt(const S : String; Out res : Integer; Const aSettings : TFormatSettings) : Boolean;\r\nFunction TryStrToInt(const S : String; Out res : NativeInt) : Boolean;\r\nfunction TryStrToInt(const S: String; out res: NativeInt; Const aSettings : TFormatSettings): Boolean;\r\nFunction StrToIntDef(const S : String; Const aDef : Integer) : Integer;\r\nFunction StrToIntDef(const S : String; Const aDef : NativeInt) : NativeInt;\r\nFunction StrToInt(const S : String) : Integer;\r\nFunction StrToNativeInt(const S : String) : NativeInt;\r\nfunction StrToUInt(const s: string): Cardinal;\r\nfunction StrToUIntDef(const s: string; aDef : Cardinal): Cardinal;\r\nfunction UIntToStr(Value: Cardinal): string; \r\nfunction TryStrToUInt(const s: string; out C: Cardinal): Boolean;\r\n// For compatibility\r\nFunction StrToInt64(const S : String) : NativeLargeInt;\r\nFunction StrToInt64Def(const S : String; ADefault : NativeLargeInt) : NativeLargeInt;\r\nFunction TryStrToInt64(const S : String; Out res : NativeLargeInt) : Boolean; overload;\r\nFunction TryStrToInt64(const S : String; Out res : Int64) : Boolean; unimplemented; overload; // only 53 bits\r\nFunction StrToQWord(const S : String) : NativeLargeUInt;\r\nFunction StrToQWordDef(const S : String; ADefault : NativeLargeUInt) : NativeLargeUInt;\r\nFunction TryStrToQWord(const S : String; Out res : NativeLargeUInt) : Boolean; overload;\r\nFunction TryStrToQWord(const S : String; Out res : QWord) : Boolean; unimplemented; overload; // only 52 bits\r\nFunction StrToUInt64(const S : String) : NativeLargeUInt;\r\nFunction StrToUInt64Def(const S : String; ADefault : NativeLargeUInt) : NativeLargeUInt;\r\nFunction TryStrToUInt64(const S : String; Out res : NativeLargeUInt) : Boolean; overload;\r\nFunction TryStrToUInt64(const S : String; Out res : UInt64) : Boolean; unimplemented; overload; // only 52 bits\r\nFunction StrToDWord(const S : String) : DWord;\r\nFunction StrToDWordDef(const S : String; ADefault : DWord) : DWord;\r\nFunction TryStrToDWord(const S : String; Out res : DWord) : Boolean;\r\n\r\nfunction IntToHex(Value: NativeInt; Digits: Integer): string; overload;\r\n\r\n{ *****************************************************************************\r\n  Float conversions\r\n  *****************************************************************************}\r\n\r\nconst\r\n  // Note: Currency is internally a double, multiplied by 10000 and truncated.\r\n  // The below values are the safe limits, within every step exists.\r\n  // Since currency is a double it can take much larger values, but the result\r\n  // may differ from Delphi/FPC\r\n  MaxCurrency: Currency =  900719925474.0991; // fpc: 922337203685477.5807;\r\n  MinCurrency: Currency = -900719925474.0991; // fpc: -922337203685477.5808;\r\n\r\nType\r\n  TFloatFormat = (ffFixed,ffGeneral,ffExponent,ffNumber,ffCurrency);\r\n\r\nFunction FloatToDecimal(Value : double; Precision, Decimals : integer) :  TFloatRec;\r\nFunction FloatToStr(Value: Double): String; overload;\r\nFunction FloatToStr(Value: Double; const aSettings : TFormatSettings): String; overload;\r\nFunction FloatToStrF(const Value : double; format: TFloatFormat; Precision, Digits: Integer): String; overload;\r\nFunction FloatToStrF(const Value : double; format: TFloatFormat; Precision, Digits: Integer;const aSettings : TFormatSettings): String; overload;\r\nFunction TryStrToFloat(const S : String; Out res : Extended) : Boolean; overload;\r\nFunction TryStrToFloat(const S : String; Out res : Extended; const aSettings : TFormatSettings) : Boolean; overload;\r\nFunction TryStrToFloat(const S : String; Out res : Double) : Boolean; overload;\r\nFunction TryStrToFloat(const S : String; Out res : Double; const aSettings : TFormatSettings) : Boolean; overload;\r\nFunction StrToFloatDef(const S : String; Const aDef : Double) : Double;\r\nfunction StrToFloatDef(const S: String; const aDef: Double; const aSettings : TFormatSettings): Double;\r\nFunction StrToFloat(const S : String) : Double; overload;\r\nFunction StrToFloat(const S : String; const aSettings : TFormatSettings) : Double; overload;\r\nFunction FormatFloat (Fmt : String; aValue : Double) : String; overload;\r\nFunction FormatFloat (Fmt : String; aValue : Double; aSettings : TFormatSettings) : String; overload;\r\n\r\n\r\n{ *****************************************************************************\r\n  Boolean conversions\r\n  *****************************************************************************}\r\n\r\nVar\r\n  TrueBoolStrs, FalseBoolStrs : Array of String;\r\n\r\nfunction StrToBool(const S: String): Boolean;\r\nfunction BoolToStr(B: Boolean; UseBoolStrs:Boolean=False): string;\r\nfunction BoolToStr(B: Boolean; const TrueS, FalseS: String): string;\r\nfunction StrToBoolDef(const S: String; Default: Boolean): Boolean;\r\nfunction TryStrToBool(const S: String; out Value: Boolean): Boolean;\r\n\r\n\r\n{*****************************************************************************\r\n                              OS/Environment\r\n*****************************************************************************}\r\n\r\nConst\r\n  ConfigExtension : String = '.cfg';\r\n  SysConfigDir    : String = '';\r\n\r\ntype\r\n  TOnGetEnvironmentVariable = function(Const EnvVar: String): String;\r\n  TOnGetEnvironmentString = function(Index: Integer): String;\r\n  TOnGetEnvironmentVariableCount = function: Integer;\r\n  TShowExceptionHandler = Procedure (Const Msg : String);\r\n  TUncaughtPascalExceptionHandler = reference to Procedure(aObject : TObject);\r\n  TUncaughtJSExceptionHandler = reference to Procedure(aObject : TJSObject);\r\n\r\nvar\r\n  OnGetEnvironmentVariable: TOnGetEnvironmentVariable;\r\n  OnGetEnvironmentString: TOnGetEnvironmentString;\r\n  OnGetEnvironmentVariableCount: TOnGetEnvironmentVariableCount;\r\n  // Handler to show an exception (used when showexception is called)\r\n  OnShowException : TShowExceptionHandler = nil;\r\n\r\n// Set handlers for uncaught exceptions. These will call HookUncaughtExceptions\r\n// They return the old exception handler, if there was any.\r\nFunction SetOnUnCaughtExceptionHandler(aValue : TUncaughtPascalExceptionHandler) : TUncaughtPascalExceptionHandler;\r\nFunction SetOnUnCaughtExceptionHandler(aValue : TUncaughtJSExceptionHandler) : TUncaughtJSExceptionHandler;\r\n// Hook the rtl handler for uncaught exceptions. If any exception handlers were set, they will be called.\r\n// If none were set, the exceptions will be displayed using ShowException.\r\nProcedure HookUncaughtExceptions;\r\n\r\nfunction GetEnvironmentVariable(Const EnvVar: String): String;\r\nfunction GetEnvironmentVariableCount: Integer;\r\nfunction GetEnvironmentString(Index: Integer): String;\r\n\r\n\r\nprocedure ShowException(ExceptObject: TObject; ExceptAddr: Pointer = Nil);\r\nProcedure Abort;\r\n\r\n\r\n{*****************************************************************************\r\n                               Events\r\n*****************************************************************************}\r\nType\r\n  TEventType = (etCustom,etInfo,etWarning,etError,etDebug);\r\n  TEventTypes = Set of TEventType;\r\n\r\n{*****************************************************************************\r\n                            Date and time\r\n*****************************************************************************}\r\nType\r\n  \r\n  TSystemTime = record\r\n     Year, Month, Day, DayOfWeek: word;\r\n     Hour, Minute, Second, MilliSecond: word;\r\n  end ;\r\n  TTimeStamp = record\r\n     Time: longint;   { Number of milliseconds since midnight }\r\n     Date: longint;   { One plus number of days since 1/1/0001 }\r\n  end ;\r\n\r\n\r\nVar\r\n  TimeSeparator : char deprecated;\r\n  DateSeparator : char deprecated;\r\n  ShortDateFormat : string deprecated;\r\n  LongDateFormat : string deprecated;\r\n  ShortTimeFormat : string deprecated;\r\n  LongTimeFormat : string deprecated;\r\n  DecimalSeparator : string deprecated;\r\n  ThousandSeparator : string deprecated;\r\n  TimeAMString : string deprecated;\r\n  TimePMString : string deprecated;\r\n\r\n\r\nconst\r\n\r\n  HoursPerDay = 24;\r\n  MinsPerHour = 60;\r\n  SecsPerMin  = 60;\r\n  MSecsPerSec = 1000;\r\n  \r\n  MinsPerDay  = HoursPerDay * MinsPerHour;\r\n  SecsPerHour = SecsPerMin * MinsPerHour;\r\n  SecsPerDay  = MinsPerDay * SecsPerMin;\r\n  MSecsPerDay = SecsPerDay * MSecsPerSec;\r\n  \r\n  MaxDateTime: TDateTime =  2958465.99999999;\r\n  MinDateTime: TDateTime =  -693593.99999999;\r\n\r\n  JulianEpoch = TDateTime(-2415018.5);\r\n  UnixEpoch = JulianEpoch + TDateTime(2440587.5);\r\n\r\n  DateDelta = 693594;        // Days between 1/1/0001 and 12/31/1899\r\n  UnixDateDelta = 25569;\r\n\r\n  { True=Leapyear }\r\n\r\nVar\r\n  MonthDays : array [Boolean] of TDayTable =\r\n    ((31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31),\r\n     (31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31));\r\n\r\nVar\r\n  ShortMonthNames : TMonthNames deprecated;\r\n  LongMonthNames : TMonthNames deprecated;\r\n  ShortDayNames : TDayNames deprecated;\r\n  LongDayNames : TDayNames deprecated;\r\n\r\n\r\nVar\r\n  FormatSettings: TFormatSettings;\r\n  TwoDigitYearCenturyWindow : word = 50;\r\n                             { Threshold to be subtracted from year before age-detection.}\r\n\r\n\r\n// Various conversions\r\n\r\nfunction DateTimeToJSDate(aDateTime : TDateTime; asUTC : Boolean = False) : TJSDate;\r\nfunction JSDateToDateTime(aDate : TJSDate) : TDateTime;\r\nfunction DateTimeToTimeStamp(DateTime: TDateTime): TTimeStamp;\r\nfunction TimeStampToDateTime(const TimeStamp: TTimeStamp): TDateTime;\r\nfunction MSecsToTimeStamp(MSecs: NativeInt): TTimeStamp;\r\nfunction TimeStampToMSecs(const TimeStamp: TTimeStamp): NativeInt;\r\nprocedure DateTimeToSystemTime(DateTime: TDateTime; out SystemTime: TSystemTime);\r\nfunction SystemTimeToDateTime(const SystemTime: TSystemTime): TDateTime;\r\nFunction FloatToDateTime (Const Value : Extended) : TDateTime;\r\n\r\n// Encode/Decode\r\nfunction TryEncodeDate(Year, Month, Day: Word; out Date: TDateTime): Boolean; overload;\r\nfunction TryEncodeTime(Hour, Min, Sec, MSec: Word; out Time: TDateTime): Boolean;\r\nfunction EncodeDate(Year, Month, Day :word): TDateTime;\r\nfunction EncodeTime(Hour, Minute, Second, MilliSecond:word): TDateTime;\r\nprocedure DecodeDate(Date: TDateTime; out Year, Month, Day: word);\r\nprocedure DecodeTime(Time: TDateTime; out Hour, Minute, Second, MilliSecond: word);\r\nfunction DecodeDateFully(const DateTime: TDateTime; out Year, Month, Day, DOW: Word): Boolean;\r\nfunction ComposeDateTime(Date,Time : TDateTime) : TDateTime;\r\nprocedure ReplaceTime(var dati: TDateTime; NewTime : TDateTime);\r\nprocedure ReplaceDate(var DateTime: TDateTime; const NewDate: TDateTime);\r\n\r\nfunction Date: TDateTime;\r\nfunction Time: TDateTime;\r\nfunction Now: TDateTime;\r\nfunction DayOfWeek(DateTime: TDateTime): integer;\r\nfunction IncMonth(const DateTime: TDateTime; NumberOfMonths: integer = 1 ): TDateTime;\r\nprocedure IncAMonth(var Year, Month, Day: Word; NumberOfMonths: Integer = 1);\r\nfunction IsLeapYear(Year: Word): boolean;\r\nfunction CurrentYear:Word;\r\n\r\n// Date <-> String conversion\r\n\r\nfunction DateToStr(Date: TDateTime): string; overload;\r\nfunction DateToStr(Date: TDateTime; const aSettings: TFormatSettings): string; overload;\r\nfunction StrToDate(const S: String): TDateTime; overload;\r\nfunction StrToDate(const S: String; separator : char): TDateTime; overload;\r\nfunction StrToDate(const S: String; const useformat : string; separator : char): TDateTime; overload;\r\nfunction StrToDate(const S: string; const aSettings : TFormatSettings): TDateTime; overload;\r\nfunction TryStrToDate(const S: String; out Value: TDateTime): Boolean; overload;\r\nfunction TryStrToDate(const S: String; out Value: TDateTime; const aSettings : TFormatSettings): Boolean; overload;\r\nfunction TryStrToDate(const S: String; out Value: TDateTime; separator : char): Boolean; overload;\r\nfunction TryStrToDate(const S: String; out Value: TDateTime; const useformat : string; separator : char): Boolean; overload;\r\nfunction StrToDateDef(const S: String; const Defvalue : TDateTime): TDateTime; overload;\r\nfunction StrToDateDef(const S: String; const Defvalue : TDateTime; separator : char): TDateTime; overload;\r\n\r\n// Time <-> String conversion\r\n\r\nfunction TimeToStr(Time: TDateTime): string;overload;\r\nfunction TimeToStr(Time: TDateTime; const aSettings: TFormatSettings): string;overload;\r\nfunction StrToTime(const S: String): TDateTime;overload;\r\nfunction StrToTime(const S: String; separator : char): TDateTime;overload;\r\nfunction StrToTime(const S: string; const aSettings : TFormatSettings): TDateTime;overload;\r\nfunction TryStrToTime(const S: String; out Value: TDateTime): Boolean;overload;\r\nfunction TryStrToTime(const S: String; out Value: TDateTime; aSettings : TFormatSettings): Boolean;overload;\r\nfunction TryStrToTime(const S: String; out Value: TDateTime; separator : char): Boolean; overload;\r\nfunction StrToTimeDef(const S: String; const Defvalue : TDateTime): TDateTime;overload;\r\nfunction StrToTimeDef(const S: String; const Defvalue : TDateTime; separator : char): TDateTime;overload;\r\nfunction StrToTimeDef(const AString: string; const ADefault: TDateTime; const aSettings: TFormatSettings): TDateTime;\r\n\r\n// DateTime <-> String conversion\r\n\r\nfunction DateTimeToStr(DateTime: TDateTime; ForceTimeIfZero : Boolean = False): string;overload;\r\nfunction DateTimeToStr(DateTime: TDateTime; const aSettings: TFormatSettings; ForceTimeIfZero : Boolean = False): string;overload;\r\nfunction StrToDateTime(const S: String): TDateTime;overload;\r\nfunction StrToDateTime(const s: String; const aSettings : TFormatSettings): TDateTime;overload;\r\nfunction TryStrToDateTime(const S: String; out Value: TDateTime): Boolean; overload;\r\nfunction TryStrToDateTime(const S: string; out Value: TDateTime; const aSettings: TFormatSettings): Boolean; overload;\r\nfunction StrToDateTimeDef(const S: String; const Defvalue : TDateTime): TDateTime; overload;\r\nfunction StrToDateTimeDef(const S: String; const Defvalue : TDateTime; aSettings : TFormatSettings): TDateTime; overload;\r\nfunction FormatDateTime(const aFormatStr: string; const DateTime: TDateTime): string; overload;\r\nfunction FormatDateTime(const aFormatStr: string; const DateTime: TDateTime; const aSettings: TFormatSettings): string; overload;\r\n\r\n// Local time\r\n\r\nfunction GetLocalTimeOffset: Integer; overload;\r\nfunction GetLocalTimeOffset(const DateTime: TDateTime; const InputIsUTC: Boolean; out Offset: Integer): Boolean; overload;\r\nfunction GetLocalTimeOffset(const DateTime: TDateTime; const InputIsUTC: Boolean = False): Integer; overload;\r\n\r\n\r\n{ *****************************************************************************\r\n  Currency support\r\n  *****************************************************************************}\r\n\r\n\r\nVar\r\n  CurrencyFormat : Byte deprecated;\r\n  NegCurrFormat : Byte deprecated;\r\n  CurrencyDecimals : Byte deprecated;\r\n  CurrencyString : String deprecated;\r\n\r\nFunction FloattoCurr (Const Value : Extended) : Currency;\r\nfunction TryFloatToCurr(const Value: Extended; var AResult: Currency): Boolean;\r\nFunction CurrToStr(Value: Currency): string;\r\nFunction CurrToStr(Value: Currency; Const aSettings: TFormatSettings): string;\r\nfunction StrToCurr(const S: string): Currency;\r\nfunction StrToCurr(const S: string; Const aSettings: TFormatSettings): Currency;\r\nfunction TryStrToCurr(const S: string;Out Value : Currency): Boolean;\r\nfunction TryStrToCurr(const S: string;Out Value : Currency; Const aSettings: TFormatSettings): Boolean;\r\nfunction StrToCurrDef(const S: string; Default : Currency): Currency;\r\nfunction StrToCurrDef(const S: string; Default : Currency; Const aSettings: TFormatSettings): Currency;\r\n\r\n{*****************************************************************************\r\n                               File Paths\r\n*****************************************************************************}\r\ntype\r\n  PathStr = String;\r\n  TPathStrArray = Array of PathStr;\r\n\r\nfunction ChangeFileExt(const FileName, Extension: PathStr): PathStr;\r\nfunction ExtractFilePath(const FileName: PathStr): PathStr;\r\nfunction ExtractFileDrive(const FileName: PathStr): PathStr;\r\nfunction ExtractFileName(const FileName: PathStr): PathStr;\r\nfunction ExtractFileExt(const FileName: PathStr): PathStr;\r\nfunction ExtractFileDir(Const FileName : PathStr): PathStr;\r\nfunction ExtractRelativepath (Const BaseName,DestName : PathStr): PathStr;\r\nfunction IncludeTrailingPathDelimiter(Const Path : PathStr) : PathStr;\r\nfunction ExcludeTrailingPathDelimiter(Const Path: PathStr): PathStr;\r\nfunction IncludeLeadingPathDelimiter(Const Path : PathStr) : PathStr;\r\nfunction ExcludeLeadingPathDelimiter(Const Path: PathStr): PathStr;\r\nfunction IsPathDelimiter(Const Path: PathStr; Index: Integer): Boolean;\r\nFunction SetDirSeparators (Const FileName : PathStr) : PathStr;\r\nFunction GetDirs (DirName : PathStr) : TPathStrArray;\r\nfunction ConcatPaths(const Paths: array of PathStr): PathStr;\r\n\r\n\r\n{*****************************************************************************\r\n                               Interfaces\r\n*****************************************************************************}\r\n\r\nconst\r\n  GUID_NULL: TGuid = '{00000000-0000-0000-0000-000000000000}';\r\n\r\nfunction Supports(const Instance: IInterface; const AClass: TClass; out Obj): Boolean; overload;\r\nfunction Supports(const Instance: IInterface; const IID: TGuid; out Intf): Boolean; overload;\r\nfunction Supports(const Instance: TObject; const IID: TGuid; out Intf): Boolean; overload;\r\nfunction Supports(const Instance: TObject; const IID: TGuidString; out Intf): Boolean; overload;\r\n\r\nfunction Supports(const Instance: IInterface; const AClass: TClass): Boolean; overload;\r\nfunction Supports(const Instance: IInterface; const IID: TGuid): Boolean; overload;\r\nfunction Supports(const Instance: TObject; const IID: TGuid): Boolean; overload;\r\nfunction Supports(const Instance: TObject; const IID: TGuidString): Boolean; overload;\r\n\r\nfunction Supports(const AClass: TClass; const IID: TGuid): Boolean; overload;\r\nfunction Supports(const AClass: TClass; const IID: TGuidString): Boolean; overload;\r\n\r\nfunction TryStringToGUID(const s: string; out Guid: TGuid): Boolean;\r\nfunction StringToGUID(const S: string): TGuid;\r\nfunction GUIDToString(const guid: TGuid): string;\r\nfunction IsEqualGUID(const guid1, guid2: TGuid): Boolean;\r\nfunction GuidCase(const guid: TGuid; const List: array of TGuid): Integer;\r\nFunction CreateGUID(out GUID : TGUID) : Integer;\r\n\r\nFunction EncodeHTMLEntities (S : String) : String;\r\n\r\n{ ---------------------------------------------------------------------\r\n  Type Helpers\r\n  ---------------------------------------------------------------------}\r\n\r\nType\r\n  TCharArray = Array of char;\r\n\r\n  TByteBitIndex = 0..7;\r\n  TShortIntBitIndex = 0..7;\r\n  TWordBitIndex = 0..15;\r\n  TSmallIntBitIndex = 0..15;\r\n  TCardinalBitIndex = 0..31;\r\n  TIntegerBitIndex = 0..31;\r\n  TLongIntBitIndex = TIntegerBitIndex;\r\n  TQwordBitIndex = 0..52;\r\n  TInt64BitIndex = 0..52;\r\n  TNativeIntBitIndex = 0..52;\r\n  TNativeUIntBitIndex = 0..52;\r\n\r\nConst\r\n  CPUEndian = {$IFNDEF FPC_LITTLE_ENDIAN}TEndian.Big{$ELSE}TEndian.Little{$ENDIF};\r\n\r\nType\r\n\r\n  { TGuidHelper }\r\n\r\n  TGuidHelper = record helper for TGUID\r\n    class function Create(Src : TGUID; BigEndian: Boolean): TGUID; overload; static;\r\n    class function Create(const Buf : TJSArrayBuffer; AStartIndex: Cardinal; BigEndian: Boolean): TGUID; overload; static;\r\n    class function Create(const Data: array of Byte; AStartIndex: Cardinal; BigEndian: Boolean): TGUID; overload; static;\r\n    Class Function Create(const B: TBytes; DataEndian: TEndian = CPUEndian): TGUID; overload; static; inline;\r\n    Class Function Create(const B: TBytes; AStartIndex: Cardinal; DataEndian: TEndian = CPUEndian): TGUID; overload; static;\r\n    Class Function Create(const S: string): TGUID; overload; static;\r\n    Class Function Create(A: Integer; B: SmallInt; C: SmallInt; const D: TBytes): TGUID; overload; static;\r\n//    Class Function Create(A: Integer; B: SmallInt; C: SmallInt; D, E, F, G, H, I, J, K: Byte): TGUID; overload; static;\r\n    Class Function Create(A: Cardinal; B: Word; C: Word; D, E, F, G, H, I, J, K: Byte): TGUID; overload; static;\r\n    Class Function NewGuid: TGUID; static;\r\n    Class Function Empty: TGUID; static;\r\n    Function ToByteArray(DataEndian: TEndian = CPUEndian): TBytes;\r\n    Function ToString(SkipBrackets: Boolean = False): string;\r\n  end;\r\n\r\n\r\n{$SCOPEDENUMS ON}\r\n  TStringSplitOptions = (None, ExcludeEmpty);\r\n{$SCOPEDENUMS OFF}\r\n\r\n  { TStringHelper }\r\n\r\n  TStringHelper = Type Helper for String\r\n  Private\r\n    Function GetChar(AIndex : SizeInt) : Char;\r\n    Function GetLength : SizeInt;\r\n  public\r\n    const Empty = '';\r\n    // Methods\r\n    Class Function Compare(const A: string; const B: string): Integer; overload; static; //inline;\r\n    Class Function Compare(const A: string; const B: string; IgnoreCase: Boolean): Integer; overload; static; //inline; //deprecated 'Use same with TCompareOptions';\r\n    Class Function Compare(const A: string; const B: string; Options: TCompareOptions): Integer; overload; static; // inline;\r\n    Class Function Compare(const A: string; IndexA: SizeInt; const B: string; IndexB: SizeInt; ALen: SizeInt): Integer; overload; static; // inline;\r\n    Class Function Compare(const A: string; IndexA: SizeInt; const B: string; IndexB: SizeInt; ALen: SizeInt; IgnoreCase: Boolean): Integer; overload; static; // inline; //deprecated 'Use same with TCompareOptions';\r\n    Class Function Compare(const A: string; IndexA: SizeInt; const B: string; IndexB: SizeInt; ALen: SizeInt; Options: TCompareOptions): Integer; overload; static;//  inline;\r\n    Class Function CompareOrdinal(const A: string; const B: string): Integer; overload; static;\r\n    Class Function CompareOrdinal(const A: string; IndexA: SizeInt; const B: string; IndexB: SizeInt; ALen: SizeInt): Integer; overload; static;\r\n    Class Function CompareText(const A: string; const B: string): Integer; static; inline;\r\n    Class Function Copy(const Str: string): string; inline; static;\r\n    Class Function Create(AChar: Char; ACount: SizeInt): string; overload; inline; static;\r\n    Class Function Create(const AValue: array of Char): string; overload; static;\r\n    Class Function Create(const AValue: array of Char; StartIndex: SizeInt; ALen: SizeInt): string; overload; static;\r\n    Class Function EndsText(const ASubText, AText: string): Boolean; static;\r\n    Class Function Equals(const a: string; const b: string): Boolean; overload; static;\r\n    Class Function Format(const AFormat: string; const args: array of const): string; overload; static;\r\n    Class Function IsNullOrEmpty(const AValue: string): Boolean; static;\r\n    Class Function IsNullOrWhiteSpace(const AValue: string): Boolean; static;\r\n    Class Function Join(const Separator: string; const Values: array of const): string; overload; static;\r\n    Class Function Join(const Separator: string; const Values: array of string): string; overload; static;\r\n    Class Function Join(const Separator: string; const Values: array of string; StartIndex: SizeInt; ACount: SizeInt): string; overload; static;\r\n    Class Function LowerCase(const S: string): string; overload; static; inline;\r\n    Class Function Parse(const AValue: Boolean): string; overload; static; inline;\r\n    Class Function Parse(const AValue: Extended): string; overload; static;inline;\r\n    Class Function Parse(const AValue: NativeInt): string; overload; static; inline;\r\n    Class Function Parse(const AValue: Integer): string; overload; static; inline;\r\n    Class Function ToBoolean(const S: string): Boolean; overload; static; inline;\r\n    Class Function ToDouble(const S: string): Double; overload; static; inline;\r\n    Class Function ToExtended(const S: string): Extended; overload; static; inline;\r\n    Class Function ToNativeInt(const S: string): NativeInt; overload; static; inline;\r\n    Class Function ToInteger(const S: string): Integer; overload; static; inline;\r\n    Class Function UpperCase(const S: string): string; overload; static; inline;\r\n    Class Function ToCharArray(const S : String) : TCharArray; static;\r\n    Function CompareTo(const B: string): Integer;\r\n    Function Contains(const AValue: string): Boolean;\r\n    Function CountChar(const C: Char): SizeInt;\r\n    Function DeQuotedString: string; overload;\r\n    Function DeQuotedString(const AQuoteChar: Char): string; overload;\r\n    Function EndsWith(const AValue: string): Boolean; overload; inline;\r\n    Function EndsWith(const AValue: string; IgnoreCase: Boolean): Boolean; overload;\r\n    Function Equals(const AValue: string): Boolean; overload;\r\n    Function Format(const args: array of const): string; overload;\r\n    Function GetHashCode: Integer;\r\n    Function IndexOf(AValue: Char): SizeInt; overload; inline;\r\n    Function IndexOf(const AValue: string): SizeInt; overload; inline;\r\n    Function IndexOf(AValue: Char; StartIndex: SizeInt): SizeInt; overload;\r\n    Function IndexOf(const AValue: string; StartIndex: SizeInt): SizeInt; overload;\r\n    Function IndexOf(AValue: Char; StartIndex: SizeInt; ACount: SizeInt): SizeInt; overload;\r\n    Function IndexOf(const AValue: string; StartIndex: SizeInt; ACount: SizeInt): SizeInt; overload;\r\n    Function IndexOfUnQuoted(const AValue: string; StartQuote, EndQuote: Char; StartIndex: SizeInt = 0): SizeInt; overload;\r\n    Function IndexOfAny(const AnyOf: string): SizeInt; overload;\r\n    Function IndexOfAny(const AnyOf: array of Char): SizeInt; overload;\r\n    Function IndexOfAny(const AnyOf: String; StartIndex: SizeInt): SizeInt; overload;\r\n    Function IndexOfAny(const AnyOf: array of Char; StartIndex: SizeInt): SizeInt; overload;\r\n    Function IndexOfAny(const AnyOf: String; StartIndex: SizeInt; ACount: SizeInt): SizeInt; overload;\r\n    Function IndexOfAny(const AnyOf: array of Char; StartIndex: SizeInt; ACount: SizeInt): SizeInt; overload;\r\n    Function IndexOfAny(const AnyOf: array of String): SizeInt; overload;\r\n    Function IndexOfAny(const AnyOf: array of String; StartIndex: SizeInt): SizeInt; overload;\r\n    Function IndexOfAny(const AnyOf: array of String; StartIndex: SizeInt; ACount: SizeInt): SizeInt; overload;\r\n    Function IndexOfAny(const AnyOf: array of String; StartIndex: SizeInt; ACount: SizeInt; Out AMatch : SizeInt): SizeInt; overload;\r\n    Function IndexOfAnyUnquoted(const AnyOf: array of Char; StartQuote, EndQuote: Char): SizeInt; overload;\r\n    Function IndexOfAnyUnquoted(const AnyOf: array of Char; StartQuote, EndQuote: Char; StartIndex: SizeInt): SizeInt; overload;\r\n    Function IndexOfAnyUnquoted(const AnyOf: array of Char; StartQuote, EndQuote: Char; StartIndex: SizeInt; ACount: SizeInt): SizeInt; overload;\r\n    function IndexOfAnyUnquoted(const AnyOf: array of string; StartQuote, EndQuote: Char; StartIndex: SizeInt; Out Matched: SizeInt): SizeInt; overload;\r\n    Function Insert(StartIndex: SizeInt; const AValue: string): string;\r\n    Function IsDelimiter(const Delimiters: string; Index: SizeInt): Boolean;\r\n    Function IsEmpty: Boolean;\r\n    Function LastDelimiter(const Delims: string): SizeInt;\r\n    Function LastIndexOf(AValue: Char): SizeInt; overload;\r\n    Function LastIndexOf(const AValue: string): SizeInt; overload;\r\n    Function LastIndexOf(AValue: Char; AStartIndex: SizeInt): SizeInt; overload;\r\n    Function LastIndexOf(const AValue: string; AStartIndex: SizeInt): SizeInt; overload;\r\n    Function LastIndexOf(AValue: Char; AStartIndex: SizeInt; ACount: SizeInt): SizeInt; overload;\r\n    Function LastIndexOf(const AValue: string; AStartIndex: SizeInt; ACount: SizeInt): SizeInt; overload;\r\n    Function LastIndexOfAny(const AnyOf: array of Char): SizeInt; overload;\r\n    Function LastIndexOfAny(const AnyOf: array of Char; AStartIndex: SizeInt): SizeInt; overload;\r\n    Function LastIndexOfAny(const AnyOf: array of Char; AStartIndex: SizeInt; ACount: SizeInt): SizeInt; overload;\r\n    Function PadLeft(ATotalWidth: SizeInt): string; overload; inline;\r\n    Function PadLeft(ATotalWidth: SizeInt; PaddingChar: Char): string; overload; inline;\r\n    Function PadRight(ATotalWidth: SizeInt): string; overload; inline;\r\n    Function PadRight(ATotalWidth: SizeInt; PaddingChar: Char): string; overload; inline;\r\n    Function QuotedString: string; overload;\r\n    Function QuotedString(const AQuoteChar: Char): string; overload;\r\n    Function Remove(StartIndex: SizeInt): string; overload; inline;\r\n    Function Remove(StartIndex: SizeInt; ACount: SizeInt): string; overload; inline;\r\n    Function Replace(OldChar: Char; NewChar: Char): string; overload;\r\n    Function Replace(OldChar: Char; NewChar: Char; ReplaceFlags: TReplaceFlags): string; overload;\r\n    Function Replace(const OldValue: string; const NewValue: string): string; overload;\r\n    Function Replace(const OldValue: string; const NewValue: string; ReplaceFlags: TReplaceFlags): string; overload;\r\n    Function Split(const Separators: String): TStringArray; overload;\r\n    Function Split(const Separators: array of Char): TStringArray; overload;\r\n    Function Split(const Separators: string; ACount: SizeInt): TStringArray; overload;\r\n    Function Split(const Separators: array of Char; ACount: SizeInt): TStringArray; overload;\r\n    Function Split(const Separators: string; Options: TStringSplitOptions): TStringArray; overload;\r\n    Function Split(const Separators: array of Char; Options: TStringSplitOptions): TStringArray; overload;\r\n    Function Split(const Separators: string; ACount: SizeInt; Options: TStringSplitOptions): TStringArray; overload;\r\n    Function Split(const Separators: array of Char; ACount: SizeInt; Options: TStringSplitOptions): TStringArray; overload;\r\n    Function Split(const Separators: array of string): TStringArray; overload;\r\n    Function Split(const Separators: array of string; ACount: SizeInt): TStringArray; overload;\r\n    Function Split(const Separators: array of string; Options: TStringSplitOptions): TStringArray; overload;\r\n    Function Split(const Separators: array of string; ACount: SizeInt; Options: TStringSplitOptions): TStringArray; overload;\r\n    Function Split(const Separators: String; AQuote: Char): TStringArray; overload;\r\n    Function Split(const Separators: array of Char; AQuote: Char): TStringArray; overload;\r\n    Function Split(const Separators: String; AQuoteStart, AQuoteEnd: Char): TStringArray; overload;\r\n    Function Split(const Separators: array of Char; AQuoteStart, AQuoteEnd: Char): TStringArray; overload;\r\n    Function Split(const Separators: string; AQuoteStart, AQuoteEnd: Char; Options: TStringSplitOptions): TStringArray; overload;\r\n    Function Split(const Separators: array of Char; AQuoteStart, AQuoteEnd: Char; Options: TStringSplitOptions): TStringArray; overload;\r\n    Function Split(const Separators: string; AQuoteStart, AQuoteEnd: Char; ACount: SizeInt): TStringArray; overload;\r\n    Function Split(const Separators: array of Char; AQuoteStart, AQuoteEnd: Char; ACount: SizeInt): TStringArray; overload;\r\n    Function Split(const Separators: string; AQuoteStart, AQuoteEnd: Char; ACount: SizeInt; Options: TStringSplitOptions): TStringArray; overload;\r\n    Function Split(const Separators: array of Char; AQuoteStart, AQuoteEnd: Char; ACount: SizeInt; Options: TStringSplitOptions): TStringArray; overload;\r\n    Function Split(const Separators: array of string; AQuote: Char): TStringArray; overload;\r\n    Function Split(const Separators: array of string; AQuoteStart, AQuoteEnd: Char): TStringArray; overload;\r\n    Function Split(const Separators: array of string; AQuoteStart, AQuoteEnd: Char; Options: TStringSplitOptions): TStringArray; overload;\r\n    Function Split(const Separators: array of string; AQuoteStart, AQuoteEnd: Char; ACount: SizeInt): TStringArray; overload;\r\n    Function Split(const Separators: array of string; AQuoteStart, AQuoteEnd: Char; ACount: SizeInt; Options: TStringSplitOptions): TStringArray; overload;\r\n    Function StartsWith(const AValue: string): Boolean; overload; inline;\r\n    Function StartsWith(const AValue: string; IgnoreCase: Boolean): Boolean; overload;\r\n    Function Substring(AStartIndex: SizeInt): string; overload;\r\n    Function Substring(AStartIndex: SizeInt; ALen: SizeInt): string; overload;\r\n    Function ToBoolean: Boolean; overload; inline;\r\n    Function ToInteger: Integer; overload; inline;\r\n    Function ToNativeInt: NativeInt; overload; inline;\r\n    Function ToDouble: Double; overload; inline;\r\n    Function ToExtended: Extended; overload; inline;\r\n    Function ToCharArray: TCharArray; overload;\r\n    Function ToCharArray(AStartIndex: SizeInt; ALen: SizeInt): TCharArray; overload;\r\n    Function ToLower: string; overload; inline;\r\n    Function ToLowerInvariant: string;\r\n    Function ToUpper: string; overload; inline;\r\n    Function ToUpperInvariant: string; inline;\r\n    Function Trim: string; overload;\r\n    Function TrimLeft: string; overload;\r\n    Function TrimRight: string; overload;\r\n    Function Trim(const ATrimChars: array of Char): string; overload;\r\n    Function TrimLeft(const ATrimChars: array of Char): string; overload;\r\n    Function TrimRight(const ATrimChars: array of Char): string; overload;\r\n    Function TrimEnd(const ATrimChars: array of Char): string; deprecated 'Use TrimRight';\r\n    Function TrimStart(const ATrimChars: array of Char): string; deprecated 'Use TrimLeft';\r\n    property Chars[AIndex: SizeInt]: Char read GetChar;\r\n    property Length: SizeInt read GetLength;\r\n  end;\r\n\r\n  TDoubleHelper = Type Helper for Double\r\n  private\r\n    Function GetB(AIndex: Cardinal): Byte;\r\n    Function GetW(AIndex: Cardinal): Word;\r\n    Function GetE: NativeUInt; inline;\r\n    Function GetF: NativeUInt; inline;\r\n    Function GetS: Boolean; inline;\r\n    Procedure SetS(aValue : Boolean); inline;\r\n    procedure SetB(AIndex: Cardinal; const AValue: Byte);\r\n    procedure SetW(AIndex: Cardinal; const AValue: Word);\r\n  public\r\n    const\r\n    {$push}\r\n    {$R-}\r\n    {$Q-}\r\n      Epsilon          : Double = 4.9406564584124654418e-324;\r\n      MaxValue         : Double = 1.7976931348623157081e+308;\r\n      MinValue         : Double = -1.7976931348623157081e+308;\r\n      // PositiveInfinity : Double = 1.0/0.0;\r\n      // NegativeInfinity : Double = -1.0/0.0;\r\n      // NaN              : Double = 0.0/0.0;\r\n    {$POP}\r\n    Class Function IsInfinity(const AValue: Double): Boolean; overload; inline; static;\r\n    Class Function IsNan(const AValue: Double): Boolean; overload; inline; static;\r\n    Class Function IsNegativeInfinity(const AValue: Double): Boolean; overload; inline; static;\r\n    Class Function IsPositiveInfinity(const AValue: Double): Boolean; overload; inline; static;\r\n    Class Function Parse(const AString: string): Double; overload; inline; static;\r\n    Class Function ToString(const AValue: Double): string; overload; inline; static;\r\n    Class Function ToString(const AValue: Double; const AFormat: TFloatFormat; const APrecision, ADigits: Integer): string; overload; inline; static;\r\n    Class Function TryParse(const AString: string; out AValue: Double): Boolean; overload; inline; static;\r\n\r\n    Procedure BuildUp(const ASignFlag: Boolean; const AMantissa: NativeUInt; const AExponent: Integer);\r\n    Function Exponent: Integer;\r\n    Function Fraction: Extended;\r\n    Function IsInfinity: Boolean; overload; inline;\r\n    Function IsNan: Boolean; overload; inline;\r\n    Function IsNegativeInfinity: Boolean; overload; inline;\r\n    Function IsPositiveInfinity: Boolean; overload; inline;\r\n    Function Mantissa: NativeUInt;\r\n\r\n    Function ToString(const AFormat: TFloatFormat; const APrecision, ADigits: Integer): string; overload; inline;\r\n    Function ToString: string; overload; inline;\r\n\r\n    property Bytes[AIndex: Cardinal]: Byte read GetB write SetB;  // 0..7\r\n    property Words[AIndex: Cardinal]: Word read GetW write SetW; // 0..3\r\n    property Sign: Boolean read GetS Write SetS;\r\n    property Exp: NativeUInt read GetE;\r\n    property Frac: NativeUInt read GetF;\r\n  end;\r\n\r\n  TByteHelper = Type Helper for Byte\r\n  public\r\n    const\r\n      MaxValue = 255;\r\n      MinValue = 0;\r\n  public\r\n    Class Function Parse(const AString: string): Byte; inline; static;\r\n    Class Function Size: Integer; inline; static;\r\n    Class Function ToString(const AValue: Byte): string; overload; inline; static;\r\n    Class Function TryParse(const AString: string; out AValue: Byte): Boolean; inline; static;\r\n  Public\r\n    Function ToBoolean: Boolean; inline;\r\n    Function ToDouble: Double; inline;\r\n    Function ToExtended: Extended; inline;\r\n    Function ToBinString:string; inline;\r\n    Function ToHexString(const AMinDigits: Integer): string; overload; inline;\r\n    Function ToHexString: string; overload; inline;\r\n    Function ToString: string; overload; inline;\r\n    Function SetBit(const Index: TByteBitIndex) : Byte; inline;\r\n    Function ClearBit(const Index: TByteBitIndex) : Byte; inline;\r\n    Function ToggleBit(const Index: TByteBitIndex) : Byte; inline;\r\n    Function TestBit(const Index:TByteBitIndex):Boolean; inline;\r\n  end;\r\n\r\n  TShortIntHelper = Type Helper for ShortInt\r\n  public\r\n    const\r\n      MaxValue = 127;\r\n      MinValue = -128;\r\n  public\r\n    Class Function Parse(const AString: string): ShortInt; inline; static;\r\n    Class Function Size: Integer; inline; static;\r\n    Class Function ToString(const AValue: ShortInt): string; overload; inline; static;\r\n    Class Function TryParse(const AString: string; out AValue: ShortInt): Boolean; inline; static;\r\n  public\r\n    Function ToBoolean: Boolean; inline;\r\n    Function ToDouble: Double; inline;\r\n    Function ToExtended: Extended; inline;\r\n    Function ToBinString:string; inline;\r\n    Function ToHexString(const AMinDigits: Integer): string; overload; inline;\r\n    Function ToHexString: string; overload; inline;\r\n    Function ToString: string; overload; inline;\r\n    Function SetBit(const Index: TShortIntBitIndex): Shortint; inline;\r\n    Function ClearBit(const Index: TShortIntBitIndex): Shortint; inline;\r\n    Function ToggleBit(const Index: TShortIntBitIndex): Shortint; inline;\r\n    Function TestBit(const Index:TShortIntBitIndex):Boolean; inline;\r\n  end;\r\n\r\n  TSmallIntHelper = Type Helper for SmallInt\r\n  public\r\n    const\r\n      MaxValue = 32767;\r\n      MinValue = -32768;\r\n  public\r\n    Class Function Parse(const AString: string): SmallInt; inline; static;\r\n    Class Function Size: Integer; inline; static;\r\n    Class Function ToString(const AValue: SmallInt): string; overload; inline; static;\r\n    Class Function TryParse(const AString: string; out AValue: SmallInt): Boolean; inline; static;\r\n  public\r\n    Function ToString: string; overload; inline;\r\n    Function ToBoolean: Boolean; inline;\r\n    Function ToBinString:string; inline;\r\n    Function ToHexString: string; overload; inline;\r\n    Function ToHexString(const AMinDigits: Integer): string; overload; inline;\r\n    Function ToDouble: Double; inline;\r\n    Function ToExtended: Extended; inline;\r\n    Function SetBit(const Index: TSmallIntBitIndex) : Smallint; inline;\r\n    Function ClearBit(const Index: TSmallIntBitIndex) : Smallint; inline;\r\n    Function ToggleBit(const Index: TSmallIntBitIndex) : Smallint; inline;\r\n    Function TestBit(const Index:TSmallIntBitIndex):Boolean; inline;\r\n  end;\r\n\r\n  TWordHelper = Type Helper for Word\r\n  public\r\n    const\r\n      MaxValue = 65535;\r\n      MinValue = 0;\r\n  Public\r\n    Class Function Parse(const AString: string): Word; inline; static;\r\n    Class Function Size: Integer; inline; static;\r\n    Class Function ToString(const AValue: Word): string; overload; inline; static;\r\n    Class Function TryParse(const AString: string; out AValue: Word): Boolean; inline; static;\r\n  Public\r\n    Function ToBoolean: Boolean; inline;\r\n    Function ToDouble: Double; inline;\r\n    Function ToExtended: Extended; inline;\r\n    Function ToBinString:string; inline;\r\n    Function ToHexString(const AMinDigits: Integer): string; overload; inline;\r\n    Function ToHexString: string; overload; inline;\r\n    Function ToString: string; overload; inline;\r\n    Function SetBit(const Index: TWordBitIndex) : Word; inline;\r\n    Function ClearBit(const Index: TWordBitIndex) : Word; inline;\r\n    Function ToggleBit(const Index: TWordBitIndex) : Word; inline;\r\n    Function TestBit(const Index:TWordBitIndex):Boolean; inline;\r\n  end;\r\n\r\n  TCardinalHelper = Type Helper for Cardinal { for LongWord Type too }\r\n  public\r\n    const\r\n      MaxValue = 4294967295;\r\n      MinValue = 0;\r\n  Public\r\n    Class Function Parse(const AString: string): Cardinal; inline; static;\r\n    Class Function Size: Integer; inline; static;\r\n    Class Function ToString(const AValue: Cardinal): string; overload; inline; static;\r\n    Class Function TryParse(const AString: string; out AValue: Cardinal): Boolean; inline; static;\r\n  Public\r\n    Function ToBoolean: Boolean; inline;\r\n    Function ToDouble: Double; inline;\r\n    Function ToExtended: Extended; inline;\r\n    Function ToBinString:string; inline;\r\n    Function ToHexString(const AMinDigits: Integer): string; overload; inline;\r\n    Function ToHexString: string; overload; inline;\r\n    Function ToString: string; overload; inline;\r\n    Function SetBit(const Index: TCardinalBitIndex) : Cardinal; inline;\r\n    Function ClearBit(const Index: TCardinalBitIndex) : Cardinal; inline;\r\n    Function ToggleBit(const Index: TCardinalBitIndex) : Cardinal; inline;\r\n    Function TestBit(const Index:TCardinalBitIndex):Boolean; inline;\r\n  end;\r\n\r\n  TIntegerHelper = Type Helper for Integer { for LongInt Type too }\r\n  public\r\n    const\r\n      MaxValue = 2147483647;\r\n      MinValue = -2147483648;\r\n  Public\r\n    Class Function Size: Integer; inline; static;\r\n    Class Function ToString(const AValue: Integer): string; overload; inline; static;\r\n    Class Function Parse(const AString: string): Integer; inline; static;\r\n    Class Function TryParse(const AString: string; out AValue: Integer): Boolean; inline; static;\r\n  Public\r\n    Function ToBoolean: Boolean; inline;\r\n    Function ToDouble: Double; inline;\r\n    Function ToExtended: Extended; inline;\r\n    Function ToBinString:string; inline;\r\n    Function ToHexString(const AMinDigits: Integer): string; overload; inline;\r\n    Function ToHexString: string; overload; inline;\r\n    Function ToString: string; overload; inline;\r\n    Function SetBit(const Index: TIntegerBitIndex) : Integer; inline;\r\n    Function ClearBit(const Index: TIntegerBitIndex) : Integer; inline;\r\n    Function ToggleBit(const Index: TIntegerBitIndex) : Integer; inline;\r\n    Function TestBit(const Index:TIntegerBitIndex):Boolean; inline;\r\n  end;\r\n\r\n  TNativeIntHelper = Type Helper for NativeInt\r\n  public\r\n    const\r\n      MaxValue = High(NativeInt);\r\n      MinValue = Low(NativeInt);\r\n  Public\r\n    Class Function Parse(const AString: string): NativeInt; inline; static;\r\n    Class Function Size: Integer; inline; static;\r\n    Class Function ToString(const AValue: NativeInt): string; overload; inline; static;\r\n    Class Function TryParse(const AString: string; out AValue: NativeInt): Boolean; inline; static;\r\n  Public\r\n    Function ToBoolean: Boolean; inline;\r\n    Function ToDouble: Double; inline;\r\n    Function ToExtended: Extended; inline;\r\n    Function ToBinString:string; inline;\r\n    Function ToHexString(const AMinDigits: Integer): string; overload; inline;\r\n    Function ToHexString: string; overload; inline;\r\n    Function ToString: string; overload; inline;\r\n    Function SetBit(const Index: TNativeIntBitIndex) : NativeInt; inline;\r\n    Function ClearBit(const Index: TNativeIntBitIndex) : NativeInt; inline;\r\n    Function ToggleBit(const Index: TNativeIntBitIndex) : NativeInt; inline;\r\n    Function TestBit(const Index:TNativeIntBitIndex):Boolean; inline;\r\n  end;\r\n\r\n  TNativeUIntHelper = Type Helper for NativeUInt\r\n  public\r\n    const\r\n      MaxValue = High(NativeUInt);\r\n      MinValue = 0;\r\n  Public\r\n    Class Function Parse(const AString: string): NativeUInt; inline; static;\r\n    Class Function Size: Integer; inline; static;\r\n    Class Function ToString(const AValue: NativeUInt): string; overload; inline; static;\r\n    Class Function TryParse(const AString: string; out AValue: NativeUInt): Boolean; inline; static;\r\n  Public\r\n    Function ToBoolean: Boolean; inline;\r\n    Function ToDouble: Double; inline;\r\n    Function ToExtended: Extended; inline;\r\n    Function ToBinString:string; inline;\r\n    Function ToHexString(const AMinDigits: Integer): string; overload; inline;\r\n    Function ToHexString: string; overload; inline;\r\n    Function ToSingle: Single; inline;\r\n    Function ToString: string; overload; inline;\r\n    Function SetBit(const Index: TNativeUIntBitIndex) : NativeUint; inline;\r\n    Function ClearBit(const Index: TNativeUIntBitIndex): NativeUint; inline;\r\n    Function ToggleBit(const Index: TNativeUIntBitIndex) : NativeUint; inline;\r\n    Function TestBit(const Index:TNativeUIntBitIndex) :Boolean; inline;\r\n  end;\r\n\r\n{$SCOPEDENUMS ON}\r\n  TUseBoolStrs = (False,True);\r\n{$SCOPEDENUMS OFF}\r\n\r\n  TBooleanHelper = Type Helper for Boolean\r\n  public\r\n    Class Function Parse(const S: string): Boolean; inline; static;\r\n    Class Function Size: Integer; inline; static;\r\n    Class Function ToString(const AValue: Boolean; UseBoolStrs: TUseBoolStrs = TUseBoolStrs.false): string; overload; inline; static;\r\n    Class Function TryToParse(const S: string; out AValue: Boolean): Boolean; inline; static;\r\n  Public\r\n    Function ToInteger: Integer; inline;\r\n    Function ToString(UseBoolStrs: TUseBoolStrs = TUseBoolStrs.False): string; overload; inline;\r\n  end;\r\n\r\n  TByteBoolHelper = Type Helper for ByteBool\r\n  public\r\n    Class Function Parse(const S: string): Boolean; inline; static;\r\n    Class Function Size: Integer; inline; static;\r\n    Class Function ToString(const AValue: Boolean; UseBoolStrs : Boolean = False): string; overload; inline; static;\r\n    Class Function TryToParse(const S: string; out AValue: Boolean): Boolean; inline; static;\r\n  Public\r\n    Function ToInteger: Integer; inline;\r\n    Function ToString(UseBoolStrs: Boolean = False): string; overload; inline;\r\n  end;\r\n\r\n  TWordBoolHelper = Type Helper for WordBool\r\n  public\r\n    Class Function Parse(const S: string): Boolean; inline; static;\r\n    Class Function Size: Integer; inline; static;\r\n    Class Function ToString(const AValue: Boolean; UseBoolStrs: Boolean = False): string; overload; inline; static;\r\n    Class Function TryToParse(const S: string; out AValue: Boolean): Boolean; inline; static;\r\n  Public\r\n    Function ToInteger: Integer; inline;\r\n    Function ToString(UseBoolStrs: boolean = False): string; overload; inline;\r\n  end;\r\n\r\n  TLongBoolHelper = Type Helper for LongBool\r\n  public\r\n    Class Function Parse(const S: string): Boolean; inline; static;\r\n    Class Function Size: Integer; inline; static;\r\n    Class Function ToString(const AValue: Boolean; UseBoolStrs: Boolean= False): string; overload; inline; static;\r\n    Class Function TryToParse(const S: string; out AValue: Boolean): Boolean; inline; static;\r\n  public\r\n    Function ToInteger: Integer; inline;\r\n    Function ToString(UseBoolStrs: Boolean = False): string; overload; inline;\r\n  end;\r\n\r\n  { TStringBuilder }\r\n\r\n  TStringBuilder = class\r\n  private\r\n    const\r\n      DefaultCapacity = 64;\r\n  private\r\n    Function  GetCapacity: Integer;\r\n    Procedure SetCapacity(AValue: Integer);\r\n    Function  GetC(Index: Integer): Char;\r\n    Procedure SetC(Index: Integer; AValue: Char);\r\n    Function  GetLength: Integer; inline;\r\n    Procedure SetLength(AValue: Integer);\r\n  protected\r\n    FData: String;\r\n    FMaxCapacity: Integer;\r\n    // Raise error on range check.\r\n    Procedure CheckRange(Idx,Count,MaxLen : Integer);inline;\r\n    Procedure CheckNegative(Const AValue : Integer; Const AName: String); inline;\r\n    // All appends/inserts pass through here.\r\n\r\n    Procedure DoAppend(Const S : String);virtual;\r\n    Procedure DoAppend(const AValue: Array of char; Idx, aCount: Integer); virtual;\r\n    Procedure DoInsert(Index: Integer; const AValue: String); virtual;\r\n    Procedure DoInsert(Index: Integer; const AValue: Array of char; StartIndex, aCharCount: Integer); virtual;\r\n    Procedure DoReplace(Index: Integer; const Old, New: String); virtual;\r\n    Procedure Grow;\r\n    Procedure Shrink;\r\n  public\r\n    Constructor Create;\r\n    Constructor Create(aCapacity: Integer);\r\n    Constructor Create(const AValue: String);\r\n    Constructor Create(aCapacity: Integer; aMaxCapacity: Integer);\r\n    Constructor Create(const AValue: String; aCapacity: Integer);\r\n    Constructor Create(const AValue: String; StartIndex: Integer; aLength: Integer; aCapacity: Integer);\r\n\r\n    Function Append(const AValue: Boolean): TStringBuilder;\r\n    Function Append(const AValue: Byte): TStringBuilder;\r\n    Function Append(const AValue: Char): TStringBuilder;\r\n    Function Append(const AValue: Currency): TStringBuilder;\r\n    Function Append(const AValue: Double): TStringBuilder;\r\n    Function Append(const AValue: Smallint): TStringBuilder;\r\n    Function Append(const AValue: LongInt): TStringBuilder;\r\n    Function Append(const AValue: Int64): TStringBuilder;\r\n    Function Append(const AValue: TObject): TStringBuilder;\r\n    Function Append(const AValue: Shortint): TStringBuilder;\r\n    Function Append(const AValue: Single): TStringBuilder;\r\n    Function Append(const AValue: UInt64): TStringBuilder;\r\n    Function Append(const AValue: Array of char): TStringBuilder;\r\n    Function Append(const AValue: Word): TStringBuilder;\r\n    Function Append(const AValue: Cardinal): TStringBuilder;\r\n    Function Append(const AValue: String): TStringBuilder;\r\n    Function Append(const AValue: Char; RepeatCount: Integer): TStringBuilder;\r\n    Function Append(const AValue: Array of char; StartIndex: Integer; SBCharCount: Integer): TStringBuilder;\r\n    Function Append(const AValue: String; StartIndex: Integer; Count: Integer): TStringBuilder;\r\n\r\n    Function Append(const Fmt: String; const Args: array of const): TStringBuilder;\r\n    Function AppendFormat(const Fmt: String; const Args: array of const): TStringBuilder;\r\n    Function AppendLine: TStringBuilder;\r\n    Function AppendLine(const AValue: String): TStringBuilder;\r\n\r\n    Procedure Clear;\r\n    Procedure CopyTo(SourceIndex: Integer; Var Destination: Array of char; DestinationIndex: Integer; Count: Integer);\r\n    Function EnsureCapacity(aCapacity: Integer): Integer;\r\n    Function Equals(StringBuilder: TStringBuilder): Boolean; reintroduce;\r\n\r\n    Function Insert(Index: Integer; const AValue: Boolean): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: Byte): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: Char): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: Currency): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: Double): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: Smallint): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: LongInt): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: Array of char): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: Int64): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: TObject): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: Shortint): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: Single): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: String): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: Word): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: Cardinal): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: UInt64): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: String; const aRepeatCount: Integer): TStringBuilder;\r\n    Function Insert(Index: Integer; const AValue: Array of char; startIndex: Integer; SBCharCount: Integer): TStringBuilder;\r\n\r\n    Function Remove(StartIndex: Integer; RemLength: Integer): TStringBuilder;\r\n\r\n    Function Replace(const OldValue, NewValue: String): TStringBuilder;\r\n    Function Replace(const OldValue, NewValue: String; StartIndex: Integer; Count: Integer): TStringBuilder;\r\n    Function ToString: String; override;\r\n    Function ToString(aStartIndex: Integer; aLength: Integer): String; reintroduce;\r\n    property Chars[index: Integer]: Char read GetC write SetC; default;\r\n    property Length: Integer read GetLength write SetLength;\r\n    property Capacity: Integer read GetCapacity write SetCapacity;\r\n    property MaxCapacity: Integer read FMaxCapacity;\r\n  end;\r\n\r\n\r\n\r\nimplementation\r\n\r\nConst\r\n  DefaultShortMonthNames : TMonthNames = (\r\n    'Jan',\r\n    'Feb',\r\n    'Mar',\r\n    'Apr',\r\n    'May',\r\n    'Jun',\r\n    'Jul',\r\n    'Aug',\r\n    'Sep',\r\n    'Oct',\r\n    'Nov',\r\n    'Dec');\r\n  DefaultLongMonthNames : TMonthNames = (\r\n    'January',\r\n    'February',\r\n    'March',\r\n    'April',\r\n    'May',\r\n    'June',\r\n    'July',\r\n    'August',\r\n    'September',\r\n    'October',\r\n    'November',\r\n    'December');\r\n  DefaultShortDayNames : TDayNames = (\r\n    'Sun',\r\n    'Mon',\r\n    'Tue',\r\n    'Wed',\r\n    'Thu',\r\n    'Fri',\r\n    'Sat');\r\n\r\n  DefaultLongDayNames : TDayNames = (\r\n    'Sunday',\r\n    'Monday',\r\n    'Tuesday',\r\n    'Wednesday',\r\n    'Thursday',\r\n    'Friday',\r\n    'Saturday');\r\n\r\n\r\n{ ---------------------------------------------------------------------\r\n  Exception handling\r\n  ---------------------------------------------------------------------}\r\nResourcestring\r\n  SAbortError = 'Operation aborted';\r\n  SApplicationException = 'Application raised an exception: ';\r\n  SErrUnknownExceptionType = 'Caught unknown exception type : ';\r\n\r\nprocedure DoShowException(S : String);\r\n\r\nbegin\r\n  if Assigned(OnShowException) then\r\n    OnShowException(S)\r\n  else\r\n    begin\r\n    {$IFDEF BROWSER}\r\n      asm\r\n        window.alert(S);\r\n      end;\r\n    {$ENDIF}\r\n    {$IFDEF NODEJS}\r\n      Writeln(S);\r\n    {$ENDIF}\r\n    end;\r\nend;\r\n\r\nprocedure ShowException(ExceptObject: TObject; ExceptAddr: Pointer = Nil);\r\n\r\nVar\r\n  S : String;\r\n\r\nbegin\r\n  S:=SApplicationException+ExceptObject.ClassName;\r\n  if ExceptObject is Exception then\r\n    S:=S+' : '+Exception(ExceptObject).Message;\r\n  DoShowException(S);\r\n  if ExceptAddr=nil then;\r\nend;\r\n\r\nType\r\n  TRTLExceptionHandler = procedure (aError : JSValue);\r\n\r\nVar\r\n  rtlExceptionHandler : TRTLExceptionHandler; External name 'rtl.onUncaughtException';\r\n  rtlShowUncaughtExceptions : Boolean; External name 'rtl.showUncaughtExceptions';\r\n  OnPascalException : TUncaughtPascalExceptionHandler;\r\n  OnJSException : TUncaughtJSExceptionHandler;\r\n\r\nProcedure RTLExceptionHook(aError : JSValue);\r\n\r\nVar\r\n  S : String;\r\n\r\nbegin\r\n  if isClassInstance(aError) then\r\n    begin\r\n    if Assigned(OnPascalException) then\r\n      OnPascalException(TObject(aError))\r\n    else\r\n      ShowException(TObject(aError),Nil);\r\n    end\r\n  else if isObject(aError) then\r\n    begin\r\n    if Assigned(OnJSException) then\r\n      OnJSException(TJSObject(aError))\r\n    else\r\n      begin\r\n      if TJSObject(aError).hasOwnProperty('message') then\r\n        S:=SErrUnknownExceptionType+String(TJSObject(aError).Properties['message'])\r\n      else\r\n        S:=SErrUnknownExceptionType+TJSObject(aError).toString;\r\n      DoShowException(S);\r\n      end\r\n    end\r\n  else\r\n    begin\r\n    S:=SErrUnknownExceptionType+String(aError);\r\n    DoShowException(S);\r\n    end;\r\nend;\r\n\r\n\r\n\r\nFunction SetOnUnCaughtExceptionHandler(aValue : TUncaughtPascalExceptionHandler) : TUncaughtPascalExceptionHandler;\r\n\r\nbegin\r\n  Result:=OnPascalException;\r\n  OnPascalException:=aValue;\r\n  HookUncaughtExceptions;\r\nend;\r\n\r\nFunction SetOnUnCaughtExceptionHandler(aValue : TUncaughtJSExceptionHandler) : TUncaughtJSExceptionHandler;\r\n\r\nbegin\r\n  Result:=OnJSException;\r\n  OnJSException:=aValue;\r\n  HookUncaughtExceptions;\r\nend;\r\n\r\nProcedure HookUncaughtExceptions;\r\n\r\nbegin\r\n  rtlExceptionHandler:=@RTLExceptionHook;\r\n  rtlShowUncaughtExceptions:=True;\r\nend;\r\n\r\nprocedure Abort;\r\nbegin\r\n  Raise EAbort.Create(SAbortError);\r\nend;\r\n\r\n{$IFNDEF MAKESTUB}\r\nType\r\n  TCharSet = Set of Char;\r\n\r\nFunction CharInSet(Ch: Char;Const CSet : TCharSet) : Boolean; overload;\r\n\r\nbegin\r\n  Result:=Ch in CSet;\r\nend;\r\n{$ENDIF}\r\n\r\nfunction CharInSet(Ch: Char; const CSet: array of char): Boolean; overload;\r\n\r\nVar\r\n  I : integer;\r\n\r\nbegin\r\n  Result:=False;\r\n  I:=Length(CSet)-1;\r\n  While (Not Result) and (I>=0) do\r\n    begin\r\n    Result:=(Ch=CSet[i]);\r\n    Dec(I);\r\n    end;\r\nend;\r\n\r\nfunction LeftStr(const S: string; Count: Integer): String; assembler;\r\nasm\r\n  return (Count>0) ? S.substr(0,Count) : \"\";\r\nend;\r\n\r\nfunction RightStr(const S: string; Count: Integer): String; assembler;\r\nasm\r\n  var l = S.length;\r\n  return (Count<1) ? \"\" : ( Count>=l ? S : S.substr(l-Count));\r\nend;\r\n\r\nfunction Trim(const S: String): String; assembler;\r\nasm\r\n  return S.replace(/^[\\s\\uFEFF\\xA0\\x00-\\x1f]+/,'').replace(/[\\s\\uFEFF\\xA0\\x00-\\x1f]+$/,'');\r\nend;\r\n\r\nfunction TrimLeft(const S: String): String; assembler;\r\nasm\r\n  return S.replace(/^[\\s\\uFEFF\\xA0\\x00-\\x1f]+/,'');\r\nend;\r\n\r\nfunction TrimRight(const S: String): String; assembler;\r\nasm\r\n  return S.replace(/[\\s\\uFEFF\\xA0\\x00-\\x1f]+$/,'');\r\nend;\r\n\r\nfunction IntToStr(const Value: Integer): string;\r\nbegin\r\n  Result:=str(Value);\r\nend;\r\n\r\nfunction FloatToDecimal(Value: double; Precision, Decimals: integer): TFloatRec;\r\n\r\n  {$ifdef DEBUGFLOATTODECIMAL}\r\n  Procedure dump;\r\n  \r\n  var\r\n    I : Integer;\r\n    S : String;\r\n  begin\r\n    for I:=0 to  FloatRecDigits do\r\n      begin\r\n      if I>0 then S:=S+',';\r\n      if Result.Digits[i]=#0 then\r\n        S:=S+'_'\r\n      else  \r\n        S:=S+Result.Digits[i];\r\n      end;\r\n    Writeln('Digits : (',S,') Exp: ',Result.Exponent,', Neg: ',Result.Negative);  \r\n  end;\r\n  {$endif}\r\n\r\nConst\r\n  Rounds = '123456789:';\r\n\r\nvar\r\n  Buffer: String;  //Though str func returns only 25 chars, this might change in the future\r\n  InfNan: string;\r\n  OutPos,Error, N, L, C: Integer;\r\n  GotNonZeroBeforeDot, BeforeDot : boolean;\r\n\r\n  \r\n\r\nbegin\r\n  {$ifdef DEBUGFLOATTODECIMAL}\r\n  Writeln('Precision ',Precision,' decimals: ',Decimals);\r\n  {$ENDIF}\r\n  Result.Negative:=False;\r\n  Result.Exponent:=0;\r\n  For C:=0 to FloatRecDigits do\r\n    Result.Digits[C]:='0';\r\n  if Value=0 then\r\n    exit;\r\n  Str(Value:24,Buffer); // Double precision\r\n  {$ifdef DEBUGFLOATTODECIMAL}\r\n  writeln('12345678901234567890123456789012345678901234567890');\r\n  Writeln('Buffer :',Buffer);\r\n  {$ENDIF}\r\n  N := 1;\r\n  L := Length(Buffer);\r\n  while Buffer[N]=' ' do\r\n    Inc(N);\r\n  Result.Negative := (Buffer[N] = '-');\r\n  if Result.Negative then\r\n    Inc(N)\r\n  else if (Buffer[N] = '+') then\r\n    inc(N);\r\n  { special cases for Inf and Nan }\r\n  if (L>=N+2) then\r\n    begin\r\n      InfNan:=copy(Buffer,N,3);\r\n      if (InfNan='Inf') then\r\n        begin\r\n          Result.Digits[0]:=#0;\r\n          Result.Exponent:=32767;\r\n          exit\r\n        end;\r\n      if (InfNan='Nan') then\r\n        begin\r\n          Result.Digits[0]:=#0;\r\n          Result.Exponent:=-32768;\r\n          exit\r\n        end;\r\n    end;\r\n  //Start := N;  //Start of digits\r\n  Outpos:=0;\r\n  Result.Exponent := 0; BeforeDot := true;\r\n  GotNonZeroBeforeDot := false;\r\n  while (L>=N) and (Buffer[N]<>'E') do\r\n    begin\r\n      {$ifdef DEBUGFLOATTODECIMAL}\r\n      Writeln('Examining : ',Buffer[N],' (output pos: ',outPos,')');\r\n      {$ENDIF}\r\n      if Buffer[N]='.' then\r\n        BeforeDot := false\r\n      else\r\n        begin\r\n        if BeforeDot then\r\n          begin  // Currently this is always 1 char\r\n            Inc(Result.Exponent);\r\n            Result.Digits[Outpos] := Buffer[N];\r\n            if Buffer[N] <> '0' then\r\n              GotNonZeroBeforeDot := true;\r\n          end\r\n        else\r\n          Result.Digits[Outpos] := Buffer[N];\r\n        {$ifdef DEBUGFLOATTODECIMAL}\r\n        Dump;\r\n        {$ENDIF}\r\n        Inc(outpos);\r\n        end;\r\n      Inc(N);\r\n    end;\r\n  {$ifdef DEBUGFLOATTODECIMAL}\r\n  Dump;  \r\n  {$ENDIF}\r\n  Inc(N); // Pass through 'E'\r\n  if N<=L then\r\n    begin\r\n      Val(Copy(Buffer, N, L-N+1), C, Error); // Get exponent after 'E'\r\n      Inc(Result.Exponent, C);\r\n    end;\r\n  // Calculate number of digits we have from str\r\n  N:=OutPos;\r\n  {$ifdef DEBUGFLOATTODECIMAL}\r\n  Writeln('Number of digits: ',N,' requested precision : ',Precision);\r\n  {$ENDIF}\r\n  L:=Length(Result.Digits);\r\n  While N<L do\r\n    begin\r\n    Result.Digits[N]:='0';  //Zero remaining space\r\n    Inc(N);\r\n    end;\r\n  if Decimals + Result.Exponent < Precision Then //After this it is the same as in FloatToDecimal\r\n    N := Decimals + Result.Exponent\r\n  Else\r\n    N := Precision;\r\n  if N >= L Then\r\n    N := L-1;\r\n  {$ifdef DEBUGFLOATTODECIMAL}\r\n  Writeln('Rounding on digit : ',N);\r\n  {$ENDIF}\r\n  if N = 0 Then\r\n    begin\r\n      if Result.Digits[0] >= '5' Then\r\n        begin\r\n          Result.Digits[0] := '1';\r\n          Result.Digits[1] := #0;\r\n          Inc(Result.Exponent);\r\n        end\r\n      Else\r\n        Result.Digits[0] := #0;\r\n    end  //N=0\r\n  Else if N > 0 Then\r\n    begin\r\n      if Result.Digits[N] >= '5' Then\r\n        begin\r\n          Repeat\r\n            Result.Digits[N] := #0;\r\n            Dec(N);\r\n           {$ifdef DEBUGFLOATTODECIMAL}\r\n            Writeln(N,': ',Result.Digits[N],', Rounding to : ',Rounds[StrToInt(Result.Digits[N])]);\r\n            {$ENDIF}\r\n            Result.Digits[N]:=Rounds[StrToInt(Result.Digits[N])+1];\r\n          Until (N = 0) Or (Result.Digits[N] < ':');\r\n          If Result.Digits[0] = ':' Then\r\n            begin\r\n              Result.Digits[0] := '1';\r\n              Inc(Result.Exponent);\r\n            end;\r\n        end\r\n      Else\r\n        begin\r\n          Result.Digits[N] := '0';\r\n          While (N > -1) And (Result.Digits[N] = '0') Do\r\n            begin\r\n              Result.Digits[N] := #0;\r\n              Dec(N);\r\n            end;\r\n        end;\r\n      end //N>0\r\n  Else\r\n    Result.Digits[0] := #0;\r\n  if (Result.Digits[0] = #0) and\r\n     not GotNonZeroBeforeDot then\r\n    begin\r\n      Result.Exponent := 0;\r\n      Result.Negative := False;\r\n    end;\r\n  {$ifdef DEBUGFLOATTODECIMAL}\r\n  Dump;\r\n  {$ENDIF}\r\nend;\r\n\r\nFunction FloatToStr(Value: Double; const aSettings : TFormatSettings): String; overload;\r\n\r\nbegin\r\n  Result:=FloatToStrF(Value,ffGeneral,15,0,aSettings);\r\nend;\r\n\r\nfunction FloatToStr(Value: Double): String;\r\nbegin\r\n  Result:=FloatToStr(Value,FormatSettings);\r\nend;\r\n\r\nfunction TryStrToFloat(const S: String; out res: Extended): Boolean;\r\nbegin\r\n  Result:=TryStrToFloat(S,double(res));\r\nend;\r\n\r\nfunction TryStrToFloat(const S: String; out res: Double): Boolean;\r\n\r\nbegin\r\n  Result:=TryStrToFloat(S,Res,FormatSettings);\r\nend;\r\n\r\nfunction TryStrToFloat(const S: String; out res: Extended; const aSettings : TFormatSettings): Boolean;\r\n\r\nbegin\r\n  Result:=TryStrToFloat(S,double(res),aSettings);\r\nend;\r\n\r\nfunction TryStrToFloat(const S: String; out res: Double; const aSettings : TFormatSettings): Boolean;\r\n\r\nType\r\n  TDecimalPart = (dpDigit,dpSignificand,dpExp);\r\n\r\nVar\r\n  J : JSValue;\r\n  I,aStart,Len : integer;\r\n  N : String;\r\n  p : TDecimalPart;\r\n\r\n\r\nbegin\r\n  Result:=False;\r\n  N:=S;\r\n  // Delocalize\r\n  if (aSettings.ThousandSeparator <>'') then\r\n    N:=StringReplace(N,aSettings.ThousandSeparator,'',[rfReplaceAll]);\r\n  if (aSettings.DecimalSeparator<>'.') then\r\n    N:=StringReplace(N,aSettings.DecimalSeparator,'.',[]);\r\n  p:=dpDigit;\r\n  I:=1;\r\n  aStart:=1;\r\n  Len:=Length(N);\r\n  While (I<=Len) do\r\n    begin\r\n    Case N[i] of\r\n      '+','-' :\r\n        Case p of\r\n          dpSignificand:\r\n            Exit;\r\n          dpDigit :\r\n            if I>aStart then\r\n              Exit;\r\n          dpExp :\r\n            if( I>aStart+1) then\r\n              Exit;\r\n        end;\r\n      '0'..'9' : ;\r\n      '.' :\r\n        begin\r\n        if (p<>dpDigit) then\r\n          Exit;\r\n        p:=dpSignificand;\r\n        aStart:=I;\r\n        end;\r\n      'E','e':\r\n        begin\r\n        if p=dpExp then\r\n          Exit\r\n        else\r\n          begin\r\n          p:=dpExp;\r\n          aStart:=I;\r\n          end;\r\n        end;\r\n    Else\r\n      Exit;\r\n    end;\r\n    inc(I);\r\n    end;\r\n  J:=parseFloat(N);\r\n  Result:=Not jsIsNaN(J);\r\n  if Result then\r\n    Res:=Double(J);\r\nend;\r\n\r\nfunction StrToFloatDef(const S: String; const aDef: Double; const aSettings : TFormatSettings): Double;\r\nbegin\r\n  if not TryStrToFloat(S,Result,aSettings) then\r\n    Result:=aDef;\r\nend;\r\n\r\nfunction StrToFloatDef(const S: String; const aDef: Double): Double;\r\nbegin\r\n  if not TryStrToFloat(S,Result,FormatSettings) then\r\n    Result:=aDef;\r\nend;\r\n\r\nfunction StrToFloat(const S: String): Double;\r\nbegin\r\n  Result:=StrToFloat(S,FormatSettings);\r\nend;\r\n\r\nfunction StrToFloat(const S: String; const aSettings : TFormatSettings): Double;\r\nbegin\r\n  if not TryStrToFloat(S,Result,aSettings) then\r\n    Raise EConvertError.CreateFmt(SErrInvalidFloat,[S]);\r\nend;\r\n\r\nFunction FormatFloat (Fmt : String; aValue : Double) : String;\r\nbegin\r\n  Result:=FormatFloat(Fmt,aValue,FormatSettings);\r\nend;\r\n\r\nfunction FormatFloat(Fmt: String; aValue: Double; aSettings : TFormatSettings): String;\r\n\r\nType\r\n  TPosArray = Array of Integer;\r\n\r\nconst\r\n  MaxPrecision = 18;  // Extended precision\r\n\r\nvar\r\n  // Input in usable format\r\n  E : Extended;              // Value as extended.\r\n  FV: TFloatRec;             // Value as floatrec.\r\n  Section : String;          // Format can contain 3 sections, semicolon separated: Pos;Neg;Zero. This is the one to use.\r\n  SectionLength : Integer;   // Length of section.\r\n  // Calculated based on section. Static during output\r\n  ThousandSep: Boolean;      // Thousands separator detected in format ?\r\n  IsScientific: Boolean;     // Use Scientific notation ? (E detected in format)\r\n  DecimalPos: Integer;       // Position of decimal point in pattern.\r\n  FirstDigit: Integer;       // First actual digit in input (# or 0), relative to decimal point\r\n  LastDigit: Integer;        // Last required (0) digit, relative to decimal point\r\n  RequestedDigits: Integer;  // Number of requested digits, # and 0 alike\r\n  ExpSize : Integer;         // Number of digits in exponent\r\n  Available: Integer;        // Available digits in FV.\r\n  // These change during output loop\r\n  Current: Integer;          // Current digit in available digits\r\n  PadZeroes: Integer;        // Difference in requested digits before comma and exponent, needs to be padded with zeroes.\r\n  DistToDecimal: Integer;    // Place of current digit, relative to decimal point taking in account PadZeroes!\r\n\r\n  Procedure InitVars;\r\n\r\n  begin\r\n    E:=aValue;\r\n    Section:='';\r\n    SectionLength:=0;\r\n    ThousandSep:=false;\r\n    IsScientific:=false;\r\n    DecimalPos:=0;\r\n    FirstDigit:=MaxInt;\r\n    LastDigit:=0;\r\n    RequestedDigits:=0;\r\n    ExpSize:=0;\r\n    Available:=-1;\r\n  end;\r\n\r\n  procedure ToResult(const AChar: Char);\r\n  begin\r\n    Result:=Result+AChar;\r\n  end;\r\n\r\n  procedure AddToResult(const AStr: String);\r\n\r\n  begin\r\n    Result:=Result+AStr;\r\n  end;\r\n\r\n  procedure WriteDigit(ADigit: Char);\r\n\r\n  // Write a digit to result, prepend with decimalseparator or append with 1000 separator\r\n\r\n  begin\r\n    if ADigit=#0 then exit;\r\n    // Writeln('WriteDigit: ',ADigit,', DistToDecimal: ',DistToDecimal);\r\n    Dec(DistToDecimal);\r\n    // -1 -> we've arrived behind the decimal\r\n    if (DistToDecimal=-1) then\r\n      begin\r\n      AddToResult(aSettings.DecimalSeparator);\r\n      ToResult(ADigit);\r\n      end\r\n    else\r\n      begin\r\n      // We're still before the decimal.\r\n      ToResult(ADigit);\r\n      if ThousandSep and ((DistToDecimal mod 3)=0) and (DistToDecimal>1) then\r\n        AddToResult(aSettings.ThousandSeparator);\r\n      end;\r\n  end;\r\n\r\n  Function GetDigit : Char;\r\n\r\n  // Return next digit from available digits.\r\n  // May return #0 if none available.\r\n  // Will return '0' if applicable.\r\n\r\n  begin\r\n    // Writeln(' DistToDecimal <= LastDigit : ',DistToDecimal,' <= ',LastDigit,' have digit: ',Current<=Available, ' (',Current,')');\r\n    Result:=#0;\r\n    if (Current<=Available) then\r\n      begin\r\n      Result:=FV.Digits[Current];\r\n      Inc(Current);\r\n      end\r\n    else if (DistToDecimal <= LastDigit) then\r\n      Dec(DistToDecimal)\r\n    else\r\n      Result:='0';\r\n    // Writeln('GetDigit ->: ',Result);\r\n  end;\r\n\r\n  procedure CopyDigit;\r\n\r\n  // Copy a digit (#, 0) to the output with the correct value\r\n\r\n  begin\r\n    // Writeln('CopyDigit: Padzeroes: ',PadZeroes,', DistToDecimal: ',DistToDecimal);\r\n    if (PadZeroes=0) then\r\n      WriteDigit(GetDigit) // No shift needed, just copy what is available.\r\n    else if (PadZeroes<0) then\r\n      begin\r\n      // We must prepend zeroes\r\n      Inc(PadZeroes);\r\n      if (DistToDecimal<=FirstDigit) then\r\n        WriteDigit('0')\r\n      else\r\n        Dec(DistToDecimal);\r\n      end\r\n    else\r\n      begin\r\n      // We must append zeroes\r\n      while PadZeroes > 0 do\r\n        begin\r\n        WriteDigit(GetDigit);\r\n        Dec(PadZeroes);\r\n        end;\r\n      WriteDigit(GetDigit);\r\n      end;\r\n  end;\r\n\r\n  Function GetSections(Var SP : TPosArray) : Integer;\r\n\r\n  var\r\n    FL : Integer;\r\n    i : Integer;\r\n    C,Q : Char;\r\n    inQuote : Boolean;\r\n\r\n  begin\r\n    Result:=1;\r\n    SP[1]:=-1;\r\n    SP[2]:=-1;\r\n    SP[3]:=-1;\r\n    inQuote:=False;\r\n    Q:=#0;\r\n    I:=1;\r\n    FL:=Length(Fmt);\r\n    while (I<=FL) do\r\n      begin\r\n      C:=Fmt[I];\r\n      case C of\r\n      ';':\r\n        begin\r\n        if not InQuote then\r\n          begin\r\n          if Result>3 then\r\n            Raise Exception.Create('Invalid float format');\r\n          SP[Result]:=I;\r\n          Inc(Result);\r\n          end;\r\n        end;\r\n      '\"','''':\r\n        begin\r\n        if InQuote then\r\n          InQuote:=C<>Q\r\n        else\r\n          begin\r\n          InQuote:=True;\r\n          Q:=C;\r\n          end;\r\n        end;\r\n      end;\r\n      Inc(I);\r\n      end;\r\n    if SP[Result]=-1 then\r\n      SP[Result]:=FL+1;\r\n  end;\r\n\r\n  Procedure AnalyzeFormat;\r\n\r\n  var\r\n    I,Len: Integer;\r\n    Q,C: Char;\r\n    InQuote : Boolean;\r\n\r\n  begin\r\n    Len:=Length(Section);\r\n    // writeln(len);\r\n    I:=1;\r\n    InQuote:=False;\r\n    Q:=#0;\r\n    while (I<=Len) do\r\n      begin\r\n      C:=Section[i];\r\n      if C in ['\"',''''] then\r\n        begin\r\n        if InQuote then\r\n          InQuote:=C<>Q\r\n        else\r\n          begin\r\n          InQuote:=True;\r\n          Q:=C;\r\n          end;\r\n        end\r\n      else if not InQuote then\r\n        case C of\r\n        '.':\r\n          if (DecimalPos=0) then\r\n            DecimalPos:=RequestedDigits+1;\r\n        ',':\r\n            ThousandSep:=aSettings.ThousandSeparator<>#0;\r\n        'e', 'E':\r\n            begin\r\n            Inc(I);\r\n            if (I<Len) then\r\n              begin\r\n              C:=Section[i];\r\n              IsScientific:=C in ['-','+'];\r\n              if IsScientific then\r\n                while (I<Len) and (Section[i+1]='0') do\r\n                  begin\r\n                  Inc(ExpSize);\r\n                  Inc(I);\r\n                  end;\r\n              if ExpSize>4 then\r\n                ExpSize:=4;\r\n              end;\r\n            end;\r\n        '#':\r\n            Inc(RequestedDigits);\r\n        '0':\r\n            begin\r\n            if RequestedDigits<FirstDigit then\r\n              FirstDigit:=RequestedDigits+1;\r\n            Inc(RequestedDigits);\r\n            LastDigit:=RequestedDigits+1;\r\n            end;\r\n        end;\r\n      Inc(I);\r\n      end;\r\n    if DecimalPos=0 then\r\n      DecimalPos:=RequestedDigits+1;\r\n    // Writeln('LastDigit: ',DecimalPos,'-',LastDigit);\r\n    LastDigit:=DecimalPos-LastDigit;\r\n    if LastDigit>0 then\r\n      LastDigit:=0;\r\n    // Writeln('FirstDigit: ',DecimalPos,'-',FirstDigit);\r\n    FirstDigit:=DecimalPos-FirstDigit;\r\n    if FirstDigit<0 then\r\n      FirstDigit:=0;\r\n  end;\r\n\r\n  Function ValueOutSideScope : Boolean;\r\n  begin\r\n    With FV do\r\n     Result:=((Exponent >= 18) and (not IsScientific)) or (Exponent = $7FF) or (Exponent = $800)\r\n  end;\r\n\r\n  Procedure CalcRunVars;\r\n\r\n  Var\r\n    D,P: Integer;\r\n\r\n  begin\r\n    if IsScientific then\r\n      begin\r\n      P:=RequestedDigits;\r\n      D:=9999;\r\n      end\r\n    else\r\n      begin\r\n      P:=MaxPrecision;\r\n      // Writeln(RequestedDigits,'-',DecimalPos,'+1');\r\n      D:=RequestedDigits-DecimalPos+1;\r\n      end;\r\n    FV:=FloatToDecimal(aValue,P,D);\r\n    // Writeln('Number of digits available : ',Length(FV.Digits));\r\n    //   For p:=0 to Length(FV.Digits)-1 do\r\n    // Writeln(P,': ',FV.Digits[p]);\r\n    DistToDecimal:=DecimalPos-1;\r\n    // Writeln('DistToDecimal : ',DistToDecimal);\r\n    if IsScientific then\r\n      PadZeroes:=0 // No padding.\r\n    else\r\n      begin\r\n      PadZeroes:=FV.Exponent-(DecimalPos-1);\r\n      if (PadZeroes>=0) then\r\n        DistToDecimal:=FV.Exponent\r\n      end;\r\n    // Writeln('PadZeroes : ',PadZeroes, ', DistToDecimal : ',DistToDecimal);\r\n    Available:=-1;\r\n    while (Available<High(FV.Digits)) and (FV.Digits[Available+1]<>#0) do\r\n      Inc(Available);\r\n    // Writeln('Available: ',Available);\r\n  end;\r\n\r\n  Function FormatExponent(ASign: Char; aExponent: Integer) : String;\r\n\r\n  begin\r\n    Result:=IntToStr(aExponent);\r\n    Result:=StringOfChar('0',ExpSize-Length(Result))+Result;\r\n    if (aExponent<0) then\r\n      Result:='-'+Result\r\n    else if (aExponent>0) and (aSign='+') then\r\n      Result:=aSign+Result;\r\n  end;\r\n\r\nvar\r\n  I,S : Integer;\r\n  C,Q : Char;\r\n  PA : TPosArray;\r\n  InLiteral : Boolean;\r\n\r\nbegin\r\n  SetLength(PA,4);\r\n  Result:='';\r\n  Initvars;\r\n  // What section to use ?\r\n  if (E>0) then\r\n    S:=1\r\n  else if (E<0) then\r\n    S:=2\r\n  else\r\n    S:=3;\r\n  PA[0]:=0;\r\n  I:=GetSections(PA);\r\n  if (I<S) or (PA[S]-PA[S-1]=0) then\r\n    S:=1;\r\n  // Extract correct section\r\n  SectionLength:=PA[S]-PA[S-1]-1;\r\n  Section:=Copy(Fmt,PA[S-1]+1,SectionLength);\r\n  SetLength(Section,SectionLength);\r\n  // Writeln('Section ',I,' : \"',Section,'\" ',SectionLength);\r\n  AnalyzeFormat;\r\n  // Writeln('RequestedDigits: ',RequestedDigits,', DecimalPos : ',DecimalPos,', LastDigit: ',LastDigit,', FirstDigit: ',FirstDigit);\r\n  CalcRunVars;\r\n  // If we cannot process value using current settings, fallback\r\n  if (SectionLength=0) or ValueOutSideScope then\r\n    begin\r\n    asm\r\n     Section=E.toPrecision(15);\r\n    end;\r\n    Result:=Section;\r\n    end;\r\n  // Get Started\r\n  I:=1;\r\n  Current:=0;\r\n  Q:=' ';\r\n  InLiteral:=False;\r\n  if (FV.Negative) and (S=1) then\r\n    ToResult('-');\r\n  while (I<=SectionLength) do\r\n    begin\r\n    C:=Section[i];\r\n    // Writeln('Analyzing pos ',I,': \"',C,'\"');\r\n    If (C in ['\"', '''']) then\r\n      begin\r\n      if InLiteral then\r\n        InLiteral:=C<>Q\r\n      else\r\n        begin\r\n        inLiteral:=True;\r\n        Q:=C;\r\n        end;\r\n      end\r\n    else if InLiteral then\r\n      ToResult(C)\r\n    else\r\n      case C of\r\n      '0', '#':\r\n        CopyDigit;\r\n      '.', ',':\r\n        ; // Do nothing, handled by CopyDigit\r\n      'e', 'E':\r\n        begin\r\n        ToResult(C); // Always needed\r\n        Inc(I);\r\n        if I<=Length(Section) then\r\n          begin\r\n          C:=Section[I];\r\n          if (C in ['+','-']) then\r\n            begin\r\n            AddToResult(FormatExponent(C,FV.Exponent-DecimalPos+1));\r\n            // Skip rest\r\n            while (I<SectionLength) and (Section[i+1]='0') do\r\n              Inc(I);\r\n            end;\r\n          end;\r\n        end;\r\n      else\r\n        ToResult(C);\r\n      end;\r\n    Inc(i);\r\n    end;\r\nend;\r\n\r\nfunction StrToBool(const S: String): Boolean;\r\nbegin\r\n  if not(TryStrToBool(S,Result)) then\r\n    raise EConvertError.CreateFmt(SInvalidBoolean,[S]);\r\nend;\r\n\r\nprocedure CheckBoolStrs;\r\nbegin\r\n  if Length(TrueBoolStrs)=0 then\r\n  begin\r\n    SetLength(TrueBoolStrs,1);\r\n    TrueBoolStrs[0]:='True';\r\n  end;\r\n  if Length(FalseBoolStrs)=0 then\r\n  begin\r\n    SetLength(FalseBoolStrs,1);\r\n    FalseBoolStrs[0]:='False';\r\n  end;\r\nend;\r\n\r\nfunction BoolToStr(B: Boolean; UseBoolStrs: Boolean): string;\r\nbegin\r\n  if UseBoolStrs Then\r\n  begin\r\n    CheckBoolStrs;\r\n    if B then\r\n      Result:=TrueBoolStrs[0]\r\n    else\r\n      Result:=FalseBoolStrs[0];\r\n  end else\r\n    if B then\r\n      Result:='-1'\r\n    else\r\n      Result:='0';\r\nend;\r\n\r\nfunction BoolToStr(B: Boolean; const TrueS, FalseS: String): string;\r\nbegin\r\n  if B then Result:=TrueS else Result:=FalseS;\r\nend;\r\n\r\nfunction StrToBoolDef(const S: String; Default: Boolean): Boolean;\r\nbegin\r\n  if not TryStrToBool(S,Result) then\r\n    Result:=Default;\r\nend;\r\n\r\nfunction TryStrToBool(const S: String; out Value: Boolean): Boolean;\r\nVar\r\n  Temp : String;\r\n  I    : Longint;\r\n  D : Double;\r\n  Code: integer;\r\nbegin\r\n  Temp:=uppercase(S);\r\n  Val(Temp,D,code);\r\n  Result:=true;\r\n  If Code=0 then\r\n    Value:=(D<>0.0)\r\n  else\r\n    begin\r\n      CheckBoolStrs;\r\n      for I:=low(TrueBoolStrs) to High(TrueBoolStrs) do\r\n        if Temp=uppercase(TrueBoolStrs[I]) then\r\n          begin\r\n            Value:=true;\r\n            exit;\r\n          end;\r\n      for I:=low(FalseBoolStrs) to High(FalseBoolStrs) do\r\n        if Temp=uppercase(FalseBoolStrs[I]) then\r\n          begin\r\n            Value:=false;\r\n            exit;\r\n          end;\r\n      Result:=false;\r\n    end;\r\nend;\r\n\r\nfunction UpperCase(const s: String): String; assembler;\r\nasm\r\n  return s.toUpperCase();\r\nend;\r\n\r\nfunction LowerCase(const s: String): String; assembler;\r\nasm\r\n  return s.toLowerCase();\r\nend;\r\n\r\nfunction CompareStr(const s1, s2: String): Integer; assembler;\r\nasm\r\n  var l1 = s1.length;\r\n  var l2 = s2.length;\r\n  if (l1<=l2){\r\n    var s = s2.substr(0,l1);\r\n    if (s1<s){ return -1;\r\n    } else if (s1>s){ return 1;\r\n    } else { return l1<l2 ? -1 : 0; };\r\n  } else {\r\n    var s = s1.substr(0,l2);\r\n    if (s<s2){ return -1;\r\n    } else { return 1; };\r\n  };\r\nend;\r\n\r\nfunction SameStr(const s1, s2: String): Boolean; assembler;\r\nasm\r\n  return s1 == s2;\r\nend;\r\n\r\nfunction CompareText(const s1, s2: String): Integer; assembler;\r\nasm\r\n  var l1 = s1.toLowerCase();\r\n  var l2 = s2.toLowerCase();\r\n  if (l1>l2){ return 1;\r\n  } else if (l1<l2){ return -1;\r\n  } else { return 0; }\r\nend;\r\n\r\nfunction SameText(const s1, s2: String): Boolean; assembler;\r\nasm\r\n  return s1.toLowerCase() == s2.toLowerCase();\r\nend;\r\n\r\nfunction AnsiCompareText(const s1, s2: String): Integer; assembler;\r\nasm\r\n  return s1.localeCompare(s2);\r\nend;\r\n\r\nfunction AnsiSameText(const s1, s2: String): Boolean; assembler;\r\nasm\r\n  return s1.toLowerCase() == s2.toLowerCase();\r\nend;\r\n\r\nfunction AnsiCompareStr(const s1, s2: String): Integer;\r\nbegin\r\n  {$IFDEF ECMAScript6}\r\n  Result:=CompareText(TJSString(s1).normalize(),TJSString(s2).normalize());\r\n  {$ELSE}\r\n  Result:=CompareText(s1,s2);\r\n  {$ENDIF}\r\nend;\r\n\r\nprocedure AppendStr(var Dest: String; const S: string);\r\n\r\nbegin\r\n  Dest:=Dest+S;\r\nend;\r\n\r\n\r\nConst\r\n  feInvalidFormat   = 1;\r\n  feMissingArgument = 2;\r\n  feInvalidArgIndex = 3;\r\n\r\nProcedure DoFormatError (ErrCode : Longint;const fmt: String);\r\nbegin\r\n  //!! must be changed to contain format string...\r\n  Case ErrCode of\r\n   feInvalidFormat : raise EConvertError.Createfmt(SInvalidFormat,[Fmt]);\r\n   feMissingArgument : raise EConvertError.Createfmt(SArgumentMissing,[Fmt]);\r\n   feInvalidArgIndex : raise EConvertError.Createfmt(SInvalidArgIndex,[Fmt]);\r\n  end;\r\nend;\r\n\r\nConst\r\n  maxdigits = 15;\r\nFunction SwapEndian(W : Word) : Word;\r\n\r\nbegin\r\n  Result:=((W and $FF) shl 8) or ((W shr 8) and $FF)\r\nend;\r\n\r\nFunction SwapEndian(C : Cardinal) : Cardinal;\r\n\r\nbegin\r\n  Result:=((C and $FF) shl 24)\r\n           or ((C and $FF00) shl 8)\r\n           or ((C shr 8) and $FF00)\r\n           or ((C shr 24) and $FF);\r\nend;\r\n\r\nFunction ReplaceDecimalSep(S: String; Const DS : string) : string;\r\n\r\nVar\r\n  P : Integer;\r\n\r\nbegin\r\n  P:=Pos('.',S);\r\n  if P>0 then\r\n    Result:=Copy(S,1,P-1)+DS+Copy(S,P+1,Length(S)-P)\r\n  else\r\n    Result:=S;\r\nend;\r\n\r\nfunction FormatGeneralFloat(Value : double; Precision : Integer; DS : String) : string;\r\n\r\nVar\r\n  P, PE, Q, Exponent: Integer;\r\n\r\nBegin\r\n  If (Precision = -1) Or (Precision > maxdigits) Then\r\n     Precision := maxdigits;\r\n  { First convert to scientific format, with correct precision }\r\n  Str(Value:precision+7, Result);\r\n  { Delete leading spaces }\r\n  Result:=TrimLeft(Result);\r\n  P:=Pos('.',Result);\r\n  if P=0 then\r\n    exit;\r\n   { Consider removing exponent }\r\n  PE:=Pos('E',Result);\r\n  if PE=0 then\r\n    begin\r\n    Result:=ReplaceDecimalSep(Result,DS);\r\n    exit;\r\n    end;\r\n  { Read exponent }\r\n  Q:=PE+2;\r\n  Exponent := 0;\r\n  while (Q <= Length(Result)) do\r\n    begin\r\n    Exponent := Exponent*10 + Ord(Result[Q])-Ord('0');\r\n    Inc(Q);\r\n    end;\r\n  if Result[PE+1] = '-' then\r\n    Exponent := -Exponent;\r\n  if (P+Exponent < PE) and (Exponent > -6) then\r\n    begin\r\n    { OK to remove exponent }\r\n    SetLength(Result,PE-1); { Trim exponent }\r\n    if Exponent >= 0 then\r\n      begin\r\n        { Shift point to right }\r\n      for Q := 0 to Exponent-1 do\r\n        begin\r\n        Result[P] := Result[P+1];\r\n        Inc(P);\r\n        end;\r\n      Result[P] := '.';\r\n      P := 1;\r\n      if Result[P] = '-' then\r\n        Inc(P);\r\n      while (Result[P] = '0') and (P < Length(Result)) and (Copy(Result,P+1,Length(DS))<>DS) do\r\n          { Trim leading zeros; conversion above should not give any, but occasionally does\r\n            because of rounding }\r\n          System.Delete(Result,P,1);\r\n      end\r\n    else\r\n      begin\r\n      { Add zeros at start }\r\n      Insert(Copy('00000',1,-Exponent),Result,P-1);\r\n      Result[P-Exponent] := Result[P-Exponent-1]; { Copy leading digit }\r\n      Result[P] := '.';\r\n      if Exponent <> -1 then\r\n        Result[P-Exponent-1] := '0';\r\n      end;\r\n    { Remove trailing zeros }\r\n    Q := Length(Result);\r\n    while (Q > 0) and (Result[Q] = '0') do\r\n      Dec(Q);\r\n    if Result[Q] = '.' then\r\n      Dec(Q); { Remove trailing decimal point }\r\n    if (Q = 0) or ((Q=1) and (Result[1] = '-')) then\r\n      Result := '0'\r\n    else\r\n      SetLength(Result,Q);\r\n    end\r\n  else\r\n    begin\r\n    { Need exponent, but remove superfluous characters }\r\n    { Delete trailing zeros }\r\n    while Result[PE-1] = '0' do\r\n      begin\r\n      System.Delete(Result,PE-1,1);\r\n      Dec(PE);\r\n      end;\r\n    { If number ends in decimal point, remove it }\r\n    if Result[PE-1] = DS then\r\n      begin\r\n      System.Delete(Result,PE-1,1);\r\n      Dec(PE);\r\n      end;\r\n    { delete superfluous + in exponent }\r\n    if Result[PE+1]='+' then\r\n      System.Delete(Result,PE+1,1)\r\n    else\r\n      Inc(PE);\r\n    while Result[PE+1] = '0' do\r\n      { Delete leading zeros in exponent }\r\n      System.Delete(Result,PE+1,1)\r\n    end;\r\n  Result:=ReplaceDecimalSep(Result,DS)\r\nend;\r\n\r\n\r\nfunction FormatExponentFloat(Value : double; Precision,Digits : Integer;DS : String) : string;\r\n\r\nVar\r\n  P: Integer;\r\nBegin\r\n  DS:=FormatSettings.DecimalSeparator;\r\n  If (Precision = -1) Or (Precision > maxdigits) Then\r\n    Precision := maxdigits;\r\n  Str(Value:Precision+7, Result);\r\n  { Delete leading spaces }\r\n  while Result[1] = ' ' do\r\n    System.Delete(Result, 1, 1);\r\n  P:=Pos('E',Result);\r\n  if P=0 then\r\n    begin\r\n    Result:=ReplaceDecimalSep(Result,DS);\r\n    exit;\r\n    end;\r\n  Inc(P, 2);\r\n  if Digits > 4 then\r\n    Digits:=4;\r\n  Digits:=Length(Result) - P - Digits + 1;\r\n  if Digits < 0 then\r\n    insert(copy('0000',1,-Digits),Result,P)\r\n  else\r\n    while (Digits > 0) and (Result[P] = '0') do\r\n      begin\r\n      System.Delete(Result, P, 1);\r\n      if P > Length(Result) then\r\n        begin\r\n        System.Delete(Result, P - 2, 2);\r\n        break;\r\n        end;\r\n      Dec(Digits);\r\n      end;\r\n  Result:=ReplaceDecimalSep(Result,DS);\r\nEnd;\r\n\r\nfunction FormatFixedFloat(Value : double; Digits : Integer; DS : String) : string;\r\n\r\nBegin\r\n  If Digits = -1 Then\r\n    Digits := 2\r\n  Else If Digits > 18 Then\r\n    Digits := 18;\r\n  Str(Value:0:Digits, Result);\r\n  if (Result<>'') and (Result[1]=' ') then\r\n    Delete(Result,1,1);\r\n  Result:=ReplaceDecimalSep(Result,DS);\r\nend;\r\n\r\n\r\nfunction FormatNumberFloat(Value : double; Digits : Integer; DS,TS : String) : string;\r\n\r\nVar\r\n  P : integer;\r\n\r\nBegin\r\n  If Digits = -1 Then\r\n    Digits := 2\r\n  else If Digits > maxdigits Then\r\n    Digits := maxdigits;\r\n  Str(Value:0:Digits, Result);\r\n  if (Result<>'') and (Result[1]=' ') then\r\n    Delete(Result,1,1);\r\n  P:=Pos('.',Result);\r\n  if (P<=0) then\r\n    P:=Length(Result)+1;\r\n  Result:=ReplaceDecimalSep(Result,DS);\r\n  Dec(P,3);\r\n  if (TS<>'') and (TS<>#0) then\r\n    While (P>1) Do\r\n      Begin\r\n      If (Result[P-1] <> '-')  Then\r\n        Insert(TS, Result, P);\r\n      Dec(P, 3);\r\n      End;\r\nEnd;\r\n\r\nfunction RemoveLeadingNegativeSign(var AValue: String; DS : String; aThousandSeparator : String): Boolean;\r\n\r\n// removes negative sign in case when result is zero eg. -0.00\r\n\r\nvar\r\n  i: PtrInt;\r\n  TS: String;\r\n  StartPos: PtrInt;\r\n\r\nbegin\r\n  Result:=False;\r\n  StartPos := 2;\r\n  TS := aThousandSeparator;\r\n  for i :=StartPos to length(AValue) do\r\n    begin\r\n    Result := (AValue[i] in ['0', DS, 'E', '+']) or (aValue[i]=TS);\r\n    if not Result then\r\n      break;\r\n    end;\r\n  if (Result) and (AValue[1]='-') then\r\n    Delete(AValue, 1, 1);\r\nend;\r\n\r\nFunction FormatNumberCurrency(const Value : Currency; Digits : Integer; const aSettings: TFormatSettings) : string;\r\n\r\nVar\r\n  Negative: Boolean;\r\n  P : Integer;\r\n  CS,DS,TS : String;\r\n\r\nBegin\r\n   DS:=aSettings.DecimalSeparator;\r\n   TS:=aSettings.ThousandSeparator;\r\n   CS:=aSettings.CurrencyString;\r\n  //  Writeln('Value ',D);\r\n   If Digits = -1 Then\r\n     Digits := aSettings.CurrencyDecimals\r\n   Else If Digits > 18 Then\r\n     Digits := 18;\r\n   Str(Value:0:Digits, Result);\r\n   // Writeln('1. Result ',Result,' currencystring : ',CS);\r\n   Negative:=Result[1] = '-';\r\n   if Negative then\r\n     System.Delete(Result, 1, 1);\r\n   P := Pos('.', Result);\r\n   // Writeln('2. Result ',Result,' currencystring : ',CurrencyString);\r\n   If TS<>'' Then\r\n     begin\r\n     If P <> 0 Then\r\n       Result:=ReplaceDecimalSep(Result,DS)\r\n     else\r\n       P := Length(Result)+1;\r\n     Dec(P, 3);\r\n     While (P > 1) Do\r\n     Begin\r\n         Insert(TS, Result, P);\r\n     Dec(P, 3);\r\n     End;\r\n     end;\r\n   // Writeln('3. Result ',Result,' currencystring : ',CS);\r\n   if Negative then\r\n     RemoveLeadingNegativeSign(Result,DS,TS);\r\n   // Writeln('4. Result ',Result,' currencystring : ',CurrencyString);\r\n   // Writeln('CurrencyFormat:  ',CurrencyFormat,'NegcurrencyFormat: ',NegCurrFormat);\r\n   If Not Negative Then\r\n     Case aSettings.CurrencyFormat Of\r\n       0: Result := CS + Result;\r\n       1: Result := Result + CS;\r\n       2: Result := CS + ' ' + Result;\r\n       3: Result := Result + ' ' + CS;\r\n     end\r\n   else\r\n     Case aSettings.NegCurrFormat Of\r\n       0: Result := '(' + CS + Result + ')';\r\n       1: Result := '-' + CS + Result;\r\n       2: Result := CS + '-' + Result;\r\n       3: Result := CS + Result + '-';\r\n       4: Result := '(' + Result + CS + ')';\r\n       5: Result := '-' + Result + CS;\r\n       6: Result := Result + '-' + CS;\r\n       7: Result := Result + CS + '-';\r\n       8: Result := '-' + Result + ' ' + CS;\r\n       9: Result := '-' + CS + ' ' + Result;\r\n       10: Result := Result + ' ' + CS + '-';\r\n       11: Result := CS + ' ' + Result + '-';\r\n       12: Result := CS + ' ' + '-' + Result;\r\n       13: Result := Result + '-' + ' ' + CS;\r\n       14: Result := '(' + CS + ' ' + Result + ')';\r\n       15: Result := '(' + Result + ' ' + CS + ')';\r\n     end;\r\nend;\r\n\r\n\r\nfunction FloatToStrF(const Value: double; format: TFloatFormat; Precision,\r\n  Digits: Integer): String;\r\nbegin\r\n  Result:=FloatToStrF(Value,Format,Precision,Digits,Formatsettings);\r\nend;\r\n\r\nfunction FloatToStrF(const Value: double; format: TFloatFormat; Precision,\r\n  Digits: Integer ;const aSettings : TFormatSettings): String;\r\n\r\nVar\r\n  TS,DS: string;\r\n\r\nBegin\r\n  DS:=aSettings.DecimalSeparator;\r\n  TS:=aSettings.ThousandSeparator;\r\n  Case format Of\r\n    ffGeneral:\r\n      Result:=FormatGeneralFloat(Value,Precision,DS);\r\n    ffExponent:\r\n      Result:=FormatExponentFloat(Value,Precision,Digits,DS);\r\n    ffFixed:\r\n      Result:=FormatFixedFloat(Value,Digits,DS);\r\n    ffNumber:\r\n      Result:=FormatNumberFloat(Value,Digits,DS,TS);\r\n    ffCurrency:\r\n     Result:=FormatNumberCurrency(Value,Digits,aSettings);\r\n  end;\r\n  if (Format<>ffCurrency) and (length(Result)>1) and (Result[1]='-') then\r\n    RemoveLeadingNegativeSign(Result,DS,TS);\r\nend;\r\n\r\nfunction Format(const Fmt: String; const Args: array of const): String;\r\n\r\nbegin\r\n  Result:=Format(Fmt,Args,FormatSettings)\r\nend;\r\n\r\nfunction Format(const Fmt: String; const Args: array of Const; const aSettings : TFormatSettings): String;\r\n\r\nVar ChPos,OldPos,ArgPos,DoArg,Len : SizeInt;\r\n    Hs,ToAdd : String;\r\n    Index : Byte;\r\n    Width,Prec : Longint;\r\n    Left : Boolean;\r\n    Fchar : char;\r\n    vq : nativeint;\r\n\r\n  {\r\n    ReadFormat reads the format string. It returns the type character in\r\n    uppercase, and sets index, Width, Prec to their correct values,\r\n    or -1 if not set. It sets Left to true if left alignment was requested.\r\n    In case of an error, DoFormatError is called.\r\n  }\r\n\r\n  Function ReadFormat : Char;\r\n\r\n  Var Value : NativeInt;\r\n\r\n    Procedure ReadInteger;\r\n\r\n    var\r\n      Code: integer;\r\n      ArgN: SizeInt;\r\n    begin\r\n      If Value<>-1 then exit; // Was already read.\r\n      OldPos:=ChPos;\r\n      While (ChPos<=Len) and\r\n            (Fmt[ChPos]<='9') and (Fmt[ChPos]>='0') do inc(ChPos);\r\n      If ChPos>len then\r\n        DoFormatError(feInvalidFormat,Fmt);\r\n      If Fmt[ChPos]='*' then\r\n        begin\r\n\r\n        if Index=High(byte) then\r\n          ArgN:=Argpos\r\n        else\r\n        begin\r\n          ArgN:=Index;\r\n          Inc(Index);\r\n        end;\r\n\r\n        If (ChPos>OldPos) or (ArgN>High(Args)) then\r\n          DoFormatError(feInvalidFormat,Fmt);\r\n\r\n        ArgPos:=ArgN+1;\r\n\r\n        case Args[ArgN].Vtype of\r\n           vtInteger: Value := Args[ArgN].VInteger;\r\n           vtNativeInt: Value := Args[ArgN].VNativeInt;\r\n        else\r\n          DoFormatError(feInvalidFormat,Fmt);\r\n        end;\r\n        Inc(ChPos);\r\n        end\r\n      else\r\n        begin\r\n        If (OldPos<ChPos) Then\r\n          begin\r\n          Val (Copy(Fmt,OldPos,ChPos-OldPos),value,code);\r\n          // This should never happen !!\r\n          If Code>0 then DoFormatError (feInvalidFormat,Fmt);\r\n          end\r\n        else\r\n          Value:=-1;\r\n        end;\r\n    end;\r\n\r\n    Procedure ReadIndex;\r\n\r\n    begin\r\n      If Fmt[ChPos]<>':' then\r\n        ReadInteger\r\n      else\r\n        value:=0; // Delphi undocumented behaviour, assume 0, #11099\r\n      If Fmt[ChPos]=':' then\r\n        begin\r\n        If Value=-1 then DoFormatError(feMissingArgument,Fmt);\r\n        Index:=Value;\r\n        Value:=-1;\r\n        Inc(ChPos);\r\n        end;\r\n    end;\r\n\r\n    Procedure ReadLeft;\r\n\r\n    begin\r\n      If Fmt[ChPos]='-' then\r\n        begin\r\n        left:=True;\r\n        Inc(ChPos);\r\n        end\r\n      else\r\n        Left:=False;\r\n    end;\r\n\r\n    Procedure ReadWidth;\r\n\r\n    begin\r\n      ReadInteger;\r\n      If Value<>-1 then\r\n        begin\r\n        Width:=Value;\r\n        Value:=-1;\r\n        end;\r\n    end;\r\n\r\n    Procedure ReadPrec;\r\n\r\n    begin\r\n      If Fmt[ChPos]='.' then\r\n        begin\r\n        inc(ChPos);\r\n          ReadInteger;\r\n        If Value=-1 then\r\n         Value:=0;\r\n        prec:=Value;\r\n        end;\r\n    end;\r\n\r\n\r\n  begin\r\n    Index:=High(byte);\r\n    Width:=-1;\r\n    Prec:=-1;\r\n    Value:=-1;\r\n    inc(ChPos);\r\n    If Fmt[ChPos]='%' then\r\n      begin\r\n      Result:='%';\r\n      exit;                           // VP fix\r\n      end;\r\n    ReadIndex;\r\n    ReadLeft;\r\n    ReadWidth;\r\n    ReadPrec;\r\n    Result:=Upcase(Fmt[ChPos]);\r\n  end;\r\n\r\n\r\n  function Checkarg (AT : Integer; err:boolean):boolean;\r\n  {\r\n    Check if argument INDEX is of correct type (AT)\r\n    If Index=-1, ArgPos is used, and argpos is augmented with 1\r\n    DoArg is set to the argument that must be used.\r\n  }\r\n  begin\r\n    result:=false;\r\n    if Index=High(Byte) then\r\n      DoArg:=Argpos\r\n    else\r\n      DoArg:=Index;\r\n    ArgPos:=DoArg+1;\r\n    If (Doarg>High(Args)) or (Args[Doarg].VType<>AT) then\r\n     begin\r\n       if err then\r\n        DoFormatError(feInvalidArgindex,Fmt);\r\n       dec(ArgPos);\r\n       exit;\r\n     end;\r\n    result:=true;\r\n  end;\r\n\r\nbegin\r\n  Result:='';\r\n  Len:=Length(Fmt);\r\n  ChPos:=1;\r\n  OldPos:=1;\r\n  ArgPos:=0;\r\n  While ChPos<=len do\r\n    begin\r\n    While (ChPos<=Len) and (Fmt[ChPos]<>'%') do\r\n      inc(ChPos);\r\n    If ChPos>OldPos Then\r\n      Result:=Result+Copy(Fmt,OldPos,ChPos-Oldpos);\r\n    If ChPos<Len then\r\n      begin\r\n      FChar:=ReadFormat;\r\n{$ifdef fmtdebug}\r\n      DumpFormat(FCHar);\r\n{$endif}\r\n      Case FChar of\r\n        'D' : begin\r\n              if Checkarg(vtinteger,false) then\r\n                toAdd:=IntToStr(Args[DoArg].VInteger)\r\n              else if CheckArg(vtNativeInt,True) then\r\n                toAdd:=IntToStr(Args[DoArg].VNativeInt);\r\n              Width:=Abs(width);\r\n              Index:=Prec-Length(ToAdd);\r\n              If ToAdd[1]<>'-' then\r\n                ToAdd:=StringOfChar('0',Index)+ToAdd\r\n              else\r\n                // + 1 to accomodate for - sign in length !!\r\n                Insert(StringOfChar('0',Index+1),toadd,2);\r\n              end;\r\n        'U' : begin\r\n              if Checkarg(vtinteger,false) then\r\n                toAdd:=IntToStr(Cardinal(Args[DoArg].VInteger))\r\n              else if CheckArg(vtNativeInt,True) then\r\n                toAdd:=IntToStr(NativeUInt(Args[DoArg].VNativeInt));\r\n              Width:=Abs(width);\r\n              Index:=Prec-Length(ToAdd);\r\n              ToAdd:=StringOfChar('0',Index)+ToAdd\r\n              end;\r\n        'E' : begin\r\n              if CheckArg(vtCurrency,false) then\r\n                ToAdd:=FloatToStrF(Args[doarg].VCurrency,ffExponent,3,Prec,aSettings)\r\n              else if CheckArg(vtExtended,True) then\r\n                ToAdd:=FloatToStrF(Args[doarg].VExtended,ffExponent,3,Prec,aSettings);\r\n              end;\r\n        'F' : begin\r\n              if CheckArg(vtCurrency,false) then\r\n                ToAdd:=FloatToStrF(Args[doarg].VCurrency,ffFixed,9999,Prec,aSettings)\r\n              else if CheckArg(vtExtended,True) then\r\n                ToAdd:=FloatToStrF(Args[doarg].VExtended,ffFixed,9999,Prec,aSettings);\r\n              end;\r\n        'G' : begin\r\n              if CheckArg(vtCurrency,false) then\r\n                ToAdd:=FloatToStrF(Args[doarg].VCurrency,ffGeneral,Prec,3,aSettings)\r\n              else if CheckArg(vtExtended,True) then\r\n                ToAdd:=FloatToStrF(Args[doarg].VExtended,ffGeneral,Prec,3,aSettings);\r\n              end;\r\n        'N' : begin\r\n              if CheckArg(vtCurrency,false) then\r\n                ToAdd:=FloatToStrF(Args[doarg].VCurrency,ffNumber,9999,Prec,aSettings)\r\n              else if CheckArg(vtExtended,True) then\r\n                ToAdd:=FloatToStrF(Args[doarg].VExtended,ffNumber,9999,Prec,aSettings);\r\n              end;\r\n        'M' : begin\r\n              if CheckArg(vtCurrency,false) then\r\n                ToAdd:=FloatToStrF(Args[doarg].VCurrency,ffCurrency,9999,Prec,aSettings)\r\n              else if CheckArg(vtExtended,True) then\r\n                ToAdd:=FloatToStrF(Args[doarg].VExtended,ffCurrency,9999,Prec,aSettings);\r\n              end;\r\n        'S' : begin\r\n              if CheckArg(vtUnicodeString,false) then\r\n                hs:=Args[doarg].VUnicodeString\r\n              else if CheckArg(vtWideChar,True) then\r\n                hs:=Args[doarg].VWideChar;\r\n              Index:=Length(hs);\r\n              If (Prec<>-1) and (Index>Prec) then\r\n                Index:=Prec;\r\n              ToAdd:=Copy(hs,1,Index);\r\n              end;\r\n        'P' : Begin\r\n              if CheckArg(vtInteger,false) then\r\n                ToAdd:=IntToHex(Args[DoArg].VInteger,8)\r\n              else if CheckArg(vtInteger,true) then\r\n                ToAdd:=IntToHex(Args[DoArg].VNativeInt,16);\r\n              end;\r\n        'X' : begin\r\n              if Checkarg(vtinteger,false) then\r\n                begin\r\n                vq:=Args[Doarg].VInteger;\r\n                Index:=16;\r\n                end\r\n              else if Checkarg(vtNativeint,True) then\r\n                begin\r\n                vq:=Args[Doarg].VNativeInt;\r\n                index:=31; // May need to adjust to NativeInt\r\n                end;\r\n              If Prec>index then\r\n                ToAdd:=IntToHex(vq,index)\r\n              else\r\n                begin\r\n                // determine minimum needed number of hex digits.\r\n                Index:=1;\r\n                While (NativeInt(1) shl (Index*4)<=vq) and (index<16) do\r\n                  inc(Index);\r\n                If Index>Prec then\r\n                  Prec:=Index;\r\n                ToAdd:=IntToHex(vq,Prec);\r\n                end;\r\n              end;\r\n        '%': ToAdd:='%';\r\n      end;\r\n      If Width<>-1 then\r\n        If Length(ToAdd)<Width then\r\n          If not Left then\r\n            ToAdd:=StringOfChar(' ',Width-Length(ToAdd))+ToAdd\r\n          else\r\n            ToAdd:=ToAdd+StringOfChar(' ',Width-Length(ToAdd));\r\n      Result:=Result+ToAdd;\r\n      end;\r\n    inc(ChPos);\r\n    Oldpos:=ChPos;\r\n    end;\r\nend;\r\n\r\nfunction BytesOf(const AVal: string): TBytes;\r\nvar\r\n  I: SizeUInt;\r\nbegin\r\n  SetLength(Result, Length(AVal));\r\n  for I := 0 to Length(AVal)-1 do\r\n    Result[I] := Ord(AVal[I+1]);\r\nend;\r\n\r\nfunction StringOf(const ABytes: TBytes): string;\r\nvar\r\n  I: Integer;\r\nbegin\r\n  Result:='';\r\n  for I := 0 to Length(ABytes)-1 do\r\n    Result:=Result+Char(ABytes[I]);\r\nend;\r\n\r\nfunction LocaleCompare(const s1, s2, locales: String): Boolean; assembler;\r\nasm\r\n  return s1.localeCompare(s2,locales) == 0;\r\nend;\r\n\r\nfunction NormalizeStr(const S: String; const Norm: String): String; assembler;\r\nasm\r\n  return S.normalize(Norm);\r\nend;\r\n\r\nfunction IsValidIdent(const Ident: string; AllowDots: Boolean = False; StrictDots: Boolean = False): Boolean;\r\nconst\r\n  Alpha = ['A'..'Z', 'a'..'z', '_'];\r\n  AlphaNum = Alpha + ['0'..'9'];\r\n  Dot = '.';\r\nvar\r\n  First: Boolean;\r\n  I, Len: Integer;\r\nbegin\r\n  Len := Length(Ident);\r\n  if Len < 1 then\r\n    Exit(False);\r\n  First := True;\r\n  Result:=false;\r\n  I:=1;\r\n  While I<=len do\r\n    begin\r\n    if First then\r\n    begin\r\n      if not (Ident[I] in Alpha) then exit;\r\n      First := False;\r\n    end\r\n    else if AllowDots and (Ident[I] = Dot) then\r\n    begin\r\n      if StrictDots then\r\n      begin\r\n        if I >= Len then exit;\r\n        First := True;\r\n      end;\r\n    end\r\n    else\r\n      if not (Ident[I] in AlphaNum) then exit;\r\n    I:=I+1;\r\n    end;\r\n  Result:=true;\r\nend;\r\n\r\nprocedure FreeAndNil(var Obj);\r\nvar\r\n  o: TObject;\r\nbegin\r\n  o:=TObject(Obj);\r\n  if o=nil then exit;\r\n  TObject(Obj):=nil;\r\n  o.Destroy;\r\nend;\r\n\r\n{ EVariantError }\r\n\r\nconstructor EVariantError.CreateCode(Code: Longint);\r\nbegin\r\n  ErrCode:=Code;\r\nend;\r\n\r\n{ Exception }\r\n\r\nconstructor Exception.Create(const Msg: String);\r\nbegin\r\n  fMessage:=Msg;\r\n  {$ifdef nodejs}\r\n  FNodeJSError:=TJSError.new;\r\n  {$endif}\r\n  if LogMessageOnCreate then\r\n    Writeln('Created exception ',ClassName,' with message: ',Msg);\r\nend;\r\n\r\nconstructor Exception.CreateFmt(const Msg: string; const Args: array of Const\r\n  );\r\nbegin\r\n  //writeln('Exception.CreateFmt START ',ClassName,' \"',Msg,'\" Args=',Args);\r\n  Create(Format(Msg,Args));\r\n  //writeln('Exception.CreateFmt END ',ClassName,' \"',Msg,'\" fMessage=',fMessage);\r\nend;\r\n\r\nconstructor Exception.CreateHelp(const Msg: String; AHelpContext: Integer);\r\nbegin\r\n  Create(Msg);\r\n  fHelpContext:=AHelpContext;\r\nend;\r\n\r\nconstructor Exception.CreateFmtHelp(const Msg: string;\r\n  const Args: array of Const; AHelpContext: Integer);\r\nbegin\r\n  Create(Format(Msg,Args));\r\n  fHelpContext:=AHelpContext;\r\nend;\r\n\r\nfunction Exception.ToString: String;\r\nbegin\r\n  Result:=ClassName+': '+Message;\r\nend;\r\n\r\nConst\r\n  RESpecials = '([\\$\\+\\[\\]\\(\\)\\\\\\.\\*\\^\\?\\|])';\r\n\r\nfunction StringReplace(aOriginal, aSearch, aReplace: string;\r\n  Flags: TStringReplaceFlags): String;\r\n\r\nVar\r\n  REFlags : String;\r\n  REString : String;\r\n\r\nbegin\r\n  REFlags:='';\r\n  if rfReplaceAll in flags then\r\n    ReFlags:='g';\r\n  if rfIgnoreCase in flags then\r\n    ReFlags:=ReFlags+'i';\r\n  REString:=TJSString(aSearch).replace(TJSRegexp.new(RESpecials,'g'),'\\$1');\r\n  Result:=TJSString(aOriginal).replace(TJSRegexp.new(REString,REFlags),aReplace);\r\nend;\r\n\r\nfunction QuoteString(aOriginal: String; AQuote: Char): String;\r\n\r\nbegin\r\n  Result:=AQuote+StringReplace(aOriginal,aQuote,aQuote+aQuote,[rfReplaceAll])+AQuote;\r\nend;\r\n\r\nfunction QuotedStr(const s: string; QuoteChar : Char = ''''): string;\r\n\r\nbegin\r\n  Result:=QuoteString(S,QuoteChar);\r\nend;\r\n\r\nfunction DeQuoteString(aQuoted: String; AQuote: Char): String;\r\nvar\r\n  i: Integer;\r\nbegin\r\n  Result:=aQuoted;\r\n  if TJSString(Result).substr(0,1)<>AQuote then exit;\r\n  Result:=TJSString(Result).slice(1);\r\n  i:=1;\r\n  while i<=length(Result) do\r\n    begin\r\n    if Result[i]=AQuote then\r\n      begin\r\n      if (i=length(Result)) or (Result[i+1]<>AQuote) then\r\n        begin\r\n        Result:=TJSString(Result).slice(0,i-1);\r\n        exit;\r\n        end\r\n      else\r\n        Result:=TJSString(Result).slice(0,i-1)+TJSString(Result).slice(i);\r\n      end\r\n    else\r\n      inc(i);\r\n    end;\r\nend;\r\n\r\nfunction IsDelimiter(const Delimiters, S: string; Index: Integer): Boolean;\r\nbegin\r\n  Result:=False;\r\n  if (Index>0) and (Index<=Length(S)) then\r\n    Result:=Pos(S[Index],Delimiters)<>0; // Note we don't do MBCS yet\r\nend;\r\n\r\nFunction LastDelimiter(const Delimiters, S: string): SizeInt;\r\n\r\nbegin\r\n  Result:=Length(S);\r\n  While (Result>0) and (Pos(S[Result],Delimiters)=0) do\r\n    Dec(Result);\r\nend;\r\n\r\n\r\nfunction AdjustLineBreaks(const S: string): string;\r\n\r\nbegin\r\n  Result:=AdjustLineBreaks(S,DefaultTextLineBreakStyle);\r\nend;\r\n\r\nfunction AdjustLineBreaks(const S: string; Style: TTextLineBreakStyle): string;\r\n\r\nvar\r\n  I,L: Longint;\r\n  Res : String;\r\n\r\n  Procedure Add(C  : Char);\r\n  begin\r\n    Res:=Res+C;\r\n  end;\r\n\r\nbegin\r\n  I:=0;\r\n  L:=Length(S);\r\n  Result:='';\r\n  While (I<=L) do\r\n    case S[I] of\r\n      #10: begin\r\n          if Style in [tlbsCRLF,tlbsCR] then\r\n            Add(#13);\r\n          if Style=tlbsCRLF then\r\n            Add(#10);\r\n          Inc(I);\r\n          end;\r\n     #13: begin\r\n          if Style=tlbsCRLF then\r\n            Add(#13);\r\n          Add(#10);\r\n          Inc(I);\r\n          if S[I]=#10 then\r\n            Inc(I);\r\n          end;\r\n    else\r\n      Add(S[i]);\r\n      Inc(I);\r\n    end;\r\n  Result:=Res;\r\nend;\r\n\r\nfunction WrapText(const Line, BreakStr: string;\r\n  const BreakChars: array of char; MaxCol: Integer): string;\r\n\r\nconst\r\n  Quotes = ['''', '\"'];\r\n\r\nVar\r\n  L : String;\r\n  C,LQ,BC : Char;\r\n  P,BLen,Len : Integer;\r\n  HB,IBC : Boolean;\r\n\r\nbegin\r\n  Result:='';\r\n  L:=Line;\r\n  Blen:=Length(BreakStr);\r\n  If (BLen>0) then\r\n    BC:=BreakStr[1]\r\n  else\r\n    BC:=#0;\r\n  Len:=Length(L);\r\n  While (Len>0) do\r\n    begin\r\n    P:=1;\r\n    LQ:=#0;\r\n    HB:=False;\r\n    IBC:=False;\r\n    While ((P<=Len) and ((P<=MaxCol) or not IBC)) and ((LQ<>#0) or Not HB) do\r\n      begin\r\n      C:=L[P];\r\n      If (C=LQ) then\r\n        LQ:=#0\r\n      else If (C in Quotes) then\r\n        LQ:=C;\r\n      If (LQ<>#0) then\r\n        Inc(P)\r\n      else\r\n        begin\r\n        HB:=((C=BC) and (BreakStr=Copy(L,P,BLen)));\r\n        If HB then\r\n          Inc(P,Blen)\r\n        else\r\n          begin\r\n          If (P>=MaxCol) then\r\n            IBC:=CharInSet(C,BreakChars);\r\n          Inc(P);\r\n          end;\r\n        end;\r\n//      Writeln('\"',C,'\" : IBC : ',IBC,' HB  : ',HB,' LQ  : ',LQ,' P>MaxCol : ',P>MaxCol);\r\n      end;\r\n    Result:=Result+Copy(L,1,P-1);\r\n    Delete(L,1,P-1);\r\n    Len:=Length(L);\r\n    If (Len>0) and Not HB then\r\n      Result:=Result+BreakStr;\r\n    end;\r\nend;\r\n\r\nfunction WrapText(const Line: string; MaxCol: Integer): string;\r\n\r\nbegin\r\n  Result:=WrapText(Line,sLineBreak, [' ', '-', #9], MaxCol);\r\nend;\r\n\r\n\r\nfunction GetEnvironmentVariable(const EnvVar: String): String;\r\nbegin\r\n  if Assigned(OnGetEnvironmentVariable) then\r\n    Result:=OnGetEnvironmentVariable(EnvVar)\r\n  else\r\n    Result:='';\r\nend;\r\n\r\nfunction GetEnvironmentVariableCount: Integer;\r\nbegin\r\n  if Assigned(OnGetEnvironmentVariableCount) then\r\n    Result:=OnGetEnvironmentVariableCount()\r\n  else\r\n    Result:=0;\r\nend;\r\n\r\nfunction GetEnvironmentString(Index: Integer): String;\r\nbegin\r\n  if Assigned(OnGetEnvironmentString) then\r\n    Result:=OnGetEnvironmentString(Index)\r\n  else\r\n    Result:='';\r\nend;\r\n\r\n{ Date/Time routines}\r\n\r\nFunction DoEncodeDate(Year, Month, Day: Word): longint;\r\n\r\nVar\r\n  D : TDateTime;\r\n\r\nbegin\r\n  If TryEncodeDate(Year,Month,Day,D) then\r\n    Result:=Trunc(D)\r\n  else\r\n    Result:=0;\r\nend;\r\n\r\nfunction DoEncodeTime(Hour, Minute, Second, MilliSecond: word): TDateTime;\r\n\r\nbegin\r\n  If not TryEncodeTime(Hour,Minute,Second,MilliSecond,Result) then\r\n    Result:=0;\r\nend;\r\n\r\nfunction DateTimeToJSDate(aDateTime: TDateTime; asUTC : Boolean = False): TJSDate;\r\n\r\nVar\r\n  Y,M,D,h,n,s,z : Word;\r\n\r\nbegin\r\n  DecodeDate(Trunc(aDateTime),Y,M,D);\r\n  DecodeTime(Frac(aDateTime),H,N,S,Z);\r\n  if asUTC then\r\n    Result:=TJSDate.New(TJSDate.UTC(Y,M-1,D,h,n,s,z))\r\n  else\r\n    Result:=TJSDate.New(Y,M-1,D,h,n,s,z);\r\nend;\r\n\r\nfunction JSDateToDateTime(aDate: TJSDate): TDateTime;\r\n\r\nbegin\r\n  Result:=EncodeDate(ADate.FullYear,ADate.Month+1,ADate.Date) +\r\n          EncodeTime(ADate.Hours,ADate.Minutes,ADate.Seconds,ADate.Milliseconds);\r\nend;\r\n\r\n\r\n{   ComposeDateTime converts a Date and a Time into one TDateTime   }\r\nfunction ComposeDateTime(Date,Time : TDateTime) : TDateTime;\r\n\r\nbegin\r\n  if Date < 0 then\r\n    Result := trunc(Date) - Abs(frac(Time))\r\n  else\r\n    Result := trunc(Date) + Abs(frac(Time));\r\nend;\r\n\r\n\r\nfunction TryEncodeDate(Year, Month, Day: Word; out Date: TDateTime): Boolean;\r\n\r\nvar\r\n  c, ya: LongWord;\r\nbegin\r\n  Result:=(Year>0) and (Year<10000) and\r\n          (Month >= 1) and (Month<=12) and\r\n          (Day>0) and (Day<=MonthDays[IsleapYear(Year),Month]);\r\n If Result then\r\n   begin\r\n     if month > 2 then\r\n      Dec(Month,3)\r\n     else\r\n      begin\r\n        Inc(Month,9);\r\n        Dec(Year);\r\n      end;\r\n     c:= Year DIV 100;\r\n     ya:= Year - 100*c;\r\n     Date := (146097*c) SHR 2 + (1461*ya) SHR 2 + (153*LongWord(Month)+2) DIV 5 + LongWord(Day);\r\n     // Note that this line can't be part of the line above, since TDateTime is\r\n     // signed and c and ya are not\r\n     Date := Date - 693900;\r\n   end\r\nend;\r\n\r\nfunction TryEncodeTime(Hour, Min, Sec, MSec: Word; out Time: TDateTime\r\n  ): Boolean;\r\n\r\nbegin\r\n  Result:=(Hour<24) and (Min<60) and (Sec<60) and (MSec<1000);\r\n  If Result then\r\n    Time:=TDateTime(LongWord(Hour)*3600000+LongWord(Min)*60000+LongWord(Sec)*1000+MSec)/MSecsPerDay;\r\nend;\r\n\r\n{   EncodeDate packs three variables Year, Month and Day into a\r\n    TDateTime value the result is the number of days since 12/30/1899   }\r\n\r\nfunction EncodeDate(Year, Month, Day: word): TDateTime;\r\n\r\nbegin\r\n  If Not TryEncodeDate(Year,Month,Day,Result) then\r\n    Raise EConvertError.CreateFmt('%s-%s-%s is not a valid date specification',\r\n                              [IntToStr(Year),IntToStr(Month),IntToStr(Day)]);\r\nend;\r\n\r\n{   EncodeTime packs four variables Hour, Minute, Second and MilliSecond into\r\n    a TDateTime value     }\r\n\r\nfunction EncodeTime(Hour, Minute, Second, MilliSecond:word):TDateTime;\r\n\r\nbegin\r\n  If not TryEncodeTime(Hour,Minute,Second,MilliSecond,Result) then\r\n    Raise EConvertError.CreateFmt('%s:%s:%s.%s is not a valid time specification',\r\n                              [IntToStr(Hour),IntToStr(Minute),IntToStr(Second),IntToStr(MilliSecond)]);\r\nend;\r\n\r\n\r\n{   DecodeDate unpacks the value Date into three values:\r\n    Year, Month and Day   }\r\n\r\nprocedure DecodeDate(Date: TDateTime; out Year, Month, Day: word);\r\nvar\r\n  ly,ld,lm,j : LongWord;\r\nbegin\r\n  if Date <= -datedelta then  // If Date is before 1-1-1 then return 0-0-0\r\n    begin\r\n    Year := 0;\r\n    Month := 0;\r\n    Day := 0;\r\n    end\r\n  else\r\n    begin\r\n    if Date>0 then\r\n      Date:=(Date+(1/(msecsperday*2)))\r\n    else\r\n      Date:=Date-(1/(msecsperday*2));\r\n    if Date>MaxDateTime then\r\n      Date:=MaxDateTime;\r\n//       Raise EConvertError.CreateFmt('%f is not a valid TDatetime encoding, maximum value is %f.',[Date,MaxDateTime]);\r\n    j := ((Trunc(Date) + 693900) SHL 2)-1;\r\n    ly:= j DIV 146097;\r\n    j:= j - 146097 * LongWord(ly);\r\n    ld := j SHR 2;\r\n    j:=(ld SHL 2 + 3) DIV 1461;\r\n    ld:= ((ld SHL 2) + 7 - 1461*j) SHR 2;\r\n    lm:=(5 * ld-3) DIV 153;\r\n    ld:= (5 * ld +2 - 153*lm) DIV 5;\r\n    ly:= 100 * LongWord(ly) + j;\r\n    if lm < 10 then\r\n     inc(lm,3)\r\n    else\r\n      begin\r\n        dec(lm,9);\r\n        inc(ly);\r\n      end;\r\n    year:=ly;\r\n    month:=lm;\r\n    day:=ld;\r\n    end;\r\nend;\r\n\r\n\r\nfunction DecodeDateFully(const DateTime: TDateTime; out Year, Month, Day, DOW: Word): Boolean;\r\nbegin\r\n  DecodeDate(DateTime,Year,Month,Day);\r\n  DOW:=DayOfWeek(DateTime);\r\n  Result:=IsLeapYear(Year);\r\nend;\r\n  {   DateTimeToTimeStamp converts DateTime to a TTimeStamp   }\r\n\r\nfunction DateTimeToTimeStamp(DateTime: TDateTime): TTimeStamp;\r\n\r\nVar\r\n  D : Double;\r\nbegin\r\n  D:=DateTime * Double(MSecsPerDay);\r\n  if D<0 then\r\n    D:=D-0.5\r\n  else\r\n    D:=D+0.5;\r\n  result.Time := Trunc(Abs(Trunc(D)) Mod MSecsPerDay);\r\n  result.Date := DateDelta + (Trunc(D) div MSecsPerDay);\r\nend;\r\n\r\n{   TimeStampToDateTime converts TimeStamp to a TDateTime value   }\r\n\r\nfunction TimeStampToDateTime(const TimeStamp: TTimeStamp): TDateTime;\r\nbegin\r\n  Result := ComposeDateTime(TimeStamp.Date - DateDelta,TimeStamp.Time/MSecsPerDay)\r\nend;\r\n\r\n{   MSecsToTimeStamp   }\r\n\r\nfunction MSecsToTimeStamp(MSecs: NativeInt): TTimeStamp;\r\nbegin\r\n  result.Date := Trunc(msecs/msecsperday);\r\n  msecs:= msecs-NativeInt(result.date)*msecsperday;\r\n  result.Time := Round(MSecs);\r\nend;\r\n\r\nfunction TimeStampToMSecs(const TimeStamp: TTimeStamp): NativeInt;\r\nbegin\r\n  result := TimeStamp.Time + (timestamp.date*msecsperday);\r\nend ;\r\n\r\n\r\n\r\n{   DecodeTime unpacks Time into four values:\r\n    Hour, Minute, Second and MilliSecond    }\r\n\r\nprocedure DecodeTime(Time: TDateTime; out Hour, Minute, Second, MilliSecond: word);\r\nVar\r\n  l : LongWord;\r\nbegin\r\n  l := DateTimeToTimeStamp(Time).Time;\r\n  Hour   := l div 3600000;\r\n  l := l mod 3600000;\r\n  Minute := l div 60000;\r\n  l := l mod 60000;\r\n  Second := l div 1000;\r\n  l := l mod 1000;\r\n  MilliSecond := l;\r\nend;\r\n\r\n{   DateTimeToSystemTime converts DateTime value to SystemTime   }\r\n\r\nprocedure DateTimeToSystemTime(DateTime: TDateTime; out SystemTime: TSystemTime);\r\nbegin\r\n  DecodeDateFully(DateTime, SystemTime.Year, SystemTime.Month, SystemTime.Day,SystemTime.DayOfWeek);\r\n  DecodeTime(DateTime, SystemTime.Hour, SystemTime.Minute, SystemTime.Second, SystemTime.MilliSecond);\r\n  Dec(SystemTime.DayOfWeek);\r\nend ;\r\n\r\n{   SystemTimeToDateTime converts SystemTime to a TDateTime value   }\r\n\r\nfunction SystemTimeToDateTime(const SystemTime: TSystemTime): TDateTime;\r\nbegin\r\n  result := ComposeDateTime(DoEncodeDate(SystemTime.Year, SystemTime.Month, SystemTime.Day),\r\n                            DoEncodeTime(SystemTime.Hour, SystemTime.Minute, SystemTime.Second, SystemTime.MilliSecond));\r\nend ;\r\n\r\nfunction DayOfWeek(DateTime: TDateTime): integer;\r\nbegin\r\n  Result:= 1+((Trunc(DateTime) - 1) mod 7);\r\n  If (Result<=0) then\r\n    Inc(Result,7);\r\nend;\r\n\r\n\r\n\r\nfunction Now: TDateTime;\r\nbegin\r\n  Result:=JSDateToDateTime(TJSDate.New());\r\nend;\r\n\r\nfunction Date: TDateTime;\r\n\r\nbegin\r\n  Result:=Trunc(Now);\r\nend;\r\n\r\nfunction Time: TDateTime;\r\nbegin\r\n  Result:=Now-Date;\r\nend ;\r\n\r\n{   IncMonth increments DateTime with NumberOfMonths months,\r\n    NumberOfMonths can be less than zero   }\r\n\r\nfunction IncMonth(const DateTime: TDateTime; NumberOfMonths: integer = 1 ): TDateTime;\r\nvar\r\n  Year, Month, Day : word;\r\nbegin\r\n  DecodeDate(DateTime, Year, Month, Day);\r\n  IncAMonth(Year, Month, Day, NumberOfMonths);\r\n  result := ComposeDateTime(DoEncodeDate(Year, Month, Day), DateTime);\r\nend ;\r\n\r\n{   IncAMonth is the same as IncMonth, but operates on decoded date  }\r\n\r\nprocedure IncAMonth(var Year, Month, Day: Word; NumberOfMonths: Integer = 1);\r\nvar\r\n  TempMonth, S: Integer;\r\nbegin\r\n  If NumberOfMonths>=0 then\r\n    s:=1\r\n  else\r\n    s:=-1;\r\n  inc(Year,(NumberOfMonths div 12));\r\n  TempMonth:=Month+(NumberOfMonths mod 12)-1;\r\n  if (TempMonth>11) or\r\n     (TempMonth<0) then\r\n   begin\r\n     Dec(TempMonth, S*12);\r\n     Inc(Year, S);\r\n   end;\r\n  Month:=TempMonth+1;          {   Months from 1 to 12   }\r\n  If (Day>MonthDays[IsLeapYear(Year)][Month]) then\r\n    Day:=MonthDays[IsLeapYear(Year)][Month];\r\nend;\r\n\r\n{  IsLeapYear returns true if Year is a leap year   }\r\n\r\nfunction IsLeapYear(Year: Word): boolean;\r\nbegin\r\n  Result := (Year mod 4 = 0) and ((Year mod 100 <> 0) or (Year mod 400 = 0));\r\nend;\r\n\r\n{  DateToStr returns a string representation of Date using ShortDateFormat   }\r\n\r\nfunction DateToStr(Date: TDateTime): string;\r\nbegin\r\n  Result:=DateToStr(Date,FormatSettings);\r\nend;\r\n\r\nfunction DateToStr(Date: TDateTime; const aSettings : TFormatSettings): string;\r\nbegin\r\n  Result:=FormatDateTime('ddddd', Date, aSettings);\r\nend ;\r\n\r\n{  TimeToStr returns a string representation of Time using LongTimeFormat   }\r\n\r\nfunction TimeToStr(Time: TDateTime): string;\r\nbegin\r\n  Result:=TimeToStr(Time,FormatSettings);\r\nend;\r\n\r\nfunction TimeToStr(Time: TDateTime; const aSettings : TFormatSettings): string;\r\nbegin\r\n  Result:=FormatDateTime('tt',Time,aSettings);\r\nend ;\r\n\r\n\r\n{   DateTimeToStr returns a string representation of DateTime using LongDateTimeFormat   }\r\n\r\nVar\r\n  DateTimeToStrFormat : Array[Boolean] of string = ('c','f');\r\n\r\n\r\nfunction DateTimeToStr(DateTime: TDateTime; ForceTimeIfZero : Boolean = False): string;\r\n\r\nbegin\r\n  Result:=DateTimeToStr(DateTime,FormatSettings,ForceTimeIfZero);\r\nend;\r\n\r\nfunction DateTimeToStr(DateTime: TDateTime; Const aSettings : TFormatSettings; ForceTimeIfZero : Boolean = False): string;\r\n\r\n\r\nbegin\r\n  Result:=FormatDateTime(DateTimeToStrFormat[ForceTimeIfZero], DateTime,aSettings)\r\nend ;\r\n\r\n\r\n{   StrToDate converts the string S to a TDateTime value\r\n    if S does not represent a valid date value\r\n    an EConvertError will be raised   }\r\n\r\nfunction IntStrToDate(Out ErrorMsg : String; const S: String; const useformat : string; separator : char): TDateTime;\r\n\r\nConst\r\n  WhiteSpace = ' '#8#9#10#12#13;\r\n  Digits = '0123456789';\r\n\r\n  procedure FixErrorMsg(const errmarg : String);\r\n\r\n  begin\r\n    ErrorMsg:=Format(SInvalidDateFormat,[errmarg]);\r\n  end;\r\n\r\nvar\r\n   df:string;\r\n   d,m,y,ly,ld,lm:word;\r\n   n,i,len:longint;\r\n   c: integer;\r\n   dp,mp,yp,which : Byte;\r\n   s1:string;\r\n   values: array of integer;\r\n   YearMoreThenTwoDigits : boolean;\r\n\r\nbegin\r\n  SetLength(values,4);\r\n  Result:=0;\r\n  Len:=Length(S);\r\n  ErrorMsg:='';\r\n  While (Len>0) and (Pos(S[Len],WhiteSpace)>0) do\r\n    Dec(len);\r\n  if (Len=0) then\r\n    begin\r\n    FixErrorMsg(S);\r\n    exit;\r\n    end;\r\n  YearMoreThenTwoDigits := False;\r\n  if separator = #0 then\r\n    if (FormatSettings.DateSeparator<>#0) then\r\n      separator := FormatSettings.DateSeparator\r\n    else\r\n      separator:='-';\r\n  // Writeln('Separator: ',Separator);\r\n  df := UpperCase(useFormat);\r\n  { Determine order of D,M,Y }\r\n  yp:=0;\r\n  mp:=0;\r\n  dp:=0;\r\n  Which:=0;\r\n  i:=0;\r\n  while (i<Length(df)) and (Which<3) do\r\n   begin\r\n     inc(i);\r\n     Case df[i] of\r\n       'Y' :\r\n         if yp=0 then\r\n          begin\r\n            Inc(Which);\r\n            yp:=which;\r\n          end;\r\n       'M' :\r\n         if mp=0 then\r\n          begin\r\n            Inc(Which);\r\n            mp:=which;\r\n          end;\r\n       'D' :\r\n         if dp=0 then\r\n          begin\r\n            Inc(Which);\r\n            dp:=which;\r\n          end;\r\n     end;\r\n   end;\r\n  // Writeln('YP: ',Yp,', MP: ',Mp,', DP: ',DP);\r\n  for i := 1 to 3 do\r\n    values[i] := 0;\r\n  s1 := '';\r\n  n := 0;\r\n  for i := 1 to len do\r\n     begin\r\n     if Pos(s[i],Digits)>0 then\r\n       s1 := s1 + s[i];\r\n     { space can be part of the shortdateformat, and is defaultly in slovak\r\n       windows, therefor it shouldn't be taken as separator (unless so specified)\r\n       and ignored }\r\n     if (Separator <> ' ') and (s[i] = ' ') then\r\n       Continue;\r\n     if (s[i] = separator) or ((i = len) and (Pos(s[i],Digits)>0)) then\r\n      begin\r\n        inc(n);\r\n        if n>3 then\r\n          begin\r\n//            Writeln('More than 3 separators');\r\n            FixErrorMsg(S);\r\n            exit;\r\n          end;\r\n         // Check if the year has more then two digits (if n=yp, then we are evaluating the year.)\r\n        if (n=yp) and (length(s1)>2) then YearMoreThenTwoDigits := True;\r\n        val(s1, values[n], c);\r\n        if c<>0 then\r\n          begin\r\n//            Writeln('S1 not a number ',S1);\r\n            FixErrorMsg(s);\r\n            Exit;\r\n          end;\r\n        s1 := '';\r\n      end\r\n     else if (Pos(s[i],Digits)=0) then\r\n       begin\r\n//       Writeln('Not a number at pos ',I,' ',S[i]);\r\n       FixErrorMsg(s);\r\n       Exit;\r\n       end;\r\n   end ;\r\n//   Writeln('Which : ',Which,' N : ',N);\r\n   if (Which<3) and (N>Which) then\r\n    begin\r\n    FixErrorMsg(s);\r\n    Exit;\r\n    end;\r\n  // Fill in values.\r\n  DecodeDate(Date,Ly,LM,LD);\r\n  If N=3 then\r\n   begin\r\n     y:=values[yp];\r\n     m:=values[mp];\r\n     d:=values[dp];\r\n   end\r\n  Else\r\n  begin\r\n    Y:=ly;\r\n    If n<2 then\r\n     begin\r\n       d:=values[1];\r\n       m := LM;\r\n     end\r\n    else\r\n     If dp<mp then\r\n      begin\r\n        d:=values[1];\r\n        m:=values[2];\r\n      end\r\n    else\r\n      begin\r\n        d:=values[2];\r\n        m:=values[1];\r\n      end;\r\n  end;\r\n  if (y >= 0) and (y < 100) and not YearMoreThenTwoDigits then\r\n    begin\r\n    ly := ly - TwoDigitYearCenturyWindow;\r\n    Inc(Y, ly div 100 * 100);\r\n    if (TwoDigitYearCenturyWindow > 0) and (Y < ly) then\r\n      Inc(Y, 100);\r\n    end;\r\n  if not TryEncodeDate(y, m, d, result) then\r\n    errormsg:=SErrInvalidDate;\r\nend;\r\n\r\nfunction StrToDate(const S: String; const useformat : string; separator : char): TDateTime;\r\nVar\r\n  MSg : String;\r\nbegin\r\n  Result:=IntStrToDate(Msg,S,useFormat,Separator);\r\n  If (Msg<>'') then\r\n    Raise EConvertError.Create(Msg);\r\nend;\r\n\r\nfunction StrToDate(const S: String; const aSettings : TFormatSettings): TDateTime;\r\n\r\nbegin\r\n  Result:=StrToDate(S,aSettings.ShortDateFormat,aSettings.DateSeparator);\r\nend;\r\n\r\nfunction StrToDate(const S: String): TDateTime;\r\nbegin\r\n  result:=StrToDate(S,FormatSettings);\r\nend;\r\n\r\nfunction StrToDate(const S: String; separator : char): TDateTime;\r\nbegin\r\n  result := StrToDate(S,FormatSettings.ShortDateFormat,separator)\r\nend;\r\n\r\n\r\n{   StrToTime converts the string S to a TDateTime value\r\n    if S does not represent a valid time value an\r\n    EConvertError will be raised   }\r\n\r\n\r\nfunction IntStrToTime(Out ErrorMsg : String; const S: String; Len : integer; Const aSettings : TFormatSettings): TDateTime;\r\n\r\nconst\r\n  AMPM_None = 0;\r\n  AMPM_AM = 1;\r\n  AMPM_PM = 2;\r\n  tiHour = 0;\r\n  tiMin = 1;\r\n  tiSec = 2;\r\n  tiMSec = 3;\r\n\r\ntype\r\n  TTimeValues = array of Word;\r\n\r\nvar\r\n   AmPm: integer;\r\n   TimeValues: TTimeValues;\r\n\r\n\r\n   function SplitElements(out TimeValues: TTimeValues; out AmPm: Integer): Boolean;\r\n   //Strict version. It does not allow #32 as Separator, it will treat it as whitespace always\r\n   const\r\n     Digits = '0123456789';\r\n   var\r\n      Cur, Offset, ElemLen, Err, TimeIndex, FirstSignificantDigit: Integer;\r\n      Value: Integer;\r\n      DigitPending, MSecPending: Boolean;\r\n      AmPmStr: String;\r\n      CurChar: Char;\r\n      I : Integer;\r\n      allowedchars : string;\r\n\r\n   begin\r\n     Result := False;\r\n     AmPm := AMPM_None; //No Am or PM in string found yet\r\n     MSecPending := False;\r\n     TimeIndex := 0; //indicating which TTimeValue must be filled next\r\n     For I:=tiHour to tiMSec do\r\n      TimeValues[i]:=0;\r\n     Cur := 1;\r\n     //skip leading blanks\r\n     While (Cur < Len) and (S[Cur] =#32) do Inc(Cur);\r\n     Offset := Cur;\r\n     //First non-blank cannot be Separator or DecimalSeparator\r\n     if (Cur > Len - 1) or (S[Cur] = aSettings.TimeSeparator) or (S[Cur] = aSettings.Decimalseparator) then\r\n       begin\r\n       // Writeln('Error in sep S[Cur]',S[Cur],' ',separator,' ',GetDecimalSeparator);\r\n       Exit;\r\n       end;\r\n     DigitPending := (Pos(S[Cur],Digits)>0);\r\n     While (Cur <= Len) do\r\n     begin\r\n       //writeln;\r\n       // writeln('Main While loop:  Cur = ',Cur,' S[Cur] = \"',S[Cur],'\" Len = ',Len,' separator : ',Separator);\r\n       CurChar := S[Cur];\r\n       if Pos(CurChar,Digits)>0 then\r\n       begin//Digits\r\n         //HH, MM, SS, or Msec?\r\n         // writeln('Digit: ', CurChar);\r\n         //Digits are only allowed after starting Am/PM or at beginning of string or after Separator\r\n         //and TimeIndex must be <= tiMSec\r\n         //Uncomment \"or (#32 = Separator)\" and it will allllow #32 as separator\r\n         if (not (DigitPending {or (#32 = Separator)})) or (TimeIndex > tiMSec) then\r\n            begin\r\n            // Writeln('DigitPending',ElemLen);\r\n            Exit;\r\n            end;\r\n         OffSet := Cur;\r\n         if (CurChar <> '0') then FirstSignificantDigit := OffSet else FirstSignificantDigit := -1;\r\n         while (Cur < Len) and (Pos(S[Cur + 1],Digits)>0) do\r\n         begin\r\n           //Mark first Digit that is not '0'\r\n           if (FirstSignificantDigit = -1) and (S[Cur] <> '0') then FirstSignificantDigit := Cur;\r\n           Inc(Cur);\r\n         end;\r\n         if (FirstSignificantDigit = -1) then FirstSignificantDigit := Cur;\r\n         ElemLen := 1+ Cur - FirstSignificantDigit;\r\n         // writeln('  S[FirstSignificantDigit] = ',S[FirstSignificantDigit], ' S[Cur] = ',S[Cur],' ElemLen = ',ElemLen,' -> ', S[Offset], ElemLen);\r\n         // writeln('  Cur = ',Cur);\r\n         //this way we know that Val() will never overflow Value !\r\n         if (ElemLen <= 2) or ((ElemLen <= 3) and (TimeIndex = tiMSec) ) then\r\n         begin\r\n           Val(Copy(S,FirstSignificantDigit, ElemLen), Value, Err);\r\n           // writeln('  Value = ',Value,' HH = ',TimeValues[0],' MM = ',TimeValues[1],' SS = ',TimeValues[2],' MSec = ',Timevalues[3]);\r\n           //This is safe now, because we know Value < High(Word)\r\n           TimeValues[TimeIndex] := Value;\r\n           Inc(TimeIndex);\r\n           DigitPending := False;\r\n         end\r\n         else\r\n           begin\r\n           // Writeln('Wrong elemlen: ',ElemLen, ' timeIndex: ',timeindex);\r\n           Exit; //Value to big, so it must be a wrong timestring\r\n           end;\r\n       end//Digits\r\n       else if (CurChar = #32) then\r\n       begin\r\n         //writeln('#32');\r\n         //just skip, but we must adress this, or it will be parsed by either AM/PM or Separator\r\n       end\r\n       else if (CurChar = aSettings.TimeSeparator) then\r\n       begin\r\n         // writeln('Separator ',Separator);\r\n         if DigitPending or (TimeIndex > tiSec) then\r\n           begin\r\n           // Writeln ('DigitPending ',DigitPending,' or (TimeIndex',Timeindex,' > tiSec,', tiSec,')');\r\n           Exit;\r\n           end;\r\n         DigitPending := True;\r\n         MSecPending := False;\r\n       end\r\n       else if (CurChar = aSettings.DecimalSeparator) then\r\n       begin\r\n         //writeln('DecimalSeparator');\r\n         if DigitPending or MSecPending or (TimeIndex <> tiMSec) then\r\n            begin\r\n            // Writeln('DigitPending ',DigitPending,' or MSecPending ',MSecPending,' (',TimeIndex,',Timeindex, >', tiMSec,'  tiSec)');\r\n            Exit;\r\n            end;\r\n         DigitPending := True;\r\n         MSecPending := True;\r\n       end\r\n       else\r\n       begin//AM/PM?\r\n         //None of the above, so this char _must_ be the start of AM/PM string\r\n         //If we already have found AM/PM or we expect a digit then then timestring must be wrong at this point\r\n         //writeln('AM/PM?');\r\n         if (AmPm <> AMPM_None) or DigitPending then\r\n           begin\r\n           // Writeln('AmPm <> AMPM_None) or DigitPending');\r\n           Exit;\r\n           end;\r\n         OffSet := Cur;\r\n         allowedchars:=aSettings.DecimalSeparator+' ';\r\n         if aSettings.TimeSeparator<>#0 then\r\n           allowedchars:=allowedchars+aSettings.TimeSeparator;\r\n         while (Cur < Len) and (Pos(S[Cur + 1],AllowedChars)=0)\r\n           and (Pos(S[Cur + 1],Digits)=0) do Inc(Cur);\r\n         ElemLen := 1 + Cur - OffSet;\r\n//         writeln('  S[Offset] = ',S[Offset], ' S[Cur] = ',S[Cur],' ElemLen = ',ElemLen,' -> ', S[1+Offset], ElemLen);\r\n//         writeln('  Cur = ',Cur, ', S =',S);\r\n         AmPmStr := Copy(S,OffSet, ElemLen);\r\n\r\n         // writeln('AmPmStr = ',ampmstr,' (',length(ampmstr),')');\r\n         //We must compare to TimeAMString before hardcoded 'AM' for delphi compatibility\r\n         //Also it is perfectly legal, though insane to have TimeAMString = 'PM' and vice versa\r\n         if (CompareText(AmPmStr, aSettings.TimeAMString) = 0) then AmPm := AMPM_AM\r\n         else if (CompareText(AmPmStr, aSettings.TimePMString) = 0) then AmPm := AMPM_PM\r\n         else if (CompareText(AmPmStr, 'AM') = 0) then AmPm := AMPM_AM\r\n         else if (CompareText(AmPmStr, 'PM') = 0) then AmPm := AMPM_PM\r\n         else\r\n           begin\r\n           // Writeln('No timestring ',AmPmStr);\r\n           Exit; //If text does not match any of these, timestring must be wrong;\r\n           end;\r\n         //if AM/PM is at beginning of string, then a digit is mandatory after it\r\n         if (TimeIndex = tiHour) then\r\n         begin\r\n           DigitPending := True;\r\n         end\r\n         //otherwise, no more TimeValues allowed after this\r\n         else\r\n         begin\r\n           TimeIndex := tiMSec + 1;\r\n           DigitPending := False;\r\n         end;\r\n       end;//AM/PM\r\n       Inc(Cur)\r\n     end;//while\r\n\r\n     //If we arrive here, parsing the elements has been successfull\r\n     //if not at least Hours specified then input is not valid\r\n     //when am/pm is specified Hour must be <= 12 and not 0\r\n     if (TimeIndex = tiHour) or ((AmPm <> AMPM_None) and ((TimeValues[tiHour] > 12) or (TimeValues[tiHour] = 0))) or DigitPending then\r\n       Exit;\r\n     Result := True;\r\n   end;\r\n\r\nbegin\r\n  setlength(timevalues,4);\r\n  AmPm := AMPM_None;\r\n  if not SplitElements(TimeValues, AmPm) then\r\n  begin\r\n    ErrorMsg:=Format(SErrInvalidTimeFormat,[S]);\r\n    Exit;\r\n  end;\r\n  if (AmPm=AMPM_PM) and (TimeValues[tiHour]<>12) then Inc(TimeValues[tiHour], 12)\r\n  else if (AmPm=AMPM_AM) and (TimeValues[tiHour]=12) then TimeValues[tiHour]:=0;\r\n  // Writeln(      TimeValues[tiHour], TimeValues[tiMin], TimeValues[tiSec], TimeValues[tiMSec]);\r\n  if not TryEncodeTime(TimeValues[tiHour], TimeValues[tiMin], TimeValues[tiSec], TimeValues[tiMSec], result) Then\r\n\r\n    ErrorMsg:=Format(SErrInvalidTimeFormat,[S]);\r\nend ;\r\n\r\nfunction StrToTime(const S: String; const aSettings : TFormatSettings): TDateTime;\r\n\r\nVar\r\n  Msg : String;\r\n\r\nbegin\r\n  Result:=IntStrToTime(Msg,S,Length(S),aSettings);\r\n  If (Msg<>'') then\r\n    Raise EConvertError.Create(Msg);\r\nend;\r\n\r\nfunction StrToTime(const S: String): TDateTime;\r\nbegin\r\n   result:=StrToTime(S, FormatSettings);\r\nend;\r\n\r\n\r\nfunction StrToTime(const S: String; separator: char): TDateTime;\r\n\r\nVar\r\n  aSettings : TFormatSettings;\r\n\r\nbegin\r\n  aSettings:=TFormatSettings.Create;\r\n  aSettings.TimeSeparator:=Separator;\r\n  Result:=StrToTime(S,aSettings);\r\nend;\r\n\r\n\r\n{   StrToDateTime converts the string S to a TDateTime value\r\n    if S does not represent a valid date and/or time value\r\n    an EConvertError will be raised   }\r\n\r\nfunction SplitDateTimeStr(DateTimeStr: String; out DateStr, TimeStr: String; Const aSettings : TFormatSettings): Integer;\r\n\r\n{ Helper function for StrToDateTime\r\n  Pre-condition\r\n    Date is before Time\r\n    If either Date or Time is omitted then see what fits best, a time or a date (issue #0020522)\r\n    Date and Time are separated by whitespace (space Tab, Linefeed or carriage return)\r\n    FS.DateSeparator can be the same as FS.TimeSeparator (issue #0020522)\r\n    If they are both #32 and TrimWhite(DateTimeStr) contains a #32 a date is assumed.\r\n  Post-condition\r\n    DateStr holds date as string or is empty\r\n    TimeStr holds time as string or is empty\r\n    Result = number of strings returned, 0 = error\r\n}\r\nconst\r\n  WhiteSpace = #9#10#13#32;\r\n\r\nvar\r\n  p: Integer;\r\n  DummyDT: TDateTime;\r\nbegin\r\n  Result := 0;\r\n  DateStr := '';\r\n  TimeStr := '';\r\n  DateTimeStr := Trim(DateTimeStr);\r\n  if Length(DateTimeStr) = 0 then exit;\r\n  if (aSettings.DateSeparator = #32) and (aSettings.TimeSeparator = #32) and (Pos(#32, DateTimeStr) > 0) then\r\n    begin\r\n    DateStr:=DateTimeStr;\r\n    {\r\n      Assume a date: dd [mm [yy]].\r\n      Really fancy would be counting the number of whitespace occurrences and decide\r\n      and split accordingly\r\n    }\r\n    Exit(1);\r\n    end;\r\n  p:=1;\r\n  //find separator\r\n  if (aSettings.DateSeparator<>#32) then\r\n    begin\r\n    while (p<Length(DateTimeStr)) and (not (Pos(DateTimeStr[p+1],WhiteSpace)>0)) do\r\n      Inc(p);\r\n    end\r\n  else\r\n    begin\r\n    p:=Pos(aSettings.TimeSeparator, DateTimeStr);\r\n    if (p<>0) then\r\n      repeat\r\n        Dec(p);\r\n      until (p=0) or (Pos(DateTimeStr[p],WhiteSpace)>0);\r\n    end;\r\n  //Always fill DateStr, it eases the algorithm later\r\n  if (p=0) then\r\n    p:=Length(DateTimeStr);\r\n  DateStr:=Copy(DateTimeStr,1,p);\r\n  TimeStr:=Trim(Copy(DateTimeStr,p+1,100));\r\n  if (Length(TimeStr)<>0) then\r\n    Result:=2\r\n  else\r\n    begin\r\n    Result:=1; //found 1 string\r\n    // 2 cases when DateTimeStr only contains a time:\r\n    // Date/time separator differ, and string contains a timeseparator\r\n    // Date/time separators are equal, but transformation to date fails.\r\n    if ((aSettings.DateSeparator<>aSettings.TimeSeparator) and (Pos(aSettings.TimeSeparator,DateStr) > 0))\r\n       or ((aSettings.DateSeparator=aSettings.TimeSeparator) and (not TryStrToDate(DateStr, DummyDT)))  then\r\n      begin\r\n      TimeStr := DateStr;\r\n      DateStr := '';\r\n      end;\r\n    end;\r\nend;\r\n\r\nfunction StrToDateTime(const S: String): TDateTime;\r\n\r\nbegin\r\n  Result:=StrToDateTime(S,FormatSettings);\r\nend;\r\n\r\nfunction StrToDateTime(const S: String; Const aSettings : TFormatSettings): TDateTime;\r\n\r\nvar\r\n  TimeStr, DateStr: String;\r\n  PartsFound: Integer;\r\nbegin\r\n  PartsFound := SplitDateTimeStr(S, DateStr, TimeStr,aSettings);\r\n  case PartsFound of\r\n    0: Result:=StrToDate('');\r\n    1: if (Length(DateStr) > 0) then\r\n         Result := StrToDate(DateStr,aSettings.ShortDateFormat,aSettings.DateSeparator)\r\n       else\r\n         Result := StrToTime(TimeStr);\r\n    2: Result := ComposeDateTime(StrTodate(DateStr,aSettings.ShortDateFormat,aSettings.DateSeparator),\r\n                                  StrToTime(TimeStr));\r\n  end;\r\nend;\r\n\r\nfunction FormatDateTime(const aFormatStr: string; const DateTime: TDateTime): string;\r\n\r\nbegin\r\n  Result:=FormatDateTime(aFormatStr,DateTime,FormatSettings);\r\nend;\r\n\r\nfunction FormatDateTime(const aFormatStr: string; const DateTime: TDateTime; const aSettings : TFormatSettings): string;\r\n\r\n\r\n  procedure StoreString(const AStr: string);\r\n\r\n  begin\r\n//    Writeln('StoreString: ',Result,'+',AStr);\r\n    Result:=Result+AStr;\r\n  end;\r\n\r\n  procedure StoreInt(Value, Digits: Integer);\r\n  var\r\n    S: string;\r\n\r\n  begin\r\n    S:=IntToStr(Value);\r\n    While (Length(S)<Digits) do\r\n      S:='0'+S;\r\n    StoreString(S);\r\n  end;\r\n\r\nvar\r\n  Year, Month, Day, DayOfWeek, Hour, Minute, Second, MilliSecond: word;\r\n\r\n  procedure StoreFormat(const FormatStr: string; Nesting: Integer; TimeFlag: Boolean);\r\n\r\n    procedure StoreStr(APos,Len: Integer);\r\n    begin\r\n  //    Writeln('StoreStr: ',Result,'+',Copy(FormatStr,APos,Len));\r\n      Result:=Result+Copy(aFormatStr,APos,Len);\r\n    end;\r\n\r\n  var\r\n    Token, lastformattoken, prevlasttoken: char;\r\n    Count: integer;\r\n    Clock12: boolean;\r\n    tmp: integer;\r\n    isInterval: Boolean;\r\n    P,FormatCurrent,FormatEnd : Integer;\r\n  begin\r\n    if Nesting > 1 then  // 0 is original string, 1 is included FormatString\r\n      Exit;\r\n    FormatCurrent := 1;\r\n    FormatEnd := Length(FormatStr);\r\n    Clock12 := false;\r\n    isInterval := false;\r\n    // look for unquoted 12-hour clock token\r\n    P:=1;\r\n    while P<=FormatEnd do\r\n      begin\r\n      Token := FormatStr[P];\r\n      case Token of\r\n        '''', '\"':\r\n        begin\r\n          Inc(P);\r\n          while (P < FormatEnd) and (FormatStr[P]<>Token) do\r\n            Inc(P);\r\n        end;\r\n        'A', 'a':\r\n        begin\r\n          if (CompareText(Copy(FormatStr,P,3),'A/P')=0) or\r\n             (CompareText(Copy(FormatStr,P,4),'AMPM')=0) or\r\n             (CompareText(Copy(FormatStr,P,5),'AM/PM')=0) then\r\n          begin\r\n            Clock12 := true;\r\n            break;\r\n          end;\r\n        end;\r\n      end;  // case\r\n      Inc(P);\r\n    end ;\r\n    token := #255;\r\n    lastformattoken := ' ';\r\n    prevlasttoken := 'H';\r\n    while FormatCurrent <= FormatEnd do\r\n    begin\r\n      Token := UpperCase(FormatStr[FormatCurrent])[1];\r\n     //  Writeln('Treating token at pos ',FormatCurrent,', : ',Token,' (',FormatStr,')');\r\n      Count := 1;\r\n      P := FormatCurrent + 1;\r\n      case Token of\r\n        '''', '\"':\r\n        begin\r\n          while (P < FormatEnd) and (FormatStr[P]<>Token) do\r\n            Inc(P);\r\n          Inc(P);\r\n          Count := P - FormatCurrent;\r\n          StoreStr(FormatCurrent + 1, Count - 2);\r\n        end ;\r\n        'A':\r\n        begin\r\n          if CompareText(Copy(FormatStr,FormatCurrent,4), 'AMPM') = 0 then\r\n          begin\r\n            Count := 4;\r\n            if Hour < 12 then\r\n              StoreString(aSettings.TimeAMString)\r\n            else\r\n              StoreString(aSettings.TimePMString);\r\n          end\r\n          else if CompareText(Copy(FormatStr,FormatCurrent,5), 'AM/PM') = 0 then\r\n          begin\r\n            Count := 5;\r\n            if Hour < 12 then StoreStr(FormatCurrent, 2)\r\n                         else StoreStr(FormatCurrent+3, 2);\r\n          end\r\n          else if CompareText(Copy(FormatStr,FormatCurrent,3), 'A/P') = 0 then\r\n          begin\r\n            Count := 3;\r\n            if Hour < 12 then StoreStr(FormatCurrent, 1)\r\n            else StoreStr(FormatCurrent+2, 1);\r\n          end\r\n          else\r\n            raise EConvertError.Create('Illegal character in format string');\r\n        end ;\r\n        '/':\r\n          begin\r\n           //  Writeln('Detected date separator');\r\n          StoreString(aSettings.DateSeparator);\r\n          end;\r\n        ':': StoreString(aSettings.TimeSeparator);\r\n        ' ', 'C', 'D', 'H', 'M', 'N', 'S', 'T', 'Y', 'Z', 'F' :\r\n        begin\r\n          // Writeln(FormatCurrent,' Special Token: ',Token,', Count: ',Count,', P: ',P);\r\n          while (P <= FormatEnd) and (UpperCase(FormatStr[P]) = Token) do\r\n            Inc(P);\r\n          Count := P - FormatCurrent;\r\n          // Writeln(FormatCurrent,' Special Token: ',Token,', Count: ',Count,', P: ',P);\r\n          case Token of\r\n            ' ': StoreStr(FormatCurrent, Count);\r\n            'Y': begin\r\n              if Count > 2 then\r\n                StoreInt(Year, 4)\r\n              else\r\n                StoreInt(Year mod 100, 2);\r\n            end;\r\n            'M': begin\r\n\t      if isInterval and ((prevlasttoken = 'H') or TimeFlag) then\r\n\t        StoreInt(Minute + (Hour + trunc(abs(DateTime))*24)*60, 0)\r\n\t      else\r\n              if (lastformattoken = 'H') or TimeFlag then\r\n              begin\r\n                if Count = 1 then\r\n                  StoreInt(Minute, 0)\r\n                else\r\n                  StoreInt(Minute, 2);\r\n              end\r\n              else\r\n              begin\r\n                case Count of\r\n                  1: StoreInt(Month, 0);\r\n                  2: StoreInt(Month, 2);\r\n                  3: StoreString(aSettings.ShortMonthNames[Month]);\r\n                else\r\n                  StoreString(aSettings.LongMonthNames[Month]);\r\n                end;\r\n              end;\r\n            end;\r\n            'D': begin\r\n              case Count of\r\n                1: StoreInt(Day, 0);\r\n                2: StoreInt(Day, 2);\r\n                3: StoreString(aSettings.ShortDayNames[DayOfWeek]);\r\n                4: StoreString(aSettings.LongDayNames[DayOfWeek]);\r\n                5: StoreFormat(aSettings.ShortDateFormat, Nesting+1, False);\r\n              else\r\n                StoreFormat(aSettings.LongDateFormat, Nesting+1, False);\r\n              end ;\r\n            end ;\r\n            'H':\r\n\t      if isInterval then\r\n\t        StoreInt(Hour + trunc(abs(DateTime))*24, 0)\r\n\t      else\r\n\t      if Clock12 then\r\n              begin\r\n                tmp := hour mod 12;\r\n                if tmp=0 then tmp:=12;\r\n                if Count = 1 then\r\n                  StoreInt(tmp, 0)\r\n                else\r\n                  StoreInt(tmp, 2);\r\n              end\r\n              else begin\r\n                if Count = 1 then\r\n\t\t  StoreInt(Hour, 0)\r\n                else\r\n                  StoreInt(Hour, 2);\r\n              end;\r\n            'N': if isInterval then\r\n\t           StoreInt(Minute + (Hour + trunc(abs(DateTime))*24)*60, 0)\r\n\t\t else\r\n\t\t if Count = 1 then\r\n                   StoreInt(Minute, 0)\r\n                 else\r\n                   StoreInt(Minute, 2);\r\n            'S': if isInterval then\r\n\t           StoreInt(Second + (Minute + (Hour + trunc(abs(DateTime))*24)*60)*60, 0)\r\n\t         else\r\n\t         if Count = 1 then\r\n                   StoreInt(Second, 0)\r\n                 else\r\n                   StoreInt(Second, 2);\r\n            'Z': if Count = 1 then\r\n                   StoreInt(MilliSecond, 0)\r\n                 else\r\n\t\t   StoreInt(MilliSecond, 3);\r\n            'T': if Count = 1 then\r\n\t\t   StoreFormat(aSettings.ShortTimeFormat, Nesting+1, True)\r\n                 else\r\n\t           StoreFormat(aSettings.LongTimeFormat, Nesting+1, True);\r\n            'C': begin\r\n                   StoreFormat(aSettings.ShortDateFormat, Nesting+1, False);\r\n                   if (Hour<>0) or (Minute<>0) or (Second<>0) then\r\n                     begin\r\n                      StoreString(' ');\r\n                      StoreFormat(aSettings.LongTimeFormat, Nesting+1, True);\r\n                     end;\r\n                 end;\r\n            'F': begin\r\n                   StoreFormat(aSettings.ShortDateFormat, Nesting+1, False);\r\n                   StoreString(' ');\r\n                   StoreFormat(aSettings.LongTimeFormat, Nesting+1, True);\r\n                 end;\r\n          end;\r\n\t  prevlasttoken := lastformattoken;\r\n          lastformattoken := token;\r\n        end;\r\n        else\r\n          StoreString(Token);\r\n      end ;\r\n      Inc(FormatCurrent, Count);\r\n    end;\r\n  end;\r\n\r\nbegin\r\n  DecodeDateFully(DateTime, Year, Month, Day, DayOfWeek);\r\n  DecodeTime(DateTime, Hour, Minute, Second, MilliSecond);\r\n  // Writeln(DateTime,'->',Year,',', Month, ',',Day, ',',DayOfWeek,',',Hour, ',',Minute, ',',Second, ',',MilliSecond);\r\n  if aFormatStr <> '' then\r\n    StoreFormat(aFormatStr, 0, False)\r\n  else\r\n    StoreFormat('C', 0, False);\r\nend ;\r\n\r\n\r\nfunction CurrentYear: Word;\r\n\r\nbegin\r\n  Result:=TJSDate.New().FullYear;\r\nend;\r\n\r\nfunction TryStrToDate(const S: String; out Value: TDateTime): Boolean;\r\nbegin\r\n  Result:=TryStrToDate(S,Value,FormatSettings);\r\nend;\r\n\r\nfunction TryStrToDate(const S: String; out Value: TDateTime; separator : char): Boolean;\r\n\r\nbegin\r\n  Result:=TryStrToDate(S,Value,FormatSettings.ShortDateFormat,Separator);\r\nend;\r\n\r\nfunction TryStrToDate(const S: String; out Value: TDateTime;  const useformat : string; separator : char): Boolean;\r\n\r\nVar\r\n  Msg : String;\r\n\r\nbegin\r\n  Result:=Length(S)<>0;\r\n  If Result then\r\n    begin\r\n    Value:=IntStrToDate(Msg,S,useformat,Separator);\r\n    Result:=(Msg='');\r\n    end;\r\nend;\r\n\r\nfunction TryStrToDate(const S: String; out Value: TDateTime; const aSettings : TFormatSettings): Boolean;\r\n\r\nbegin\r\n  Result:=TryStrToDate(S,Value,aSettings.ShortDateFormat,aSettings.DateSeparator);\r\nend;\r\n\r\nfunction TryStrToTime(const S: String; out Value: TDateTime; aSettings : TFormatSettings): Boolean;\r\n\r\nVar\r\n  Msg : String;\r\n\r\nbegin\r\n  Result:=Length(S)<>0;\r\n  If Result then\r\n    begin\r\n      Value:=IntStrToTime(Msg,S,Length(S),aSettings);\r\n      Result:=(Msg='');\r\n    end;\r\nend;\r\n\r\nfunction TryStrToTime(const S: String; out Value: TDateTime; separator : char): Boolean;\r\n\r\nVar\r\n  Fmt : TFormatSettings;\r\n\r\nbegin\r\n  fmt:=TFormatSettings.Create;\r\n  fmt.TimeSeparator:=Separator;\r\n  Result:=TryStrToTime(S,Value,Fmt);\r\nend;\r\n\r\nfunction TryStrToTime(const S: String; out Value: TDateTime): Boolean;\r\nbegin\r\n  result:=TryStrToTime(S,Value,FormatSettings);\r\nend;\r\n\r\nfunction TryStrToDateTime(const S: String; out Value: TDateTime): Boolean;\r\n\r\nbegin\r\n  Result:=TryStrToDateTime(S,Value,FormatSettings);\r\nend;\r\n\r\nfunction TryStrToDateTime(const S: String; out Value: TDateTime; Const aSettings : TFormatSettings): Boolean;\r\n\r\nvar\r\n  I: integer;\r\n  dtdate, dttime :TDateTime;\r\nbegin\r\n  result:=false;\r\n  I:=Pos(aSettings.TimeSeparator,S);\r\n  If (I>0) then\r\n    begin\r\n      While (I>0) and (S[I]<>' ') do\r\n        Dec(I);\r\n      If I>0 then\r\n        begin\r\n          if not TryStrToDate(Copy(S,1,I-1),dtdate,aSettings) then\r\n            exit;\r\n          if not TryStrToTime(Copy(S,i+1, Length(S)-i),dttime,aSettings) then\r\n            exit;\r\n          Value:=ComposeDateTime(dtdate,dttime);\r\n          result:=true;\r\n        end\r\n      else\r\n         result:=TryStrToTime(s,Value,aSettings);\r\n    end\r\n  else\r\n    result:=TryStrToDate(s,Value,aSettings);\r\nend;\r\n\r\n\r\n\r\nfunction StrToDateDef(const S: String; const Defvalue : TDateTime): TDateTime;\r\nbegin\r\n   result := StrToDateDef(S,DefValue,#0);\r\nend;\r\n\r\nfunction StrToTimeDef(const S: String; const Defvalue : TDateTime): TDateTime;\r\nbegin\r\n   result := StrToTimeDef(S,DefValue,#0);\r\nend;\r\n\r\nfunction StrToDateTimeDef(const S: String; const Defvalue : TDateTime; aSettings : TFormatSettings): TDateTime; overload;\r\nbegin\r\n  if not TryStrToDateTime(s,Result,aSettings) Then\r\n    result:=defvalue;\r\nend;\r\n\r\nfunction StrToDateTimeDef(const S: String; const Defvalue : TDateTime): TDateTime;\r\nbegin\r\n  Result:=StrToDateTimeDef(s,DefValue,FormatSettings);\r\nend;\r\n\r\nfunction StrToDateDef(const S: String; const Defvalue : TDateTime; separator : char): TDateTime;\r\nbegin\r\n  if not TryStrToDate(s,Result, separator) Then\r\n    result:=defvalue;\r\nend;\r\n\r\nfunction StrToTimeDef(const S: String; const Defvalue : TDateTime; separator : char): TDateTime;\r\nbegin\r\n  if not TryStrToTime(s,Result, separator) Then\r\n    result:=defvalue;\r\nend;\r\n\r\nfunction StrToTimeDef(const AString: string; const ADefault: TDateTime;\r\n  const aSettings: TFormatSettings): TDateTime;\r\nbegin\r\n  if not TryStrToTime(AString, Result, aSettings) Then\r\n    Result := ADefault;\r\nend;\r\n\r\nprocedure ReplaceTime(var dati:TDateTime; NewTime : TDateTime);\r\nbegin\r\n  dati:= ComposeDateTime(dati, newtime);\r\nend;\r\n\r\nprocedure ReplaceDate(var DateTime: TDateTime; const NewDate: TDateTime);\r\nvar\r\n  tmp : TDateTime;\r\nbegin\r\n  tmp:=NewDate;\r\n  ReplaceTime(tmp,DateTime);\r\n  DateTime:=tmp;\r\nend;\r\n\r\nfunction FloatToDateTime(const Value: Extended): TDateTime;\r\nbegin\r\n  If (Value<MinDateTime) or (Value>MaxDateTime) then\r\n    Raise EConvertError.CreateFmt (SInvalidDateTime,[FloatToStr(Value)]);\r\n  Result:=Value;\r\nend;\r\n\r\nfunction FloattoCurr(const Value: Extended): Currency;\r\nbegin\r\n  if not TryFloatToCurr(Value, Result) then\r\n    Raise EConvertError.CreateFmt(SInvalidCurrency, [FloatToStr(Value)]);\r\nend;\r\n\r\nfunction TryFloatToCurr(const Value: Extended; var AResult: Currency): Boolean;\r\nbegin\r\n  Result:=(Value>=MinCurrency) and (Value<=MaxCurrency);\r\n  if Result then\r\n    AResult := Value;\r\nend;\r\n\r\nfunction CurrToStr(Value: Currency): string;\r\nbegin\r\n  Result:=FloatToStrF(Value,ffGeneral,-1,0,FormatSettings);\r\nend;\r\n\r\n\r\nfunction CurrToStr(Value: Currency; const aSettings: TFormatSettings): string;\r\nbegin\r\n  Result:=FloatToStrF(Value,ffGeneral,-1,0,aSettings);\r\nend;\r\n\r\n\r\nfunction StrToCurr(const S: string): Currency;\r\n\r\nbegin\r\n  if not TryStrToCurr(S,Result) then\r\n    Raise EConvertError.createfmt(SInvalidCurrency,[S]);\r\nend;\r\n\r\nfunction StrToCurr(const S: string; const aSettings: TFormatSettings): Currency;\r\nbegin\r\n  if not TryStrToCurr(S,Result,aSettings) then\r\n    Raise EConvertError.createfmt(SInvalidCurrency,[S]);\r\nend;\r\n\r\nfunction TryStrToCurr(const S: string; out Value: Currency): Boolean;\r\n\r\nVar\r\n  D : Double;\r\n\r\nbegin\r\n  Result:=TryStrToFloat(S,D,FormatSettings);\r\n  if Result then\r\n    Value:=D;\r\nend;\r\n\r\n\r\nfunction TryStrToCurr(const S: string; out Value: Currency; const aSettings: TFormatSettings): Boolean;\r\nVar\r\n  D : Double;\r\n\r\nbegin\r\n  Result:=TryStrToFloat(S,D,aSettings);\r\n  if Result then\r\n    Value:=D;\r\nend;\r\n\r\n\r\nfunction StrToCurrDef(const S: string; Default: Currency): Currency;\r\n\r\nVar\r\n  R : Currency;\r\n\r\nbegin\r\n  if TryStrToCurr(S,R,FormatSettings) then\r\n    Result:=R\r\n  else\r\n    Result:=Default;\r\nend;\r\n\r\n\r\nfunction StrToCurrDef(const S: string; Default: Currency; const aSettings: TFormatSettings): Currency;\r\nVar\r\n  R : Currency;\r\n\r\nbegin\r\n  if TryStrToCurr(S,R,aSettings) then\r\n    Result:=R\r\n  else\r\n    Result:=Default;\r\nend;\r\n\r\n\r\n{ ---------------------------------------------------------------------\r\n  Interface related\r\n  ---------------------------------------------------------------------}\r\nfunction Supports(const Instance: IInterface; const AClass: TClass; out Obj\r\n  ): Boolean;\r\nbegin\r\n  Result := (Instance<>nil) and (Instance.QueryInterface(IObjectInstance,Obj)=S_OK)\r\n     and (TObject(Obj).InheritsFrom(AClass));\r\nend;\r\n\r\nfunction Supports(const Instance: IInterface; const IID: TGuid; out Intf\r\n  ): Boolean;\r\nbegin\r\n  Result:=(Instance<>nil) and (Instance.QueryInterface(IID,Intf)=S_OK);\r\nend;\r\n\r\nfunction Supports(const Instance: TObject; const IID: TGuid; out Intf): Boolean;\r\nbegin\r\n  Result:=(Instance<>nil) and Instance.GetInterface(IID,Intf);\r\nend;\r\n\r\nfunction Supports(const Instance: TObject; const IID: TGuidString; out Intf\r\n  ): Boolean;\r\nbegin\r\n  Result:=(Instance<>nil) and Instance.GetInterfaceByStr(IID,Intf);\r\nend;\r\n\r\nfunction Supports(const Instance: IInterface; const AClass: TClass): Boolean;\r\nvar\r\n  Temp: TObject;\r\nbegin\r\n  Result:=Supports(Instance,AClass,Temp);\r\nend;\r\n\r\nfunction Supports(const Instance: IInterface; const IID: TGuid): Boolean;\r\nvar\r\n  Temp: IInterface;\r\nbegin\r\n  Result:=Supports(Instance,IID,Temp);\r\nend;\r\n\r\nfunction Supports(const Instance: TObject; const IID: TGuid): Boolean;\r\nvar\r\n  Temp: TJSObject;\r\nbegin\r\n  Result:=Supports(Instance,IID,Temp);\r\n  asm\r\n    if (Temp && Temp.$kind==='com') Temp._Release();\r\n  end;\r\nend;\r\n\r\nfunction Supports(const Instance: TObject; const IID: TGuidString): Boolean;\r\nvar\r\n  Temp: TJSObject;\r\nbegin\r\n  Result:=Supports(Instance,IID,Temp);\r\n  asm\r\n    if (Temp && Temp.$kind==='com') Temp._Release();\r\n  end;\r\nend;\r\n\r\nfunction Supports(const AClass: TClass; const IID: TGuid): Boolean;\r\nvar\r\n  maps: JSValue;\r\nbegin\r\n  if AClass=nil then exit(false);\r\n  maps := TJSObject(AClass)['$intfmaps'];\r\n  if not maps then exit(false);\r\n  if TJSObject(maps)[GUIDToString(IID)] then exit(true);\r\n  Result:=false;\r\nend;\r\n\r\nfunction Supports(const AClass: TClass; const IID: TGuidString): Boolean;\r\nvar\r\n  maps: JSValue;\r\nbegin\r\n  if AClass=nil then exit(false);\r\n  maps := TJSObject(AClass)['$intfmaps'];\r\n  if not maps then exit(false);\r\n  if TJSObject(maps)[uppercase(IID)] then exit(true);\r\n  Result:=false;\r\nend;\r\n\r\nfunction TryStringToGUID(const s: string; out Guid: TGuid): Boolean;\r\nvar\r\n  re: TJSRegexp;\r\nbegin\r\n  if Length(s)<>38 then Exit(False);\r\n  re:=TJSRegexp.new('^\\{[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\\}$');\r\n  Result:=re.test(s);\r\n  if not Result then\r\n    begin\r\n    Guid.D1:=0;\r\n    exit;\r\n    end;\r\n  asm\r\n    rtl.strToGUIDR(s,Guid);\r\n  end;\r\n  Result:=true;\r\nend;\r\n\r\nfunction StringToGUID(const S: string): TGuid;\r\nbegin\r\n  if not TryStringToGUID(S, Result) then\r\n    raise EConvertError.CreateFmt(SInvalidGUID, [S]);\r\nend;\r\n\r\nfunction GUIDToString(const guid: TGuid): string;\r\nbegin\r\n  Result:=System.GUIDToString(guid);\r\nend;\r\n\r\nfunction IsEqualGUID(const guid1, guid2: TGuid): Boolean;\r\nvar\r\n  i: integer;\r\nbegin\r\n  if (guid1.D1<>guid2.D1) or (guid1.D2<>guid2.D2) or (guid1.D3<>guid2.D3) then\r\n    exit(false);\r\n  for i:=0 to 7 do if guid1.D4[i]<>guid2.D4[i] then exit(false);\r\n  Result:=true;\r\nend;\r\n\r\nfunction GuidCase(const guid: TGuid; const List: array of TGuid): Integer;\r\nbegin\r\n  for Result := High(List) downto 0 do\r\n    if IsEqualGUID(guid, List[Result]) then\r\n      Exit;\r\n  Result := -1;\r\nend;\r\n\r\nfunction CreateGUID(out GUID: TGUID): Integer;\r\n\r\n  Function R(B: Integer) : NativeInt;\r\n\r\n  Var\r\n    v : NativeInt;\r\n  begin\r\n    v:=Random(256);\r\n    While B>1 do\r\n      begin\r\n      v:=v*256+Random(256);\r\n      Dec(B);\r\n      end;\r\n    Result:=V;\r\n  end;\r\n\r\nVar\r\n  I : Integer;\r\n\r\nbegin\r\n  Result:=0;\r\n  GUID.D1:= R(4);\r\n  GUID.D2:= R(2);\r\n  GUID.D3:= R(2);\r\n  For I:=0 to 7 do\r\n   GUID.D4[I]:=R(1);\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  Integer/Ordinal related\r\n  ---------------------------------------------------------------------}\r\n\r\nfunction TryStrToInt(const S: String; out res: Integer): Boolean;\r\n\r\nVar\r\n  NI : NativeInt;\r\n\r\nbegin\r\n  Result:=TryStrToInt(S,NI);\r\n  Result:=Result and (-2147483648<=NI) and (NI<=2147483647);\r\n  if Result then\r\n    res:=NI;\r\nend;\r\n\r\n\r\nfunction IntTryStrToInt(const S: String; out res: NativeInt; Const aSep : string): Boolean;\r\n\r\nVar\r\n  Radix : Integer = 10;\r\n  N : String;\r\n  J : JSValue;\r\n\r\nbegin\r\n  N:=S;\r\n  // Javascript Parseint allows 1.0 or 1E0 to be an integer, so we must check for this to get the same behaviour as FPC/Delphi.\r\n  if (Pos(aSep,N)<>0) or (Pos('.',N)<>0) then\r\n    exit(False);\r\n  case Copy(N,1,1) of\r\n  '$': Radix:=16;\r\n  '&': Radix:=8;\r\n  '%': Radix:=2;\r\n  end;\r\n  // Check for E after we know radix\r\n  if (Radix<>16) and (Pos('e',LowerCase(N))<>0) then\r\n    exit(False);\r\n  If Radix<>10 then\r\n    Delete(N,1,1);\r\n  J:=parseInt(N,Radix);\r\n  Result:=Not jsIsNan(j);\r\n  if Result then\r\n    res:=NativeInt(J);\r\nend;\r\n\r\nfunction TryStrToInt(const S: String; out res: NativeInt): Boolean;\r\n\r\nbegin\r\n  Result:=IntTryStrToInt(S,res,FormatSettings.DecimalSeparator);\r\nend;\r\n\r\nfunction TryStrToInt(const S: String; out res: NativeInt; Const aSettings : TFormatSettings): Boolean;\r\n\r\nbegin\r\n  Result:=IntTryStrToInt(S,res,aSettings.DecimalSeparator);\r\nend;\r\n\r\nfunction TryStrToInt(const S: String; out res: Integer; Const aSettings : TFormatSettings): Boolean;\r\n\r\nVar\r\n  N : NativeInt;\r\n\r\nbegin\r\n  Result:=IntTryStrToInt(S,N,aSettings.DecimalSeparator);\r\n  if Result then\r\n    if (N<=MaxLongint) then\r\n      Res:=N\r\n    else\r\n      Result:=False;\r\nend;\r\n\r\n\r\nfunction StrToIntDef(const S: String; const aDef: Integer): Integer;\r\n\r\nVar\r\n  R : NativeInt;\r\n\r\nbegin\r\n  if TryStrToInt(S,R) then\r\n    Result:=R\r\n  else\r\n    Result:=aDef;\r\nend;\r\n\r\nfunction StrToIntDef(const S: String; const aDef: NativeInt): NativeInt;\r\n\r\nVar\r\n  R : NativeInt;\r\n\r\nbegin\r\n  if TryStrToInt(S,R) then\r\n    Result:=R\r\n  else\r\n    Result:=aDef;\r\nend;\r\n\r\nfunction StrToInt(const S: String): Integer;\r\n\r\nVar\r\n  R : NativeInt;\r\n\r\nbegin\r\n  if not TryStrToInt(S,R) then\r\n    Raise EConvertError.CreateFmt(SErrInvalidInteger,[S]);\r\n  Result:=R;\r\nend;\r\n\r\nfunction StrToNativeInt(const S: String): NativeInt;\r\n\r\nbegin\r\n  if not TryStrToInt(S,Result) then\r\n    Raise EConvertError.CreateFmt(SErrInvalidInteger,[S]);\r\nend;\r\n\r\nfunction StrToUInt(const s: string): Cardinal;\r\n\r\nbegin\r\n  If not TryStrToUint(S,Result) then\r\n    Raise EConvertError.CreateFmt(SErrInvalidInteger,[S])\r\nend;\r\n\r\nfunction StrToUIntDef(const s: string; aDef : Cardinal): Cardinal;\r\n\r\nbegin\r\n  If not TryStrToUint(S,Result) then\r\n    Result:=aDef;\r\nend;\r\n\r\nfunction UIntToStr(Value: Cardinal): string; \r\n\r\nbegin\r\n  Result:=IntToStr(Value);\r\nend;\r\n\r\nfunction TryStrToUInt(const s: string; out C: Cardinal): Boolean;\r\nVar\r\n  N : NativeInt;\r\nbegin\r\n  Result:=TryStrToInt(S,N);\r\n  Result:=(N>=0) and (N<=high(longword));\r\n  If Result then \r\n    C:=N;\r\nend;\r\n\r\nfunction StrToInt64(const S: String): NativeLargeInt;\r\n\r\nVar\r\n  N : NativeInt;\r\n\r\nbegin\r\n  if not TryStrToInt(S,N) then\r\n    Raise EConvertError.CreateFmt(SErrInvalidInteger,[S]);\r\n  Result:=N;\r\nend;\r\n\r\nfunction TryStrToInt64(const S: String; out res: NativeLargeInt): Boolean;\r\n\r\nVar\r\n  R : nativeint;\r\n\r\nbegin\r\n  Result:=TryStrToInt(S,R);\r\n  If Result then\r\n    Res:=R;\r\nend;\r\n\r\nfunction TryStrToInt64(const S: String; out res: Int64): Boolean;\r\nbegin\r\n  Result:=TryStrToInt64(S,NativeLargeInt(res));\r\nend;\r\n\r\nfunction StrToInt64Def(const S: String; ADefault: NativeLargeInt\r\n  ): NativeLargeInt;\r\n\r\n\r\nbegin\r\n  if not TryStrToInt64(S,Result) then\r\n    Result:=ADefault;\r\nend;\r\n\r\nfunction StrToQWord(const S: String): NativeLargeUInt;\r\n\r\nVar\r\n  N : NativeInt;\r\n\r\nbegin\r\n  if (not TryStrToInt(S,N)) or (N<0) then\r\n    Raise EConvertError.CreateFmt(SErrInvalidInteger,[S]);\r\n  Result:=N;\r\nend;\r\n\r\nfunction TryStrToQWord(const S: String; out res: NativeLargeUInt): Boolean;\r\n\r\nVar\r\n  R : nativeint;\r\n\r\nbegin\r\n  Result:=TryStrToInt(S,R) and (R>=0);\r\n  If Result then\r\n    Res:=R;\r\nend;\r\n\r\nfunction TryStrToQWord(const S: String; out res: QWord): Boolean;\r\nbegin\r\n  Result:=TryStrToQWord(S,NativeLargeUInt(res));\r\nend;\r\n\r\nfunction StrToQWordDef(const S: String; ADefault: NativeLargeUInt\r\n  ): NativeLargeUInt;\r\n\r\nbegin\r\n  if Not TryStrToQword(S,Result) then\r\n    Result:=ADefault;\r\nend;\r\n\r\nfunction StrToUInt64(const S: String): NativeLargeUInt;\r\n\r\nVar\r\n  N : NativeInt;\r\n\r\nbegin\r\n  if (not TryStrToInt(S,N)) or (N<0) then\r\n    Raise EConvertError.CreateFmt(SErrInvalidInteger,[S]);\r\n  Result:=N;\r\nend;\r\n\r\nfunction TryStrToUInt64(const S: String; out res: NativeLargeUInt): Boolean;\r\n\r\nVar\r\n  R : nativeint;\r\n\r\nbegin\r\n  Result:=TryStrToInt(S,R) and (R>=0);\r\n  If Result then\r\n    Res:=R;\r\nend;\r\n\r\nfunction TryStrToUInt64(const S: String; out res: UInt64): Boolean;\r\nbegin\r\n  Result:=TryStrToUInt64(S,NativeLargeUInt(res));\r\nend;\r\n\r\nfunction StrToUInt64Def(const S: String; ADefault: NativeLargeUInt\r\n  ): NativeLargeUInt;\r\n\r\n\r\nbegin\r\n  if Not TryStrToUInt64(S,Result) then\r\n    Result:=ADefault;\r\nend;\r\n\r\nfunction TryStrToDWord(const S: String; out res: DWord): Boolean;\r\n\r\nVar\r\n  R : nativeint;\r\n\r\nbegin\r\n  Result:=TryStrToInt(S,R) and (R>=0) and (R<=DWord($FFFFFFFF));\r\n  If Result then\r\n    Res:=R;\r\nend;\r\n\r\nfunction StrToDWord(const S: String): DWord;\r\n\r\nbegin\r\n  if not TryStrToDWord(S,Result) then\r\n    Raise EConvertError.CreateFmt(SErrInvalidInteger,[S]);\r\nend;\r\n\r\n\r\nfunction StrToDWordDef(const S: String; ADefault: DWord): DWord;\r\n\r\nbegin\r\n  if Not TryStrToDWord(S,Result) then\r\n    Result:=ADefault;\r\nend;\r\n\r\n\r\nfunction IntToHex(Value: NativeInt; Digits: integer): string;\r\n\r\nbegin\r\n//  Result:=HexStr(Value,Digits);     // TestNegLongintHelper  Failed: \"ToHexString\" expected: <FFFE0000> but was: <00-20000> !\r\n  Result:='';\r\n  if Value<0 then\r\n    asm\r\n    if (Value<0) Value = 0xFFFFFFFF + Value + 1;\r\n    end;\r\n  asm\r\n  Result=Value.toString(16);\r\n  end;\r\n  Result:=UpperCase(Result);\r\n  while (Length(Result)<Digits) do\r\n    Result:='0'+Result;\r\nend;\r\n\r\nprocedure InitGlobalFormatSettings;\r\nbegin\r\n  // So the defaults are taken from FormatSettings.\r\n  {$WARN 5043 off}\r\n  FormatSettings:=TFormatSettings.Create;\r\n  TimeSeparator:=FormatSettings.TimeSeparator;\r\n  DateSeparator:=FormatSettings.DateSeparator;\r\n  ShortDateFormat:=FormatSettings.ShortDateFormat;\r\n  LongDateFormat:=FormatSettings.LongDateFormat;\r\n  ShortTimeFormat:=FormatSettings.ShortTimeFormat;\r\n  LongTimeFormat:=FormatSettings.LongTimeFormat;\r\n  DecimalSeparator:=FormatSettings.DecimalSeparator;\r\n  ThousandSeparator:=FormatSettings.ThousandSeparator;\r\n  TimeAMString:=FormatSettings.TimeAMString;\r\n  TimePMString:=FormatSettings.TimePMString;\r\n  CurrencyFormat:=FormatSettings.CurrencyFormat;\r\n  NegCurrFormat:=FormatSettings.NegCurrFormat;\r\n  CurrencyDecimals:=FormatSettings.CurrencyDecimals;\r\n  CurrencyString:=FormatSettings.CurrencyString;\r\nend;\r\n\r\n{ TFormatSettings }\r\n\r\nclass function TFormatSettings.Create: TFormatSettings;\r\nbegin\r\n  Result := Create(GetJSLocale);\r\nend;\r\n\r\nclass function TFormatSettings.Create(const ALocale: string): TFormatSettings;\r\nbegin\r\n  Result.LongDayNames:=DefaultLongDayNames;\r\n  Result.ShortDayNames:=DefaultShortDayNames;\r\n  Result.ShortMonthNames:=DefaultShortMonthNames;\r\n  Result.LongMonthNames:=DefaultLongMonthNames;\r\n  Result.DateTimeToStrFormat[False] := 'c';\r\n  Result.DateTimeToStrFormat[True] := 'f';\r\n  Result.DateSeparator := '-';\r\n  Result.TimeSeparator := ':';\r\n  Result.ShortDateFormat := 'yyyy-mm-dd';\r\n  Result.LongDateFormat := 'ddd, yyyy-mm-dd';\r\n  Result.ShortTimeFormat := 'hh:nn';\r\n  Result.LongTimeFormat := 'hh:nn:ss';\r\n  Result.DecimalSeparator := '.';\r\n  Result.ThousandSeparator := ',';\r\n  Result.TimeAMString := 'AM';\r\n  Result.TimePMString := 'PM';\r\n  Result.TwoDigitYearCenturyWindow := 50;\r\n  Result.CurrencyFormat:=0;\r\n  Result.NegCurrFormat:=0;\r\n  Result.CurrencyDecimals:=2;\r\n  Result.CurrencyString:='$';\r\n\r\n  if Assigned(TFormatSettings.InitLocaleHandler) then\r\n    TFormatSettings.InitLocaleHandler(UpperCase(aLocale),Result);\r\nend;\r\n\r\nclass function TFormatSettings.Invariant: TFormatSettings;\r\nbegin\r\n  Result.CurrencyString := #$00A4;\r\n  Result.CurrencyFormat := 0;\r\n  Result.CurrencyDecimals := 2;\r\n  Result.DateSeparator := '/';\r\n  Result.TimeSeparator := ':';\r\n  Result.ShortDateFormat := 'MM/dd/yyyy';\r\n  Result.LongDateFormat := 'dddd, dd MMMMM yyyy HH:mm:ss';\r\n  Result.TimeAMString := 'AM';\r\n  Result.TimePMString := 'PM';\r\n  Result.ShortTimeFormat := 'HH:mm';\r\n  Result.LongTimeFormat := 'HH:mm:ss';\r\n  Result.ShortMonthNames := DefaultShortMonthNames;\r\n  Result.ShortMonthNames := DefaultShortMonthNames;\r\n  Result.LongMonthNames := DefaultLongMonthNames;\r\n  Result.ShortDayNames := DefaultShortDayNames;\r\n  Result.LongDayNames := DefaultLongDayNames;\r\n  Result.ThousandSeparator := ',';\r\n  Result.DecimalSeparator := '.';\r\n  Result.TwoDigitYearCenturyWindow := 50;\r\n  Result.NegCurrFormat := 0;\r\nend;\r\n\r\nclass constructor TFormatSettings.Init;\r\nbegin\r\n  InitGlobalFormatSettings;\r\nend;\r\n\r\nclass function TFormatSettings.GetJSLocale: string; assembler;\r\nasm\r\n  return Intl.DateTimeFormat().resolvedOptions().locale\r\nend;\r\n\r\nclass function TFormatSettings.GetLocaleDecimalSeparator(const ALocale: string\r\n  ): string; assembler;\r\nasm\r\n  var lNumber = 1.1;\r\n  lNumber = lNumber.toLocaleString(ALocale).substring(1, 2);\r\n  return lNumber;\r\nend;\r\n\r\nclass function TFormatSettings.GetLocaleLongDayName(const ADayOfWeek: Integer;\r\n  const ALocale: string): string; assembler;\r\nasm\r\n  var lBaseDate = new Date(2017, 0, 1); // Sunday\r\n  lBaseDate.setDate(lBaseDate.getDate() + ADayOfWeek - 1);\r\n  return lBaseDate.toLocaleDateString(ALocale, { weekday: 'long' });\r\nend;\r\n\r\nclass function TFormatSettings.GetLocaleLongMonthName(const AMonth: Integer;\r\n  const ALocale: string): string; assembler;\r\nasm\r\n  var lBaseDate = new Date(2017, AMonth - 1, 1);\r\n  return lBaseDate.toLocaleDateString(ALocale, { month: 'long' });\r\nend;\r\n\r\nclass function TFormatSettings.GetLocaleShortDayName(const ADayOfWeek: Integer; const ALocale: string): string;\r\n\r\nVar\r\n  d : TJSDate;\r\n\r\nbegin\r\n  d:=TJSDate.New(2017, 0, 1); // Sunday\r\n  d.Date:=d.Date + ADayOfWeek - 1;\r\n  Result:=d.toLocaleDateString(aLocale, new(['weekday','short']));\r\nend;\r\n\r\nclass function TFormatSettings.GetLocaleShortMonthName(const AMonth: Integer; const ALocale: string): string;\r\nVar\r\n  d : TJSDate;\r\n\r\nbegin\r\n  d:=TJSDate.New(2017, aMonth-1, 1); // Sunday\r\n  Result:=d.toLocaleDateString(aLocale,new(['month','short']));\r\nend;\r\n\r\n\r\n{ ---------------------------------------------------------------------\r\n  FileNames\r\n  ---------------------------------------------------------------------}\r\n\r\nfunction ChangeFileExt(const FileName, Extension: PathStr): PathStr;\r\nvar\r\n  i : longint;\r\n  EndSep : Set of Char;\r\n  SOF : Boolean;\r\n\r\nbegin\r\n  i := Length(FileName);\r\n  EndSep:=AllowDirectorySeparators+AllowDriveSeparators+[ExtensionSeparator];\r\n  while (I > 0) and not(FileName[I] in EndSep) do\r\n    Dec(I);\r\n  if (I = 0) or (FileName[I] <> ExtensionSeparator) then\r\n    I := Length(FileName)+1\r\n  else\r\n    begin\r\n        SOF:=(I=1) or (FileName[i-1] in AllowDirectorySeparators);\r\n        if (SOF) and not FirstDotAtFileNameStartIsExtension then\r\n          I:=Length(FileName)+1;\r\n        end;\r\n  Result := Copy(FileName, 1, I - 1) + Extension;\r\nend;\r\n\r\nfunction ExtractFilePath(const FileName: PathStr): PathStr;\r\nvar\r\n  i : longint;\r\n  EndSep : Set of Char;\r\nbegin\r\n  i := Length(FileName);\r\n  EndSep:=AllowDirectorySeparators+AllowDriveSeparators;\r\n  while (i > 0) and not CharInSet(FileName[i],EndSep) do\r\n    Dec(i);\r\n  If I>0 then\r\n    Result := Copy(FileName, 1, i)\r\n  else\r\n    Result:='';\r\nend;\r\n\r\nfunction ExtractFileDir(const FileName: PathStr): PathStr;\r\nvar\r\n  i : longint;\r\n  EndSep : Set of Char;\r\nbegin\r\n  I := Length(FileName);\r\n  EndSep:=AllowDirectorySeparators+AllowDriveSeparators;\r\n  while (I > 0) and not CharInSet(FileName[I],EndSep) do\r\n    Dec(I);\r\n  if (I > 1) and CharInSet(FileName[I],AllowDirectorySeparators) and\r\n     not CharInSet(FileName[I - 1],EndSep) then\r\n    Dec(I);\r\n  Result := Copy(FileName, 1, I);\r\nend;\r\n\r\nfunction ExtractFileDrive(const FileName: PathStr): PathStr;\r\nvar\r\n  i,l: longint;\r\nbegin\r\n  Result := '';\r\n  l:=Length(FileName);\r\n  if (l<2) then\r\n    exit;\r\n  If CharInSet(FileName[2],AllowDriveSeparators) then\r\n    result:=Copy(FileName,1,2)\r\n  else if CharInSet(FileName[1],AllowDirectorySeparators) and\r\n          CharInSet(FileName[2],AllowDirectorySeparators) then\r\n    begin\r\n      i := 2;\r\n\r\n      { skip share }\r\n      While (i<l) and Not CharInSet(Filename[i+1],AllowDirectorySeparators) do\r\n        inc(i);\r\n      inc(i);\r\n\r\n      While (i<l) and Not CharInSet(Filename[i+1],AllowDirectorySeparators) do\r\n        inc(i);\r\n      Result:=Copy(FileName,1,i);\r\n    end;\r\nend;\r\n\r\nfunction ExtractFileName(const FileName: PathStr): PathStr;\r\nvar\r\n  i : longint;\r\n  EndSep : Set of Char;\r\nbegin\r\n  I := Length(FileName);\r\n  EndSep:=AllowDirectorySeparators+AllowDriveSeparators;\r\n  while (I > 0) and not CharInSet(FileName[I],EndSep) do\r\n    Dec(I);\r\n  Result := Copy(FileName, I + 1, MaxInt);\r\nend;\r\n\r\nfunction ExtractFileExt(const FileName: PathStr): PathStr;\r\nvar\r\n  i : longint;\r\n  EndSep : Set of Char;\r\n  SOF : Boolean; // Dot at Start of filename ?\r\n\r\nbegin\r\n  Result:='';\r\n  I := Length(FileName);\r\n  EndSep:=AllowDirectorySeparators+AllowDriveSeparators+[ExtensionSeparator];\r\n  while (I > 0) and not CharInSet(FileName[I],EndSep) do\r\n    Dec(I);\r\n  if (I > 0) and (FileName[I] = ExtensionSeparator) then\r\n    begin\r\n        SOF:=(I=1) or (FileName[i-1] in AllowDirectorySeparators);\r\n        if (Not SOF) or FirstDotAtFileNameStartIsExtension then\r\n          Result := Copy(FileName, I, MaxInt);\r\n        end\r\n  else\r\n    Result := '';\r\nend;\r\n\r\nfunction ExtractRelativepath(const BaseName, DestName: PathStr): PathStr;\r\n\r\nVar\r\n  OneLevelBack,Source, Dest   : PathStr;\r\n  Sc,Dc,I,J      : Longint;\r\n  SD,DD          : TPathStrArray;\r\n\r\n\r\nbegin\r\n  OneLevelBack := '..'+PathDelim;\r\n  If Uppercase(ExtractFileDrive(BaseName))<>Uppercase(ExtractFileDrive(DestName)) Then\r\n    begin\r\n    Result:=DestName;\r\n    exit;\r\n    end;\r\n  Source:=ExcludeTrailingPathDelimiter(ExtractFilePath(BaseName));\r\n  Dest:=ExcludeTrailingPathDelimiter(ExtractFilePath(DestName));\r\n  SD:=GetDirs (Source);\r\n  SC:=Length(SD);\r\n  DD:=GetDirs (Dest);\r\n  DC:=Length(SD);\r\n  I:=0;\r\n  While (I<DC) and (I<SC) do\r\n    begin\r\n    If SameText(DD[i],SD[i]) then\r\n      Inc(i)\r\n    else\r\n      Break;\r\n    end;\r\n  Result:='';\r\n  For J:=I to SC do Result:=Result+OneLevelBack;\r\n  For J:=I to DC do Result:=Result+DD[J]+PathDelim;\r\n  Result:=Result+ExtractFileName(DestName);\r\nend;\r\n\r\nfunction SetDirSeparators(const FileName: PathStr): PathStr;\r\n\r\nVar\r\n  I : integer;\r\n\r\nbegin\r\n  Result:=FileName;\r\n  For I:=1 to Length(Result) do\r\n    If CharInSet(Result[I],AllowDirectorySeparators) then\r\n      Result[i]:=PathDelim;\r\nend;\r\n\r\nfunction GetDirs(DirName: PathStr): TPathStrArray;\r\n\r\nVar\r\n  I,J,L : Longint;\r\n  D : String;\r\n\r\nbegin\r\n  I:=1;\r\n  J:=0;\r\n  L:=0;\r\n  SetLength(Result,Length(DirName));\r\n  While I<=Length(DirName) do\r\n    begin\r\n    If CharInSet(DirName[i],AllowDirectorySeparators) then\r\n      begin\r\n      D:=Copy(DirName,J+1,J-I);\r\n      if (D<>'') then\r\n        begin\r\n        Result[L]:=D;\r\n        Inc(L);\r\n        end;\r\n      J:=I;\r\n      end;\r\n    Inc(I);\r\n    end;\r\n  SetLength(Result,L);\r\nend;\r\n\r\nfunction IncludeTrailingPathDelimiter(const Path: PathStr): PathStr;\r\n\r\nVar\r\n  l : Integer;\r\n\r\nbegin\r\n  Result:=Path;\r\n  l:=Length(Result);\r\n  If (L=0) or not CharInSet(Result[l],AllowDirectorySeparators) then\r\n    Result:=Result+PathDelim;\r\nend;\r\n\r\nfunction ExcludeTrailingPathDelimiter(const Path: PathStr): PathStr;\r\n\r\nVar\r\n  L : Integer;\r\n\r\nbegin\r\n  L:=Length(Path);\r\n  If (L>0) and CharInSet(Path[L],AllowDirectorySeparators) then\r\n    Dec(L);\r\n  Result:=Copy(Path,1,L);\r\nend;\r\n\r\nfunction IncludeLeadingPathDelimiter(const Path: PathStr): PathStr;\r\n\r\nVar\r\n  l : Integer;\r\n\r\nbegin\r\n  Result:=Path;\r\n  l:=Length(Result);\r\n  If (L=0) or not CharInSet(Result[1],AllowDirectorySeparators) then\r\n    Result:=PathDelim+Result;\r\nend;\r\n\r\nfunction ExcludeLeadingPathDelimiter(const Path: PathStr): PathStr;\r\n\r\nVar\r\n  L : Integer;\r\n\r\nbegin\r\n  Result:=Path;\r\n  L:=Length(Result);\r\n  If (L>0) and CharInSet(Result[1],AllowDirectorySeparators) then\r\n    Delete(Result,1,1);\r\nend;\r\n\r\nfunction IsPathDelimiter(const Path: PathStr; Index: Integer): Boolean;\r\n\r\nbegin\r\n  Result:=(Index>0) and (Index<=Length(Path)) and CharInSet(Path[Index],AllowDirectorySeparators);\r\nend;\r\n\r\nfunction ConcatPaths(const Paths: array of PathStr): PathStr;\r\nvar\r\n  I: Integer;\r\nbegin\r\n  if Length(Paths) > 0 then\r\n  begin\r\n    Result := Paths[0];\r\n    for I := 1 to Length(Paths) - 1 do\r\n      Result := IncludeTrailingPathDelimiter(Result) + ExcludeLeadingPathDelimiter(Paths[I]);\r\n  end else\r\n    Result := '';\r\nend;\r\n\r\nFunction EncodeHTMLEntities (S : String) : String;\r\n\r\nbegin\r\n  Result:='';\r\n  if S='' then exit;\r\n  asm\r\n   return S.replace(/[\\u00A0-\\u9999<>\\&]/gim, function(i) {\r\n     return '&#'+i.charCodeAt(0)+';';\r\n   });\r\n  end;\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  Type helpers implementation\r\n  ---------------------------------------------------------------------}\r\n\r\n{ ---------------------------------------------------------------------\r\n  TGUIDHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nProcedure NotImplemented(S : String);\r\n\r\nbegin\r\n  Raise Exception.Create('Not yet implemented : '+S);\r\nend;\r\n\r\nclass function TGuidHelper.Create(Src: TGUID; BigEndian: Boolean): TGUID;\r\nbegin\r\n  Result:=Src;\r\n  if Not Bigendian then\r\n    begin\r\n    Result.D1:=SwapEndian(Result.D1);\r\n    Result.D2:=SwapEndian(Result.D2);\r\n    Result.D3:=SwapEndian(Result.D3);\r\n    end;\r\nend;\r\n\r\nclass function TGuidHelper.Create(const Buf: TJSArrayBuffer; AStartIndex: Cardinal; BigEndian: Boolean): TGUID;\r\n\r\nVar\r\n  A : Cardinal;\r\n  B,C : Word;\r\n  V : TJSDataView;\r\n\r\nbegin\r\n  V:=TJSDataView.New(Buf);\r\n  // The get functions return by default correct endianness.\r\n  if BigEndian then\r\n    begin\r\n    A:=V.getUint32(aStartIndex);\r\n    B:=V.getUint16(AStartIndex+4);\r\n    C:=V.getUint16(AStartIndex+6);\r\n    end\r\n  else\r\n    begin\r\n    A:=SwapEndian(V.getUint32(aStartIndex));\r\n    B:=SwapEndian(V.getUint16(AStartIndex+4));\r\n    C:=SwapEndian(V.getUint16(AStartIndex+6));\r\n    end;\r\n  Result:=Create(A,B,C,V.GetUint8(AStartIndex+8),V.GetUint8(AStartIndex+9),V.GetUint8(AStartIndex+10),V.GetUint8(AStartIndex+11),V.GetUint8(AStartIndex+12),V.GetUint8(AStartIndex+13),V.GetUint8(AStartIndex+14),V.GetUint8(AStartIndex+15));\r\nend;\r\n\r\n\r\nclass function TGuidHelper.Create(const Data: array of Byte; AStartIndex: Cardinal; BigEndian: Boolean): TGUID;\r\n\r\nVar\r\n  D : TJSUint8Array;\r\n\r\nbegin\r\n  if ((System.Length(Data)-AStartIndex)<16) then\r\n    raise EArgumentException.CreateFmt('The length of a GUID array must be at least %d',[]);\r\n  D:=TJSUint8Array.From(Data);\r\n  Result:=Create(D.buffer,aStartIndex,BigEndian);\r\nend;\r\n\r\n\r\nclass function TGuidHelper.Create(const B: TBytes; DataEndian: TEndian): TGUID;\r\n\r\nbegin\r\n  Result:=Create(B,0,DataEndian);\r\nend;\r\n\r\nclass function TGuidHelper.Create(const B: TBytes; AStartIndex: Cardinal; DataEndian: TEndian): TGUID;\r\n\r\nbegin\r\n  if ((System.Length(B)-AStartIndex)<16) then\r\n    raise EArgumentException.CreateFmt('The length of a GUID array must be at least %d',[]);\r\n  Result:=Create(B,AStartIndex,DataEndian=TEndian.Big);\r\nend;\r\n\r\nclass function TGuidHelper.Create(const S: string): TGUID;\r\n\r\nbegin\r\n  Result:=StringToGUID(S);\r\nend;\r\n\r\nclass function TGuidHelper.Create(A: Integer; B: SmallInt; C: SmallInt; const D: TBytes): TGUID;\r\n\r\nbegin\r\n  if (System.Length(D)<>8) then\r\n    raise EArgumentException.CreateFmt('The length of a GUID array must be %d',[]);\r\n  Result:=Create(Cardinal(A),Word(B),Word(C),D[0],D[1],D[2],D[3],D[4],D[5],D[6],D[7]);\r\nend;\r\n\r\n(*\r\nclass function TGuidHelper.Create(A: Integer; B: SmallInt; C: SmallInt; D, E, F, G, H, I, J, K: Byte): TGUID;\r\n\r\nbegin\r\n  Result:=Create(Cardinal(A),Word(B),Word(C),D,E,F,G,H,I,J,K);\r\nend;\r\n*)\r\nclass function TGuidHelper.Create(A: Cardinal; B: Word; C: Word; D, E, F, G, H, I, J, K: Byte): TGUID;\r\n\r\nbegin\r\n  Result.D1 := Cardinal(A);\r\n  Result.D2 := Word(B);\r\n  Result.D3 := Word(C);\r\n  Result.D4[0] := D;\r\n  Result.D4[1] := E;\r\n  Result.D4[2] := F;\r\n  Result.D4[3] := G;\r\n  Result.D4[4] := H;\r\n  Result.D4[5] := I;\r\n  Result.D4[6] := J;\r\n  Result.D4[7] := K;\r\nend;\r\n\r\nclass function TGuidHelper.NewGuid: TGUID;\r\n\r\nbegin\r\n  CreateGUID(Result)\r\nend;\r\n\r\nclass function TGuidHelper.Empty: TGUID;\r\nbegin\r\n  Result:=Default(TGUID);\r\nend;\r\n\r\nfunction TGuidHelper.ToByteArray(DataEndian: TEndian): TBytes;\r\n\r\nVar\r\n  D : TJSUint8Array;\r\n  V : TJSDataView;\r\n  I : Integer;\r\n\r\nbegin\r\n  D:=TJSUint8array.New(16);\r\n  V:=TJSDataView.New(D.buffer);\r\n  V.setUint32(0,D1,DataEndian=TEndian.Little);\r\n  V.setUint16(4,D2,DataEndian=TEndian.Little);\r\n  V.setUint16(6,D3,DataEndian=TEndian.Little);\r\n  for I:=0 to 7 do\r\n    V.setUint8(8+I,D4[i]);\r\n  SetLength(Result, 16);\r\n  for I:=0 to 15 do\r\n    Result[i]:=V.getUint8(I);\r\nend;\r\n\r\nfunction TGuidHelper.ToString(SkipBrackets: Boolean): string;\r\n\r\nbegin\r\n  Result:=GuidToString(Self);\r\n  If SkipBrackets then\r\n    Result:=Copy(Result,2,Length(Result)-2);\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  TStringHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nFunction HaveChar(AChar : Char; const AList: array of Char) : Boolean;\r\n\r\nVar\r\n  I : SizeInt;\r\n\r\nbegin\r\n  I:=0;\r\n  Result:=False;\r\n  While (Not Result) and (I<Length(AList)) do\r\n    begin\r\n    Result:=(AList[i]=AChar);\r\n    Inc(I);\r\n    end;\r\nend;\r\n\r\nfunction TStringHelper.GetChar(AIndex: SizeInt): Char;\r\nbegin\r\n  Result:=Self[AIndex+1];\r\nend;\r\n\r\n\r\nfunction TStringHelper.GetLength: SizeInt;\r\n\r\nbegin\r\n  Result:=System.Length(Self);\r\nend;\r\n\r\n\r\nclass function TStringHelper.Compare(const A: string; const B: string): Integer;\r\nbegin\r\n  Result:=Compare(A,0,B,0,System.Length(B),[]);\r\nend;\r\n\r\n\r\nclass function TStringHelper.Compare(const A: string; const B: string;\r\n  IgnoreCase: Boolean): Integer; //deprecated 'Use same with TCompareOptions';\r\nbegin\r\n  if IgnoreCase then\r\n    Result:=Compare(A,B,[coIgnoreCase])\r\n  else\r\n    Result:=Compare(A,B,[]);\r\nend;\r\n\r\n\r\nclass function TStringHelper.Compare(const A: string; const B: string;\r\n  Options: TCompareOptions): Integer;\r\nbegin\r\n  Result:=Compare(A,0,B,0,System.Length(B),Options);\r\nend;\r\n\r\n\r\nclass function TStringHelper.Compare(const A: string; IndexA: SizeInt;\r\n  const B: string; IndexB: SizeInt; ALen: SizeInt): Integer;\r\nbegin\r\n  Result:=Compare(A,IndexA,B,IndexB,ALen,[]);\r\nend;\r\n\r\n\r\nclass function TStringHelper.Compare(const A: string; IndexA: SizeInt;\r\n  const B: string; IndexB: SizeInt; ALen: SizeInt; IgnoreCase: Boolean\r\n  ): Integer; //deprecated 'Use same with TCompareOptions';\r\nbegin\r\n  if IgnoreCase then\r\n    Result:=Compare(A,IndexA,B,IndexB,ALen,[coIgnoreCase])\r\n  else\r\n    Result:=Compare(A,IndexA,B,IndexB,ALen,[])\r\nend;\r\n\r\n\r\nclass function TStringHelper.Compare(const A: string; IndexA: SizeInt;\r\n  const B: string; IndexB: SizeInt; ALen: SizeInt; Options: TCompareOptions\r\n  ): Integer;\r\n\r\nVar\r\n  AL,BL : String;\r\n\r\nbegin\r\n  AL:=System.Copy(A,IndexA+1,aLen);\r\n  BL:=System.Copy(B,IndexB+1,aLen);\r\n  if (coIgnoreCase in Options) then\r\n    Result:=TJSString(UpperCase(AL)).localeCompare(UpperCase(BL))\r\n  else\r\n    Result:=TJSString(AL).localeCompare(BL)\r\nend;\r\n\r\n\r\nclass function TStringHelper.CompareOrdinal(const A: string; const B: string\r\n  ): Integer;\r\n\r\nVar\r\n  L : SizeInt;\r\n\r\nbegin\r\n  L:=System.Length(B);\r\n  if L>System.Length(A) then\r\n    L:=System.Length(A);\r\n  Result:=CompareOrdinal(A,0,B,0,L);\r\nend;\r\n\r\n\r\nclass function TStringHelper.CompareOrdinal(const A: string; IndexA: SizeInt;\r\n  const B: string; IndexB: SizeInt; ALen: SizeInt): Integer;\r\n\r\nVar\r\n  I,M : integer;\r\n\r\nbegin\r\n  M:=System.Length(A)-IndexA;\r\n  If M>(System.Length(B)-IndexB) then\r\n    M:=(System.Length(B)-IndexB);\r\n  if M>aLen then\r\n    M:=aLen;\r\n  I:=0;\r\n  Result:=0;\r\n  While (Result=0) and (I<M) do\r\n    begin\r\n    Result:=TJSString(A).charCodeAt(IndexA+I)-TJSString(B).charCodeAt(IndexB+I);\r\n    Inc(I);\r\n    end;\r\nend;\r\n\r\n\r\nclass function TStringHelper.CompareText(const A: string; const B: string\r\n  ): Integer;\r\nbegin\r\n  Result:={$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}SysUtils.CompareText(A,B);\r\nend;\r\n\r\n\r\nclass function TStringHelper.Copy(const Str: string): string;\r\nbegin\r\n  Result:=Str;\r\nend;\r\n\r\n\r\nclass function TStringHelper.Create(AChar: Char; ACount: SizeInt): string;\r\nbegin\r\n   Result:=StringOfChar(AChar,ACount);\r\nend;\r\n\r\n\r\nclass function TStringHelper.Create(const AValue: array of Char): string;\r\n\r\nbegin\r\n  Result:=Create(AValue,0,System.Length(AValue));\r\nend;\r\n\r\n\r\nclass function TStringHelper.Create(const AValue: array of Char;\r\n  StartIndex: SizeInt; ALen: SizeInt): string;\r\nVar\r\n  I : Integer;\r\nbegin\r\n  SetLength(Result,ALen);\r\n  For I:=1 to ALen do\r\n    Result[I]:=AValue[StartIndex+I-1];\r\nend;\r\n\r\n\r\nclass function TStringHelper.EndsText(const ASubText, AText: string): Boolean;\r\nbegin\r\n  Result:=(ASubText<>'') and ({$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}SysUtils.CompareText(System.Copy(AText,System.Length(AText)-System.Length(ASubText)+1,System.Length(ASubText)),ASubText)=0);\r\nend;\r\n\r\n\r\nclass function TStringHelper.Equals(const a: string; const b: string): Boolean;\r\nbegin\r\n  Result:=A=B;\r\nend;\r\n\r\n\r\nclass function TStringHelper.Format(const AFormat: string; const args: array of const): string;\r\nbegin\r\n  Result:={$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}SysUtils.Format(AFormat,Args);\r\nend;\r\n\r\n\r\nclass function TStringHelper.IsNullOrEmpty(const AValue: string): Boolean;\r\nbegin\r\n  Result:=system.Length(AValue)=0;\r\nend;\r\n\r\n\r\nclass function TStringHelper.IsNullOrWhiteSpace(const AValue: string): Boolean;\r\nbegin\r\n  Result:=system.Length({$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}SysUtils.Trim(AValue))=0;\r\nend;\r\n\r\n\r\nclass function TStringHelper.Join(const Separator: string; const Values: array of const): string;\r\n\r\nbegin\r\n  Result:=TJSArray(Values).Join(Separator);\r\nend;\r\n\r\nclass function TStringHelper.Join(const Separator: string;\r\n  const Values: array of string): string;\r\nbegin\r\n  Result:=TJSArray(Values).Join(Separator);\r\nend;\r\n\r\n\r\nclass function TStringHelper.Join(const Separator: string;\r\n  const Values: array of string; StartIndex: SizeInt; ACount: SizeInt): string;\r\n\r\nVar\r\n  VLen : SizeInt;\r\n\r\nbegin\r\n  VLen:=High(Values);\r\n  If (ACount<0) or ((StartIndex>0) and (StartIndex>VLen)) then\r\n    raise ERangeError.Create(SRangeError);\r\n  If (ACount=0) or (VLen<0) then\r\n    Result:=''\r\n  else\r\n    Result:=TJSArray(Values).Slice(StartIndex,StartIndex+aCount).Join(Separator);\r\nend;\r\n\r\n\r\nclass function TStringHelper.LowerCase(const S: string): string;\r\nbegin\r\n  Result:={$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}SysUtils.Lowercase(S);\r\nend;\r\n\r\n\r\nclass function TStringHelper.Parse(const AValue: Boolean): string;\r\nbegin\r\n  Result:=BoolToStr(AValue);\r\nend;\r\n\r\n\r\nclass function TStringHelper.Parse(const AValue: Extended): string;\r\nbegin\r\n  Result:=FloatToStr(AValue);\r\nend;\r\n\r\n\r\nclass function TStringHelper.Parse(const AValue: NativeInt): string;\r\nbegin\r\n  Result:=IntToStr(AValue);\r\nend;\r\n\r\n\r\nclass function TStringHelper.Parse(const AValue: Integer): string;\r\nbegin\r\n  Result:=IntToStr(AValue);\r\nend;\r\n\r\n\r\nclass function TStringHelper.ToBoolean(const S: string): Boolean;\r\nbegin\r\n  Result:=StrToBool(S);\r\nend;\r\n\r\n\r\nclass function TStringHelper.ToDouble(const S: string): Double;\r\nbegin\r\n  Result:=StrToFloat(S);\r\nend;\r\n\r\n\r\nclass function TStringHelper.ToExtended(const S: string): Extended;\r\nbegin\r\n  Result:=StrToFloat(S);\r\nend;\r\n\r\n\r\nclass function TStringHelper.ToNativeInt(const S: string): NativeInt;\r\nbegin\r\n  Result:=StrToInt64(S);\r\nend;\r\n\r\n\r\nclass function TStringHelper.ToInteger(const S: string): Integer;\r\nbegin\r\n  Result:=StrToInt(S);\r\nend;\r\n\r\n\r\nclass function TStringHelper.UpperCase(const S: string): string;\r\nbegin\r\n  Result:={$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}SysUtils.Uppercase(S);\r\nend;\r\n\r\nclass function TStringHelper.ToCharArray(const S: String): TCharArray;\r\n\r\nVar\r\n  I,Len: integer;\r\n\r\nbegin\r\n  Len:=System.Length(S);\r\n  SetLength(Result,Len);\r\n  For I:=1 to Len do\r\n    Result[I-1]:=S[I];\r\nend;\r\n\r\nfunction TStringHelper.CompareTo(const B: string): Integer;\r\nbegin\r\n  // Order is important\r\n  Result:=Compare(Self,B);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Contains(const AValue: string): Boolean;\r\nbegin\r\n  Result:=(AValue<>'') and (Pos(AValue,Self)>0);\r\nend;\r\n\r\n\r\nfunction TStringHelper.CountChar(const C: Char): SizeInt;\r\n\r\nVar\r\n  S : Char;\r\nbegin\r\n  Result:=0;\r\n  For S in Self do\r\n    if (S=C) then\r\n      Inc(Result);\r\nend;\r\n\r\n\r\nfunction TStringHelper.DeQuotedString: string;\r\nbegin\r\n  Result:=DeQuotedString('''');\r\nend;\r\n\r\n\r\nfunction TStringHelper.DeQuotedString(const AQuoteChar: Char): string;\r\n\r\nvar\r\n  L,I : SizeInt;\r\n  Res : Array of Char;\r\n  PS,PD : SizeInt;\r\n  IsQuote : Boolean;\r\n\r\nbegin\r\n  L:=System.Length(Self);\r\n  if (L<2) or Not ((Self[1]=AQuoteChar) and (Self[L]=AQuoteChar)) then\r\n    Exit(Self);\r\n  SetLength(Res,L);\r\n  IsQuote:=False;\r\n  PS:=2;\r\n  PD:=1;\r\n  For I:=2 to L-1 do\r\n    begin\r\n    if (Self[PS]=AQuoteChar) then\r\n      begin\r\n      IsQuote:=Not IsQuote;\r\n      if Not IsQuote then\r\n        begin\r\n        Result[PD]:=Self[PS];\r\n        Inc(PD);\r\n        end;\r\n      end\r\n    else\r\n      begin\r\n      if IsQuote then\r\n        IsQuote:=false;\r\n      Result[PD]:=Self[PS];\r\n      Inc(PD);\r\n      end;\r\n    Inc(PS);\r\n    end;\r\n  SetLength(Result,PD-1);\r\nend;\r\n\r\n\r\nfunction TStringHelper.EndsWith(const AValue: string): Boolean;\r\nbegin\r\n  Result:=EndsWith(AValue,False);\r\nend;\r\n\r\n\r\nfunction TStringHelper.EndsWith(const AValue: string; IgnoreCase: Boolean): Boolean;\r\n\r\nVar\r\n  L : SizeInt;\r\n  S : String;\r\n\r\nbegin\r\n  L:=system.Length(AVAlue);\r\n  Result:=L=0;\r\n  if Not Result then\r\n    begin\r\n    S:=system.Copy(Self,Length-L+1,L);\r\n    Result:=system.Length(S)=L;\r\n    if Result then\r\n      if IgnoreCase then\r\n        Result:=CompareText(S,AValue)=0\r\n      else\r\n        Result:=S=AValue;\r\n    end;\r\nend;\r\n\r\n\r\nfunction TStringHelper.Equals(const AValue: string): Boolean;\r\n\r\nbegin\r\n  Result:=(Self=AValue);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Format(const args: array of const): string;\r\n\r\nbegin\r\n  Result:={$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}SysUtils.Format(Self,Args);\r\nend;\r\n\r\n\r\nfunction TStringHelper.GetHashCode: Integer;\r\n\r\n// Taken from contnrs, fphash\r\nvar\r\n  P,pmax : Integer;\r\n  L : TJSString;\r\n\r\nbegin\r\n{$push}\r\n{$Q-}\r\n  L:=TJSString(Self);\r\n  Result:=0;\r\n\r\n  P:=1;\r\n  pmax:=length+1;\r\n  while (p<pmax) do\r\n    begin\r\n    Result:=LongWord(LongInt(Result shl 5) - LongInt(Result)) xor L.CharCodeAt(P);\r\n    Inc(p);\r\n    end;\r\n{$pop}\r\nend;\r\n\r\n\r\nfunction TStringHelper.IndexOf(AValue: Char): SizeInt;\r\nbegin\r\n  Result:=IndexOf(AValue,0,Length);\r\nend;\r\n\r\n\r\nfunction TStringHelper.IndexOf(const AValue: string): SizeInt;\r\nbegin\r\n  Result:=IndexOf(AValue,0,Length);\r\nend;\r\n\r\n\r\nfunction TStringHelper.IndexOf(AValue: Char; StartIndex: SizeInt): SizeInt;\r\nbegin\r\n  Result:=IndexOf(AValue,StartIndex,Length);\r\nend;\r\n\r\n\r\nfunction TStringHelper.IndexOf(const AValue: string; StartIndex: SizeInt\r\n  ): SizeInt;\r\nbegin\r\n  Result:=IndexOf(AValue,StartIndex,Length);\r\nend;\r\n\r\n\r\nfunction TStringHelper.IndexOf(AValue: Char; StartIndex: SizeInt;\r\n  ACount: SizeInt): SizeInt;\r\n\r\nVar\r\n  S : String;\r\n\r\nbegin\r\n  S:=System.Copy(Self,StartIndex+1,ACount);\r\n  Result:=Pos(AValue,S)-1;\r\n  if Result<>-1 then\r\n    Result:=Result+StartIndex;\r\nend;\r\n\r\n\r\nfunction TStringHelper.IndexOf(const AValue: string; StartIndex: SizeInt;\r\n  ACount: SizeInt): SizeInt;\r\n\r\nVar\r\n  S : String;\r\n\r\nbegin\r\n  S:=System.Copy(Self,StartIndex+1,ACount);\r\n  Result:=Pos(AValue,S)-1;\r\n  if Result<>-1 then\r\n    Result:=Result+StartIndex;\r\nend;\r\n\r\nfunction TStringHelper.IndexOfUnQuoted(const AValue: string; StartQuote,\r\n  EndQuote: Char; StartIndex: SizeInt = 0): SizeInt;\r\n\r\nVar\r\n  LV : SizeInt;\r\n  S : String;\r\n\r\n  Function MatchAt(I : SizeInt) : Boolean ; Inline;\r\n\r\n  Var\r\n    J : SizeInt;\r\n\r\n  begin\r\n    J:=1;\r\n    Repeat\r\n      Result:=(S[I+J-1]=AValue[j]);\r\n      Inc(J);\r\n    Until (Not Result) or (J>LV);\r\n  end;\r\n\r\nVar\r\n  I,L,Q: SizeInt;\r\n\r\nbegin\r\n  S:=Self;\r\n  Result:=-1;\r\n  LV:=system.Length(AValue);\r\n  L:=Length-LV+1;\r\n  if L<0 then\r\n    L:=0;\r\n  I:=StartIndex+1;\r\n  Q:=0;\r\n  if StartQuote=EndQuote then\r\n    begin\r\n    While (Result=-1) and (I<=L) do\r\n      begin\r\n      if (S[I]=StartQuote) then\r\n        Q:=1-Q;\r\n      if (Q=0) and MatchAt(i) then\r\n        Result:=I-1;\r\n      Inc(I);\r\n      end;\r\n    end\r\n  else\r\n    begin\r\n    While (Result=-1) and (I<=L) do\r\n      begin\r\n      if S[I]=StartQuote then\r\n        Inc(Q)\r\n      else if (S[I]=EndQuote) and (Q>0) then\r\n        Dec(Q);\r\n      if (Q=0) and MatchAt(i) then\r\n        Result:=I-1;\r\n      Inc(I);\r\n      end;\r\n    end;\r\nend;\r\n\r\nfunction TStringHelper.IndexOfAny(const AnyOf: string): SizeInt;\r\nbegin\r\n  Result:=IndexOfAny(AnyOf.ToCharArray);\r\nend;\r\n\r\n\r\nfunction TStringHelper.IndexOfAny(const AnyOf: array of Char): SizeInt;\r\nbegin\r\n  Result:=IndexOfAny(AnyOf,0,Length);\r\nend;\r\n\r\nfunction TStringHelper.IndexOfAny(const AnyOf: String; StartIndex: SizeInt): SizeInt;\r\nbegin\r\n  Result:=IndexOfAny(AnyOf.ToCharArray,StartIndex);\r\nend;\r\n\r\n\r\nfunction TStringHelper.IndexOfAny(const AnyOf: array of Char;\r\n  StartIndex: SizeInt): SizeInt;\r\nbegin\r\n  Result:=IndexOfAny(AnyOf,StartIndex,Length);\r\nend;\r\n\r\nfunction TStringHelper.IndexOfAny(const AnyOf: String; StartIndex: SizeInt; ACount: SizeInt): SizeInt;\r\nbegin\r\n  Result:=IndexOfAny(AnyOf.ToCharArray,StartIndex,aCount);\r\nend;\r\n\r\nfunction TStringHelper.IndexOfAny(const AnyOf: array of Char;\r\n  StartIndex: SizeInt; ACount: SizeInt): SizeInt;\r\n\r\nVar\r\n  i,L : SizeInt;\r\n\r\nbegin\r\n  I:=StartIndex+1;\r\n  L:=I+ACount-1;\r\n  If L>Length then\r\n    L:=Length;\r\n  Result:=-1;\r\n  While (Result=-1) and (I<=L) do\r\n    begin\r\n    if HaveChar(Self[i],AnyOf) then\r\n      Result:=I-1;\r\n    Inc(I);\r\n    end;\r\nend;\r\n\r\nfunction TStringHelper.IndexOfAny(const AnyOf: array of String): SizeInt;\r\nbegin\r\n  Result:=IndexOfAny(AnyOf,0,Length);\r\nend;\r\n\r\nfunction TStringHelper.IndexOfAny(const AnyOf: array of String;\r\n  StartIndex: SizeInt): SizeInt;\r\nbegin\r\n  Result:=IndexOfAny(AnyOf,StartIndex,Length-StartIndex);\r\nend;\r\n\r\nfunction TStringHelper.IndexOfAny(const AnyOf: array of String;\r\n  StartIndex: SizeInt; ACount: SizeInt): SizeInt;\r\n\r\nVar\r\n  M : SizeInt;\r\n\r\nbegin\r\n  Result:=IndexOfAny(AnyOf,StartIndex,ACount,M);\r\nend;\r\n\r\nfunction TStringHelper.IndexOfAny(const AnyOf: array of String;\r\n  StartIndex: SizeInt; ACount: SizeInt; out AMatch: SizeInt): SizeInt;\r\n\r\nVar\r\n  L,I : SizeInt;\r\n\r\nbegin\r\n  Result:=-1;\r\n  For I:=0 to System.Length(AnyOf)-1 do\r\n    begin\r\n    L:=IndexOf(AnyOf[i],StartIndex,ACount);\r\n    If (L>=0) and ((Result=-1) or (L<Result)) then\r\n      begin\r\n      Result:=L;\r\n      AMatch:=I;\r\n      end;\r\n    end;\r\nend;\r\n\r\n\r\nfunction TStringHelper.IndexOfAnyUnquoted(const AnyOf: array of Char;\r\n  StartQuote, EndQuote: Char): SizeInt;\r\nbegin\r\n  Result:=IndexOfAnyUnquoted(AnyOf,StartQuote,EndQuote,0,Length);\r\nend;\r\n\r\n\r\nfunction TStringHelper.IndexOfAnyUnquoted(const AnyOf: array of Char;\r\n  StartQuote, EndQuote: Char; StartIndex: SizeInt): SizeInt;\r\nbegin\r\n  Result:=IndexOfAnyUnquoted(AnyOf,StartQuote,EndQuote,StartIndex,Length);\r\nend;\r\n\r\n\r\nfunction TStringHelper.IndexOfAnyUnquoted(const AnyOf: array of Char;\r\n  StartQuote, EndQuote: Char; StartIndex: SizeInt; ACount: SizeInt): SizeInt;\r\n\r\nVar\r\n  I,L : SizeInt;\r\n  Q : SizeInt;\r\n\r\nbegin\r\n  Result:=-1;\r\n  L:=StartIndex+ACount-1;\r\n  if L>Length then\r\n    L:=Length;\r\n  I:=StartIndex+1;\r\n  Q:=0;\r\n  if StartQuote=EndQuote then\r\n    begin\r\n    While (Result=-1) and (I<=L) do\r\n      begin\r\n      if (Self[I]=StartQuote) then\r\n        Q:=1-Q;\r\n      if (Q=0) and HaveChar(Self[i],AnyOf) then\r\n        Result:=I-1;\r\n      Inc(I);\r\n      end;\r\n    end\r\n  else\r\n  begin\r\n    While (Result=-1) and (I<=L) do\r\n      begin\r\n      if Self[I]=StartQuote then\r\n        Inc(Q)\r\n      else if (Self[I]=EndQuote) and (Q>0) then\r\n        Dec(Q);\r\n      if (Q=0) and HaveChar(Self[i],AnyOf) then\r\n        Result:=I-1;\r\n      Inc(I);\r\n      end;\r\n    end;\r\n\r\nend;\r\n\r\nfunction TStringHelper.IndexOfAnyUnquoted(const AnyOf: array of string;\r\n  StartQuote, EndQuote: Char; StartIndex: SizeInt; out Matched: SizeInt\r\n  ): SizeInt;\r\n\r\nVar\r\n  L,I : SizeInt;\r\n\r\nbegin\r\n  Result:=-1;\r\n  For I:=0 to System.Length(AnyOf)-1 do\r\n    begin\r\n    L:=IndexOfUnquoted(AnyOf[i],StartQuote,EndQuote,StartIndex);\r\n    If (L>=0) and ((Result=-1) or (L<Result)) then\r\n      begin\r\n      Result:=L;\r\n      Matched:=I;\r\n      end;\r\n    end;\r\nend;\r\n\r\n\r\nfunction TStringHelper.Insert(StartIndex: SizeInt; const AValue: string\r\n  ): string;\r\nbegin\r\n  system.Insert(AValue,Self,StartIndex+1);\r\n  Result:=Self;\r\nend;\r\n\r\n\r\nfunction TStringHelper.IsDelimiter(const Delimiters: string; Index: SizeInt\r\n  ): Boolean;\r\nbegin\r\n  Result:={$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}SysUtils.IsDelimiter(Delimiters,Self,Index+1);\r\nend;\r\n\r\n\r\nfunction TStringHelper.IsEmpty: Boolean;\r\nbegin\r\n  Result:=(Length=0)\r\nend;\r\n\r\n\r\nfunction TStringHelper.LastDelimiter(const Delims: string): SizeInt;\r\nbegin\r\n  Result:={$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}SysUtils.LastDelimiter(Delims,Self)-1;\r\nend;\r\n\r\n\r\nfunction TStringHelper.LastIndexOf(AValue: Char): SizeInt;\r\nbegin\r\n  Result:=LastIndexOf(AValue,Length-1,Length);\r\nend;\r\n\r\n\r\nfunction TStringHelper.LastIndexOf(const AValue: string): SizeInt;\r\nbegin\r\n  Result:=LastIndexOf(AValue,Length-1,Length);\r\nend;\r\n\r\n\r\nfunction TStringHelper.LastIndexOf(AValue: Char; AStartIndex: SizeInt): SizeInt;\r\nbegin\r\n  Result:=LastIndexOf(AValue,AStartIndex,Length);\r\nend;\r\n\r\n\r\nfunction TStringHelper.LastIndexOf(const AValue: string; AStartIndex: SizeInt\r\n  ): SizeInt;\r\nbegin\r\n  Result:=LastIndexOf(AValue,AStartIndex,Length);\r\nend;\r\n\r\n\r\nfunction TStringHelper.LastIndexOf(AValue: Char; AStartIndex: SizeInt;\r\n  ACount: SizeInt): SizeInt;\r\n\r\nVar\r\n  Min : SizeInt;\r\n\r\nbegin\r\n  Result:=AStartIndex+1;\r\n  Min:=Result-ACount+1;\r\n  If Min<1 then\r\n    Min:=1;\r\n  While (Result>=Min) and (Self[Result]<>AValue) do\r\n    Dec(Result);\r\n  if Result<Min then\r\n    Result:=-1\r\n  else\r\n    Result:=Result-1;\r\nend;\r\n\r\n\r\nfunction TStringHelper.LastIndexOf(const AValue: string; AStartIndex: SizeInt; ACount: SizeInt): SizeInt;\r\n\r\nbegin\r\n  Result:=TJSString(Self).lastIndexOf(aValue,aStartIndex);\r\n  if (aStartIndex-Result)>aCount then\r\n    Result:=-1;\r\nend;\r\n\r\n\r\nfunction TStringHelper.LastIndexOfAny(const AnyOf: array of Char): SizeInt;\r\nbegin\r\n  Result:=LastIndexOfAny(AnyOf,Length-1,Length);\r\nend;\r\n\r\n\r\nfunction TStringHelper.LastIndexOfAny(const AnyOf: array of Char;\r\n  AStartIndex: SizeInt): SizeInt;\r\nbegin\r\n  Result:=LastIndexOfAny(AnyOf,AStartIndex,Length);\r\nend;\r\n\r\n\r\nfunction TStringHelper.LastIndexOfAny(const AnyOf: array of Char;\r\n  AStartIndex: SizeInt; ACount: SizeInt): SizeInt;\r\n\r\nVar\r\n  Min : SizeInt;\r\n\r\nbegin\r\n  Result:=AStartIndex+1;\r\n  Min:=Result-ACount+1;\r\n  If Min<1 then\r\n    Min:=1;\r\n  While (Result>=Min) and Not HaveChar(Self[Result],AnyOf) do\r\n    Dec(Result);\r\n  if Result<Min then\r\n    Result:=-1\r\n  else\r\n    Result:=Result-1;\r\nend;\r\n\r\n\r\nfunction TStringHelper.PadLeft(ATotalWidth: SizeInt): string;\r\nbegin\r\n  Result:=PadLeft(ATotalWidth,' ');\r\nend;\r\n\r\n\r\nfunction TStringHelper.PadLeft(ATotalWidth: SizeInt; PaddingChar: Char): string;\r\nVar\r\n  L : SizeInt;\r\n\r\nbegin\r\n  Result:=Self;\r\n  L:=ATotalWidth-Length;\r\n  If L>0 then\r\n    Result:=StringOfChar(PaddingChar,L)+Result;\r\nend;\r\n\r\n\r\nfunction TStringHelper.PadRight(ATotalWidth: SizeInt): string;\r\nbegin\r\n  Result:=PadRight(ATotalWidth,' ');\r\nend;\r\n\r\n\r\nfunction TStringHelper.PadRight(ATotalWidth: SizeInt; PaddingChar: Char\r\n  ): string;\r\n\r\nVar\r\n  L : SizeInt;\r\n\r\nbegin\r\n  Result:=Self;\r\n  L:=ATotalWidth-Length;\r\n  If L>0 then\r\n    Result:=Result+StringOfChar(PaddingChar,L);\r\nend;\r\n\r\n\r\nfunction TStringHelper.QuotedString: string;\r\nbegin\r\n  Result:=QuotedStr(Self);\r\nend;\r\n\r\n\r\nfunction TStringHelper.QuotedString(const AQuoteChar: Char): string;\r\nbegin\r\n  Result:=QuotedStr(Self,AQuoteChar);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Remove(StartIndex: SizeInt): string;\r\nbegin\r\n  Result:=Remove(StartIndex,Self.Length-StartIndex);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Remove(StartIndex: SizeInt; ACount: SizeInt): string;\r\nbegin\r\n  Result:=Self;\r\n  System.Delete(Result,StartIndex+1,ACount);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Replace(OldChar: Char; NewChar: Char): string;\r\nbegin\r\n  Result:=Replace(OldChar,NewChar,[rfReplaceAll]);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Replace(OldChar: Char; NewChar: Char;\r\n  ReplaceFlags: TReplaceFlags): string;\r\nbegin\r\n  Result:=StringReplace(Self,OldChar,NewChar,ReplaceFlags);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Replace(const OldValue: string; const NewValue: string\r\n  ): string;\r\nbegin\r\n  Result:=Replace(OldValue,NewValue,[rfReplaceAll]);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Replace(const OldValue: string; const NewValue: string;\r\n  ReplaceFlags: TReplaceFlags): string;\r\nbegin\r\n  Result:=StringReplace(Self,OldValue,NewValue,ReplaceFlags);\r\nend;\r\n\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: String): TStringArray;\r\nbegin\r\n  Result:=Split(Separators.ToCharArray);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of Char): TStringArray;\r\nbegin\r\n  Result:=Split(Separators,#0,#0,Length+1,TStringSplitOptions.None);\r\nend;\r\n\r\nfunction TStringHelper.Split(const Separators: string; ACount: SizeInt): TStringArray;\r\nbegin\r\n  Result:=Split(Separators.ToCharArray,aCount);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of Char; ACount: SizeInt\r\n  ): TStringArray;\r\nbegin\r\n  Result:=Split(Separators,#0,#0,ACount,TStringSplitOptions.None);\r\nend;\r\n\r\nfunction TStringHelper.Split(const Separators: string; Options: TStringSplitOptions): TStringArray;\r\nbegin\r\n  Result:=Split(Separators.ToCharArray,Options);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of Char;\r\n  Options: TStringSplitOptions): TStringArray;\r\nbegin\r\n  Result:=Split(Separators,Length+1,Options);\r\nend;\r\n\r\nfunction TStringHelper.Split(const Separators: string; ACount: SizeInt; Options: TStringSplitOptions): TStringArray;\r\nbegin\r\n  Result:=Split(Separators.ToCharArray,aCount,Options);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of Char; ACount: SizeInt;\r\n  Options: TStringSplitOptions): TStringArray;\r\nbegin\r\n  Result:=Split(Separators,#0,#0,ACount,Options);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of string): TStringArray;\r\nbegin\r\n  Result:=Split(Separators,Length+1);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of string; ACount: SizeInt\r\n  ): TStringArray;\r\nbegin\r\n  Result:=Split(Separators,ACount,TStringSplitOptions.None);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of string;\r\n  Options: TStringSplitOptions): TStringArray;\r\nbegin\r\n  Result:=Split(Separators,Length+1,Options);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of string;\r\n  ACount: SizeInt; Options: TStringSplitOptions): TStringArray;\r\nbegin\r\n  Result:=Split(Separators,#0,#0,ACount,Options);\r\nend;\r\n\r\nfunction TStringHelper.Split(const Separators: String; AQuote: Char): TStringArray;\r\nbegin\r\n  Result:=Split(Separators.ToCharArray,aQuote);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of Char; AQuote: Char\r\n  ): TStringArray;\r\nbegin\r\n  Result:=Split(Separators,AQuote,AQuote);\r\nend;\r\n\r\nfunction TStringHelper.Split(const Separators: String; AQuoteStart, AQuoteEnd: Char): TStringArray;\r\nbegin\r\n  Result:=Split(Separators.ToCharArray,aQuoteStart,aQuoteEnd);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of Char; AQuoteStart,\r\n  AQuoteEnd: Char): TStringArray;\r\nbegin\r\n  Result:=Split(Separators,AQuoteStart,AQuoteEnd,TStringSplitOptions.None);\r\nend;\r\n\r\nfunction TStringHelper.Split(const Separators: string; AQuoteStart, AQuoteEnd: Char; Options: TStringSplitOptions): TStringArray;\r\nbegin\r\n  Result:=Split(Separators.ToCharArray,aQuoteStart,aQuoteEnd,Options);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of Char; AQuoteStart,\r\n  AQuoteEnd: Char; Options: TStringSplitOptions): TStringArray;\r\nbegin\r\n  Result:=Split(Separators,AQuoteStart,AQuoteEnd,Length+1,Options);\r\nend;\r\n\r\nfunction TStringHelper.Split(const Separators: string; AQuoteStart, AQuoteEnd: Char; ACount: SizeInt): TStringArray;\r\nbegin\r\n  Result:=Split(Separators.ToCharArray,aQuoteStart,aQuoteEnd,aCount);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of Char; AQuoteStart,\r\n  AQuoteEnd: Char; ACount: SizeInt): TStringArray;\r\nbegin\r\n  Result:=Split(Separators,AQuoteStart,AQuoteEnd,ACount,TStringSplitOptions.None);\r\nend;\r\n\r\nfunction TStringHelper.Split(const Separators: string; AQuoteStart, AQuoteEnd: Char; ACount: SizeInt; Options: TStringSplitOptions\r\n  ): TStringArray;\r\nbegin\r\n  Result:=Split(Separators.ToCharArray,aQuoteStart,aQuoteEnd,aCount,Options);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of Char; AQuoteStart,\r\n  AQuoteEnd: Char; ACount: SizeInt; Options: TStringSplitOptions): TStringArray;\r\n\r\n\r\nConst\r\n  BlockSize = 10;\r\n\r\nVar\r\n  S : String;\r\n\r\n  Function NextSep(StartIndex : SizeInt) : SizeInt;\r\n\r\n  begin\r\n    if (AQuoteStart<>#0) then\r\n      Result:=S.IndexOfAnyUnQuoted(Separators,AQuoteStart,AQuoteEnd,StartIndex)\r\n    else\r\n      Result:=S.IndexOfAny(Separators,StartIndex);\r\n  end;\r\n\r\n  Procedure MaybeGrow(Curlen : SizeInt);\r\n\r\n  begin\r\n    if System.Length(Result)<=CurLen then\r\n      SetLength(Result,System.Length(Result)+BlockSize);\r\n  end;\r\n\r\nVar\r\n  Sep,LastSep,Len : SizeInt;\r\n  T : String;\r\n\r\nbegin\r\n\r\n  S:=Self;\r\n  SetLength(Result,BlockSize);\r\n  Len:=0;\r\n  LastSep:=0;\r\n  Sep:=NextSep(0);\r\n  While (Sep<>-1) and ((ACount=0) or (Len<ACount)) do\r\n    begin\r\n    T:=SubString(LastSep,Sep-LastSep);\r\n//    Writeln('Examining >',T,'< at pos ',LastSep,', till pos ',Sep);\r\n    If (T<>'') or (not (TStringSplitOptions.ExcludeEmpty=Options)) then\r\n      begin\r\n      MaybeGrow(Len);\r\n      Result[Len]:=T;\r\n      Inc(Len);\r\n      end;\r\n    LastSep:=Sep+1;\r\n    Sep:=NextSep(LastSep);\r\n    end;\r\n  if (LastSep<=Length) and ((ACount=0) or (Len<ACount)) then\r\n    begin\r\n    T:=SubString(LastSep);\r\n//    Writeln('Examining >',T,'< at pos,',LastSep,' till pos ',Sep);\r\n    If (T<>'') or (not (TStringSplitOptions.ExcludeEmpty=Options)) then\r\n      begin\r\n      MaybeGrow(Len);\r\n      Result[Len]:=T;\r\n      Inc(Len);\r\n      end;\r\n    end;\r\n  SetLength(Result,Len);\r\n\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of string; AQuote: Char\r\n  ): TStringArray;\r\nbegin\r\n  Result:=SPlit(Separators,AQuote,AQuote);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of string; AQuoteStart,\r\n  AQuoteEnd: Char): TStringArray;\r\nbegin\r\n  Result:=SPlit(Separators,AQuoteStart,AQuoteEnd,Length+1,TStringSplitOptions.None);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of string; AQuoteStart,\r\n  AQuoteEnd: Char; Options: TStringSplitOptions): TStringArray;\r\nbegin\r\n  Result:=SPlit(Separators,AQuoteStart,AQuoteEnd,Length+1,Options);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of string; AQuoteStart,\r\n  AQuoteEnd: Char; ACount: SizeInt): TStringArray;\r\nbegin\r\n  Result:=SPlit(Separators,AQuoteStart,AQuoteEnd,ACount,TStringSplitOptions.None);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Split(const Separators: array of string; AQuoteStart,\r\n  AQuoteEnd: Char; ACount: SizeInt; Options: TStringSplitOptions): TStringArray;\r\n\r\nConst\r\n  BlockSize = 10;\r\n\r\nVar\r\n  S : String;\r\n\r\n  Function NextSep(StartIndex : SizeInt; out Match : SizeInt) : SizeInt;\r\n\r\n  begin\r\n    if (AQuoteStart<>#0) then\r\n      Result:=S.IndexOfAnyUnQuoted(Separators,AQuoteStart,AQuoteEnd,StartIndex,Match)\r\n    else\r\n      Result:=S.IndexOfAny(Separators,StartIndex,Length,Match);\r\n  end;\r\n\r\n  Procedure MaybeGrow(Curlen : SizeInt);\r\n\r\n  begin\r\n    if System.Length(Result)<=CurLen then\r\n      SetLength(Result,System.Length(Result)+BlockSize);\r\n  end;\r\n\r\nVar\r\n  Sep,LastSep,Len,Match : SizeInt;\r\n  T : String;\r\n\r\nbegin\r\n  S:=Self;\r\n  SetLength(Result,BlockSize);\r\n  Len:=0;\r\n  LastSep:=0;\r\n  Sep:=NextSep(0,Match);\r\n  While (Sep<>-1) and ((ACount=0) or (Len<ACount)) do\r\n    begin\r\n    T:=SubString(LastSep,Sep-LastSep);\r\n    If (T<>'') or (not (TStringSplitOptions.ExcludeEmpty=Options)) then\r\n      begin\r\n      MaybeGrow(Len);\r\n      Result[Len]:=T;\r\n      Inc(Len);\r\n      end;\r\n    LastSep:=Sep+System.Length(Separators[Match]);\r\n    Sep:=NextSep(LastSep,Match);\r\n    end;\r\n  if (LastSep<=Length) and ((ACount=0) or (Len<ACount)) then\r\n    begin\r\n    T:=SubString(LastSep);\r\n//    Writeln('Examining >',T,'< at pos,',LastSep,' till pos ',Sep);\r\n    If (T<>'') or (not (TStringSplitOptions.ExcludeEmpty=Options)) then\r\n      begin\r\n      MaybeGrow(Len);\r\n      Result[Len]:=T;\r\n      Inc(Len);\r\n      end;\r\n    end;\r\n  SetLength(Result,Len);\r\n\r\nend;\r\n\r\n\r\nfunction TStringHelper.StartsWith(const AValue: string): Boolean;\r\nbegin\r\n  Result:=StartsWith(AValue,False);\r\nend;\r\n\r\n\r\nfunction TStringHelper.StartsWith(const AValue: string; IgnoreCase: Boolean\r\n  ): Boolean;\r\nVar\r\n  L : SizeInt;\r\n  S : String;\r\n\r\nbegin\r\n  L:=System.Length(AValue);\r\n  Result:=L<=0;\r\n  if not Result then\r\n    begin\r\n    S:=System.Copy(Self,1,L);\r\n    Result:=(System.Length(S)=L);\r\n    if Result then\r\n      if IgnoreCase then\r\n        Result:=SameText(S,aValue)\r\n      else\r\n        Result:=SameStr(S,AValue);\r\n    end;\r\nend;\r\n\r\n\r\nfunction TStringHelper.Substring(AStartIndex: SizeInt): string;\r\nbegin\r\n  Result:=Self.SubString(AStartIndex,Self.Length-AStartIndex);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Substring(AStartIndex: SizeInt; ALen: SizeInt): string;\r\nbegin\r\n  Result:=system.Copy(Self,AStartIndex+1,ALen);\r\nend;\r\n\r\n\r\nfunction TStringHelper.ToBoolean: Boolean;\r\nbegin\r\n  Result:=StrToBool(Self);\r\nend;\r\n\r\n\r\nfunction TStringHelper.ToInteger: Integer;\r\nbegin\r\n  Result:=StrToInt(Self);\r\nend;\r\n\r\n\r\nfunction TStringHelper.ToNativeInt: NativeInt;\r\nbegin\r\n  Result:=StrToNativeInt(Self);\r\nend;\r\n\r\nfunction TStringHelper.ToDouble: Double;\r\nbegin\r\n  Result:=StrToFLoat(Self);\r\nend;\r\n\r\n\r\nfunction TStringHelper.ToExtended: Extended;\r\nbegin\r\n  Result:=StrToFLoat(Self);\r\nend;\r\n\r\n\r\nfunction TStringHelper.ToCharArray: TCharArray;\r\n\r\nbegin\r\n  Result:=ToCharArray(0,Self.Length);\r\nend;\r\n\r\n\r\nfunction TStringHelper.ToCharArray(AStartIndex: SizeInt; ALen: SizeInt\r\n  ): TCharArray;\r\n\r\nVar\r\n  I : SizeInt;\r\n\r\nbegin\r\n  SetLength(Result,ALen);\r\n  For I:=0 to ALen-1 do\r\n    Result[I]:=Self[AStartIndex+I+1];\r\nend;\r\n\r\n\r\nfunction TStringHelper.ToLower: string;\r\nbegin\r\n  Result:=LowerCase(Self);\r\nend;\r\n\r\n\r\nfunction TStringHelper.ToLowerInvariant: string;\r\nbegin\r\n  Result:=LowerCase(Self);\r\nend;\r\n\r\n\r\nfunction TStringHelper.ToUpper: string;\r\nbegin\r\n  Result:=UpperCase(Self);\r\nend;\r\n\r\n\r\nfunction TStringHelper.ToUpperInvariant: string;\r\nbegin\r\n  Result:=UpperCase(Self);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Trim: string;\r\nbegin\r\n  Result:={$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}SysUtils.Trim(self);\r\nend;\r\n\r\n\r\nfunction TStringHelper.TrimLeft: string;\r\nbegin\r\n  Result:={$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}SysUtils.TrimLeft(Self);\r\nend;\r\n\r\n\r\nfunction TStringHelper.TrimRight: string;\r\nbegin\r\n  Result:={$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}SysUtils.TrimRight(Self);\r\nend;\r\n\r\n\r\nfunction TStringHelper.Trim(const ATrimChars: array of Char): string;\r\nbegin\r\n  Result:=Self.TrimLeft(ATrimChars).TrimRight(ATrimChars);\r\nend;\r\n\r\n\r\nfunction TStringHelper.TrimLeft(const ATrimChars: array of Char): string;\r\n\r\nVar\r\n  I,Len : SizeInt;\r\n\r\nbegin\r\n  I:=1;\r\n  Len:=Self.Length;\r\n  While (I<=Len) and HaveChar(Self[i],ATrimChars) do Inc(I);\r\n  if I=1 then\r\n    Result:=Self\r\n  else if I>Len then\r\n    Result:=''\r\n  else\r\n    Result:=system.Copy(Self,I,Len-I+1);\r\nend;\r\n\r\n\r\nfunction TStringHelper.TrimRight(const ATrimChars: array of Char): string;\r\n\r\nVar\r\n  I,Len : SizeInt;\r\n\r\nbegin\r\n  Len:=Self.Length;\r\n  I:=Len;\r\n  While (I>=1) and HaveChar(Self[i],ATrimChars) do Dec(I);\r\n  if I<1 then\r\n    Result:=''\r\n  else if I=Len then\r\n    Result:=Self\r\n  else\r\n    Result:=system.Copy(Self,1,I);\r\nend;\r\n\r\n\r\nfunction TStringHelper.TrimEnd(const ATrimChars: array of Char): string;\r\nbegin\r\n  Result:=TrimRight(ATrimChars);\r\nend;\r\n\r\n\r\nfunction TStringHelper.TrimStart(const ATrimChars: array of Char): string;\r\nbegin\r\n  Result:=TrimLeft(ATrimChars);\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  TDoubleHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nClass Function TDoubleHelper.IsNan(const AValue: Double): Boolean; overload; inline;\r\n\r\nbegin\r\n  Result:={$IFDEF FPC_DOTTEDUNITS}JSApi.{$ENDIF}JS.jsIsNaN(AValue);\r\nend;\r\n\r\nClass Function TDoubleHelper.IsInfinity(const AValue: Double): Boolean; overload; inline;\r\n\r\nbegin\r\n  Result:=Not jsIsFinite(aValue);\r\nend;\r\n\r\nClass Function TDoubleHelper.IsNegativeInfinity(const AValue: Double): Boolean; overload; inline;\r\n\r\nbegin\r\n  asm\r\n    return (AValue=Number.NEGATIVE_INFINITY);\r\n  end;\r\n  Result:=aValue=0; // Fool compiler\r\nend;\r\n\r\nClass Function TDoubleHelper.IsPositiveInfinity(const AValue: Double): Boolean; overload; inline;\r\n\r\nbegin\r\n  asm\r\n    return (AValue=Number.POSITIVE_INFINITY);\r\n  end;\r\n  Result:=aValue=0;  // Fool compiler.\r\nend;\r\n\r\nClass Function TDoubleHelper.Parse(const AString: string): Double; overload; inline;\r\n\r\nbegin\r\n  Result:=StrToFloat(AString);\r\nend;\r\n\r\n\r\nClass Function TDoubleHelper.ToString(const AValue: Double): string; overload; inline;\r\n\r\nbegin\r\n  Result:=FloatToStr(AValue);\r\nend;\r\n\r\n\r\nClass Function TDoubleHelper.ToString(const AValue: Double; const AFormat: TFloatFormat; const APrecision, ADigits: Integer): string; overload; inline;\r\n\r\nbegin\r\n  Result:=FloatToStrF(AValue,AFormat,APrecision,ADigits);\r\nend;\r\n\r\n\r\nClass Function TDoubleHelper.TryParse(const AString: string; out AValue: Double): Boolean; overload; inline;\r\n\r\nbegin\r\n  Result:=TryStrToFloat(AString,AValue);\r\nend;\r\n\r\n\r\n\r\nFunction TDoubleHelper.GetB(AIndex: Cardinal): Byte;\r\n\r\nvar\r\n  F : TJSFloat64Array;\r\n  B : TJSUInt8array;\r\n\r\nbegin\r\n  F:=TJSFloat64Array.New(1);\r\n  B:=TJSUInt8array.New(F.Buffer);\r\n  F[0]:=Self;\r\n  Result:=B[AIndex];\r\nend;\r\n\r\nFunction TDoubleHelper.GetW(AIndex: Cardinal): Word;\r\n\r\nvar\r\n  F : TJSFloat64Array;\r\n  W : TJSUInt16array;\r\n\r\nbegin\r\n  F:=TJSFloat64Array.New(1);\r\n  W:=TJSUInt16array.New(F.Buffer);\r\n  F[0]:=Self;\r\n  Result:=W[AIndex];\r\nend;\r\n\r\nType\r\n  TFloatParts = Record\r\n    sign : boolean;\r\n    exp : integer;\r\n    mantissa : double;\r\n  end;\r\n\r\n// See https://stackoverflow.com/questions/9383593/extracting-the-exponent-and-mantissa-of-a-javascript-number\r\n\r\nFunction FloatToParts(aValue : Double) : TFloatParts;\r\n\r\nvar\r\n  F : TJSFloat64Array;\r\n  B : TJSUInt8array;\r\n\r\nbegin\r\n  F:=TJSFloat64Array.New(1);\r\n  B:=TJSUInt8array.New(F.Buffer);\r\n  F[0]:=aValue;\r\n  Result.Sign:=(B[7] shr 7)=0;\r\n  Result.exp:=(((B[7] and $7f) shl 4) or (B[6] shr 4))- $3ff;\r\n  B[3]:=$3F;\r\n  B[6]:=B[6] or $F0;\r\n  Result.Mantissa:=F[0];\r\nend;\r\n\r\nFunction TDoubleHelper.GetE: NativeUInt; inline;\r\n\r\nbegin\r\n  Result:=FloatToParts(Self).Exp;\r\nend;\r\n\r\nFunction TDoubleHelper.GetF: NativeUInt; inline;\r\n\r\nbegin\r\n  Result:=0;\r\n  NotImplemented('GetF');\r\nend;\r\n\r\nFunction TDoubleHelper.GetS: Boolean; inline;\r\n\r\nbegin\r\n  Result:=FloatToParts(Self).Sign;\r\nend;\r\n\r\nprocedure TDoubleHelper.SetB(AIndex: Cardinal; const AValue: Byte);\r\n\r\nvar\r\n  F : TJSFloat64Array;\r\n  B : TJSUInt8array;\r\n\r\nbegin\r\n  if (AIndex>=8) then\r\n    raise ERangeError.Create(SRangeError);\r\n  F:=TJSFloat64Array.New(1);\r\n  B:=TJSUInt8array.New(F.Buffer);\r\n  F[0]:=Self;\r\n  B[AIndex]:=aValue;\r\n  Self:=F[0];\r\nend;\r\n\r\nprocedure TDoubleHelper.SetW(AIndex: Cardinal; const AValue: Word);\r\n\r\nVar\r\n  F : TJSFloat64Array;\r\n  W : TJSUInt16array;\r\n\r\nbegin\r\n  if (AIndex>=4) then\r\n    raise ERangeError.Create(SRangeError);\r\n  F:=TJSFloat64Array.New(1);\r\n  W:=TJSUInt16array.New(F.Buffer);\r\n  F[0]:=Self;\r\n  W[AIndex]:=aValue;\r\n  Self:=F[0];\r\nend;\r\n\r\n\r\n\r\nprocedure TDoubleHelper.SetS(AValue: Boolean);\r\n\r\n\r\nVar\r\n  F : TJSFloat64Array;\r\n  B : TJSUInt8array;\r\n\r\nbegin\r\n  F:=TJSFloat64Array.New(1);\r\n  B:=TJSUInt8array.New(F.Buffer);\r\n  F[0]:=Self;\r\n  if aValue then\r\n    B[7]:=B[7] or (1 shr 7)\r\n  else\r\n    B[7]:=B[7] and not (1 shr 7);\r\n  Self:=F[0];\r\nend;\r\n\r\n\r\nProcedure TDoubleHelper.BuildUp(const ASignFlag: Boolean; const AMantissa: NativeUInt; const AExponent: Integer);\r\n\r\nbegin\r\n  NotImplemented('BuildUp');\r\n  // Following statement is just to fool the compiler\r\n  if ASignFlag and (AMantissa>0) and (AExponent<0) then exit;\r\n//  TFloatRec(Self).BuildUp(ASignFlag, AMantissa, AExponent);\r\nend;\r\n\r\nFunction TDoubleHelper.Exponent: Integer;\r\n\r\nbegin\r\n  Result:=FloatToParts(Self).Exp;\r\nend;\r\n\r\nFunction TDoubleHelper.Fraction: Extended;\r\n\r\nbegin\r\n  Result:=system.Frac(Self);\r\nend;\r\n\r\nFunction TDoubleHelper.IsInfinity: Boolean; overload; inline;\r\n\r\nbegin\r\n  Result:=Double.IsInfinity(Self);\r\nend;\r\n\r\nFunction TDoubleHelper.IsNan: Boolean; overload; inline;\r\n\r\nbegin\r\n  Result:=Double.IsNan(Self);\r\nend;\r\n\r\nFunction TDoubleHelper.IsNegativeInfinity: Boolean; overload; inline;\r\n\r\nbegin\r\n  Result:=Double.IsNegativeInfinity(Self);\r\nend;\r\n\r\nFunction TDoubleHelper.IsPositiveInfinity: Boolean; overload; inline;\r\n\r\nbegin\r\n  Result:=Double.IsPositiveInfinity(Self);\r\nend;\r\n\r\nFunction TDoubleHelper.Mantissa: NativeUInt;\r\n\r\nbegin\r\n  Result:=Trunc(FloatToParts(Self).mantissa);\r\nend;\r\n\r\nFunction TDoubleHelper.ToString(const AFormat: TFloatFormat; const APrecision, ADigits: Integer): string; overload; inline;\r\n\r\nbegin\r\n  Result:=FloatToStrF(Self,AFormat,APrecision,ADigits);\r\nend;\r\n\r\nFunction TDoubleHelper.ToString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=FloatToStr(Self);\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  TByteHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nClass Function TByteHelper.Parse(const AString: string): Byte; inline;\r\n\r\nbegin\r\n  Result:=StrToInt(AString);\r\nend;\r\n\r\nClass Function TByteHelper.Size: Integer; inline;\r\n\r\nbegin\r\n  Result:=1;\r\nend;\r\n\r\nClass Function TByteHelper.ToString(const AValue: Byte): string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(AValue);\r\nend;\r\n\r\nClass Function TByteHelper.TryParse(const AString: string; out AValue: Byte): Boolean; inline;\r\n\r\nVar\r\n  C : Integer;\r\n\r\nbegin\r\n  Val(AString,AValue,C);\r\n  Result:=(C=0);\r\nend;\r\n\r\nFunction TByteHelper.ToBoolean: Boolean; inline;\r\n\r\nbegin\r\n  Result:=(Self<>0);\r\nend;\r\n\r\nFunction TByteHelper.ToDouble: Double; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TByteHelper.ToExtended: Extended; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TByteHelper.ToBinString: string; inline;\r\n\r\nbegin\r\n  Result:=BinStr(Self,Size*8);\r\nend;\r\n\r\nFunction TByteHelper.ToHexString(const AMinDigits: Integer): string;\r\noverload; inline;\r\n\r\nbegin\r\n  Result:=IntToHex(Self,AMinDigits);\r\nend;\r\n\r\nFunction TByteHelper.ToHexString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToHex(Self,Size*2);\r\nend;\r\n\r\nFunction TByteHelper.ToString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(Self);\r\nend;\r\n\r\nFunction TByteHelper.SetBit(const index: TByteBitIndex) : Byte; inline;\r\n\r\nbegin\r\n  Self := Self or (Byte(1) shl index);\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TByteHelper.ClearBit(const index: TByteBitIndex) : Byte; inline;\r\n\r\nbegin\r\n  Self:=Self and not Byte((Byte(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TByteHelper.ToggleBit(const index: TByteBitIndex) : Byte; inline;\r\n\r\nbegin\r\n  Self := Self xor Byte((Byte(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TByteHelper.TestBit(const Index: TByteBitIndex):Boolean; inline;\r\n\r\nbegin\r\n  Result := (Self and Byte((Byte(1) shl index)))<>0;\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  TShortintHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nClass Function TShortIntHelper.Parse(const AString: string): ShortInt; inline;\r\n\r\nbegin\r\n  Result:=StrToInt(AString);\r\nend;\r\n\r\nClass Function TShortIntHelper.Size: Integer; inline;\r\n\r\nbegin\r\n  Result:=1;\r\nend;\r\n\r\nClass Function TShortIntHelper.ToString(const AValue: ShortInt): string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(AValue);\r\nend;\r\n\r\nClass Function TShortIntHelper.TryParse(const AString: string; out AValue: ShortInt): Boolean; inline;\r\n\r\nVar\r\n  C : Integer;\r\n\r\nbegin\r\n  Val(AString,AValue,C);\r\n  Result:=(C=0);\r\nend;\r\n\r\nFunction TShortIntHelper.ToBoolean: Boolean; inline;\r\n\r\nbegin\r\n  Result:=(Self<>0);\r\nend;\r\n\r\nFunction TShortIntHelper.ToDouble: Double; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TShortIntHelper.ToExtended: Extended; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TShortIntHelper.ToBinString: string; inline;\r\n\r\nbegin\r\n  Result:=BinStr(Self,Size*8);\r\nend;\r\n\r\nFunction TShortIntHelper.ToHexString(const AMinDigits: Integer): string; overload; inline;\r\n\r\nVar\r\n  B : Word;\r\n  U : TJSUInt8Array;\r\n  S : TJSInt8array;\r\n\r\nbegin\r\n  if Self>=0 then\r\n    B:=Self\r\n  else\r\n    begin\r\n    S:=TJSInt8Array.New(1);\r\n    S[0]:=Self;\r\n    U:=TJSUInt8Array.New(S);\r\n    B:=U[0];\r\n    if AMinDigits>2 then\r\n      B:=$FF00+B;\r\n    end;\r\n  Result:=IntToHex(B,AMinDigits);\r\nend;\r\n\r\nFunction TShortIntHelper.ToHexString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=ToHexString(Size*2);\r\nend;\r\n\r\nFunction TShortIntHelper.ToString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(Self);\r\nend;\r\n\r\nFunction TShortIntHelper.SetBit(const index: TShortIntBitIndex) : ShortInt; inline;\r\n\r\nbegin\r\n  Self := Self or (ShortInt(1) shl index);\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TShortIntHelper.ClearBit(const index: TShortIntBitIndex) : ShortInt; inline;\r\n\r\nbegin\r\n  Self:=Self and not ShortInt((ShortInt(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TShortIntHelper.ToggleBit(const index: TShortIntBitIndex) : ShortInt; inline;\r\n\r\nbegin\r\n  Self := Self xor ShortInt((ShortInt(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TShortIntHelper.TestBit(const Index: TShortIntBitIndex):Boolean; inline;\r\n\r\nbegin\r\n  Result := (Self and ShortInt((ShortInt(1) shl index)))<>0;\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  TSmallintHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nClass Function TSmallIntHelper.Parse(const AString: string): SmallInt; inline;\r\n\r\nbegin\r\n  Result:=StrToInt(AString);\r\nend;\r\n\r\nClass Function TSmallIntHelper.Size: Integer; inline;\r\n\r\nbegin\r\n  Result:=2;\r\nend;\r\n\r\nClass Function TSmallIntHelper.ToString(const AValue: SmallInt): string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(AValue);\r\nend;\r\n\r\nClass Function TSmallIntHelper.TryParse(const AString: string; out AValue: SmallInt): Boolean; inline;\r\n\r\nVar\r\n  C : Integer;\r\n\r\nbegin\r\n  Val(AString,AValue,C);\r\n  Result:=(C=0);\r\nend;\r\n\r\nFunction TSmallIntHelper.ToBoolean: Boolean; inline;\r\n\r\nbegin\r\n  Result:=(Self<>0);\r\nend;\r\n\r\nFunction TSmallIntHelper.ToDouble: Double; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TSmallIntHelper.ToExtended: Extended; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TSmallIntHelper.ToBinString: string; inline;\r\n\r\nbegin\r\n  Result:=BinStr(Self,Size*8);\r\nend;\r\n\r\nFunction TSmallIntHelper.ToHexString(const AMinDigits: Integer): string; overload; inline;\r\n\r\nVar\r\n  B : Cardinal;\r\n  U : TJSUInt16Array;\r\n  S : TJSInt16array;\r\n\r\n\r\nbegin\r\n  if Self>=0 then\r\n    B:=Self\r\n  else\r\n    begin\r\n    S:=TJSInt16Array.New(1);\r\n    S[0]:=Self;\r\n    U:=TJSUInt16Array.New(S);\r\n    B:=U[0];\r\n    if AMinDigits>6 then\r\n      B:=$FFFF0000+B\r\n    else if AMinDigits>4 then\r\n      B:=$FF0000+B;\r\n    end;\r\n  Result:=IntToHex(B,AMinDigits);\r\nend;\r\n\r\nFunction TSmallIntHelper.ToHexString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=ToHexString(Size*2);\r\nend;\r\n\r\n\r\nFunction TSmallIntHelper.ToString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(Self);\r\nend;\r\n\r\nFunction TSmallIntHelper.SetBit(const index: TSmallIntBitIndex) : SmallInt; inline;\r\n\r\nbegin\r\n  Self := Self or (SmallInt(1) shl index);\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TSmallIntHelper.ClearBit(const index: TSmallIntBitIndex) : SmallInt; inline;\r\n\r\nbegin\r\n  Self:=Self and not SmallInt((SmallInt(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TSmallIntHelper.ToggleBit(const index: TSmallIntBitIndex) : SmallInt; inline;\r\n\r\nbegin\r\n  Self := Self xor SmallInt((SmallInt(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TSmallIntHelper.TestBit(const Index: TSmallIntBitIndex):Boolean; inline;\r\n\r\nbegin\r\n  Result := (Self and SmallInt((SmallInt(1) shl index)))<>0;\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  TWordHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nClass Function TWordHelper.Parse(const AString: string): Word; inline;\r\n\r\nbegin\r\n  Result:=StrToInt(AString);\r\nend;\r\n\r\nClass Function TWordHelper.Size: Integer; inline;\r\n\r\nbegin\r\n  Result:=2;\r\nend;\r\n\r\nClass Function TWordHelper.ToString(const AValue: Word): string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(AValue);\r\nend;\r\n\r\nClass Function TWordHelper.TryParse(const AString: string; out AValue: Word): Boolean; inline;\r\n\r\nVar\r\n  C : Integer;\r\n\r\nbegin\r\n  Val(AString,AValue,C);\r\n  Result:=(C=0);\r\nend;\r\n\r\nFunction TWordHelper.ToBoolean: Boolean; inline;\r\n\r\nbegin\r\n  Result:=(Self<>0);\r\nend;\r\n\r\nFunction TWordHelper.ToDouble: Double; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TWordHelper.ToExtended: Extended; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TWordHelper.ToBinString: string; inline;\r\n\r\nbegin\r\n  Result:=BinStr(Self,Size*8);\r\nend;\r\n\r\nFunction TWordHelper.ToHexString(const AMinDigits: Integer): string;\r\noverload; inline;\r\n\r\nbegin\r\n  Result:=IntToHex(Self,AMinDigits);\r\nend;\r\n\r\nFunction TWordHelper.ToHexString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToHex(Self,Size*2);\r\nend;\r\n\r\n\r\nFunction TWordHelper.ToString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(Self);\r\nend;\r\n\r\nFunction TWordHelper.SetBit(const index: TWordBitIndex) : Word; inline;\r\n\r\nbegin\r\n  Self := Self or (Word(1) shl index);\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TWordHelper.ClearBit(const index: TWordBitIndex) : Word; inline;\r\n\r\nbegin\r\n  Self:=Self and not Word((Word(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TWordHelper.ToggleBit(const index: TWordBitIndex) : Word; inline;\r\n\r\nbegin\r\n  Self := Self xor Word((Word(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TWordHelper.TestBit(const Index: TWordBitIndex):Boolean; inline;\r\n\r\nbegin\r\n  Result := (Self and Word((Word(1) shl index)))<>0;\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  TCardinalHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nClass Function TCardinalHelper.Parse(const AString: string): Cardinal; inline;\r\n\r\nbegin\r\n  Result:=StrToInt(AString);\r\nend;\r\n\r\nClass Function TCardinalHelper.Size: Integer; inline;\r\n\r\nbegin\r\n  Result:=4;\r\nend;\r\n\r\nClass Function TCardinalHelper.ToString(const AValue: Cardinal): string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(AValue);\r\nend;\r\n\r\nClass Function TCardinalHelper.TryParse(const AString: string; out AValue: Cardinal): Boolean; inline;\r\n\r\nVar\r\n  C : Integer;\r\n\r\nbegin\r\n  Val(AString,AValue,C);\r\n  Result:=(C=0);\r\nend;\r\n\r\nFunction TCardinalHelper.ToBoolean: Boolean; inline;\r\n\r\nbegin\r\n  Result:=(Self<>0);\r\nend;\r\n\r\nFunction TCardinalHelper.ToDouble: Double; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TCardinalHelper.ToExtended: Extended; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TCardinalHelper.ToBinString: string; inline;\r\n\r\nbegin\r\n  Result:=BinStr(Self,Size*8);\r\nend;\r\n\r\nFunction TCardinalHelper.ToHexString(const AMinDigits: Integer): string;\r\noverload; inline;\r\n\r\nbegin\r\n  Result:=IntToHex(Self,AMinDigits);\r\nend;\r\n\r\nFunction TCardinalHelper.ToHexString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=ToHexString(Size*2);\r\nend;\r\n\r\nFunction TCardinalHelper.ToString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(Self);\r\nend;\r\n\r\nFunction TCardinalHelper.SetBit(const index: TCardinalBitIndex) : Cardinal; inline;\r\n\r\nbegin\r\n  Self := Self or (Cardinal(1) shl index);\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TCardinalHelper.ClearBit(const index: TCardinalBitIndex) : Cardinal; inline;\r\n\r\nbegin\r\n  Self:=Self and not Cardinal((Cardinal(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TCardinalHelper.ToggleBit(const index: TCardinalBitIndex) : Cardinal; inline;\r\n\r\nbegin\r\n  Self := Self xor Cardinal((Cardinal(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TCardinalHelper.TestBit(const Index: TCardinalBitIndex):Boolean; inline;\r\n\r\nbegin\r\n  Result := (Self and Cardinal((Cardinal(1) shl index)))<>0;\r\nend;\r\n\r\n\r\n{ ---------------------------------------------------------------------\r\n  TIntegerHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nClass Function TIntegerHelper.Parse(const AString: string): Integer; inline;\r\n\r\nbegin\r\n  Result:=StrToInt(AString);\r\nend;\r\n\r\nClass Function TIntegerHelper.Size: Integer; inline;\r\n\r\nbegin\r\n  Result:=4;\r\nend;\r\n\r\nClass Function TIntegerHelper.ToString(const AValue: Integer): string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(AValue);\r\nend;\r\n\r\nClass Function TIntegerHelper.TryParse(const AString: string; out AValue: Integer): Boolean; inline;\r\n\r\nVar\r\n  C : Integer;\r\n\r\nbegin\r\n  Val(AString,AValue,C);\r\n  Result:=(C=0);\r\nend;\r\n\r\nFunction TIntegerHelper.ToBoolean: Boolean; inline;\r\n\r\nbegin\r\n  Result:=(Self<>0);\r\nend;\r\n\r\nFunction TIntegerHelper.ToDouble: Double; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TIntegerHelper.ToExtended: Extended; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TIntegerHelper.ToBinString: string; inline;\r\n\r\nbegin\r\n  Result:=BinStr(Self,Size*8);\r\nend;\r\n\r\nFunction TIntegerHelper.ToHexString(const AMinDigits: Integer): string;\r\noverload; inline;\r\n\r\n\r\nVar\r\n  B : Word;\r\n  U : TJSUInt32Array;\r\n  S : TJSInt32array;\r\n\r\nbegin\r\n  if Self>=0 then\r\n    B:=Self\r\n  else\r\n    begin\r\n    S:=TJSInt32Array.New(1);\r\n    S[0]:=Self;\r\n    U:=TJSUInt32Array.New(S);\r\n    B:=U[0];\r\n    end;\r\n  Result:=IntToHex(B,AMinDigits);\r\nend;\r\n\r\nFunction TIntegerHelper.ToHexString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=ToHexString(Size*2);\r\nend;\r\n\r\n\r\nFunction TIntegerHelper.ToString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(Self);\r\nend;\r\n\r\nFunction TIntegerHelper.SetBit(const index: TIntegerBitIndex) : Integer; inline;\r\n\r\nbegin\r\n  Self := Self or (Integer(1) shl index);\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TIntegerHelper.ClearBit(const index: TIntegerBitIndex) : Integer; inline;\r\n\r\nbegin\r\n  Self:=Self and not Integer((Integer(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TIntegerHelper.ToggleBit(const index: TIntegerBitIndex) : Integer; inline;\r\n\r\nbegin\r\n  Self := Self xor Integer((Integer(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TIntegerHelper.TestBit(const Index: TIntegerBitIndex):Boolean; inline;\r\n\r\nbegin\r\n  Result := (Self and Integer((Integer(1) shl index)))<>0;\r\nend;\r\n\r\n\r\n{ ---------------------------------------------------------------------\r\n  TNativeIntHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nClass Function TNativeIntHelper.Parse(const AString: string): NativeInt; inline;\r\n\r\nbegin\r\n  Result:=StrToInt(AString);\r\nend;\r\n\r\nClass Function TNativeIntHelper.Size: Integer; inline;\r\n\r\nbegin\r\n  Result:=7;\r\nend;\r\n\r\nClass Function TNativeIntHelper.ToString(const AValue: NativeInt): string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(AValue);\r\nend;\r\n\r\nClass Function TNativeIntHelper.TryParse(const AString: string; out AValue: NativeInt): Boolean; inline;\r\n\r\nVar\r\n  C : Integer;\r\n\r\nbegin\r\n  Val(AString,AValue,C);\r\n  Result:=(C=0);\r\nend;\r\n\r\nFunction TNativeIntHelper.ToBoolean: Boolean; inline;\r\n\r\nbegin\r\n  Result:=(Self<>0);\r\nend;\r\n\r\nFunction TNativeIntHelper.ToDouble: Double; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TNativeIntHelper.ToExtended: Extended; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TNativeIntHelper.ToBinString: string; inline;\r\n\r\nbegin\r\n  Result:=BinStr(Self,Size*8);\r\nend;\r\n\r\nFunction TNativeIntHelper.ToHexString(const AMinDigits: Integer): string;\r\noverload; inline;\r\n\r\nbegin\r\n  Result:=IntToHex(Self,AMinDigits);\r\nend;\r\n\r\nFunction TNativeIntHelper.ToHexString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToHex(Self,Size*2);\r\nend;\r\n\r\nFunction TNativeIntHelper.ToString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(Self);\r\nend;\r\n\r\nFunction TNativeIntHelper.SetBit(const index: TNativeIntBitIndex) : NativeInt; inline;\r\n\r\nbegin\r\n  Self := Self or (NativeInt(1) shl index);\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TNativeIntHelper.ClearBit(const index: TNativeIntBitIndex) : NativeInt; inline;\r\n\r\nbegin\r\n  Self:=Self and not NativeInt((NativeInt(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TNativeIntHelper.ToggleBit(const index: TNativeIntBitIndex) : NativeInt; inline;\r\n\r\nbegin\r\n  Self := Self xor NativeInt((NativeInt(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TNativeIntHelper.TestBit(const Index: TNativeIntBitIndex):Boolean; inline;\r\n\r\nbegin\r\n  Result := (Self and NativeInt((NativeInt(1) shl index)))<>0;\r\nend;\r\n\r\n\r\n{ ---------------------------------------------------------------------\r\n  TNativeUIntHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nClass Function TNativeUIntHelper.Parse(const AString: string): NativeUInt; inline;\r\n\r\nbegin\r\n  Result:=StrToInt(AString);\r\nend;\r\n\r\nClass Function TNativeUIntHelper.Size: Integer; inline;\r\n\r\nbegin\r\n  Result:=7;\r\nend;\r\n\r\nClass Function TNativeUIntHelper.ToString(const AValue: NativeUInt): string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(AValue);\r\nend;\r\n\r\nClass Function TNativeUIntHelper.TryParse(const AString: string; out AValue: NativeUInt): Boolean; inline;\r\n\r\nVar\r\n  C : Integer;\r\n\r\nbegin\r\n  Val(AString,AValue,C);\r\n  Result:=(C=0);\r\nend;\r\n\r\nFunction TNativeUIntHelper.ToBoolean: Boolean; inline;\r\n\r\nbegin\r\n  Result:=(Self<>0);\r\nend;\r\n\r\nFunction TNativeUIntHelper.ToDouble: Double; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TNativeUIntHelper.ToExtended: Extended; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TNativeUIntHelper.ToBinString: string; inline;\r\n\r\nbegin\r\n  Result:=BinStr(Self,Size*8);\r\nend;\r\n\r\nFunction TNativeUIntHelper.ToHexString(const AMinDigits: Integer): string;\r\noverload; inline;\r\n\r\nbegin\r\n  Result:=IntToHex(Self,AMinDigits);\r\nend;\r\n\r\nFunction TNativeUIntHelper.ToHexString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToHex(Self,Size*2);\r\nend;\r\n\r\nFunction TNativeUIntHelper.ToSingle: Single; inline;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TNativeUIntHelper.ToString: string; overload; inline;\r\n\r\nbegin\r\n  Result:=IntToStr(Self);\r\nend;\r\n\r\nFunction TNativeUIntHelper.SetBit(const index: TNativeUIntBitIndex) : NativeUInt; inline;\r\n\r\nbegin\r\n  Self := Self or (NativeUInt(1) shl index);\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TNativeUIntHelper.ClearBit(const index: TNativeUIntBitIndex) : NativeUInt; inline;\r\n\r\nbegin\r\n  Self:=Self and not NativeUInt((NativeUInt(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TNativeUIntHelper.ToggleBit(const index: TNativeUIntBitIndex) : NativeUInt; inline;\r\n\r\nbegin\r\n  Self := Self xor NativeUInt((NativeUInt(1) shl index));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TNativeUIntHelper.TestBit(const Index: TNativeUIntBitIndex):Boolean; inline;\r\n\r\nbegin\r\n  Result := (Self and NativeUInt((NativeUInt(1) shl index)))<>0;\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  TBooleanHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nClass Function TBooleanHelper.Parse(const S: string): Boolean; inline;\r\n\r\nbegin\r\n  Result:=StrToBool(S);\r\nend;\r\n\r\nClass Function TBooleanHelper.Size: Integer; inline;\r\n\r\nbegin\r\n  Result:=1;\r\nend;\r\n\r\nClass Function TBooleanHelper.ToString(const AValue: Boolean; UseBoolStrs: TUseBoolStrs = TUseBoolStrs.False): string; overload; inline;\r\n\r\nbegin\r\n  Result:=BoolToStr(AValue,UseBoolStrs=TUseBoolStrs.True);\r\nend;\r\n\r\nClass Function TBooleanHelper.TryToParse(const S: string; out AValue: Boolean): Boolean; inline;\r\n\r\nbegin\r\n  Result:=TryStrToBool(S,AValue);\r\nend;\r\n\r\nFunction TBooleanHelper.ToInteger: Integer; inline;\r\n\r\nbegin\r\n  Result:=Integer(Self);\r\nend;\r\n\r\nFunction TBooleanHelper.ToString(UseBoolStrs: TUseBoolStrs = TUseBoolStrs.False): string; overload; inline;\r\n\r\nbegin\r\n  Result:=BoolToStr(Self,UseBoolStrs=TUseBoolStrs.True);\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  TByteBoolHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nClass Function TByteBoolHelper.Parse(const S: string): Boolean; inline;\r\n\r\nbegin\r\n  Result:=StrToBool(S);\r\nend;\r\n\r\nClass Function TByteBoolHelper.Size: Integer; inline;\r\n\r\nbegin\r\n  Result:=1;\r\nend;\r\n\r\nClass Function TByteBoolHelper.ToString(const AValue: Boolean; UseBoolStrs: Boolean = False): string; overload; inline;\r\n\r\nbegin\r\n  Result:=BoolToStr(AValue,UseBoolStrs);\r\nend;\r\n\r\nClass Function TByteBoolHelper.TryToParse(const S: string; out AValue: Boolean): Boolean; inline;\r\n\r\nbegin\r\n  Result:=TryStrToBool(S,AValue);\r\nend;\r\n\r\nFunction TByteBoolHelper.ToInteger: Integer; inline;\r\n\r\nbegin\r\n  Result:=Integer(Self);\r\nend;\r\n\r\nFunction TByteBoolHelper.ToString(UseBoolStrs: Boolean = False): string; overload; inline;\r\n\r\nbegin\r\n  Result:=BoolToStr(Self,UseBoolStrs);\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  TWordBoolHelper\r\n  ---------------------------------------------------------------------}\r\n\r\nClass Function TWordBoolHelper.Parse(const S: string): Boolean; inline;\r\n\r\nbegin\r\n  Result:=StrToBool(S);\r\nend;\r\n\r\nClass Function TWordBoolHelper.Size: Integer; inline;\r\n\r\nbegin\r\n  Result:=2;\r\nend;\r\n\r\nClass Function TWordBoolHelper.ToString(const AValue: Boolean; UseBoolStrs: boolean = False): string; overload; inline;\r\n\r\nbegin\r\n  Result:=BoolToStr(AValue,UseBoolStrs);\r\nend;\r\n\r\nClass Function TWordBoolHelper.TryToParse(const S: string; out AValue: Boolean): Boolean; inline;\r\n\r\nbegin\r\n  Result:=TryStrToBool(S,AValue);\r\nend;\r\n\r\nFunction TWordBoolHelper.ToInteger: Integer; inline;\r\n\r\nbegin\r\n  Result:=Integer(Self);\r\nend;\r\n\r\nFunction TWordBoolHelper.ToString(UseBoolStrs: Boolean = False): string; overload; inline;\r\n\r\nbegin\r\n  Result:=BoolToStr(Self,UseBoolStrs);\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  TLongBoolHelper\r\n  ---------------------------------------------------------------------}\r\n\r\n\r\nClass Function TLongBoolHelper.Parse(const S: string): Boolean; inline;\r\n\r\nbegin\r\n  Result:=StrToBool(S);\r\nend;\r\n\r\nClass Function TLongBoolHelper.Size: Integer; inline;\r\n\r\nbegin\r\n  Result:=4;\r\nend;\r\n\r\nClass Function TLongBoolHelper.ToString(const AValue: Boolean; UseBoolStrs: Boolean = False): string; overload; inline;\r\n\r\nbegin\r\n  Result:=BoolToStr(AValue,UseBoolStrs);\r\nend;\r\n\r\nClass Function TLongBoolHelper.TryToParse(const S: string; out AValue: Boolean): Boolean; inline;\r\n\r\nbegin\r\n  Result:=TryStrToBool(S,AValue);\r\nend;\r\n\r\nFunction TLongBoolHelper.ToInteger: Integer; inline;\r\n\r\nbegin\r\n  Result:=Integer(Self);\r\nend;\r\n\r\nFunction TLongBoolHelper.ToString(UseBoolStrs: Boolean = False): string; overload; inline;\r\n\r\nbegin\r\n  Result:=BoolToStr(Self,UseBoolStrs);\r\nend;\r\n\r\n{ TStringBuilder }\r\n\r\nconstructor TStringBuilder.Create;\r\nbegin\r\n  Create(DefaultCapacity,Maxint);\r\nend;\r\n\r\nconstructor TStringBuilder.Create(const AValue: String; aCapacity: Integer);\r\nbegin\r\n  Create(aCapacity,Maxint);\r\n  if (system.Length(AValue)>0) then\r\n    Append(AValue);\r\nend;\r\n\r\n\r\nconstructor TStringBuilder.Create(const AValue: String; StartIndex, Alength,\r\n  aCapacity: Integer);\r\nbegin\r\n  Create(Copy(AValue,StartIndex+1,Alength), aCapacity);\r\nend;\r\n\r\nconstructor TStringBuilder.Create(aCapacity, aMaxCapacity: Integer);\r\nbegin\r\n  FMaxCapacity:=aMaxCapacity;\r\n  Capacity:=aCapacity;\r\nend;\r\n\r\nconstructor TStringBuilder.Create(aCapacity: Integer);\r\nbegin\r\n  Create(aCapacity,MaxInt);\r\nend;\r\n\r\nconstructor TStringBuilder.Create(const AValue: String);\r\nbegin\r\n  Create(aValue,DefaultCapacity);\r\nend;\r\n\r\n\r\n{ Property getter/setter }\r\n\r\nfunction TStringBuilder.GetLength: Integer;\r\nbegin\r\n  Result:=System.Length(FData);\r\nend;\r\n\r\nfunction TStringBuilder.GetCapacity: Integer;\r\nbegin\r\n  Result:=System.Length(FData);\r\nend;\r\n\r\nfunction TStringBuilder.GetC(Index: Integer): Char;\r\nbegin\r\n  CheckNegative(Index,'Index');\r\n  CheckRange(Index,0,Length);\r\n  Result:=FData[Index];\r\nend;\r\n\r\nprocedure TStringBuilder.SetC(Index: Integer; AValue: Char);\r\nbegin\r\n  CheckNegative(Index,'Index');\r\n  CheckRange(Index,0,Length-1);\r\n  FData[Index]:=AValue;\r\nend;\r\n\r\nprocedure TStringBuilder.SetLength(AValue: Integer);\r\n\r\nbegin\r\n  CheckNegative(AValue,'AValue');\r\n  CheckRange(AValue,0,MaxCapacity);\r\n  SetLength(FData,aValue);\r\nend;\r\n\r\n{ Check functions }\r\n\r\n\r\n\r\nprocedure TStringBuilder.CheckRange(Idx, Count, MaxLen: Integer);\r\n\r\nbegin\r\n  if (Idx<0) or (Idx+Count>MaxLen) then\r\n    Raise ERangeError.CreateFmt(SListIndexError,[Idx]);\r\nend;\r\n\r\n\r\nprocedure TStringBuilder.CheckNegative(const AValue: Integer;\r\n  const AName: String);\r\n\r\nbegin\r\n  if (AValue<0) then\r\n    Raise ERangeError.CreateFmt(SParamIsNegative,[AName])\r\nend;\r\n\r\n{  These do the actual Appending/Inserting }\r\n\r\nprocedure TStringBuilder.DoAppend(const S: String);\r\n\r\nbegin\r\n  FData:=FData+S;\r\nend;\r\n\r\nprocedure TStringBuilder.DoAppend(const AValue: Array of Char; Idx, aCount: Integer\r\n  );\r\n\r\nVar\r\n  S : String;\r\n  I : Integer;\r\n\r\nbegin\r\n  S:='';\r\n  CheckRange(Idx,aCount,System.Length(AValue));\r\n  for I:=Idx to Idx+aCount-1 do\r\n    S:=S+aValue[I];\r\n  DoAppend(S);\r\nend;\r\n\r\nprocedure TStringBuilder.DoInsert(Index: Integer; const AValue: String);\r\n\r\nbegin\r\n  CheckRange(Index,0,Length-1);\r\n  System.Insert(aValue,FData,Index+1);\r\nend;\r\n\r\nprocedure TStringBuilder.DoInsert(Index: Integer; const AValue: Array of Char;\r\n  StartIndex, aCharCount: Integer);\r\n\r\nVar\r\n  I : Integer;\r\n  S : String;\r\n\r\nbegin\r\n  CheckRange(Index,0,Length-1);\r\n  CheckNegative(StartIndex,'StartIndex');\r\n  CheckNegative(aCharCount,'SBCharCount');\r\n  CheckRange(StartIndex,aCharCount,System.Length(AValue));\r\n  S:='';\r\n  for I:=StartIndex to StartIndex+aCharCount-1 do\r\n    S:=S+aValue[I];\r\n  DoInsert(Index,S);\r\nend;\r\n\r\n{ Public routines for appending }\r\n\r\nfunction TStringBuilder.Append(const AValue: UInt64): TStringBuilder;\r\nbegin\r\n  DoAppend(IntToStr(AValue));\r\n  Result:=self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: Array of Char): TStringBuilder;\r\n\r\nvar\r\n  I,L: Integer;\r\n\r\nbegin\r\n  I:=-1;\r\n  L:=System.Length(AValue);\r\n  If L=0 then\r\n    Exit(Self);\r\n  Repeat\r\n    Inc(I);\r\n  Until (I>=L) or (AValue[I]=#0);\r\n  DoAppend(AValue,0,I);\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: Single): TStringBuilder;\r\nbegin\r\n  DoAppend(FloatToStr(AValue));\r\n  Result:=self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: Word): TStringBuilder;\r\nbegin\r\n  Append(IntToStr(AValue));\r\n  Result:=self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: Cardinal): TStringBuilder;\r\nbegin\r\n  DoAppend(IntToStr(AValue));\r\n  Result:=self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: Char; RepeatCount: Integer\r\n  ): TStringBuilder;\r\nbegin\r\n  DoAppend(StringOfChar(AValue,RepeatCount));\r\n  Result:=Self;\r\nend;\r\n\r\n\r\nfunction TStringBuilder.Append(const AValue: Shortint): TStringBuilder;\r\nbegin\r\n  DoAppend(IntToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: Char): TStringBuilder;\r\nbegin\r\n  DoAppend(AValue);\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: Currency): TStringBuilder;\r\nbegin\r\n  DoAppend(CurrToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: Boolean): TStringBuilder;\r\nbegin\r\n  DoAppend(BoolToStr(AValue, True));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: Byte): TStringBuilder;\r\nbegin\r\n  DoAppend(IntToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: Double): TStringBuilder;\r\nbegin\r\n  DoAppend(FloatToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: Int64): TStringBuilder;\r\nbegin\r\n  DoAppend(IntToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: TObject): TStringBuilder;\r\nbegin\r\n  DoAppend(AValue.ToString);\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: Smallint): TStringBuilder;\r\nbegin\r\n  DoAppend(IntToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const AValue: LongInt): TStringBuilder;\r\nbegin\r\n  DoAppend(IntToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TStringBuilder.Append(const AValue: Array of Char; StartIndex, SBCharCount: Integer): TStringBuilder;\r\n\r\nbegin\r\n  DoAppend(AValue,StartIndex,SBCharCount);\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TStringBuilder.Append(const AValue: String; StartIndex, Count: Integer): TStringBuilder;\r\n\r\nbegin\r\n  CheckRange(StartIndex,Count,System.Length(AValue));\r\n  DoAppend(Copy(AValue,StartIndex+1,Count));\r\n  Result:=Self;\r\nend;\r\n\r\n\r\nfunction TStringBuilder.Append(const AValue: String): TStringBuilder;\r\nbegin\r\n  DoAppend(AValue);\r\n  Result:=Self;\r\nend;\r\n\r\n\r\nfunction TStringBuilder.AppendFormat(const Fmt: String;\r\n  const Args: array of const): TStringBuilder;\r\nbegin\r\n  DoAppend(Format(Fmt,Args));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Append(const Fmt: String;\r\n  const Args: array of const): TStringBuilder;\r\nbegin\r\n  DoAppend(Format(Fmt,Args));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.AppendLine: TStringBuilder;\r\nbegin\r\n  DoAppend(sLineBreak);\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.AppendLine(const AValue: String): TStringBuilder;\r\nbegin\r\n  DoAppend(AValue);\r\n  Result:=AppendLine();\r\nend;\r\n\r\nprocedure TStringBuilder.Clear;\r\nbegin\r\n  Length:=0;\r\n  Capacity:=DefaultCapacity;\r\nend;\r\n\r\n\r\nprocedure TStringBuilder.CopyTo(SourceIndex: Integer;\r\n  Var Destination: Array of Char; DestinationIndex: Integer; Count: Integer);\r\n\r\nVar\r\n  I : Integer;\r\n\r\nbegin\r\n  CheckNegative(Count,'Count');\r\n  CheckNegative(DestinationIndex,'DestinationIndex');\r\n  CheckRange(DestinationIndex,Count,System.Length(Destination));\r\n  if Count>0 then\r\n    begin\r\n    CheckRange(SourceIndex,Count,Length);\r\n    For I:=SourceIndex+1 to SourceIndex+Count do\r\n      Destination[DestinationIndex]:=FData[I];\r\n    end;\r\nend;\r\n\r\n\r\nfunction TStringBuilder.EnsureCapacity(aCapacity: Integer): Integer;\r\nbegin\r\n  CheckRange(aCapacity,0,MaxCapacity);\r\n  if Capacity<aCapacity then\r\n    Capacity:=aCapacity;\r\n  Result:=Capacity;\r\nend;\r\n\r\nfunction TStringBuilder.Equals(StringBuilder: TStringBuilder): Boolean;\r\nbegin\r\n  Result:=(StringBuilder<>nil);\r\n  if Result then\r\n    Result:=(Length=StringBuilder.Length)\r\n             and (MaxCapacity=StringBuilder.MaxCapacity)\r\n             and (FData=StringBuilder.FData[0]);\r\nend;\r\n\r\nprocedure TStringBuilder.Grow;\r\n\r\nvar\r\n  NewCapacity: SizeInt;\r\n\r\nbegin\r\n  NewCapacity:=Capacity*2;\r\n  if NewCapacity>MaxCapacity then\r\n    NewCapacity:=MaxCapacity;\r\n  Capacity:=NewCapacity;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: TObject\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,AValue.ToString());\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: Int64\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,IntToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: Single\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,FloatToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: String\r\n  ): TStringBuilder;\r\n\r\nbegin\r\n  DoInsert(Index,AValue);\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: Word\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,IntToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: Shortint\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index, IntToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: Currency\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,CurrToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: Char\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,AValue);\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: Byte\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,IntToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: Double\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,FloatToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: LongInt\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,IntToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: Smallint\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,IntToStr(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: Boolean\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,BoolToStr(AValue,True));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: String;\r\n  const aRepeatCount: Integer): TStringBuilder;\r\nvar\r\n  I: Integer;\r\nbegin\r\n  for I:=0 to aRepeatCount-1 do\r\n    DoInsert(Index,AValue);\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: Array of Char\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,AValue,0,System.Length(AValue));\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: Array of Char;\r\n  startIndex: Integer; SBCharCount: Integer): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,AValue,StartIndex,SBCharCount);\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: Cardinal\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,IntToStr(AValue));\r\n  Result:=self;\r\nend;\r\n\r\nfunction TStringBuilder.Insert(Index: Integer; const AValue: UInt64\r\n  ): TStringBuilder;\r\nbegin\r\n  DoInsert(Index,IntToStr(AValue));\r\n  Result:=self;\r\nend;\r\n\r\nprocedure TStringBuilder.Shrink;\r\n\r\nbegin\r\n  if (Capacity div 4)>=Length then\r\n    Capacity:=Capacity div 2;\r\nend;\r\n\r\nfunction TStringBuilder.Remove(StartIndex: Integer; RemLength: Integer\r\n  ): TStringBuilder;\r\n\r\nVar\r\n  MoveIndex : Integer;\r\n\r\nbegin\r\n  if (RemLength=0) then\r\n    exit(Self);\r\n  CheckNegative(RemLength,'RemLength');\r\n  CheckRange(StartIndex,0,Length);\r\n  MoveIndex:=StartIndex+RemLength;\r\n  CheckRange(MoveIndex,0,Length);\r\n  Delete(FData,StartIndex+1,RemLength);\r\n  Shrink;\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TStringBuilder.Replace(const OldValue, NewValue: String; StartIndex, Count: Integer): TStringBuilder;\r\n\r\nvar\r\n  I : Integer;\r\n  Start : String;\r\n\r\nbegin\r\n  if Count=0 then\r\n    Exit(Self);\r\n  // Some checks.\r\n  CheckNegative(StartIndex,'StartIndex');\r\n  CheckNegative(Count,'Count');\r\n  CheckRange(Startindex,Count,Length);\r\n  // Init\r\n  Start:=Copy(FData,1,StartIndex+1);\r\n  FData:=Copy(FData,StartIndex+1);\r\n  For I:=1 to Count do\r\n    FData:=StringReplace(FData,OldValue,NewValue,[]);\r\n  FData:=Start+FData;\r\n  Result:=Self;\r\nend;\r\n\r\nFunction TStringBuilder.Replace(const OldValue, NewValue: String): TStringBuilder;\r\nbegin\r\n  Result:=Replace(OldValue,NewValue,0,Length);\r\nend;\r\n\r\nprocedure TStringBuilder.SetCapacity(AValue: Integer);\r\nbegin\r\n  if (AValue>FMaxCapacity) then\r\n    Raise ERangeError.CreateFmt(SListCapacityError,[AValue]);\r\n  if (AValue<Length) then\r\n    Raise ERangeError.CreateFmt(SListCapacityError,[AValue]);\r\n  // No-op\r\nend;\r\n\r\nfunction TStringBuilder.ToString: String;\r\nbegin\r\n  Result:=ToString(0,Length);\r\nend;\r\n\r\nfunction TStringBuilder.ToString(aStartIndex: Integer; aLength: Integer\r\n  ): String;\r\nbegin\r\n  CheckNegative(aStartIndex,'aStartIndex');\r\n  CheckNegative(aLength,'aLength');\r\n  CheckRange(aStartIndex,aLength,Length);\r\n  Writeln('FData : ',FData);\r\n  Result:=Copy(FData,1+aStartIndex,aStartIndex+aLength);\r\nend;\r\n\r\nprocedure TStringBuilder.DoReplace(Index: Integer; const Old, New: String);\r\n\r\nvar\r\n  OVLen : Integer;\r\n\r\nbegin\r\n  OVLen:=System.Length(Old);\r\n  System.Delete(FData,Index+1,OVLen);\r\n  System.Insert(New,FData,Index+1);\r\nend;\r\n\r\nFunction GetLocalTimeOffset : Integer;\r\n\r\nbegin\r\n  Result:=TJSDate.New.getTimezoneOffset;\r\nend;\r\n\r\nfunction GetLocalTimeOffset(const DateTime: TDateTime; const InputIsUTC: Boolean; out Offset: Integer): Boolean;\r\nbegin\r\n  offset:=DateTimeToJSDate(DateTime, InputIsUTC).getTimezoneOffset;\r\n  Result:=True;\r\nend;\r\n\r\nfunction GetLocalTimeOffset(const DateTime: TDateTime; const InputIsUTC: Boolean): Integer;\r\nbegin\r\n  if not GetLocalTimeOffset(DateTime, InputIsUTC, Result) then\r\n    Result:=GetLocalTimeOffset();\r\nend;\r\n\r\n\r\ninitialization\r\n  ShortMonthNames:=DefaultShortMonthNames;\r\n  LongMonthNames:=DefaultLongMonthNames;\r\n  ShortDayNames:=DefaultShortDayNames;\r\n  LongDayNames:=DefaultLongDayNames;\r\n\r\nend.\r\n\r\n","{\r\n    This file is part of the Pas2JS run time library.\r\n    Copyright (c) 2017 by Mattias Gaertner\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n{$IFNDEF FPC_DOTTEDUNITS}\r\nunit Classes;\r\n{$ENDIF}\r\n\r\n{$mode objfpc}\r\n\r\ninterface\r\n\r\nuses\r\n{$IFDEF FPC_DOTTEDUNITS}\r\n  System.RTLConsts, System.Types, System.SysUtils, JSApi.JS, System.TypInfo, System.Res;\r\n{$ELSE}\r\n  RTLConsts, Types, SysUtils, JS, TypInfo, p2jsres;\r\n{$ENDIF}  \r\n\r\ntype\r\n  TNotifyEvent = procedure(Sender: TObject) of object;\r\n  TNotifyEventRef = reference to procedure(Sender: TObject);\r\n  TStringNotifyEventRef = Reference to Procedure(Sender: TObject; Const aString : String);\r\n\r\n  // Notification operations :\r\n  // Observer has changed, is freed, item added to/deleted from list, custom event.\r\n  TFPObservedOperation = (ooChange,ooFree,ooAddItem,ooDeleteItem,ooCustom);\r\n\r\n  EStreamError = class(Exception);\r\n  EFCreateError = class(EStreamError);\r\n  EFOpenError = class(EStreamError);\r\n  EFilerError = class(EStreamError);\r\n  EReadError = class(EFilerError);\r\n  EWriteError = class(EFilerError);\r\n  EClassNotFound = class(EFilerError);\r\n  EMethodNotFound = class(EFilerError);\r\n  EInvalidImage = class(EFilerError);\r\n  EResNotFound = class(Exception);\r\n  EListError = class(Exception);\r\n  EBitsError = class(Exception);\r\n  EStringListError = class(EListError);\r\n  EComponentError = class(Exception);\r\n  EParserError = class(Exception);\r\n  EOutOfResources = class(EOutOfMemory);\r\n  EInvalidOperation = class(Exception);\r\n\r\n  TListAssignOp = (laCopy, laAnd, laOr, laXor, laSrcUnique, laDestUnique);\r\n  TListSortCompare = function(Item1, Item2: JSValue): Integer;\r\n  TListSortCompareFunc = reference to function (Item1, Item2: JSValue): Integer;\r\n  TListCallback = {$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}Types.TListCallback;\r\n  TListStaticCallback = {$IFDEF FPC_DOTTEDUNITS}System.{$ENDIF}Types.TListStaticCallback;\r\n  TAlignment = (taLeftJustify, taRightJustify, taCenter);\r\n\r\n  // Forward class definitions\r\n  TFPList = Class;\r\n  TReader = Class;\r\n  TWriter = Class;\r\n  TFiler = Class;\r\n\r\n  { TFPListEnumerator }\r\n  TFPListEnumerator = class\r\n  private\r\n    FList: TFPList;\r\n    FPosition: Integer;\r\n  public\r\n    constructor Create(AList: TFPList); reintroduce;\r\n    function GetCurrent: JSValue;\r\n    function MoveNext: Boolean;\r\n    property Current: JSValue read GetCurrent;\r\n  end;\r\n\r\n  { TFPList }\r\n\r\n  TFPList = class(TObject)\r\n  private\r\n    FList: TJSValueDynArray;\r\n    FCount: Integer;\r\n    FCapacity: Integer;\r\n    procedure CopyMove(aList: TFPList);\r\n    procedure MergeMove(aList: TFPList);\r\n    procedure DoCopy(ListA, ListB: TFPList);\r\n    procedure DoSrcUnique(ListA, ListB: TFPList);\r\n    procedure DoAnd(ListA, ListB: TFPList);\r\n    procedure DoDestUnique(ListA, ListB: TFPList);\r\n    procedure DoOr(ListA, ListB: TFPList);\r\n    procedure DoXOr(ListA, ListB: TFPList);\r\n  protected\r\n    function Get(Index: Integer): JSValue; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n    procedure Put(Index: Integer; Item: JSValue); {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n    procedure SetCapacity(NewCapacity: Integer);\r\n    procedure SetCount(NewCount: Integer);\r\n    Procedure RaiseIndexError(Index: Integer);\r\n  public\r\n    //Type\r\n    //  TDirection = (FromBeginning, FromEnd);\r\n    destructor Destroy; override;\r\n    procedure AddList(AList: TFPList);\r\n    function Add(Item: JSValue): Integer; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n    procedure Clear;\r\n    procedure Delete(Index: Integer); {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n    class procedure Error(const Msg: string; const Data: String);\r\n    procedure Exchange(Index1, Index2: Integer);\r\n    function Expand: TFPList; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n    function Extract(Item: JSValue): JSValue;\r\n    function First: JSValue;\r\n    function GetEnumerator: TFPListEnumerator;\r\n    function IndexOf(Item: JSValue): Integer;\r\n    function IndexOfItem(Item: JSValue; Direction: TDirection): Integer;\r\n    procedure Insert(Index: Integer; Item: JSValue); {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n    function Last: JSValue;\r\n    procedure Move(CurIndex, NewIndex: Integer);\r\n    procedure Assign (ListA: TFPList; AOperator: TListAssignOp=laCopy; ListB: TFPList=nil);\r\n    function Remove(Item: JSValue): Integer;\r\n    procedure Pack;\r\n    procedure Sort(const Compare: TListSortCompare);\r\n    procedure SortList(const Compare: TListSortCompareFunc);\r\n    procedure ForEachCall(const proc2call: TListCallback; const arg: JSValue);\r\n    procedure ForEachCall(const proc2call: TListStaticCallback; const arg: JSValue);\r\n    property Capacity: Integer read FCapacity write SetCapacity;\r\n    property Count: Integer read FCount write SetCount;\r\n    property Items[Index: Integer]: JSValue read Get write Put; default;\r\n    property List: TJSValueDynArray read FList;\r\n  end;\r\n\r\n  TListNotification = (lnAdded, lnExtracted, lnDeleted);\r\n  TList = class;\r\n\r\n  { TListEnumerator }\r\n\r\n  TListEnumerator = class\r\n  private\r\n    FList: TList;\r\n    FPosition: Integer;\r\n  public\r\n    constructor Create(AList: TList); reintroduce;\r\n    function GetCurrent: JSValue;\r\n    function MoveNext: Boolean;\r\n    property Current: JSValue read GetCurrent;\r\n  end;\r\n\r\n  { TList }\r\n\r\n  TList = class(TObject)\r\n  private\r\n    FList: TFPList;\r\n    procedure CopyMove (aList : TList);\r\n    procedure MergeMove (aList : TList);\r\n    procedure DoCopy(ListA, ListB : TList);\r\n    procedure DoSrcUnique(ListA, ListB : TList);\r\n    procedure DoAnd(ListA, ListB : TList);\r\n    procedure DoDestUnique(ListA, ListB : TList);\r\n    procedure DoOr(ListA, ListB : TList);\r\n    procedure DoXOr(ListA, ListB : TList);\r\n  protected\r\n    function Get(Index: Integer): JSValue;\r\n    procedure Put(Index: Integer; Item: JSValue);\r\n    procedure Notify(aValue: JSValue; Action: TListNotification); virtual;\r\n    procedure SetCapacity(NewCapacity: Integer);\r\n    function GetCapacity: integer;\r\n    procedure SetCount(NewCount: Integer);\r\n    function GetCount: integer;\r\n    function GetList: TJSValueDynArray;\r\n    property FPList : TFPList Read FList;\r\n  public\r\n    constructor Create; reintroduce;\r\n    destructor Destroy; override;\r\n    Procedure AddList(AList : TList);\r\n    function Add(Item: JSValue): Integer;\r\n    procedure Clear; virtual;\r\n    procedure Delete(Index: Integer);\r\n    class procedure Error(const Msg: string; Data: String); virtual;\r\n    procedure Exchange(Index1, Index2: Integer);\r\n    function Expand: TList;\r\n    function Extract(Item: JSValue): JSValue;\r\n    function First: JSValue;\r\n    function GetEnumerator: TListEnumerator;\r\n    function IndexOf(Item: JSValue): Integer;\r\n    procedure Insert(Index: Integer; Item: JSValue);\r\n    function Last: JSValue;\r\n    procedure Move(CurIndex, NewIndex: Integer);\r\n    procedure Assign (ListA: TList; AOperator: TListAssignOp=laCopy; ListB: TList=nil);\r\n    function Remove(Item: JSValue): Integer;\r\n    procedure Pack;\r\n    procedure Sort(const Compare: TListSortCompare);\r\n    procedure SortList(const Compare: TListSortCompareFunc);\r\n    property Capacity: Integer read GetCapacity write SetCapacity;\r\n    property Count: Integer read GetCount write SetCount;\r\n    property Items[Index: Integer]: JSValue read Get write Put; default;\r\n    property List: TJSValueDynArray read GetList;\r\n  end;\r\n\r\n  { TPersistent }\r\n  \r\n{$M+}\r\n\r\n  TPersistent = class(TObject)\r\n  private\r\n    //FObservers : TFPList;\r\n    procedure AssignError(Source: TPersistent);\r\n  protected\r\n    procedure DefineProperties(Filer: TFiler); virtual;\r\n    procedure AssignTo(Dest: TPersistent); virtual;\r\n    function GetOwner: TPersistent; virtual;\r\n  public\r\n    procedure Assign(Source: TPersistent); virtual;\r\n    //procedure FPOAttachObserver(AObserver : TObject);\r\n    //procedure FPODetachObserver(AObserver : TObject);\r\n    //procedure FPONotifyObservers(ASender : TObject; AOperation: TFPObservedOperation; Data: TObject);\r\n    function GetNamePath: string; virtual;\r\n  end;\r\n  TPersistentClass = Class of TPersistent;\r\n\r\n  { TInterfacedPersistent }\r\n\r\n  TInterfacedPersistent = class(TPersistent, IInterface)\r\n  private\r\n    FOwnerInterface: IInterface;\r\n  protected\r\n    function _AddRef: Integer; {$IFDEF MAKESTUB}stdcall;{$ENDIF}\r\n    function _Release: Integer; {$IFDEF MAKESTUB}stdcall;{$ENDIF}\r\n  public\r\n    function QueryInterface(const IID: TGUID; out Obj): HRESULT; virtual;{$IFDEF MAKESTUB} stdcall;{$ENDIF}\r\n    procedure AfterConstruction; override;\r\n  end;\r\n\r\n\r\n  TStrings = Class;\r\n  { TStringsEnumerator class }\r\n\r\n  TStringsEnumerator = class\r\n  private\r\n    FStrings: TStrings;\r\n    FPosition: Integer;\r\n  public\r\n    constructor Create(AStrings: TStrings); reintroduce;\r\n    function GetCurrent: String;\r\n    function MoveNext: Boolean;\r\n    property Current: String read GetCurrent;\r\n  end;\r\n\r\n\r\n  { TStrings class }\r\n  TStrings = class(TPersistent)\r\n  private\r\n    FSpecialCharsInited : boolean;\r\n    FAlwaysQuote: Boolean;\r\n    FQuoteChar : Char;\r\n    FDelimiter : Char;\r\n    FNameValueSeparator : Char;\r\n    FUpdateCount: Integer;\r\n    FLBS : TTextLineBreakStyle;\r\n    FSkipLastLineBreak : Boolean;\r\n    FStrictDelimiter : Boolean;\r\n    FLineBreak : String;\r\n    function GetCommaText: string;\r\n    function GetName(Index: Integer): string;\r\n    function GetValue(const Name: string): string;\r\n    Function GetLBS : TTextLineBreakStyle;\r\n    Procedure SetLBS (AValue : TTextLineBreakStyle);\r\n    procedure SetCommaText(const Value: string);\r\n    procedure SetValue(const Name : String; Const Value: string);\r\n    procedure SetDelimiter(c:Char);\r\n    procedure SetQuoteChar(c:Char);\r\n    procedure SetNameValueSeparator(c:Char);\r\n    procedure DoSetTextStr(const Value: string; DoClear : Boolean);\r\n    Function GetDelimiter : Char;\r\n    Function GetNameValueSeparator : Char;\r\n    Function GetQuoteChar: Char;\r\n    Function GetLineBreak : String;\r\n    procedure SetLineBreak(const S : String);\r\n    Function GetSkipLastLineBreak : Boolean;\r\n    procedure SetSkipLastLineBreak(const AValue : Boolean);\r\n    procedure ReadData(Reader: TReader);\r\n    procedure WriteData(Writer: TWriter);\r\n  protected\r\n    procedure DefineProperties(Filer: TFiler); override;\r\n    procedure Error(const Msg: string; Data: Integer);\r\n    function Get(Index: Integer): string; virtual; abstract;\r\n    function GetCapacity: Integer; virtual;\r\n    function GetCount: Integer; virtual; abstract;\r\n    function GetObject(Index: Integer): TObject; virtual;\r\n    function GetTextStr: string; virtual;\r\n    procedure Put(Index: Integer; const S: string); virtual;\r\n    procedure PutObject(Index: Integer; AObject: TObject); virtual;\r\n    procedure SetCapacity(NewCapacity: Integer); virtual;\r\n    procedure SetTextStr(const Value: string); virtual;\r\n    procedure SetUpdateState(Updating: Boolean); virtual;\r\n    property UpdateCount: Integer read FUpdateCount;\r\n    Function DoCompareText(const s1,s2 : string) : PtrInt; virtual;\r\n    Function GetDelimitedText: string;\r\n    Procedure SetDelimitedText(Const AValue: string);\r\n    Function GetValueFromIndex(Index: Integer): string;\r\n    Procedure SetValueFromIndex(Index: Integer; const Value: string);\r\n    Procedure CheckSpecialChars;\r\n//    Class Function GetNextLine (Const Value : String; Var S : String; Var P : Integer) : Boolean;\r\n    Function GetNextLinebreak (Const Value : String; Out S : String; Var P : Integer) : Boolean;\r\n  public\r\n    constructor Create; reintroduce;\r\n    destructor Destroy; override;\r\n    function ToObjectArray: TObjectDynArray; overload;\r\n    function ToObjectArray(aStart,aEnd : Integer): TObjectDynArray; overload;\r\n    function ToStringArray: TStringDynArray; overload;\r\n    function ToStringArray(aStart,aEnd : Integer): TStringDynArray; overload;\r\n    function Add(const S: string): Integer; virtual; overload;\r\n    function Add(const Fmt : string; const Args : Array of const): Integer; overload;\r\n    function AddFmt(const Fmt : string; const Args : Array of const): Integer;\r\n    function AddObject(const S: string; AObject: TObject): Integer; virtual; overload;\r\n    function AddObject(const Fmt: string; Args : Array of const; AObject: TObject): Integer; overload;\r\n    procedure Append(const S: string);\r\n    procedure AddStrings(TheStrings: TStrings); overload; virtual;\r\n    procedure AddStrings(TheStrings: TStrings; ClearFirst : Boolean); overload;\r\n    procedure AddStrings(const TheStrings: array of string); overload; virtual;\r\n    procedure AddStrings(const TheStrings: array of string; ClearFirst : Boolean); overload;\r\n    function AddPair(const AName, AValue: string): TStrings; overload;\r\n    function AddPair(const AName, AValue: string; AObject: TObject): TStrings; overload;\r\n    Procedure AddText(Const S : String); virtual;\r\n    procedure Assign(Source: TPersistent); override;\r\n    procedure BeginUpdate;\r\n    procedure Clear; virtual; abstract;\r\n    procedure Delete(Index: Integer); virtual; abstract;\r\n    procedure EndUpdate;\r\n    function Equals(Obj: TObject): Boolean; override; overload;\r\n    function Equals(TheStrings: TStrings): Boolean; overload;\r\n    procedure Exchange(Index1, Index2: Integer); virtual;\r\n    function GetEnumerator: TStringsEnumerator;\r\n    function IndexOf(const S: string): Integer; virtual;\r\n    function IndexOfName(const Name: string): Integer; virtual;\r\n    function IndexOfObject(AObject: TObject): Integer; virtual;\r\n    procedure Insert(Index: Integer; const S: string); virtual; abstract;\r\n    procedure InsertObject(Index: Integer; const S: string; AObject: TObject);\r\n    procedure Move(CurIndex, NewIndex: Integer); virtual;\r\n    procedure GetNameValue(Index : Integer; Out AName,AValue : String);\r\n    Procedure LoadFromURL(Const aURL : String; Async : Boolean = True; OnLoaded : TNotifyEventRef = Nil; OnError: TStringNotifyEventRef = Nil); virtual;\r\n    // Delphi compatibility. Must be an URL\r\n    Procedure LoadFromFile(Const aFileName : String; const OnLoaded : TProc = Nil; const AError: TProcString = Nil);\r\n    function  ExtractName(Const S:String):String;\r\n    Property TextLineBreakStyle : TTextLineBreakStyle Read GetLBS Write SetLBS;\r\n    property Delimiter: Char read GetDelimiter write SetDelimiter;\r\n    property DelimitedText: string read GetDelimitedText write SetDelimitedText;\r\n    property LineBreak : string Read GetLineBreak write SetLineBreak;\r\n    Property StrictDelimiter : Boolean Read FStrictDelimiter Write FStrictDelimiter;\r\n    property AlwaysQuote: Boolean read FAlwaysQuote write FAlwaysQuote;\r\n    property QuoteChar: Char read GetQuoteChar write SetQuoteChar;\r\n    Property NameValueSeparator : Char Read GetNameValueSeparator Write SetNameValueSeparator;\r\n    property ValueFromIndex[Index: Integer]: string read GetValueFromIndex write SetValueFromIndex;\r\n    property Capacity: Integer read GetCapacity write SetCapacity;\r\n    property CommaText: string read GetCommaText write SetCommaText;\r\n    property Count: Integer read GetCount;\r\n    property Names[Index: Integer]: string read GetName;\r\n    property Objects[Index: Integer]: TObject read GetObject write PutObject;\r\n    property Values[const Name: string]: string read GetValue write SetValue;\r\n    property Strings[Index: Integer]: string read Get write Put; default;\r\n    property Text: string read GetTextStr write SetTextStr;\r\n    Property SkipLastLineBreak : Boolean Read GetSkipLastLineBreak Write SetSkipLastLineBreak;\r\n  end;\r\n\r\n  { TStringList}\r\n  TStringItem = record\r\n     FString: string;\r\n     FObject: TObject;\r\n   end;\r\n\r\n  TStringItemArray = Array of TStringItem;\r\n\r\n  TStringList = class;\r\n  TStringListSortCompare = function(List: TStringList; Index1, Index2: Integer): Integer;\r\n\r\n  TStringsSortStyle = (sslNone,sslUser,sslAuto);\r\n  TStringsSortStyles = Set of TStringsSortStyle;\r\n\r\n  TStringList = class(TStrings)\r\n  private\r\n    FList: TStringItemArray;\r\n    FCount: Integer;\r\n    FOnChange: TNotifyEvent;\r\n    FOnChanging: TNotifyEvent;\r\n    FDuplicates: TDuplicates;\r\n    FCaseSensitive : Boolean;\r\n    FForceSort : Boolean;\r\n    FOwnsObjects : Boolean;\r\n    FSortStyle: TStringsSortStyle;\r\n    procedure ExchangeItemsInt(Index1, Index2: Integer);\r\n    function GetSorted: Boolean;\r\n    procedure Grow;\r\n    procedure InternalClear(FromIndex : Integer = 0; ClearOnly : Boolean = False);\r\n    procedure QuickSort(L, R: Integer; CompareFn: TStringListSortCompare);\r\n    procedure SetSorted(Value: Boolean);\r\n    procedure SetCaseSensitive(b : boolean);\r\n    procedure SetSortStyle(AValue: TStringsSortStyle);\r\n  protected\r\n    Procedure CheckIndex(AIndex : Integer);\r\n    procedure ExchangeItems(Index1, Index2: Integer); virtual;\r\n    procedure Changed; virtual;\r\n    procedure Changing; virtual;\r\n    function Get(Index: Integer): string; override;\r\n    function GetCapacity: Integer; override;\r\n    function GetCount: Integer; override;\r\n    function GetObject(Index: Integer): TObject; override;\r\n    procedure Put(Index: Integer; const S: string); override;\r\n    procedure PutObject(Index: Integer; AObject: TObject); override;\r\n    procedure SetCapacity(NewCapacity: Integer); override;\r\n    procedure SetUpdateState(Updating: Boolean); override;\r\n    procedure InsertItem(Index: Integer; const S: string); virtual;\r\n    procedure InsertItem(Index: Integer; const S: string; O: TObject); virtual;\r\n    Function DoCompareText(const s1,s2 : string) : PtrInt; override;\r\n    function CompareStrings(const s1,s2 : string) : Integer; virtual;\r\n  public\r\n    destructor Destroy; override;\r\n    function Add(const S: string): Integer; override;\r\n    procedure Clear; override;\r\n    procedure Delete(Index: Integer); override;\r\n    procedure Exchange(Index1, Index2: Integer); override;\r\n    function Find(const S: string; Out Index: Integer): Boolean; virtual;\r\n    function IndexOf(const S: string): Integer; override;\r\n    procedure Insert(Index: Integer; const S: string); override;\r\n    procedure Sort; virtual;\r\n    procedure CustomSort(CompareFn: TStringListSortCompare); virtual;\r\n    property Duplicates: TDuplicates read FDuplicates write FDuplicates;\r\n    property Sorted: Boolean read GetSorted write SetSorted;\r\n    property CaseSensitive: Boolean read FCaseSensitive write SetCaseSensitive;\r\n    property OnChange: TNotifyEvent read FOnChange write FOnChange;\r\n    property OnChanging: TNotifyEvent read FOnChanging write FOnChanging;\r\n    property OwnsObjects : boolean read FOwnsObjects write FOwnsObjects;\r\n    Property SortStyle : TStringsSortStyle Read FSortStyle Write SetSortStyle;\r\n  end;\r\n\r\n  TCollection = class;\r\n\r\n  { TCollectionItem }\r\n\r\n  TCollectionItem = class(TPersistent)\r\n  private\r\n    FCollection: TCollection;\r\n    FID: Integer;\r\n    FUpdateCount: Integer;\r\n    function GetIndex: Integer;\r\n  protected\r\n    procedure SetCollection(Value: TCollection);virtual;\r\n    procedure Changed(AllItems: Boolean);\r\n    function GetOwner: TPersistent; override;\r\n    function GetDisplayName: string; virtual;\r\n    procedure SetIndex(Value: Integer); virtual;\r\n    procedure SetDisplayName(const Value: string); virtual;\r\n    property UpdateCount: Integer read FUpdateCount;\r\n  public\r\n    constructor Create(ACollection: TCollection); virtual; reintroduce;\r\n    destructor Destroy; override;\r\n    function GetNamePath: string; override;\r\n    property Collection: TCollection read FCollection write SetCollection;\r\n    property ID: Integer read FID;\r\n    property Index: Integer read GetIndex write SetIndex;\r\n    property DisplayName: string read GetDisplayName write SetDisplayName;\r\n  end;\r\n\r\n  TCollectionEnumerator = class\r\n  private\r\n    FCollection: TCollection;\r\n    FPosition: Integer;\r\n  public\r\n    constructor Create(ACollection: TCollection); reintroduce;\r\n    function GetCurrent: TCollectionItem;\r\n    function MoveNext: Boolean;\r\n    property Current: TCollectionItem read GetCurrent;\r\n  end;\r\n\r\n  TCollectionItemClass = class of TCollectionItem;\r\n  TCollectionNotification = (cnAdded, cnExtracting, cnDeleting);\r\n  TCollectionSortCompare = function (Item1, Item2: TCollectionItem): Integer;\r\n  TCollectionSortCompareFunc = reference to function (Item1, Item2: TCollectionItem): Integer;\r\n\r\n  TCollection = class(TPersistent)\r\n  private\r\n    FItemClass: TCollectionItemClass;\r\n    FItems: TFpList;\r\n    FUpdateCount: Integer;\r\n    FNextID: Integer;\r\n    FPropName: string;\r\n    function GetCount: Integer;\r\n    function GetPropName: string;\r\n    procedure InsertItem(Item: TCollectionItem);\r\n    procedure RemoveItem(Item: TCollectionItem);\r\n    procedure DoClear;\r\n  protected\r\n    { Design-time editor support }\r\n    function GetAttrCount: Integer; virtual;\r\n    function GetAttr(Index: Integer): string; virtual;\r\n    function GetItemAttr(Index, ItemIndex: Integer): string; virtual;\r\n    procedure Changed;\r\n    function GetItem(Index: Integer): TCollectionItem;\r\n    procedure SetItem(Index: Integer; Value: TCollectionItem);\r\n    procedure SetItemName(Item: TCollectionItem); virtual;\r\n    procedure SetPropName; virtual;\r\n    procedure Update(Item: TCollectionItem); virtual;\r\n    procedure Notify(Item: TCollectionItem;Action: TCollectionNotification); virtual;\r\n    property PropName: string read GetPropName write FPropName;\r\n    property UpdateCount: Integer read FUpdateCount;\r\n  public\r\n    constructor Create(AItemClass: TCollectionItemClass); reintroduce;\r\n    destructor Destroy; override;\r\n    function Owner: TPersistent;\r\n    function Add: TCollectionItem;\r\n    procedure Assign(Source: TPersistent); override;\r\n    procedure BeginUpdate; virtual;\r\n    procedure Clear;\r\n    procedure EndUpdate; virtual;\r\n    procedure Delete(Index: Integer);\r\n    function GetEnumerator: TCollectionEnumerator;\r\n    function GetNamePath: string; override;\r\n    function Insert(Index: Integer): TCollectionItem;\r\n    function FindItemID(ID: Integer): TCollectionItem;\r\n    procedure Exchange(Const Index1, index2: integer);\r\n    procedure Sort(Const Compare : TCollectionSortCompare);\r\n    procedure SortList(Const Compare : TCollectionSortCompareFunc);\r\n    property Count: Integer read GetCount;\r\n    property ItemClass: TCollectionItemClass read FItemClass;\r\n    property Items[Index: Integer]: TCollectionItem read GetItem write SetItem;\r\n  end;\r\n\r\n  TOwnedCollection = class(TCollection)\r\n  private\r\n    FOwner: TPersistent;\r\n  protected\r\n    Function GetOwner: TPersistent; override;\r\n  public\r\n    Constructor Create(AOwner: TPersistent; AItemClass: TCollectionItemClass); reintroduce;\r\n  end;\r\n\r\n  TComponent = Class;\r\n\r\n  TOperation = (opInsert, opRemove);\r\n\r\n  TComponentStateItem = ( csLoading, csReading, csWriting,  csDestroying,\r\n    csDesigning, csAncestor, csUpdating, csFixups, csFreeNotification,\r\n    csInline, csDesignInstance);\r\n  TComponentState = set of TComponentStateItem;\r\n  TComponentStyleItem = (csInheritable, csCheckPropAvail, csSubComponent, csTransient);\r\n  TComponentStyle = set of TComponentStyleItem;\r\n\r\n  TGetChildProc = procedure (Child: TComponent) of object;\r\n\r\n  TComponentName = string;\r\n\r\n  { TComponentEnumerator }\r\n\r\n  TComponentEnumerator = class\r\n  private\r\n    FComponent: TComponent;\r\n    FPosition: Integer;\r\n  public\r\n    constructor Create(AComponent: TComponent); reintroduce;\r\n    function GetCurrent: TComponent;\r\n    function MoveNext: Boolean;\r\n    property Current: TComponent read GetCurrent;\r\n  end;\r\n\r\n  TComponent = class(TPersistent, IInterface)\r\n  private\r\n    FOwner: TComponent;\r\n    FName: TComponentName;\r\n    FTag: Ptrint;\r\n    FComponents: TFpList;\r\n    FFreeNotifies: TFpList;\r\n    FDesignInfo: Longint;\r\n    FComponentState: TComponentState;\r\n    function GetComponent(AIndex: Integer): TComponent;\r\n    function GetComponentCount: Integer;\r\n    function GetComponentIndex: Integer;\r\n    procedure Insert(AComponent: TComponent);\r\n    procedure ReadLeft(AReader: TReader);\r\n    procedure ReadTop(AReader: TReader);\r\n    procedure Remove(AComponent: TComponent);\r\n    procedure RemoveNotification(AComponent: TComponent);\r\n    procedure SetComponentIndex(Value: Integer);\r\n    procedure SetReference(Enable: Boolean);\r\n    procedure WriteLeft(AWriter: TWriter);\r\n    procedure WriteTop(AWriter: TWriter);\r\n  protected\r\n    FComponentStyle: TComponentStyle;\r\n    procedure ChangeName(const NewName: TComponentName);\r\n    procedure DefineProperties(Filer: TFiler); override;\r\n    procedure GetChildren(Proc: TGetChildProc; Root: TComponent); virtual;\r\n    function GetChildOwner: TComponent; virtual;\r\n    function GetChildParent: TComponent; virtual;\r\n    function GetOwner: TPersistent; override;\r\n    procedure Loaded; virtual;\r\n    procedure Loading; virtual;\r\n    procedure SetWriting(Value: Boolean); virtual;\r\n    procedure SetReading(Value: Boolean); virtual;\r\n    procedure Notification(AComponent: TComponent;  Operation: TOperation); virtual;\r\n    procedure PaletteCreated; virtual;\r\n    procedure ReadState(Reader: TReader); virtual;\r\n    procedure SetAncestor(Value: Boolean);\r\n    procedure SetDesigning(Value: Boolean; SetChildren : Boolean = True);\r\n    procedure SetDesignInstance(Value: Boolean);\r\n    procedure SetInline(Value: Boolean);\r\n    procedure SetName(const NewName: TComponentName); virtual;\r\n    procedure SetChildOrder(Child: TComponent; Order: Integer); virtual;\r\n    procedure SetParentComponent(Value: TComponent); virtual;\r\n    procedure Updating; virtual;\r\n    procedure Updated; virtual;\r\n    procedure ValidateRename(AComponent: TComponent;  const CurName, NewName: string); virtual;\r\n    procedure ValidateContainer(AComponent: TComponent); virtual;\r\n    procedure ValidateInsert(AComponent: TComponent); virtual;\r\n  protected\r\n    function _AddRef: Integer; {$IFDEF MAKESTUB}stdcall;{$ENDIF}\r\n    function _Release: Integer;  {$IFDEF MAKESTUB}stdcall;{$ENDIF}\r\n  public\r\n    constructor Create(AOwner: TComponent); virtual; reintroduce;\r\n    destructor Destroy; override;\r\n    procedure BeforeDestruction; override;\r\n    procedure DestroyComponents;\r\n    procedure Destroying;\r\n    function QueryInterface(const IID: TGUID; out Obj): HRESULT; virtual;  {$IFDEF MAKESTUB} stdcall;{$ENDIF}\r\n    procedure WriteState(Writer: TWriter); virtual;\r\n//    function ExecuteAction(Action: TBasicAction): Boolean; virtual;\r\n    function FindComponent(const AName: string): TComponent;\r\n    procedure FreeNotification(AComponent: TComponent);\r\n    procedure RemoveFreeNotification(AComponent: TComponent);\r\n    function GetNamePath: string; override;\r\n    function GetParentComponent: TComponent; virtual;\r\n    function HasParent: Boolean; virtual;\r\n    procedure InsertComponent(AComponent: TComponent);\r\n    procedure RemoveComponent(AComponent: TComponent);\r\n    procedure SetSubComponent(ASubComponent: Boolean);\r\n    function GetEnumerator: TComponentEnumerator;\r\n//    function UpdateAction(Action: TBasicAction): Boolean; dynamic;\r\n    property Components[Index: Integer]: TComponent read GetComponent;\r\n    property ComponentCount: Integer read GetComponentCount;\r\n    property ComponentIndex: Integer read GetComponentIndex write SetComponentIndex;\r\n    property ComponentState: TComponentState read FComponentState;\r\n    property ComponentStyle: TComponentStyle read FComponentStyle;\r\n    property DesignInfo: Longint read FDesignInfo write FDesignInfo;\r\n    property Owner: TComponent read FOwner;\r\n  published\r\n    property Name: TComponentName read FName write SetName stored False;\r\n    property Tag: PtrInt read FTag write FTag default 0;\r\n  end;\r\n  TComponentClass = Class of TComponent;\r\n\r\n  TSeekOrigin = (soBeginning, soCurrent, soEnd);\r\n\r\n  { TStream }\r\n\r\n  TStream = class(TObject)\r\n  private\r\n    FEndian: TEndian;\r\n    function MakeInt(B: TBytes; aSize: Integer; Signed: Boolean): NativeInt;\r\n    function MakeBytes(B: NativeInt; aSize: Integer; Signed: Boolean): TBytes;\r\n  protected\r\n    procedure InvalidSeek; virtual;\r\n    procedure Discard(const Count: NativeInt);\r\n    procedure DiscardLarge(Count: NativeInt; const MaxBufferSize: Longint);\r\n    procedure FakeSeekForward(Offset: NativeInt; const Origin: TSeekOrigin; const Pos: NativeInt);\r\n    function  GetPosition: NativeInt; virtual;\r\n    procedure SetPosition(const Pos: NativeInt); virtual;\r\n    function  GetSize: NativeInt; virtual;\r\n    procedure SetSize(const NewSize: NativeInt); virtual;\r\n    procedure SetSize64(const NewSize: NativeInt); virtual;\r\n    procedure ReadNotImplemented;\r\n    procedure WriteNotImplemented;\r\n    function ReadMaxSizeData(Buffer : TBytes; aSize,aCount : NativeInt) : NativeInt;\r\n    Procedure ReadExactSizeData(Buffer : TBytes; aSize,aCount : NativeInt);\r\n    function WriteMaxSizeData(Const Buffer : TBytes; aSize,aCount : NativeInt) : NativeInt;\r\n    Procedure WriteExactSizeData(Const Buffer : TBytes; aSize,aCount : NativeInt);\r\n  public\r\n    function Read(var Buffer: TBytes; Count: Longint): Longint; overload;\r\n    function Read(Buffer : TBytes; aOffset, Count: Longint): Longint; virtual; abstract; overload;\r\n\r\n    function Write(const Buffer: TBytes; Count: Longint): Longint; virtual; overload;\r\n    function Write(const Buffer: TBytes; Offset, Count: Longint): Longint; virtual; abstract; overload;\r\n\r\n    function Seek(const Offset: NativeInt; Origin: TSeekOrigin): NativeInt; virtual; abstract; overload;\r\n\r\n    function ReadData(Buffer: TBytes; Count: NativeInt): NativeInt; overload;\r\n    function ReadData(var Buffer: Boolean): NativeInt; overload;\r\n    function ReadData(var Buffer: Boolean; Count: NativeInt): NativeInt; overload;\r\n    function ReadData(var Buffer: WideChar): NativeInt; overload;\r\n    function ReadData(var Buffer: WideChar; Count: NativeInt): NativeInt; overload;\r\n    function ReadData(var Buffer: Int8): NativeInt; overload;\r\n    function ReadData(var Buffer: Int8; Count: NativeInt): NativeInt; overload;\r\n    function ReadData(var Buffer: UInt8): NativeInt; overload;\r\n    function ReadData(var Buffer: UInt8; Count: NativeInt): NativeInt; overload;\r\n    function ReadData(var Buffer: Int16): NativeInt; overload;\r\n    function ReadData(var Buffer: Int16; Count: NativeInt): NativeInt; overload;\r\n    function ReadData(var Buffer: UInt16): NativeInt; overload;\r\n    function ReadData(var Buffer: UInt16; Count: NativeInt): NativeInt; overload;\r\n    function ReadData(var Buffer: Int32): NativeInt; overload;\r\n    function ReadData(var Buffer: Int32; Count: NativeInt): NativeInt; overload;\r\n    function ReadData(var Buffer: UInt32): NativeInt; overload;\r\n    function ReadData(var Buffer: UInt32; Count: NativeInt): NativeInt; overload;\r\n    // NativeLargeint. Stored as a float64, Read as float64.\r\n    function ReadData(var Buffer: NativeLargeInt): NativeInt; overload;\r\n    function ReadData(var Buffer: NativeLargeInt; Count: NativeInt): NativeInt; overload;\r\n    function ReadData(var Buffer: NativeLargeUInt): NativeInt; overload;\r\n    function ReadData(var Buffer: NativeLargeUInt; Count: NativeInt): NativeInt; overload;\r\n    // Note: a ReadData with Int64 would be Delphi/FPC incompatible\r\n    function ReadData(var Buffer: Double): NativeInt; overload;\r\n    function ReadData(var Buffer: Double; Count: NativeInt): NativeInt; overload;\r\n    procedure ReadBuffer(var Buffer: TBytes; Count: NativeInt); overload;\r\n    procedure ReadBuffer(var Buffer: TBytes; Offset, Count: NativeInt); overload;\r\n\r\n    procedure ReadBufferData(var Buffer: Boolean); overload;\r\n    procedure ReadBufferData(var Buffer: Boolean; Count: NativeInt); overload;\r\n    procedure ReadBufferData(var Buffer: WideChar); overload;\r\n    procedure ReadBufferData(var Buffer: WideChar; Count: NativeInt); overload;\r\n    procedure ReadBufferData(var Buffer: Int8); overload;\r\n    procedure ReadBufferData(var Buffer: Int8; Count: NativeInt); overload;\r\n    procedure ReadBufferData(var Buffer: UInt8); overload;\r\n    procedure ReadBufferData(var Buffer: UInt8; Count: NativeInt); overload;\r\n    procedure ReadBufferData(var Buffer: Int16); overload;\r\n    procedure ReadBufferData(var Buffer: Int16; Count: NativeInt); overload;\r\n    procedure ReadBufferData(var Buffer: UInt16); overload;\r\n    procedure ReadBufferData(var Buffer: UInt16; Count: NativeInt); overload;\r\n    procedure ReadBufferData(var Buffer: Int32); overload;\r\n    procedure ReadBufferData(var Buffer: Int32; Count: NativeInt); overload;\r\n    procedure ReadBufferData(var Buffer: UInt32); overload;\r\n    procedure ReadBufferData(var Buffer: UInt32; Count: NativeInt); overload;\r\n    // NativeLargeint. Stored as a float64, Read as float64.\r\n    procedure ReadBufferData(var Buffer: NativeLargeInt); overload;\r\n    procedure ReadBufferData(var Buffer: NativeLargeInt; Count: NativeInt); overload;\r\n    procedure ReadBufferData(var Buffer: NativeLargeUInt); overload;\r\n    procedure ReadBufferData(var Buffer: NativeLargeUInt; Count: NativeInt); overload;\r\n    procedure ReadBufferData(var Buffer: Double); overload;\r\n    procedure ReadBufferData(var Buffer: Double; Count: NativeInt); overload;\r\n    procedure WriteBuffer(const Buffer: TBytes; Count: NativeInt); overload;\r\n    procedure WriteBuffer(const Buffer: TBytes; Offset, Count: NativeInt); overload;\r\n\r\n    function WriteData(const Buffer: TBytes; Count: NativeInt): NativeInt; overload;\r\n    function WriteData(const Buffer: Boolean): NativeInt; overload;\r\n    function WriteData(const Buffer: Boolean; Count: NativeInt): NativeInt; overload;\r\n    function WriteData(const Buffer: WideChar): NativeInt; overload;\r\n    function WriteData(const Buffer: WideChar; Count: NativeInt): NativeInt; overload;\r\n    function WriteData(const Buffer: Int8): NativeInt; overload;\r\n    function WriteData(const Buffer: Int8; Count: NativeInt): NativeInt; overload;\r\n    function WriteData(const Buffer: UInt8): NativeInt; overload;\r\n    function WriteData(const Buffer: UInt8; Count: NativeInt): NativeInt; overload;\r\n    function WriteData(const Buffer: Int16): NativeInt; overload;\r\n    function WriteData(const Buffer: Int16; Count: NativeInt): NativeInt; overload;\r\n    function WriteData(const Buffer: UInt16): NativeInt; overload;\r\n    function WriteData(const Buffer: UInt16; Count: NativeInt): NativeInt; overload;\r\n    function WriteData(const Buffer: Int32): NativeInt; overload;\r\n    function WriteData(const Buffer: Int32; Count: NativeInt): NativeInt; overload;\r\n    function WriteData(const Buffer: UInt32): NativeInt; overload;\r\n    function WriteData(const Buffer: UInt32; Count: NativeInt): NativeInt; overload;\r\n    // NativeLargeint. Stored as a float64, Read as float64.\r\n    function WriteData(const Buffer: NativeLargeInt): NativeInt; overload;\r\n    function WriteData(const Buffer: NativeLargeInt; Count: NativeInt): NativeInt; overload;\r\n    function WriteData(const Buffer: NativeLargeUInt): NativeInt; overload;\r\n    function WriteData(const Buffer: NativeLargeUInt; Count: NativeInt): NativeInt; overload;\r\n    function WriteData(const Buffer: Double): NativeInt; overload;\r\n    function WriteData(const Buffer: Double; Count: NativeInt): NativeInt; overload;\r\n{$IFDEF FPC_HAS_TYPE_EXTENDED}\r\n    function WriteData(const Buffer: Extended): NativeInt; overload;\r\n    function WriteData(const Buffer: Extended; Count: NativeInt): NativeInt; overload;\r\n    function WriteData(const Buffer: TExtended80Rec): NativeInt; overload;\r\n    function WriteData(const Buffer: TExtended80Rec; Count: NativeInt): NativeInt; overload;\r\n{$ENDIF}\r\n    procedure WriteBufferData(Buffer: Int32); overload;\r\n    procedure WriteBufferData(Buffer: Int32; Count: NativeInt); overload;\r\n    procedure WriteBufferData(Buffer: Boolean); overload;\r\n    procedure WriteBufferData(Buffer: Boolean; Count: NativeInt); overload;\r\n    procedure WriteBufferData(Buffer: WideChar); overload;\r\n    procedure WriteBufferData(Buffer: WideChar; Count: NativeInt); overload;\r\n    procedure WriteBufferData(Buffer: Int8); overload;\r\n    procedure WriteBufferData(Buffer: Int8; Count: NativeInt); overload;\r\n    procedure WriteBufferData(Buffer: UInt8); overload;\r\n    procedure WriteBufferData(Buffer: UInt8; Count: NativeInt); overload;\r\n    procedure WriteBufferData(Buffer: Int16); overload;\r\n    procedure WriteBufferData(Buffer: Int16; Count: NativeInt); overload;\r\n    procedure WriteBufferData(Buffer: UInt16); overload;\r\n    procedure WriteBufferData(Buffer: UInt16; Count: NativeInt); overload;\r\n    procedure WriteBufferData(Buffer: UInt32); overload;\r\n    procedure WriteBufferData(Buffer: UInt32; Count: NativeInt); overload;\r\n    // NativeLargeint. Stored as a float64, Read as float64.\r\n    procedure WriteBufferData(Buffer: NativeLargeInt); overload;\r\n    procedure WriteBufferData(Buffer: NativeLargeInt; Count: NativeInt); overload;\r\n    procedure WriteBufferData(Buffer: NativeLargeUInt); overload;\r\n    procedure WriteBufferData(Buffer: NativeLargeUInt; Count: NativeInt); overload;\r\n    procedure WriteBufferData(Buffer: Double); overload;\r\n    procedure WriteBufferData(Buffer: Double; Count: NativeInt); overload;\r\n    function CopyFrom(Source: TStream; Count: NativeInt): NativeInt;\r\n    function ReadComponent(Instance: TComponent): TComponent;\r\n    function ReadComponentRes(Instance: TComponent): TComponent;\r\n    procedure WriteComponent(Instance: TComponent);\r\n    procedure WriteComponentRes(const ResName: string; Instance: TComponent);\r\n    procedure WriteDescendent(Instance, Ancestor: TComponent);\r\n    procedure WriteDescendentRes(const ResName: string; Instance, Ancestor: TComponent);\r\n    procedure WriteResourceHeader(const ResName: string; {!!!:out} var FixupInfo: Longint);\r\n    procedure FixupResourceHeader(FixupInfo: Longint);\r\n    procedure ReadResHeader;\r\n    function ReadByte : Byte;\r\n    function ReadWord : Word;\r\n    function ReadDWord : Cardinal;\r\n    function ReadQWord : NativeLargeUInt;\r\n    procedure WriteByte(b : Byte);\r\n    procedure WriteWord(w : Word);\r\n    procedure WriteDWord(d : Cardinal);\r\n    procedure WriteQWord(q : NativeLargeUInt);\r\n    property Position: NativeInt read GetPosition write SetPosition;\r\n    property Size: NativeInt read GetSize write SetSize64;\r\n    Property Endian: TEndian Read FEndian Write FEndian;\r\n  end;\r\n\r\n  { TCustomMemoryStream abstract class }\r\n\r\n  TCustomMemoryStream = class(TStream)\r\n  private\r\n    FMemory: TJSArrayBuffer;\r\n    FDataView : TJSDataView;\r\n    FDataArray : TJSUint8Array;\r\n    FSize, FPosition: PtrInt;\r\n    FSizeBoundsSeek : Boolean;\r\n    function GetDataArray: TJSUint8Array;\r\n    function GetDataView: TJSDataview;\r\n  protected\r\n    Function GetSize : NativeInt; Override;\r\n    function GetPosition: NativeInt; Override;\r\n    procedure SetPointer(Ptr: TJSArrayBuffer; ASize: PtrInt);\r\n    Property DataView : TJSDataview Read GetDataView;\r\n    Property DataArray : TJSUint8Array Read GetDataArray;\r\n  public\r\n    Class Function MemoryToBytes(Mem : TJSArrayBuffer) : TBytes; overload;\r\n    Class Function MemoryToBytes(Mem : TJSUint8Array) : TBytes; overload;\r\n    Class Function BytesToMemory(aBytes : TBytes) : TJSArrayBuffer;\r\n    function Read(Buffer : TBytes; Offset, Count: LongInt): LongInt; override;\r\n    function Seek(const Offset: NativeInt; Origin: TSeekOrigin): NativeInt; override;\r\n    procedure SaveToStream(Stream: TStream);\r\n    Procedure LoadFromURL(Const aURL : String; Async : Boolean = True; OnLoaded : TNotifyEventRef = Nil; OnError: TStringNotifyEventRef = Nil); virtual;\r\n    // Delphi compatibility. Must be an URL\r\n    Procedure LoadFromFile(Const aFileName : String; const OnLoaded : TProc = Nil; const AError: TProcString = Nil);\r\n    property Memory: TJSArrayBuffer read FMemory;\r\n    Property SizeBoundsSeek : Boolean Read FSizeBoundsSeek Write FSizeBoundsSeek;\r\n  end;\r\n\r\n  { TMemoryStream }\r\n\r\n  TMemoryStream = class(TCustomMemoryStream)\r\n  private\r\n    FCapacity: PtrInt;\r\n    procedure SetCapacity(NewCapacity: PtrInt);\r\n  protected\r\n    function Realloc(var NewCapacity: PtrInt): TJSArrayBuffer; virtual;\r\n    property Capacity: PtrInt read FCapacity write SetCapacity;\r\n  public\r\n    destructor Destroy; override;\r\n    procedure Clear;\r\n    procedure LoadFromStream(Stream: TStream);\r\n    procedure SetSize(const NewSize: NativeInt); override;\r\n    function Write(const Buffer: TBytes; Offset, Count: LongInt): LongInt; override;\r\n  end;\r\n\r\n{ TBytesStream }\r\n\r\n  TBytesStream = class(TMemoryStream)\r\n  private\r\n    function GetBytes: TBytes;\r\n  public\r\n    constructor Create(const ABytes: TBytes); virtual; overload;\r\n    property Bytes: TBytes read GetBytes;\r\n  end;\r\n\r\n  { TStringStream }\r\n\r\n  TStringStream = class(TMemoryStream)\r\n  private\r\n    function GetDataString : String;\r\n  public\r\n    constructor Create; reintroduce; overload;\r\n    constructor Create(const aString: String); virtual; overload;\r\n    function ReadString(Count: Integer): string;\r\n    procedure WriteString(const AString: string);\r\n    property DataString: String read GetDataString;\r\n  end;\r\n\r\n  TFPResourceHMODULE = THandle;\r\n\r\n  { TResourceStream }\r\n\r\n  TResourceStream = class(TCustomMemoryStream)\r\n  private\r\n    procedure Initialize(aInfo : TResourceInfo);\r\n    procedure Initialize(Instance{%H-}: TFPResourceHMODULE; Name, ResType{%H-}: String);\r\n  public\r\n    constructor Create(aInfo: TResourceInfo);\r\n    constructor Create(Instance: TFPResourceHMODULE; const ResName, ResType : String);\r\n    constructor CreateFromID(Instance: TFPResourceHMODULE; ResID: Integer; ResType: String);\r\n    function Write(const Buffer{%H-}: TBytes; Offset{%H-}, Count{%H-}: LongInt): LongInt; override;\r\n    destructor Destroy; override;\r\n  end;\r\n\r\n\r\n  TFilerFlag = (ffInherited, ffChildPos, ffInline);\r\n  TFilerFlags = set of TFilerFlag;\r\n\r\n  TReaderProc = procedure(Reader: TReader) of object;\r\n  TWriterProc = procedure(Writer: TWriter) of object;\r\n  TStreamProc = procedure(Stream: TStream) of object;\r\n\r\n  TFiler = class(TObject)\r\n  private\r\n    FRoot: TComponent;\r\n    FLookupRoot: TComponent;\r\n    FAncestor: TPersistent;\r\n    FIgnoreChildren: Boolean;\r\n  protected\r\n    procedure SetRoot(ARoot: TComponent); virtual;\r\n  public\r\n    procedure DefineProperty(const Name: string;\r\n      ReadData: TReaderProc; WriteData: TWriterProc;\r\n      HasData: Boolean); virtual; abstract;\r\n    procedure DefineBinaryProperty(const Name: string;\r\n      ReadData, WriteData: TStreamProc;\r\n      HasData: Boolean); virtual; abstract;\r\n    Procedure FlushBuffer; virtual; abstract;\r\n    property Root: TComponent read FRoot write SetRoot;\r\n    property LookupRoot: TComponent read FLookupRoot;\r\n    property Ancestor: TPersistent read FAncestor write FAncestor;\r\n    property IgnoreChildren: Boolean read FIgnoreChildren write FIgnoreChildren;\r\n  end;\r\n\r\n\r\n  TValueType = (\r\n      vaNull, vaList, vaInt8, vaInt16, vaInt32, vaDouble,\r\n      vaString, vaIdent, vaFalse, vaTrue, vaBinary, vaSet,\r\n      vaNil, vaCollection, vaCurrency, vaDate, vaNativeInt\r\n      );\r\n\r\n  { TAbstractObjectReader }\r\n\r\n  TAbstractObjectReader = class\r\n  public\r\n    Procedure FlushBuffer; virtual;\r\n    function NextValue: TValueType; virtual; abstract;\r\n    function ReadValue: TValueType; virtual; abstract;\r\n    procedure BeginRootComponent; virtual; abstract;\r\n    procedure BeginComponent(var Flags: TFilerFlags; var AChildPos: Integer;\r\n      var CompClassName, CompName: String); virtual; abstract;\r\n    function BeginProperty: String; virtual; abstract;\r\n\r\n    //Please don't use read, better use ReadBinary whenever possible\r\n    procedure Read(var Buffer : TBytes; Count: Longint); virtual;abstract;\r\n\r\n    { All ReadXXX methods are called _after_ the value type has been read! }\r\n    procedure ReadBinary(const DestData: TMemoryStream); virtual; abstract;\r\n    function ReadFloat: Extended; virtual; abstract;\r\n    function ReadCurrency: Currency; virtual; abstract;\r\n    function ReadIdent(ValueType: TValueType): String; virtual; abstract;\r\n    function ReadInt8: ShortInt; virtual; abstract;\r\n    function ReadInt16: SmallInt; virtual; abstract;\r\n    function ReadInt32: LongInt; virtual; abstract;\r\n    function ReadNativeInt: NativeInt; virtual; abstract;\r\n    function ReadSet(EnumType: TTypeInfoEnum): Integer; virtual; abstract;\r\n    procedure ReadSignature; virtual; abstract;\r\n    function ReadStr: String; virtual; abstract;\r\n    function ReadString(StringType: TValueType): String; virtual; abstract;\r\n    function ReadWideString: WideString;virtual;abstract;\r\n    function ReadUnicodeString: UnicodeString;virtual;abstract;\r\n    procedure SkipComponent(SkipComponentInfos: Boolean); virtual; abstract;\r\n    procedure SkipValue; virtual; abstract;\r\n  end;\r\n\r\n  { TBinaryObjectReader }\r\n\r\n  TBinaryObjectReader = class(TAbstractObjectReader)\r\n  protected\r\n    FStream: TStream;\r\n    function ReadWord : word;\r\n    function ReadDWord : longword;\r\n    procedure SkipProperty;\r\n    procedure SkipSetBody;\r\n  public\r\n    constructor Create(Stream: TStream);\r\n    function NextValue: TValueType; override;\r\n    function ReadValue: TValueType; override;\r\n    procedure BeginRootComponent; override;\r\n    procedure BeginComponent(var Flags: TFilerFlags; var AChildPos: Integer;\r\n      var CompClassName, CompName: String); override;\r\n    function BeginProperty: String; override;\r\n    //Please don't use read, better use ReadBinary whenever possible\r\n    procedure Read(var Buffer : TBytes; Count: Longint); override;\r\n    procedure ReadBinary(const DestData: TMemoryStream); override;\r\n    function ReadFloat: Extended; override;\r\n    function ReadCurrency: Currency; override;\r\n    function ReadIdent(ValueType: TValueType): String; override;\r\n    function ReadInt8: ShortInt; override;\r\n    function ReadInt16: SmallInt; override;\r\n    function ReadInt32: LongInt; override;\r\n    function ReadNativeInt: NativeInt; override;\r\n    function ReadSet(EnumType: TTypeInfoEnum): Integer; override;\r\n    procedure ReadSignature; override;\r\n    function ReadStr: String; override;\r\n    function ReadString(StringType: TValueType): String; override;\r\n    function ReadWideString: WideString;override;\r\n    function ReadUnicodeString: UnicodeString;override;\r\n    procedure SkipComponent(SkipComponentInfos: Boolean); override;\r\n    procedure SkipValue; override;\r\n  end;\r\n\r\n\r\n  TFindMethodEvent = procedure(Reader: TReader; const MethodName: string;  var Address: CodePointer; var Error: Boolean) of object;\r\n  TSetNameEvent = procedure(Reader: TReader; Component: TComponent;  var Name: string) of object;\r\n  TReferenceNameEvent = procedure(Reader: TReader; var Name: string) of object;\r\n  TAncestorNotFoundEvent = procedure(Reader: TReader; const ComponentName: string; ComponentClass: TPersistentClass; var Component: TComponent) of object;\r\n  TReadComponentsProc = procedure(Component: TComponent) of object;\r\n  TReaderError = procedure(Reader: TReader; const Message: string; var Handled: Boolean) of object;\r\n  TPropertyNotFoundEvent = procedure(Reader: TReader; Instance: TPersistent; var PropName: string; IsPath: boolean; var Handled, Skip: Boolean) of object;\r\n  TFindComponentClassEvent = procedure(Reader: TReader; const ClassName: string; var ComponentClass: TComponentClass) of object;\r\n  TCreateComponentEvent = procedure(Reader: TReader; ComponentClass: TComponentClass; var Component: TComponent) of object;\r\n\r\n  TSetMethodPropertyEvent = procedure(Reader: TReader; Instance: TPersistent; PropInfo: TTypeMemberProperty; const TheMethodName: string;\r\n    var Handled: boolean) of object;\r\n  TReadWriteStringPropertyEvent = procedure(Sender:TObject; const Instance: TPersistent; PropInfo: TTypeMemberProperty; var Content:string) of object;\r\n\r\n\r\n  { TReader }\r\n\r\n  TReader = class(TFiler)\r\n  private\r\n    FDriver: TAbstractObjectReader;\r\n    FOwner: TComponent;\r\n    FParent: TComponent;\r\n    FFixups: TObject;\r\n    FLoaded: TFpList;\r\n    FOnFindMethod: TFindMethodEvent;\r\n    FOnSetMethodProperty: TSetMethodPropertyEvent;\r\n    FOnSetName: TSetNameEvent;\r\n    FOnReferenceName: TReferenceNameEvent;\r\n    FOnAncestorNotFound: TAncestorNotFoundEvent;\r\n    FOnError: TReaderError;\r\n    FOnPropertyNotFound: TPropertyNotFoundEvent;\r\n    FOnFindComponentClass: TFindComponentClassEvent;\r\n    FOnCreateComponent: TCreateComponentEvent;\r\n    FPropName: string;\r\n    FCanHandleExcepts: Boolean;\r\n    FOnReadStringProperty:TReadWriteStringPropertyEvent;\r\n    procedure DoFixupReferences;\r\n    function FindComponentClass(const AClassName: string): TComponentClass;\r\n  protected\r\n    function Error(const Message: string): Boolean; virtual;\r\n    function FindMethod(ARoot: TComponent; const AMethodName: string): CodePointer; virtual;\r\n    procedure ReadProperty(AInstance: TPersistent);\r\n    procedure ReadPropValue(Instance: TPersistent; PropInfo: TTypeMemberProperty);\r\n    procedure PropertyError;\r\n    procedure ReadData(Instance: TComponent);\r\n    property PropName: string read FPropName;\r\n    property CanHandleExceptions: Boolean read FCanHandleExcepts;\r\n    function CreateDriver(Stream: TStream): TAbstractObjectReader; virtual;\r\n  public\r\n    constructor Create(Stream: TStream);\r\n    destructor Destroy; override;\r\n    Procedure FlushBuffer; override;\r\n    procedure BeginReferences;\r\n    procedure CheckValue(Value: TValueType);\r\n    procedure DefineProperty(const Name: string;\r\n      AReadData: TReaderProc; WriteData: TWriterProc;\r\n      HasData: Boolean); override;\r\n    procedure DefineBinaryProperty(const Name: string;\r\n      AReadData, WriteData: TStreamProc;\r\n      HasData: Boolean); override;\r\n    function EndOfList: Boolean;\r\n    procedure EndReferences;\r\n    procedure FixupReferences;\r\n    function NextValue: TValueType;\r\n    //Please don't use read, better use ReadBinary whenever possible\r\n    //uuups, ReadBinary is protected ..\r\n    procedure Read(var Buffer : TBytes; Count: LongInt); virtual;\r\n\r\n    function ReadBoolean: Boolean;\r\n    function ReadChar: Char;\r\n    function ReadWideChar: WideChar;\r\n    function ReadUnicodeChar: UnicodeChar;\r\n    procedure ReadCollection(Collection: TCollection);\r\n    function ReadComponent(Component: TComponent): TComponent;\r\n    procedure ReadComponents(AOwner, AParent: TComponent;\r\n      Proc: TReadComponentsProc);\r\n    function ReadFloat: Extended;\r\n    function ReadCurrency: Currency;\r\n    function ReadIdent: string;\r\n    function ReadInteger: Longint;\r\n    function ReadNativeInt: NativeInt;\r\n    function ReadSet(EnumType: Pointer): Integer;\r\n    procedure ReadListBegin;\r\n    procedure ReadListEnd;\r\n    function ReadRootComponent(ARoot: TComponent): TComponent;\r\n    function ReadVariant: JSValue;\r\n    procedure ReadSignature;\r\n    function ReadString: string;\r\n    function ReadWideString: WideString;\r\n    function ReadUnicodeString: UnicodeString;\r\n    function ReadValue: TValueType;\r\n    procedure CopyValue(Writer: TWriter);\r\n    property Driver: TAbstractObjectReader read FDriver;\r\n    property Owner: TComponent read FOwner write FOwner;\r\n    property Parent: TComponent read FParent write FParent;\r\n    property OnError: TReaderError read FOnError write FOnError;\r\n    property OnPropertyNotFound: TPropertyNotFoundEvent read FOnPropertyNotFound write FOnPropertyNotFound;\r\n    property OnFindMethod: TFindMethodEvent read FOnFindMethod write FOnFindMethod;\r\n    property OnSetMethodProperty: TSetMethodPropertyEvent read FOnSetMethodProperty write FOnSetMethodProperty;\r\n    property OnSetName: TSetNameEvent read FOnSetName write FOnSetName;\r\n    property OnReferenceName: TReferenceNameEvent read FOnReferenceName write FOnReferenceName;\r\n    property OnAncestorNotFound: TAncestorNotFoundEvent read FOnAncestorNotFound write FOnAncestorNotFound;\r\n    property OnCreateComponent: TCreateComponentEvent read FOnCreateComponent write FOnCreateComponent;\r\n    property OnFindComponentClass: TFindComponentClassEvent read FOnFindComponentClass write FOnFindComponentClass;\r\n    property OnReadStringProperty: TReadWriteStringPropertyEvent read FOnReadStringProperty write FOnReadStringProperty;\r\n  end;\r\n\r\n\r\n  { TAbstractObjectWriter }\r\n\r\n  TAbstractObjectWriter = class\r\n  public\r\n    { Begin/End markers. Those ones who don't have an end indicator, use\r\n      \"EndList\", after the occurrence named in the comment. Note that this\r\n      only counts for \"EndList\" calls on the same level; each BeginXXX call\r\n      increases the current level. }\r\n    procedure BeginCollection; virtual; abstract;  { Ends with the next \"EndList\" }\r\n    procedure BeginComponent(Component: TComponent; Flags: TFilerFlags;\r\n      ChildPos: Integer); virtual; abstract;  { Ends after the second \"EndList\" }\r\n    procedure WriteSignature; virtual; abstract;\r\n    procedure BeginList; virtual; abstract;\r\n    procedure EndList; virtual; abstract;\r\n    procedure BeginProperty(const PropName: String); virtual; abstract;\r\n    procedure EndProperty; virtual; abstract;\r\n    //Please don't use write, better use WriteBinary whenever possible\r\n    procedure Write(const Buffer : TBytes; Count: Longint); virtual;abstract;\r\n    Procedure FlushBuffer; virtual; abstract;\r\n\r\n    procedure WriteBinary(const Buffer : TBytes; Count: Longint); virtual; abstract;\r\n    procedure WriteBoolean(Value: Boolean); virtual; abstract;\r\n    // procedure WriteChar(Value: Char);\r\n    procedure WriteFloat(const Value: Extended); virtual; abstract;\r\n    procedure WriteCurrency(const Value: Currency); virtual; abstract;\r\n    procedure WriteIdent(const Ident: string); virtual; abstract;\r\n    procedure WriteInteger(Value: NativeInt); virtual; abstract;\r\n    procedure WriteNativeInt(Value: NativeInt); virtual; abstract;\r\n    procedure WriteVariant(const Value: JSValue); virtual; abstract;\r\n    procedure WriteMethodName(const Name: String); virtual; abstract;\r\n    procedure WriteSet(Value: LongInt; SetType: Pointer); virtual; abstract;\r\n    procedure WriteString(const Value: String); virtual; abstract;\r\n    procedure WriteWideString(const Value: WideString);virtual;abstract;\r\n    procedure WriteUnicodeString(const Value: UnicodeString);virtual;abstract;\r\n  end;\r\n\r\n  { TBinaryObjectWriter }\r\n\r\n  TBinaryObjectWriter = class(TAbstractObjectWriter)\r\n  protected\r\n    FStream: TStream;\r\n    FBuffer: Pointer;\r\n    FBufSize: Integer;\r\n    FBufPos: Integer;\r\n    FBufEnd: Integer;\r\n    procedure WriteWord(w : word);\r\n    procedure WriteDWord(lw : longword);\r\n    procedure WriteValue(Value: TValueType);\r\n  public\r\n    constructor Create(Stream: TStream);\r\n    procedure WriteSignature; override;\r\n    procedure BeginCollection; override;\r\n    procedure BeginComponent(Component: TComponent; Flags: TFilerFlags;\r\n      ChildPos: Integer); override;\r\n    procedure BeginList; override;\r\n    procedure EndList; override;\r\n    procedure BeginProperty(const PropName: String); override;\r\n    procedure EndProperty; override;\r\n    Procedure FlushBuffer; override;\r\n\r\n    //Please don't use write, better use WriteBinary whenever possible\r\n    procedure Write(const Buffer : TBytes; Count: Longint); override;\r\n    procedure WriteBinary(const Buffer : TBytes; Count: LongInt); override;\r\n    procedure WriteBoolean(Value: Boolean); override;\r\n    procedure WriteFloat(const Value: Extended); override;\r\n    procedure WriteCurrency(const Value: Currency); override;\r\n    procedure WriteIdent(const Ident: string); override;\r\n    procedure WriteInteger(Value: NativeInt); override;\r\n    procedure WriteNativeInt(Value: NativeInt); override;\r\n    procedure WriteMethodName(const Name: String); override;\r\n    procedure WriteSet(Value: LongInt; SetType: Pointer); override;\r\n    procedure WriteStr(const Value: String);\r\n    procedure WriteString(const Value: String); override;\r\n    procedure WriteWideString(const Value: WideString); override;\r\n    procedure WriteUnicodeString(const Value: UnicodeString); override;\r\n    procedure WriteVariant(const VarValue: JSValue);override;\r\n  end;\r\n\r\n  TFindAncestorEvent = procedure (Writer: TWriter; Component: TComponent;\r\n    const Name: string; var Ancestor, RootAncestor: TComponent) of object;\r\n  TWriteMethodPropertyEvent = procedure (Writer: TWriter; Instance: TPersistent;\r\n    PropInfo: TTypeMemberProperty;\r\n    const MethodValue, DefMethodValue: TMethod;\r\n    var Handled: boolean) of object;\r\n\r\n  { TWriter }\r\n\r\n  TWriter = class(TFiler)\r\n  private\r\n    FDriver: TAbstractObjectWriter;\r\n    FDestroyDriver: Boolean;\r\n    FRootAncestor: TComponent;\r\n    FPropPath: String;\r\n    FAncestors: TStringList;\r\n    FAncestorPos: Integer;\r\n    FCurrentPos: Integer;\r\n    FOnFindAncestor: TFindAncestorEvent;\r\n    FOnWriteMethodProperty: TWriteMethodPropertyEvent;\r\n    FOnWriteStringProperty:TReadWriteStringPropertyEvent;\r\n    procedure AddToAncestorList(Component: TComponent);\r\n    procedure WriteComponentData(Instance: TComponent);\r\n    Procedure DetermineAncestor(Component: TComponent);\r\n    procedure DoFindAncestor(Component : TComponent);\r\n  protected\r\n    procedure SetRoot(ARoot: TComponent); override;\r\n    procedure WriteBinary(AWriteData: TStreamProc);\r\n    procedure WriteProperty(Instance: TPersistent; PropInfo: TTypeMemberProperty);\r\n    procedure WriteProperties(Instance: TPersistent);\r\n    procedure WriteChildren(Component: TComponent);\r\n    function CreateDriver(Stream: TStream): TAbstractObjectWriter; virtual;\r\n  public\r\n    constructor Create(ADriver: TAbstractObjectWriter);\r\n    constructor Create(Stream: TStream);\r\n    destructor Destroy; override;\r\n    procedure DefineProperty(const Name: string;\r\n      ReadData: TReaderProc; AWriteData: TWriterProc;\r\n      HasData: Boolean); override;\r\n    procedure DefineBinaryProperty(const Name: string;\r\n      ReadData, AWriteData: TStreamProc;\r\n      HasData: Boolean); override;\r\n    Procedure FlushBuffer; override;\r\n    procedure Write(const Buffer : TBytes; Count: Longint); virtual;\r\n    procedure WriteBoolean(Value: Boolean);\r\n    procedure WriteCollection(Value: TCollection);\r\n    procedure WriteComponent(Component: TComponent);\r\n    procedure WriteChar(Value: Char);\r\n    procedure WriteWideChar(Value: WideChar);\r\n    procedure WriteDescendent(ARoot: TComponent; AAncestor: TComponent);\r\n    procedure WriteFloat(const Value: Extended);\r\n    procedure WriteCurrency(const Value: Currency);\r\n    procedure WriteIdent(const Ident: string);\r\n    procedure WriteInteger(Value: Longint); overload;\r\n    procedure WriteInteger(Value: NativeInt); overload;\r\n    procedure WriteSet(Value: LongInt; SetType: Pointer);\r\n    procedure WriteListBegin;\r\n    procedure WriteListEnd;\r\n    Procedure WriteSignature;\r\n    procedure WriteRootComponent(ARoot: TComponent);\r\n    procedure WriteString(const Value: string);\r\n    procedure WriteWideString(const Value: WideString);\r\n    procedure WriteUnicodeString(const Value: UnicodeString);\r\n    procedure WriteVariant(const VarValue: JSValue);\r\n    property RootAncestor: TComponent read FRootAncestor write FRootAncestor;\r\n    property OnFindAncestor: TFindAncestorEvent read FOnFindAncestor write FOnFindAncestor;\r\n    property OnWriteMethodProperty: TWriteMethodPropertyEvent read FOnWriteMethodProperty write FOnWriteMethodProperty;\r\n    property OnWriteStringProperty: TReadWriteStringPropertyEvent read FOnWriteStringProperty write FOnWriteStringProperty;\r\n\r\n    property Driver: TAbstractObjectWriter read FDriver;\r\n    property PropertyPath: string read FPropPath;\r\n  end;\r\n\r\n  TParserToken = (toUnknown,  // everything else\r\n                  toEOF,      // EOF\r\n                  toSymbol,   // Symbol (identifier)\r\n                  toString,   // ''string''\r\n                  toInteger,  // 123\r\n                  toFloat,    // 12.3\r\n                  toMinus,    // -\r\n                  toSetStart, // [\r\n                  toListStart, // (\r\n                  toCollectionStart, // <\r\n                  toBinaryStart, // {\r\n                  toSetEnd, // ]\r\n                  toListEnd, // )\r\n                  toCollectionEnd, // >\r\n                  toBinaryEnd, // }\r\n                  toComma, // ,\r\n                  toDot, // .\r\n                  toEqual, // =\r\n                  toColon, // :\r\n                  toPlus // +\r\n                  );\r\n\r\n  TParser = class(TObject)\r\n  private\r\n    fStream : TStream;\r\n    fBuf : Array of Char;\r\n    FBufLen : integer;\r\n    fPos : integer;\r\n    fDeltaPos : integer;\r\n    fFloatType : char;\r\n    fSourceLine : integer;\r\n    fToken : TParserToken;\r\n    fEofReached : boolean;\r\n    fLastTokenStr : string;\r\n    function GetTokenName(aTok : TParserToken) : string;\r\n    procedure LoadBuffer;\r\n    procedure CheckLoadBuffer; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n    procedure ProcessChar; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n    function IsNumber : boolean; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n    function IsHexNum : boolean; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n    function IsAlpha : boolean; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n    function IsAlphaNum : boolean; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n    function GetHexValue(c : char) : byte; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n    function GetAlphaNum : string;\r\n    procedure HandleNewLine;\r\n    procedure SkipBOM;\r\n    procedure SkipSpaces;\r\n    procedure SkipWhitespace;\r\n    procedure HandleEof;\r\n    procedure HandleAlphaNum;\r\n    procedure HandleNumber;\r\n    procedure HandleHexNumber;\r\n    function HandleQuotedString : string;\r\n    Function HandleDecimalCharacter: char;\r\n    procedure HandleString;\r\n    procedure HandleMinus;\r\n    procedure HandleUnknown;\r\n    procedure GotoToNextChar;\r\n  public\r\n    // Input stream is expected to be UTF16 !\r\n    constructor Create(Stream: TStream);\r\n    destructor Destroy; override;\r\n    procedure CheckToken(T: TParserToken);\r\n    procedure CheckTokenSymbol(const S: string);\r\n    procedure Error(const Ident: string);\r\n    procedure ErrorFmt(const Ident: string; const Args: array of const);\r\n    procedure ErrorStr(const Message: string);\r\n    procedure HexToBinary(Stream: TStream);\r\n    function NextToken: TParserToken;\r\n    function SourcePos: Longint;\r\n    function TokenComponentIdent: string;\r\n    function TokenFloat: Double;\r\n    function TokenInt: NativeInt;\r\n    function TokenString: string;\r\n    function TokenSymbolIs(const S: string): Boolean;\r\n    property FloatType: Char read fFloatType;\r\n    property SourceLine: Integer read fSourceLine;\r\n    property Token: TParserToken read fToken;\r\n  end;\r\n\r\n\r\n  { TObjectStreamConverter }\r\n\r\n  TObjectTextEncoding = (oteDFM,oteLFM);\r\n\r\n  TObjectStreamConverter = Class\r\n  private\r\n     FIndent: String;\r\n     FInput : TStream;\r\n     FOutput : TStream;\r\n     FEncoding : TObjectTextEncoding;\r\n  Private\r\n    FPlainStrings: Boolean;\r\n     // Low level writing\r\n     procedure Outchars(S : String); virtual;\r\n     procedure OutLn(s: String); virtual;\r\n     procedure OutStr(s: String); virtual;\r\n     procedure OutString(s: String); virtual;\r\n     // Low level reading\r\n     function ReadWord: word;\r\n     function ReadDWord: longword;\r\n     function ReadDouble: Double;\r\n     function ReadInt(ValueType: TValueType): NativeInt;\r\n     function ReadInt: NativeInt;\r\n     function ReadNativeInt: NativeInt;\r\n     function ReadStr: String;\r\n     function ReadString(StringType: TValueType): String; virtual;\r\n     // High-level\r\n     procedure ProcessBinary; virtual;\r\n     procedure ProcessValue(ValueType: TValueType; Indent: String); virtual;\r\n     procedure ReadObject(indent: String); virtual;\r\n     procedure ReadPropList(indent: String); virtual;\r\n   Public\r\n     procedure ObjectBinaryToText(aInput, aOutput: TStream);\r\n     procedure ObjectBinaryToText(aInput, aOutput: TStream; aEncoding: TObjectTextEncoding);\r\n     Procedure Execute;\r\n     // use this to get previous streaming behavour: strings written as-is\r\n     Property PlainStrings : Boolean Read FPlainStrings Write FPlainStrings;\r\n     Property Input : TStream Read FInput Write FInput;\r\n     Property Output : TStream Read Foutput Write FOutput;\r\n     Property Encoding : TObjectTextEncoding Read FEncoding Write FEncoding;\r\n     Property Indent : String Read FIndent Write Findent;\r\n   end;\r\n\r\n  { TObjectTextConverter }\r\n\r\n  TObjectTextConverter = Class\r\n  private\r\n    FParser: TParser;\r\n  private\r\n    FInput: TStream;\r\n    Foutput: TStream;\r\n    procedure WriteDouble(e: double);\r\n    procedure WriteDWord(lw: longword);\r\n    procedure WriteInteger(value: nativeInt);\r\n    //procedure WriteLString(const s: String);\r\n    procedure WriteQWord(q: nativeint);\r\n    procedure WriteString(s: String);\r\n    procedure WriteWord(w: word);\r\n    procedure WriteWString(const s: WideString);\r\n    procedure ProcessObject; virtual;\r\n    procedure ProcessProperty; virtual;\r\n    procedure ProcessValue; virtual;\r\n    procedure ProcessWideString(const left: string);\r\n    Property Parser : TParser Read FParser;\r\n  Public\r\n    // Input stream must be UTF16 !\r\n    procedure ObjectTextToBinary(aInput, aOutput: TStream);\r\n    Procedure Execute; virtual;\r\n    Property Input : TStream Read FInput Write FInput;\r\n    Property Output: TStream Read Foutput Write Foutput;\r\n  end;\r\n\r\n  TLoadHelper = Class (TObject)\r\n  Public\r\n  Type\r\n    TTextLoadedCallBack = reference to procedure (const aText : String);\r\n    TBytesLoadedCallBack = reference to procedure (const aBuffer : TJSArrayBuffer);\r\n    TErrorCallBack = reference to procedure (const aError : String);\r\n    Class Procedure LoadText(aURL : String; aSync : Boolean; OnLoaded : TTextLoadedCallBack; OnError : TErrorCallBack); virtual; abstract;\r\n    Class Procedure LoadBytes(aURL : String; aSync : Boolean; OnLoaded : TBytesLoadedCallBack; OnError : TErrorCallBack); virtual; abstract;\r\n  end;\r\n\r\n  TLoadHelperClass = Class of TLoadHelper;\r\n\r\n  { ---------------------------------------------------------------------\r\n      TDatamodule support\r\n    ---------------------------------------------------------------------}\r\n\r\n    { TDataModule }\r\n\r\n    TDataModule = class(TComponent)\r\n    private\r\n      FDPos: TPoint;\r\n      FDSize: TPoint;\r\n      FDPPI: Integer;\r\n      FOnCreate: TNotifyEvent;\r\n      FOnDestroy: TNotifyEvent;\r\n      FOldOrder : Boolean;\r\n      Procedure ReadP(Reader: TReader);\r\n      Procedure WriteP(Writer: TWriter);\r\n      Procedure ReadT(Reader: TReader);\r\n      Procedure WriteT(Writer: TWriter);\r\n      Procedure ReadL(Reader: TReader);\r\n      Procedure WriteL(Writer: TWriter);\r\n      Procedure ReadW(Reader: TReader);\r\n      Procedure WriteW(Writer: TWriter);\r\n      Procedure ReadH(Reader: TReader);\r\n      Procedure WriteH(Writer: TWriter);\r\n    protected\r\n      Procedure DoCreate; virtual;\r\n      Procedure DoDestroy; virtual;\r\n      Procedure DefineProperties(Filer: TFiler); override;\r\n      Procedure GetChildren(Proc: TGetChildProc; Root: TComponent); override;\r\n      Function HandleCreateException: Boolean; virtual;\r\n      Procedure ReadState(Reader: TReader); override;\r\n    public\r\n      constructor Create(AOwner: TComponent); override;\r\n      Constructor CreateNew(AOwner: TComponent);\r\n      Constructor CreateNew(AOwner: TComponent; CreateMode: Integer); virtual;\r\n      class constructor ClassCreate;\r\n      destructor Destroy; override;\r\n      Procedure AfterConstruction; override;\r\n      Procedure BeforeDestruction; override;\r\n      property DesignOffset: TPoint read FDPos write FDPos;\r\n      property DesignSize: TPoint read FDSize write FDSize;\r\n      property DesignPPI: Integer read FDPPI write FDPPI;\r\n    published\r\n      property OnCreate: TNotifyEvent read FOnCreate write FOnCreate;\r\n      property OnDestroy: TNotifyEvent read FOnDestroy write FOnDestroy;\r\n      property OldCreateOrder: Boolean read FOldOrder write FOldOrder;\r\n    end;\r\n    TDataModuleClass = Class of TDataModule;\r\n\r\n\r\ntype\r\n  TIdentMapEntry = record\r\n    Value: Integer;\r\n    Name: String;\r\n  end;\r\n\r\n  TIdentToInt = function(const Ident: string; var Int: Longint): Boolean;\r\n  TIntToIdent = function(Int: Longint; var Ident: string): Boolean;\r\n  TFindGlobalComponent = function(const Name: string): TComponent;\r\n  TInitComponentHandler = function(Instance: TComponent; RootAncestor : TClass): boolean;\r\n\r\nprocedure RegisterInitComponentHandler(ComponentClass: TComponentClass;   Handler: TInitComponentHandler);\r\nProcedure RegisterClass(AClass : TPersistentClass);\r\nProcedure RegisterClasses(AClasses : specialize TArray<TPersistentClass>);\r\nFunction GetClass(AClassName : string) : TPersistentClass;\r\nprocedure RegisterFindGlobalComponentProc(AFindGlobalComponent: TFindGlobalComponent);\r\nprocedure UnregisterFindGlobalComponentProc(AFindGlobalComponent: TFindGlobalComponent);\r\nfunction FindGlobalComponent(const Name: string): TComponent;\r\nFunction FindNestedComponent(Root : TComponent; APath : String; CStyle : Boolean = True) : TComponent;\r\nfunction InitInheritedComponent(Instance: TComponent; RootAncestor: TClass): Boolean;\r\n\r\nprocedure RedirectFixupReferences(Root: TComponent; const OldRootName, NewRootName: string);\r\nprocedure RemoveFixupReferences(Root: TComponent; const RootName: string);\r\nprocedure RegisterIntegerConsts(IntegerType: Pointer; IdentToIntFn: TIdentToInt;  IntToIdentFn: TIntToIdent);\r\nfunction ExtractStrings(Separators, WhiteSpace: TSysCharSet; Content: String; Strings: TStrings; AddEmptyStrings : Boolean = False): Integer;\r\nfunction IdentToInt(const Ident: string; out Int: Longint; const Map: array of TIdentMapEntry): Boolean;\r\nfunction IntToIdent(Int: Longint; var Ident: string; const Map: array of TIdentMapEntry): Boolean;\r\nfunction FindIntToIdent(AIntegerType: Pointer): TIntToIdent;\r\nfunction FindIdentToInt(AIntegerType: Pointer): TIdentToInt;\r\nfunction FindClass(const AClassName: string): TPersistentClass;\r\nfunction CollectionsEqual(C1, C2: TCollection): Boolean;\r\nfunction CollectionsEqual(C1, C2: TCollection; Owner1, Owner2: TComponent): Boolean;\r\nprocedure GetFixupReferenceNames(Root: TComponent; Names: TStrings);\r\nprocedure GetFixupInstanceNames(Root: TComponent; const ReferenceRootName: string; Names: TStrings);\r\nprocedure ObjectBinaryToText(aInput, aOutput: TStream);\r\nprocedure ObjectBinaryToText(aInput, aOutput: TStream; aEncoding: TObjectTextEncoding);\r\nprocedure ObjectTextToBinary(aInput, aOutput: TStream);\r\nFunction SetLoadHelperClass(aClass : TLoadHelperClass) : TLoadHelperClass;\r\n// Create buffer from string. aLen in bytes, not in characters\r\nFunction StringToBuffer(aString : String; aLen : Integer) : TJSArrayBuffer;\r\n// Create buffer from string. aPos,aLen are in bytes, not in characters.\r\nFunction BufferToString(aBuffer : TJSArrayBuffer; aPos,aLen : Integer) : String;\r\n\r\nprocedure BeginGlobalLoading;\r\nprocedure NotifyGlobalLoading;\r\nprocedure EndGlobalLoading;\r\n\r\nType\r\n  TDataModuleNotifyEvent = procedure (DataModule: TDataModule) of object;\r\n  TExceptionNotifyEvent = procedure (E: Exception) of object;\r\n\r\nvar\r\n  // IDE hooks for TDatamodule support.\r\n  AddDataModule              : TDataModuleNotifyEvent;\r\n  RemoveDataModule           : TDataModuleNotifyEvent;\r\n  ApplicationHandleException : TNotifyEvent;\r\n  ApplicationShowException   : TExceptionNotifyEvent;\r\n  FormResourceIsText : Boolean = True;\r\n\r\nConst\r\n  // Some aliases\r\n  vaSingle = vaDouble;\r\n  vaExtended = vaDouble;\r\n  vaLString = vaString;\r\n  vaUTF8String = vaString;\r\n  vaUString = vaString;\r\n  vaWString = vaString;\r\n  vaQWord = vaNativeInt;\r\n  vaInt64 = vaNativeInt;\r\n  toWString = toString;\r\n\r\nimplementation\r\n\r\n{$IFDEF FPC_DOTTEDUNITS}\r\nuses System.SimpleLinkedList;\r\n{$ELSE}\r\nuses simplelinkedlist;\r\n{$ENDIF}\r\n\r\nvar\r\n  GlobalLoaded,\r\n  IntConstList: TFPList;\r\n  GlobalLoadHelper : TLoadHelperClass;\r\n\r\nprocedure BeginGlobalLoading;\r\nbegin\r\n  GlobalLoaded := TFPList.Create;\r\nend;\r\n\r\nprocedure NotifyGlobalLoading;\r\nvar\r\n  I: Integer;\r\n  G: TFPList;\r\nbegin\r\n  G := GlobalLoaded;\r\n  for I := 0 to G.Count - 1 do\r\n    TComponent(G[I]).Loaded;\r\nend;\r\n\r\nprocedure EndGlobalLoading;\r\nbegin\r\n  GlobalLoaded.Free;\r\nend;\r\n\r\nFunction SetLoadHelperClass(aClass : TLoadHelperClass) : TLoadHelperClass;\r\n\r\nbegin\r\n  Result:=GlobalLoadHelper;\r\n  GlobalLoadHelper:=aClass;\r\nend;\r\n\r\nProcedure CheckLoadHelper;\r\n\r\nbegin\r\n  If (GlobalLoadHelper=Nil) then\r\n    Raise EInOutError.Create('No support for loading URLS. Include Rtl.BrowserLoadHelper in your project uses clause');\r\nend;\r\n\r\nFunction StringToBuffer(aString : String; aLen : Integer) : TJSArrayBuffer;\r\n\r\nvar\r\n   I : Integer;\r\n\r\nbegin\r\n  Result:=TJSArrayBuffer.new(aLen*2);// 2 bytes for each char\r\n  With TJSUint16Array.new(Result) do\r\n    for i:=0 to aLen-1 do\r\n      values[i] := TJSString(aString).charCodeAt(i);\r\nend;\r\n\r\nfunction BufferToString(aBuffer: TJSArrayBuffer; aPos, aLen: Integer): String;\r\n\r\nvar\r\n  a : TJSUint16Array;\r\n\r\nbegin\r\n  Result:=''; // Silence warning\r\n  a:=TJSUint16Array.New(aBuffer.slice(aPos,aLen));\r\n  if a<>nil then\r\n    Result:=String(TJSFunction(@TJSString.fromCharCode).apply(nil,TJSValueDynArray(JSValue(a))));\r\nend;\r\n\r\nfunction CreateComponentfromRes(const res : string; Inst : THandle; var Component : TComponent) : Boolean;\r\n\r\nvar\r\n  ResStream : TResourceStream;\r\n\r\n  Src : TStream;\r\n  aInfo : TResourceInfo;\r\n\r\nbegin\r\n  if Inst=0 then ;\r\n  result:=GetResourceInfo(Res,aInfo);\r\n  if Result then\r\n    begin\r\n    ResStream:=TResourceStream.Create(aInfo);\r\n    try\r\n      if Not FormResourceIsText then\r\n        Src:=ResStream\r\n      else\r\n        begin\r\n        Src:=TMemoryStream.Create;\r\n        ObjectTextToBinary(ResStream,Src);\r\n        Src.Position:=0;\r\n        end;\r\n      Component:=Src.ReadComponent(Component);\r\n    finally\r\n      if Src<>ResStream then\r\n        Src.Free;\r\n      ResStream.Free;\r\n    end;\r\n    end;\r\nend;\r\n\r\nfunction DefaultInitHandler(Instance: TComponent; RootAncestor: TClass): Boolean;\r\n\r\n  function doinit(_class : TClass) : boolean;\r\n    begin\r\n      result:=false;\r\n      if (_class.ClassType=TComponent) or (_class.ClassType=RootAncestor) then\r\n        exit;\r\n      result:=doinit(_class.ClassParent);\r\n      // Resources are written with their unit name\r\n      result:=CreateComponentfromRes(_class.UnitName,0,Instance) or result;\r\n    end;\r\n\r\nbegin\r\n  result:=doinit(Instance.ClassType);\r\nend;\r\n\r\n{ TResourceStream }\r\n\r\n// We need a polyfill for nodejs.\r\nFunction atob (s : String) : string; external name 'atob';\r\n\r\nprocedure TResourceStream.Initialize(aInfo: TResourceInfo);\r\n\r\nvar\r\n  Ptr : TJSArrayBuffer;\r\n  S : String;\r\n\r\nbegin\r\n  if aInfo.encoding='base64' then\r\n    S:=atob(aInfo.Data)\r\n  else if (aInfo.Encoding='text') then\r\n    s:=aInfo.Data\r\n  else\r\n    Raise ENotSupportedException.CreateFmt(SErrResourceNotBase64,[aInfo.name]);\r\n  Ptr:=StringToBuffer(S, length(S));\r\n  SetPointer(Ptr,Ptr.byteLength);\r\nend;\r\n\r\nprocedure TResourceStream.Initialize(Instance: TFPResourceHMODULE; Name, ResType: String);\r\n\r\nVar\r\n  aInfo : TResourceInfo;\r\n\r\nbegin\r\n  if not GetResourceInfo(Name, aInfo) then\r\n    raise EResNotFound.CreateFmt(SResNotFound,[Name]);\r\n  Initialize(aInfo);\r\nend;\r\n\r\nconstructor TResourceStream.Create(aInfo: TResourceInfo);\r\nbegin\r\n  inherited create;\r\n  Initialize(aInfo);\r\nend;\r\n\r\nconstructor TResourceStream.Create(Instance: TFPResourceHMODULE; const ResName, ResType: String);\r\nbegin\r\n  inherited create;\r\n  Initialize(Instance,ResName,ResType);\r\nend;\r\n\r\nconstructor TResourceStream.CreateFromID(Instance: TFPResourceHMODULE;\r\n  ResID: Integer; ResType: String);\r\nbegin\r\n  inherited create;\r\n  Initialize(Instance,IntToStr(ResID),ResType);\r\nend;\r\n\r\nfunction TResourceStream.Write(const Buffer: TBytes; Offset, Count: LongInt\r\n  ): LongInt;\r\nbegin\r\n  Raise ENotSupportedException.Create(SErrResourceStreamNoWrite);\r\n  Result:=0;\r\nend;\r\n\r\ndestructor TResourceStream.Destroy;\r\nbegin\r\n  inherited Destroy;\r\nend;\r\n\r\n{ TStringStream }\r\n\r\nfunction TStringStream.GetDataString: String;\r\nvar\r\n  a : TJSUint16Array;\r\nbegin\r\n  Result:=''; // Silence warning\r\n  a:=TJSUint16Array.New(Memory.slice(0,Size));\r\n  if a<>nil then\r\n    asm\r\n      // Result=String.fromCharCode.apply(null, new Uint16Array(a));\r\n      Result=String.fromCharCode.apply(null, a);\r\n    end;\r\nend;\r\n\r\nconstructor TStringStream.Create;\r\nbegin\r\n  Create('');\r\nend;\r\n\r\nconstructor TStringStream.Create(const aString: String);\r\n\r\nvar\r\n  Len : Integer;\r\n\r\nbegin\r\n  inherited Create;\r\n  Len:=Length(aString);\r\n  SetPointer(StringToBuffer(aString,Len),Len*2);\r\n  FCapacity:=Len*2;\r\nend;\r\n\r\nfunction TStringStream.ReadString(Count: Integer): string;\r\n\r\n\r\nVar\r\n  B : TBytes;\r\n  Buf : TJSArrayBuffer;\r\n  BytesLeft : Integer;\r\n  ByteCount : Integer;\r\n\r\nbegin\r\n  // Top off\r\n  ByteCount:=Count*2; // UTF-16\r\n  BytesLeft:=(Size-Position);\r\n  if BytesLeft<ByteCount then\r\n    ByteCount:=BytesLeft;\r\n  SetLength(B,ByteCount);\r\n  ReadBuffer(B,0,ByteCount);\r\n  Buf:=BytesToMemory(B);\r\n  Result:=BufferToString(Buf,0,ByteCount);\r\nend;\r\n\r\nprocedure TStringStream.WriteString(const AString: string);\r\n\r\nVar\r\n  Buf : TJSArrayBuffer;\r\n  B : TBytes;\r\n\r\nbegin\r\n  Buf:=StringToBuffer(aString,Length(aString));\r\n  B:=MemoryToBytes(Buf);\r\n  WriteBuffer(B,Length(B));\r\nend;\r\n\r\ntype\r\n  TIntConst = class\r\n  Private\r\n    IntegerType: PTypeInfo;             // The integer type RTTI pointer\r\n    IdentToIntFn: TIdentToInt;          // Identifier to Integer conversion\r\n    IntToIdentFn: TIntToIdent;          // Integer to Identifier conversion\r\n  Public\r\n    constructor Create(AIntegerType: PTypeInfo; AIdentToInt: TIdentToInt;\r\n      AIntToIdent: TIntToIdent);\r\n  end;\r\n\r\nconstructor TIntConst.Create(AIntegerType: PTypeInfo; AIdentToInt: TIdentToInt;\r\n  AIntToIdent: TIntToIdent);\r\nbegin\r\n  IntegerType := AIntegerType;\r\n  IdentToIntFn := AIdentToInt;\r\n  IntToIdentFn := AIntToIdent;\r\nend;\r\n\r\nprocedure RegisterIntegerConsts(IntegerType: Pointer; IdentToIntFn: TIdentToInt;\r\n  IntToIdentFn: TIntToIdent);\r\nbegin\r\n  if Not Assigned(IntConstList) then\r\n    IntConstList:=TFPList.Create;\r\n  IntConstList.Add(TIntConst.Create(IntegerType, IdentToIntFn, IntToIdentFn));\r\nend;\r\n\r\nfunction ExtractStrings(Separators, WhiteSpace: TSysCharSet; Content: String; Strings: TStrings; AddEmptyStrings : Boolean = False): Integer;\r\nvar\r\n  b,c : integer;\r\n\r\n  procedure SkipWhitespace;\r\n    begin\r\n      while (Content[c] in Whitespace) do\r\n        inc (C);\r\n    end;\r\n\r\n  procedure AddString;\r\n    var\r\n      l : integer;\r\n\r\n    begin\r\n      l := c-b;\r\n      if (l > 0) or AddEmptyStrings then\r\n        begin\r\n          if assigned(Strings) then\r\n            begin\r\n            if l>0 then\r\n              Strings.Add (Copy(Content,B,L))\r\n            else\r\n              Strings.Add('');\r\n            end;\r\n          inc (result);\r\n        end;\r\n    end;\r\n\r\nvar\r\n  cc,quoted : char;\r\n  aLen : Integer;\r\nbegin\r\n  result := 0;\r\n  c := 1;\r\n  Quoted := #0;\r\n  Separators := Separators + [#13, #10] - ['''','\"'];\r\n  SkipWhitespace;\r\n  b := c;\r\n  aLen:=Length(Content);\r\n  while C<=aLen do\r\n    begin\r\n      CC:=Content[c];\r\n      if (CC = Quoted) then\r\n        begin\r\n          if (C<aLen) and (Content[C+1] = Quoted) then\r\n            inc (c)\r\n          else\r\n            Quoted := #0\r\n        end\r\n      else if (Quoted = #0) and (CC in ['''','\"']) then\r\n        Quoted := CC;\r\n      if (Quoted = #0) and (CC in Separators) then\r\n        begin\r\n          AddString;\r\n          inc (c);\r\n          SkipWhitespace;\r\n          b := c;\r\n        end\r\n      else\r\n        inc (c);\r\n    end;\r\n  if (c <> b) then\r\n    AddString;\r\nend;\r\n\r\n\r\nfunction FindIntToIdent(AIntegerType: Pointer): TIntToIdent;\r\n\r\nvar\r\n  i: Integer;\r\n\r\nbegin\r\n  Result := nil;\r\n  if Not Assigned(IntConstList) then\r\n    exit;\r\n  with IntConstList do\r\n    for i := 0 to Count - 1 do\r\n      if TIntConst(Items[i]).IntegerType = AIntegerType then\r\n        exit(TIntConst(Items[i]).IntToIdentFn);\r\nend;\r\n\r\nfunction FindIdentToInt(AIntegerType: Pointer): TIdentToInt;\r\nvar\r\n  i: Integer;\r\nbegin\r\n  Result := nil;\r\n  if Not Assigned(IntConstList) then\r\n    exit;\r\n  with IntConstList do\r\n    for i := 0 to Count - 1 do\r\n      with TIntConst(Items[I]) do\r\n        if TIntConst(Items[I]).IntegerType = AIntegerType then\r\n          exit(IdentToIntFn);\r\nend;\r\n\r\nfunction IdentToInt(const Ident: String; out Int: LongInt;\r\n  const Map: array of TIdentMapEntry): Boolean;\r\nvar\r\n  i: Integer;\r\nbegin\r\n  for i := Low(Map) to High(Map) do\r\n    if CompareText(Map[i].Name, Ident) = 0 then\r\n    begin\r\n      Int := Map[i].Value;\r\n      exit(True);\r\n    end;\r\n  Result := False;\r\nend;\r\n\r\nfunction IntToIdent(Int: LongInt; var Ident: String;\r\n  const Map: array of TIdentMapEntry): Boolean;\r\nvar\r\n  i: Integer;\r\nbegin\r\n  for i := Low(Map) to High(Map) do\r\n    if Map[i].Value = Int then\r\n      begin\r\n      Ident := Map[i].Name;\r\n      exit(True);\r\n      end;\r\n  Result := False;\r\nend;\r\n\r\nfunction GlobalIdentToInt(const Ident: String; var Int: LongInt):boolean;\r\nvar\r\n  i : Integer;\r\nbegin\r\n  Result := false;\r\n  if Not Assigned(IntConstList) then\r\n    exit;\r\n  with IntConstList do\r\n    for i := 0 to Count - 1 do\r\n      if TIntConst(Items[I]).IdentToIntFn(Ident, Int) then\r\n        Exit(True);\r\nend;\r\n\r\nfunction FindClass(const AClassName: string): TPersistentClass;\r\n\r\nbegin\r\n  Result := GetClass(AClassName);\r\n  if not Assigned(Result) then\r\n    raise EClassNotFound.CreateFmt(SClassNotFound, [AClassName]);\r\nend;\r\n\r\n\r\nfunction CollectionsEqual(C1, C2: TCollection): Boolean;\r\n\r\nVar\r\n  Comp1,Comp2 : TComponent;\r\n\r\nbegin\r\n  Comp2:=Nil;\r\n  Comp1:=TComponent.Create;\r\n  try\r\n    Result:=CollectionsEqual(C1,C2,Comp1,Comp2);\r\n  finally\r\n    Comp1.Free;\r\n    Comp2.Free;\r\n  end;\r\nend;\r\n\r\nfunction CollectionsEqual(C1, C2: TCollection; Owner1, Owner2: TComponent): Boolean;\r\n\r\n  procedure stream_collection(s : tstream;c : tcollection;o : tcomponent);\r\n    var\r\n      w : twriter;\r\n    begin\r\n      w:=twriter.create(s);\r\n      try\r\n        w.root:=o;\r\n        w.flookuproot:=o;\r\n        w.writecollection(c);\r\n      finally\r\n        w.free;\r\n      end;\r\n    end;\r\n\r\n  var\r\n    s1,s2 : tbytesstream;\r\n    b1,b2 : TBytes;\r\n    I,Len : Integer;\r\n  begin\r\n    result:=false;\r\n    if (c1.classtype<>c2.classtype) or\r\n      (c1.count<>c2.count) then\r\n      exit;\r\n    if c1.count = 0 then\r\n      begin\r\n      result:= true;\r\n      exit;\r\n      end;\r\n    s2:=Nil;\r\n    s1:=tbytesstream.create;\r\n    try\r\n      s2:=tbytesstream.create;\r\n      stream_collection(s1,c1,owner1);\r\n      stream_collection(s2,c2,owner2);\r\n      result:=(s1.size=s2.size);\r\n      if Result then\r\n        begin\r\n        b1:=S1.Bytes;\r\n        b2:=S2.Bytes;\r\n        I:=0;\r\n        Len:=S1.Size; // Not length of B\r\n        While Result and (I<Len) do\r\n           begin\r\n           Result:=b1[I]=b2[i];\r\n           Inc(i);\r\n           end;\r\n        end;\r\n    finally\r\n      s2.free;\r\n      s1.free;\r\n    end;\r\n  end;\r\n\r\n\r\n\r\n\r\n{ TInterfacedPersistent }\r\n\r\nfunction TInterfacedPersistent._AddRef: Integer;\r\nbegin\r\n  Result:=-1;\r\n  if Assigned(FOwnerInterface) then\r\n    Result:=FOwnerInterface._AddRef;\r\nend;\r\n\r\nfunction TInterfacedPersistent._Release: Integer;\r\n\r\nbegin\r\n  Result:=-1;\r\n  if Assigned(FOwnerInterface) then\r\n    Result:=FOwnerInterface._Release;\r\nend;\r\n\r\nfunction TInterfacedPersistent.QueryInterface(const IID: TGUID; out Obj): HRESULT;\r\nbegin\r\n  Result:=E_NOINTERFACE;\r\n  if GetInterface(IID, Obj)  then\r\n    Result:=0;\r\nend;\r\n\r\nprocedure TInterfacedPersistent.AfterConstruction;\r\nbegin\r\n  inherited AfterConstruction;\r\n  if (GetOwner<>nil) then\r\n    GetOwner.GetInterface(IInterface, FOwnerInterface);\r\nend;\r\n\r\n{ TComponentEnumerator }\r\n\r\nconstructor TComponentEnumerator.Create(AComponent: TComponent);\r\nbegin\r\n  inherited Create;\r\n  FComponent := AComponent;\r\n  FPosition := -1;\r\nend;\r\n\r\nfunction TComponentEnumerator.GetCurrent: TComponent;\r\nbegin\r\n  Result := FComponent.Components[FPosition];\r\nend;\r\n\r\nfunction TComponentEnumerator.MoveNext: Boolean;\r\nbegin\r\n  Inc(FPosition);\r\n  Result := FPosition < FComponent.ComponentCount;\r\nend;\r\n\r\n{ TListEnumerator }\r\n\r\nconstructor TListEnumerator.Create(AList: TList);\r\nbegin\r\n  inherited Create;\r\n  FList := AList;\r\n  FPosition := -1;\r\nend;\r\n\r\nfunction TListEnumerator.GetCurrent: JSValue;\r\nbegin\r\n  Result := FList[FPosition];\r\nend;\r\n\r\nfunction TListEnumerator.MoveNext: Boolean;\r\nbegin\r\n  Inc(FPosition);\r\n  Result := FPosition < FList.Count;\r\nend;\r\n\r\n{ TFPListEnumerator }\r\n\r\nconstructor TFPListEnumerator.Create(AList: TFPList);\r\nbegin\r\n  inherited Create;\r\n  FList := AList;\r\n  FPosition := -1;\r\nend;\r\n\r\nfunction TFPListEnumerator.GetCurrent: JSValue;\r\nbegin\r\n  Result := FList[FPosition];\r\nend;\r\n\r\nfunction TFPListEnumerator.MoveNext: Boolean;\r\nbegin\r\n  Inc(FPosition);\r\n  Result := FPosition < FList.Count;\r\nend;\r\n\r\n{ TFPList }\r\n\r\nprocedure TFPList.CopyMove(aList: TFPList);\r\nvar r : integer;\r\nbegin\r\n  Clear;\r\n  for r := 0 to aList.count-1 do\r\n    Add(aList[r]);\r\nend;\r\n\r\nprocedure TFPList.MergeMove(aList: TFPList);\r\nvar r : integer;\r\nbegin\r\n  For r := 0 to aList.count-1 do\r\n    if IndexOf(aList[r]) < 0 then\r\n      Add(aList[r]);\r\nend;\r\n\r\nprocedure TFPList.DoCopy(ListA, ListB: TFPList);\r\nbegin\r\n  if Assigned(ListB) then\r\n    CopyMove(ListB)\r\n  else\r\n    CopyMove(ListA);\r\nend;\r\n\r\nprocedure TFPList.DoSrcUnique(ListA, ListB: TFPList);\r\nvar r : integer;\r\nbegin\r\n  if Assigned(ListB) then\r\n    begin\r\n    Clear;\r\n    for r := 0 to ListA.Count-1 do\r\n      if ListB.IndexOf(ListA[r]) < 0 then\r\n        Add(ListA[r]);\r\n    end\r\n  else\r\n    begin\r\n    for r := Count-1 downto 0 do\r\n      if ListA.IndexOf(Self[r]) >= 0 then\r\n        Delete(r);\r\n    end;\r\nend;\r\n\r\nprocedure TFPList.DoAnd(ListA, ListB: TFPList);\r\nvar r : integer;\r\nbegin\r\n  if Assigned(ListB) then\r\n    begin\r\n    Clear;\r\n    for r := 0 to ListA.count-1 do\r\n      if ListB.IndexOf(ListA[r]) >= 0 then\r\n        Add(ListA[r]);\r\n    end\r\n  else\r\n    begin\r\n    for r := Count-1 downto 0 do\r\n      if ListA.IndexOf(Self[r]) < 0 then\r\n        Delete(r);\r\n    end;\r\nend;\r\n\r\nprocedure TFPList.DoDestUnique(ListA, ListB: TFPList);\r\n\r\n  procedure MoveElements(Src, Dest: TFPList);\r\n  var r : integer;\r\n  begin\r\n    Clear;\r\n    for r := 0 to Src.count-1 do\r\n      if Dest.IndexOf(Src[r]) < 0 then\r\n        self.Add(Src[r]);\r\n  end;\r\n\r\nvar Dest : TFPList;\r\nbegin\r\n  if Assigned(ListB) then\r\n    MoveElements(ListB, ListA)\r\n  else\r\n    Dest := TFPList.Create;\r\n    try\r\n      Dest.CopyMove(Self);\r\n      MoveElements(ListA, Dest)\r\n    finally\r\n      Dest.Destroy;\r\n    end;\r\nend;\r\n\r\nprocedure TFPList.DoOr(ListA, ListB: TFPList);\r\nbegin\r\n  if Assigned(ListB) then\r\n    begin\r\n    CopyMove(ListA);\r\n    MergeMove(ListB);\r\n    end\r\n  else\r\n    MergeMove(ListA);\r\nend;\r\n\r\nprocedure TFPList.DoXOr(ListA, ListB: TFPList);\r\nvar\r\n  r : integer;\r\n  l : TFPList;\r\nbegin\r\n  if Assigned(ListB) then\r\n    begin\r\n    Clear;\r\n    for r := 0 to ListA.Count-1 do\r\n      if ListB.IndexOf(ListA[r]) < 0 then\r\n        Add(ListA[r]);\r\n    for r := 0 to ListB.Count-1 do\r\n      if ListA.IndexOf(ListB[r]) < 0 then\r\n        Add(ListB[r]);\r\n    end\r\n  else\r\n    begin\r\n    l := TFPList.Create;\r\n    try\r\n      l.CopyMove(Self);\r\n      for r := Count-1 downto 0 do\r\n        if listA.IndexOf(Self[r]) >= 0 then\r\n          Delete(r);\r\n      for r := 0 to ListA.Count-1 do\r\n        if l.IndexOf(ListA[r]) < 0 then\r\n          Add(ListA[r]);\r\n    finally\r\n      l.Destroy;\r\n    end;\r\n    end;\r\nend;\r\n\r\nfunction TFPList.Get(Index: Integer): JSValue;\r\nbegin\r\n  If (Index < 0) or (Index >= FCount) then\r\n    RaiseIndexError(Index);\r\n  Result:=FList[Index];\r\nend;\r\n\r\nprocedure TFPList.Put(Index: Integer; Item: JSValue);\r\nbegin\r\n  if (Index < 0) or (Index >= FCount) then\r\n    RaiseIndexError(Index);\r\n  FList[Index] := Item;\r\nend;\r\n\r\nprocedure TFPList.SetCapacity(NewCapacity: Integer);\r\nbegin\r\n  If (NewCapacity < FCount) then\r\n     Error (SListCapacityError, str(NewCapacity));\r\n  if NewCapacity = FCapacity then\r\n    exit;\r\n  SetLength(FList,NewCapacity);\r\n  FCapacity := NewCapacity;\r\nend;\r\n\r\nprocedure TFPList.SetCount(NewCount: Integer);\r\nbegin\r\n  if (NewCount < 0) then\r\n    Error(SListCountError, str(NewCount));\r\n  If NewCount > FCount then\r\n    begin\r\n    If NewCount > FCapacity then\r\n      SetCapacity(NewCount);\r\n    end;\r\n  FCount := NewCount;\r\nend;\r\n\r\nprocedure TFPList.RaiseIndexError(Index: Integer);\r\nbegin\r\n  Error(SListIndexError, str(Index));\r\nend;\r\n\r\ndestructor TFPList.Destroy;\r\nbegin\r\n  Clear;\r\n  inherited Destroy;\r\nend;\r\n\r\nprocedure TFPList.AddList(AList: TFPList);\r\n\r\nVar\r\n  I : Integer;\r\n\r\nbegin\r\n  If (Capacity<Count+AList.Count) then\r\n    Capacity:=Count+AList.Count;\r\n  For I:=0 to AList.Count-1 do\r\n    Add(AList[i]);\r\nend;\r\n\r\nfunction TFPList.Add(Item: JSValue): Integer;\r\nbegin\r\n  if FCount = FCapacity then\r\n    Expand;\r\n  FList[FCount] := Item;\r\n  Result := FCount;\r\n  Inc(FCount);\r\nend;\r\n\r\nprocedure TFPList.Clear;\r\nbegin\r\n  if Assigned(FList) then\r\n  begin\r\n    SetCount(0);\r\n    SetCapacity(0);\r\n  end;\r\nend;\r\n\r\nprocedure TFPList.Delete(Index: Integer);\r\nbegin\r\n  If (Index<0) or (Index>=FCount) then\r\n    Error (SListIndexError, str(Index));\r\n  FCount := FCount-1;\r\n  System.Delete(FList,Index,1);\r\n  Dec(FCapacity);\r\nend;\r\n\r\nclass procedure TFPList.Error(const Msg: string; const Data: String);\r\nbegin\r\n  Raise EListError.CreateFmt(Msg,[Data]);\r\nend;\r\n\r\nprocedure TFPList.Exchange(Index1, Index2: Integer);\r\nvar\r\n  Temp : JSValue;\r\nbegin\r\n  If (Index1 >= FCount) or (Index1 < 0) then\r\n    Error(SListIndexError, str(Index1));\r\n  If (Index2 >= FCount) or (Index2 < 0) then\r\n    Error(SListIndexError, str(Index2));\r\n  Temp := FList[Index1];\r\n  FList[Index1] := FList[Index2];\r\n  FList[Index2] := Temp;\r\nend;\r\n\r\nfunction TFPList.Expand: TFPList;\r\nvar\r\n  IncSize : Integer;\r\nbegin\r\n  if FCount < FCapacity then exit(self);\r\n  IncSize := 4;\r\n  if FCapacity > 3 then IncSize := IncSize + 4;\r\n  if FCapacity > 8 then IncSize := IncSize+8;\r\n  if FCapacity > 127 then Inc(IncSize, FCapacity shr 2);\r\n  SetCapacity(FCapacity + IncSize);\r\n  Result := Self;\r\nend;\r\n\r\nfunction TFPList.Extract(Item: JSValue): JSValue;\r\nvar\r\n  i : Integer;\r\nbegin\r\n  i := IndexOf(Item);\r\n  if i >= 0 then\r\n  begin\r\n    Result := Item;\r\n    Delete(i);\r\n  end\r\n  else\r\n    Result := nil;\r\nend;\r\n\r\nfunction TFPList.First: JSValue;\r\nbegin\r\n  If FCount = 0 then\r\n    Result := Nil\r\n  else\r\n    Result := Items[0];\r\nend;\r\n\r\nfunction TFPList.GetEnumerator: TFPListEnumerator;\r\nbegin\r\n  Result:=TFPListEnumerator.Create(Self);\r\nend;\r\n\r\nfunction TFPList.IndexOf(Item: JSValue): Integer;\r\n\r\nVar\r\n  C : Integer;\r\n\r\nbegin\r\n  Result:=0;\r\n  C:=Count;\r\n  while (Result<C) and (FList[Result]<>Item) do\r\n    Inc(Result);\r\n  If Result>=C then\r\n    Result:=-1;\r\n\r\nend;\r\n\r\nfunction TFPList.IndexOfItem(Item: JSValue; Direction: TDirection): Integer;\r\n\r\nbegin\r\n  if Direction=fromBeginning then\r\n    Result:=IndexOf(Item)\r\n  else\r\n    begin\r\n    Result:=Count-1;\r\n    while (Result >=0) and (Flist[Result]<>Item) do\r\n      Result:=Result - 1;\r\n    end;\r\nend;\r\n\r\n\r\nprocedure TFPList.Insert(Index: Integer; Item: JSValue);\r\nbegin\r\n  if (Index < 0) or (Index > FCount )then\r\n    Error(SlistIndexError, str(Index));\r\n  TJSArray(FList).splice(Index, 0, Item);\r\n  inc(FCapacity);\r\n  inc(FCount);\r\nend;\r\n\r\nfunction TFPList.Last: JSValue;\r\nbegin\r\n  If FCount = 0 then\r\n    Result := nil\r\n  else\r\n    Result := Items[FCount - 1];\r\nend;\r\n\r\nprocedure TFPList.Move(CurIndex, NewIndex: Integer);\r\nvar\r\n  Temp: JSValue;\r\nbegin\r\n  if (CurIndex < 0) or (CurIndex > Count - 1) then\r\n    Error(SListIndexError, str(CurIndex));\r\n  if (NewIndex < 0) or (NewIndex > Count -1) then\r\n    Error(SlistIndexError, str(NewIndex));\r\n  if CurIndex=NewIndex then exit;\r\n  Temp:=FList[CurIndex];\r\n  // ToDo: use TJSArray.copyWithin if available\r\n  TJSArray(FList).splice(CurIndex,1);\r\n  TJSArray(FList).splice(NewIndex,0,Temp);\r\nend;\r\n\r\nprocedure TFPList.Assign(ListA: TFPList; AOperator: TListAssignOp;\r\n  ListB: TFPList);\r\nbegin\r\n  case AOperator of\r\n    laCopy      : DoCopy (ListA, ListB);      // replace dest with src\r\n    laSrcUnique : DoSrcUnique (ListA, ListB); // replace dest with src that are not in dest\r\n    laAnd       : DoAnd (ListA, ListB);       // remove from dest that are not in src\r\n    laDestUnique: DoDestUnique (ListA, ListB);// remove from dest that are in src\r\n    laOr        : DoOr (ListA, ListB);        // add to dest from src and not in dest\r\n    laXOr       : DoXOr (ListA, ListB);       // add to dest from src and not in dest, remove from dest that are in src\r\n  end;\r\nend;\r\n\r\nfunction TFPList.Remove(Item: JSValue): Integer;\r\nbegin\r\n  Result := IndexOf(Item);\r\n  If Result <> -1 then\r\n    Delete(Result);\r\nend;\r\n\r\nprocedure TFPList.Pack;\r\nvar\r\n  Dst, i: Integer;\r\n  V: JSValue;\r\nbegin\r\n  Dst:=0;\r\n  for i:=0 to Count-1 do\r\n    begin\r\n    V:=FList[i];\r\n    if not Assigned(V) then continue;\r\n    FList[Dst]:=V;\r\n    inc(Dst);\r\n    end;\r\nend;\r\n\r\n// Needed by Sort method.\r\n\r\nProcedure QuickSort(aList: TJSValueDynArray; L, R : Longint;\r\n                    const Compare: TListSortCompareFunc\r\n                    );\r\nvar\r\n  I, J, PivotIdx : SizeUInt;\r\n  P, Q : JSValue;\r\nbegin\r\n repeat\r\n   I := L;\r\n   J := R;\r\n   PivotIdx := L + ((R - L) shr 1); { same as ((L + R) div 2), but without the possibility of overflow }\r\n   P := aList[PivotIdx];\r\n   repeat\r\n     while (I < PivotIdx) and (Compare(P, aList[i]) > 0) do\r\n       Inc(I);\r\n     while (J > PivotIdx) and (Compare(P, aList[J]) < 0) do\r\n       Dec(J);\r\n     if I < J then\r\n     begin\r\n       Q := aList[I];\r\n       aList[I] := aList[J];\r\n       aList[J] := Q;\r\n       if PivotIdx = I then\r\n       begin\r\n         PivotIdx := J;\r\n         Inc(I);\r\n       end\r\n       else if PivotIdx = J then\r\n       begin\r\n         PivotIdx := I;\r\n         Dec(J);\r\n       end\r\n       else\r\n       begin\r\n         Inc(I);\r\n         Dec(J);\r\n       end;\r\n     end;\r\n   until I >= J;\r\n   // sort the smaller range recursively\r\n   // sort the bigger range via the loop\r\n   // Reasons: memory usage is O(log(n)) instead of O(n) and loop is faster than recursion\r\n   if (PivotIdx - L) < (R - PivotIdx) then\r\n   begin\r\n     if (L + 1) < PivotIdx then\r\n       QuickSort(aList, L, PivotIdx - 1, Compare);\r\n     L := PivotIdx + 1;\r\n   end\r\n   else\r\n   begin\r\n     if (PivotIdx + 1) < R then\r\n       QuickSort(aList, PivotIdx + 1, R, Compare);\r\n     if (L + 1) < PivotIdx then\r\n       R := PivotIdx - 1\r\n     else\r\n       exit;\r\n   end;\r\n until L >= R;\r\nend;\r\n\r\n(*\r\nProcedure QuickSort(aList: TJSValueDynArray; L, R : Longint;\r\n                    const Compare: TListSortCompareFunc);\r\nvar\r\n  I, J : Longint;\r\n  P, Q : JSValue;\r\nbegin\r\n  repeat\r\n    I := L;\r\n    J := R;\r\n    P := aList[ (L + R) div 2 ];\r\n    repeat\r\n      while Compare(P, aList[i]) > 0 do\r\n        I := I + 1;\r\n      while Compare(P, aList[J]) < 0 do\r\n        J := J - 1;\r\n      If I <= J then\r\n      begin\r\n        Q := aList[I];\r\n        aList[I] := aList[J];\r\n        aList[J] := Q;\r\n        I := I + 1;\r\n        J := J - 1;\r\n      end;\r\n    until I > J;\r\n    // sort the smaller range recursively\r\n    // sort the bigger range via the loop\r\n    // Reasons: memory usage is O(log(n)) instead of O(n) and loop is faster than recursion\r\n    if J - L < R - I then\r\n    begin\r\n      if L < J then\r\n        QuickSort(aList, L, J, Compare);\r\n      L := I;\r\n    end\r\n    else\r\n    begin\r\n      if I < R then\r\n        QuickSort(aList, I, R, Compare);\r\n      R := J;\r\n    end;\r\n  until L >= R;\r\nend;\r\n*)\r\n\r\nprocedure TFPList.Sort(const Compare: TListSortCompare);\r\nbegin\r\n  if Not Assigned(FList) or (FCount < 2) then exit;\r\n  QuickSort(Flist, 0, FCount-1,\r\n    function(Item1, Item2: JSValue): Integer\r\n    begin\r\n      Result := Compare(Item1, Item2);\r\n    end);\r\nend;\r\n\r\nprocedure TFPList.SortList(const Compare: TListSortCompareFunc);\r\nbegin\r\n  if Not Assigned(FList) or (FCount < 2) then exit;\r\n  QuickSort(Flist, 0, FCount-1, Compare);\r\nend;\r\n\r\nprocedure TFPList.ForEachCall(const proc2call: TListCallback; const arg: JSValue\r\n  );\r\nvar\r\n  i : integer;\r\n  v : JSValue;\r\nbegin\r\n  For I:=0 To Count-1 Do\r\n    begin\r\n      v:=FList[i];\r\n      if Assigned(v) then\r\n        proc2call(v,arg);\r\n    end;\r\nend;\r\n\r\nprocedure TFPList.ForEachCall(const proc2call: TListStaticCallback;\r\n  const arg: JSValue);\r\nvar\r\n  i : integer;\r\n  v : JSValue;\r\nbegin\r\n  For I:=0 To Count-1 Do\r\n    begin\r\n      v:=FList[i];\r\n      if Assigned(v) then\r\n        proc2call(v,arg);\r\n    end;\r\nend;\r\n\r\n{ TList }\r\n\r\nprocedure TList.CopyMove(aList: TList);\r\nvar\r\n  r : integer;\r\nbegin\r\n  Clear;\r\n  for r := 0 to aList.count-1 do\r\n    Add(aList[r]);\r\nend;\r\n\r\nprocedure TList.MergeMove(aList: TList);\r\nvar r : integer;\r\nbegin\r\n  For r := 0 to aList.count-1 do\r\n    if IndexOf(aList[r]) < 0 then\r\n      Add(aList[r]);\r\nend;\r\n\r\nprocedure TList.DoCopy(ListA, ListB: TList);\r\nbegin\r\n  if Assigned(ListB) then\r\n    CopyMove(ListB)\r\n  else\r\n    CopyMove(ListA);\r\nend;\r\n\r\nprocedure TList.DoSrcUnique(ListA, ListB: TList);\r\nvar r : integer;\r\nbegin\r\n  if Assigned(ListB) then\r\n    begin\r\n    Clear;\r\n    for r := 0 to ListA.Count-1 do\r\n      if ListB.IndexOf(ListA[r]) < 0 then\r\n        Add(ListA[r]);\r\n    end\r\n  else\r\n    begin\r\n    for r := Count-1 downto 0 do\r\n      if ListA.IndexOf(Self[r]) >= 0 then\r\n        Delete(r);\r\n    end;\r\nend;\r\n\r\nprocedure TList.DoAnd(ListA, ListB: TList);\r\nvar r : integer;\r\nbegin\r\n  if Assigned(ListB) then\r\n    begin\r\n    Clear;\r\n    for r := 0 to ListA.Count-1 do\r\n      if ListB.IndexOf(ListA[r]) >= 0 then\r\n        Add(ListA[r]);\r\n    end\r\n  else\r\n    begin\r\n    for r := Count-1 downto 0 do\r\n      if ListA.IndexOf(Self[r]) < 0 then\r\n        Delete(r);\r\n    end;\r\nend;\r\n\r\nprocedure TList.DoDestUnique(ListA, ListB: TList);\r\n\r\n  procedure MoveElements(Src, Dest : TList);\r\n  var r : integer;\r\n  begin\r\n    Clear;\r\n    for r := 0 to Src.Count-1 do\r\n      if Dest.IndexOf(Src[r]) < 0 then\r\n        Add(Src[r]);\r\n  end;\r\n\r\nvar Dest : TList;\r\nbegin\r\n  if Assigned(ListB) then\r\n    MoveElements(ListB, ListA)\r\n  else\r\n    try\r\n      Dest := TList.Create;\r\n      Dest.CopyMove(Self);\r\n      MoveElements(ListA, Dest)\r\n    finally\r\n      Dest.Destroy;\r\n    end;\r\nend;\r\n\r\nprocedure TList.DoOr(ListA, ListB: TList);\r\nbegin\r\n  if Assigned(ListB) then\r\n    begin\r\n    CopyMove(ListA);\r\n    MergeMove(ListB);\r\n    end\r\n  else\r\n    MergeMove(ListA);\r\nend;\r\n\r\nprocedure TList.DoXOr(ListA, ListB: TList);\r\nvar\r\n  r : integer;\r\n  l : TList;\r\nbegin\r\n  if Assigned(ListB) then\r\n    begin\r\n    Clear;\r\n    for r := 0 to ListA.Count-1 do\r\n      if ListB.IndexOf(ListA[r]) < 0 then\r\n        Add(ListA[r]);\r\n    for r := 0 to ListB.Count-1 do\r\n      if ListA.IndexOf(ListB[r]) < 0 then\r\n        Add(ListB[r]);\r\n    end\r\n  else\r\n    try\r\n      l := TList.Create;\r\n      l.CopyMove (Self);\r\n      for r := Count-1 downto 0 do\r\n        if listA.IndexOf(Self[r]) >= 0 then\r\n          Delete(r);\r\n      for r := 0 to ListA.Count-1 do\r\n        if l.IndexOf(ListA[r]) < 0 then\r\n          Add(ListA[r]);\r\n    finally\r\n      l.Destroy;\r\n    end;\r\nend;\r\n\r\nfunction TList.Get(Index: Integer): JSValue;\r\nbegin\r\n  Result := FList.Get(Index);\r\nend;\r\n\r\nprocedure TList.Put(Index: Integer; Item: JSValue);\r\nvar V : JSValue;\r\nbegin\r\n  V := Get(Index);\r\n  FList.Put(Index, Item);\r\n  if Assigned(V) then\r\n    Notify(V, lnDeleted);\r\n  if Assigned(Item) then\r\n    Notify(Item, lnAdded);\r\nend;\r\n\r\nprocedure TList.Notify(aValue: JSValue; Action: TListNotification);\r\nbegin\r\n  if Assigned(aValue) then ;\r\n  if Action=lnExtracted then ;\r\nend;\r\n\r\nprocedure TList.SetCapacity(NewCapacity: Integer);\r\nbegin\r\n  FList.SetCapacity(NewCapacity);\r\nend;\r\n\r\nfunction TList.GetCapacity: integer;\r\nbegin\r\n  Result := FList.Capacity;\r\nend;\r\n\r\nprocedure TList.SetCount(NewCount: Integer);\r\nbegin\r\n  if NewCount < FList.Count then\r\n    while FList.Count > NewCount do\r\n      Delete(FList.Count - 1)\r\n  else\r\n    FList.SetCount(NewCount);\r\nend;\r\n\r\nfunction TList.GetCount: integer;\r\nbegin\r\n  Result := FList.Count;\r\nend;\r\n\r\nfunction TList.GetList: TJSValueDynArray;\r\nbegin\r\n  Result := FList.List;\r\nend;\r\n\r\nconstructor TList.Create;\r\nbegin\r\n  inherited Create;\r\n  FList := TFPList.Create;\r\nend;\r\n\r\ndestructor TList.Destroy;\r\nbegin\r\n  if Assigned(FList) then\r\n    Clear;\r\n  FreeAndNil(FList);\r\nend;\r\n\r\nprocedure TList.AddList(AList: TList);\r\nvar\r\n  I: Integer;\r\nbegin\r\n  { this only does FList.AddList(AList.FList), avoiding notifications }\r\n  FList.AddList(AList.FList);\r\n\r\n  { make lnAdded notifications }\r\n  for I := 0 to AList.Count - 1 do\r\n    if Assigned(AList[I]) then\r\n      Notify(AList[I], lnAdded);\r\nend;\r\n\r\nfunction TList.Add(Item: JSValue): Integer;\r\nbegin\r\n  Result := FList.Add(Item);\r\n  if Assigned(Item) then\r\n    Notify(Item, lnAdded);\r\nend;\r\n\r\nprocedure TList.Clear;\r\nbegin\r\n  While (FList.Count>0) do\r\n    Delete(Count-1);\r\nend;\r\n\r\nprocedure TList.Delete(Index: Integer);\r\n\r\nvar V : JSValue;\r\n\r\nbegin\r\n  V:=FList.Get(Index);\r\n  FList.Delete(Index);\r\n  if assigned(V) then\r\n    Notify(V, lnDeleted);\r\nend;\r\n\r\nclass procedure TList.Error(const Msg: string; Data: String);\r\nbegin\r\n  Raise EListError.CreateFmt(Msg,[Data]);\r\nend;\r\n\r\nprocedure TList.Exchange(Index1, Index2: Integer);\r\nbegin\r\n  FList.Exchange(Index1, Index2);\r\nend;\r\n\r\nfunction TList.Expand: TList;\r\nbegin\r\n  FList.Expand;\r\n  Result:=Self;\r\nend;\r\n\r\nfunction TList.Extract(Item: JSValue): JSValue;\r\nvar c : integer;\r\nbegin\r\n  c := FList.Count;\r\n  Result := FList.Extract(Item);\r\n  if c <> FList.Count then\r\n    Notify (Result, lnExtracted);\r\nend;\r\n\r\nfunction TList.First: JSValue;\r\nbegin\r\n  Result := FList.First;\r\nend;\r\n\r\nfunction TList.GetEnumerator: TListEnumerator;\r\nbegin\r\n  Result:=TListEnumerator.Create(Self);\r\nend;\r\n\r\nfunction TList.IndexOf(Item: JSValue): Integer;\r\nbegin\r\n  Result := FList.IndexOf(Item);\r\nend;\r\n\r\nprocedure TList.Insert(Index: Integer; Item: JSValue);\r\nbegin\r\n  FList.Insert(Index, Item);\r\n  if Assigned(Item) then\r\n    Notify(Item,lnAdded);\r\nend;\r\n\r\nfunction TList.Last: JSValue;\r\nbegin\r\n  Result := FList.Last;\r\nend;\r\n\r\nprocedure TList.Move(CurIndex, NewIndex: Integer);\r\nbegin\r\n  FList.Move(CurIndex, NewIndex);\r\nend;\r\n\r\nprocedure TList.Assign(ListA: TList; AOperator: TListAssignOp; ListB: TList);\r\nbegin\r\n  case AOperator of\r\n    laCopy      : DoCopy (ListA, ListB);      // replace dest with src\r\n    laSrcUnique : DoSrcUnique (ListA, ListB); // replace dest with src that are not in dest\r\n    laAnd       : DoAnd (ListA, ListB);       // remove from dest that are not in src\r\n    laDestUnique: DoDestUnique (ListA, ListB);// remove from dest that are in src\r\n    laOr        : DoOr (ListA, ListB);        // add to dest from src and not in dest\r\n    laXOr       : DoXOr (ListA, ListB);       // add to dest from src and not in dest, remove from dest that are in src\r\n  end;\r\nend;\r\n\r\nfunction TList.Remove(Item: JSValue): Integer;\r\nbegin\r\n  Result := IndexOf(Item);\r\n  if Result <> -1 then\r\n    Self.Delete(Result);\r\nend;\r\n\r\nprocedure TList.Pack;\r\nbegin\r\n  FList.Pack;\r\nend;\r\n\r\nprocedure TList.Sort(const Compare: TListSortCompare);\r\nbegin\r\n  FList.Sort(Compare);\r\nend;\r\n\r\nprocedure TList.SortList(const Compare: TListSortCompareFunc);\r\nbegin\r\n  FList.SortList(Compare);\r\nend;\r\n\r\n{ TPersistent }\r\n\r\nprocedure TPersistent.AssignError(Source: TPersistent);\r\nvar\r\n  SourceName: String;\r\nbegin\r\n  if Source<>Nil then\r\n    SourceName:=Source.ClassName\r\n  else\r\n    SourceName:='Nil';\r\n  raise EConvertError.Create('Cannot assign a '+SourceName+' to a '+ClassName+'.');\r\nend;\r\n\r\nprocedure TPersistent.DefineProperties(Filer: TFiler);\r\nbegin\r\n  if Filer=Nil then exit;\r\n  // Do nothing\r\nend;\r\n\r\nprocedure TPersistent.AssignTo(Dest: TPersistent);\r\nbegin\r\n  Dest.AssignError(Self);\r\nend;\r\n\r\nfunction TPersistent.GetOwner: TPersistent;\r\nbegin\r\n  Result:=nil;\r\nend;\r\n\r\nprocedure TPersistent.Assign(Source: TPersistent);\r\nbegin\r\n  If Source<>Nil then\r\n    Source.AssignTo(Self)\r\n  else\r\n    AssignError(Nil);\r\nend;\r\n\r\nfunction TPersistent.GetNamePath: string;\r\nvar\r\n  OwnerName: String;\r\n  TheOwner: TPersistent;\r\nbegin\r\n  Result:=ClassName;\r\n  TheOwner:=GetOwner;\r\n  if TheOwner<>Nil then\r\n  begin\r\n    OwnerName:=TheOwner.GetNamePath;\r\n    if OwnerName<>'' then Result:=OwnerName+'.'+Result;\r\n  end;\r\nend;\r\n\r\n{\r\n    This file is part of the Free Component Library (FCL)\r\n    Copyright (c) 1999-2000 by the Free Pascal development team\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n\r\n{****************************************************************************}\r\n{*                        TStringsEnumerator                                *}\r\n{****************************************************************************}\r\n\r\nconstructor TStringsEnumerator.Create(AStrings: TStrings);\r\nbegin\r\n  inherited Create;\r\n  FStrings := AStrings;\r\n  FPosition := -1;\r\nend;\r\n\r\nfunction TStringsEnumerator.GetCurrent: String;\r\nbegin\r\n  Result := FStrings[FPosition];\r\nend;\r\n\r\nfunction TStringsEnumerator.MoveNext: Boolean;\r\nbegin\r\n  Inc(FPosition);\r\n  Result := FPosition < FStrings.Count;\r\nend;\r\n\r\n{****************************************************************************}\r\n{*                             TStrings                                     *}\r\n{****************************************************************************}\r\n\r\n// Function to quote text. Should move maybe to sysutils !!\r\n// Also, it is not clear at this point what exactly should be done.\r\n\r\n{ //!! is used to mark unsupported things. }\r\n\r\n{\r\n  For compatibility we can't add a Constructor to TSTrings to initialize\r\n  the special characters. Therefore we add a routine which is called whenever\r\n  the special chars are needed.\r\n}\r\n\r\nprocedure TStrings.CheckSpecialChars;\r\n\r\nbegin\r\n  If Not FSpecialCharsInited then\r\n    begin\r\n    FQuoteChar:='\"';\r\n    FDelimiter:=',';\r\n    FNameValueSeparator:='=';\r\n    FLBS:=DefaultTextLineBreakStyle;\r\n    FSpecialCharsInited:=true;\r\n    FLineBreak:=sLineBreak;\r\n    end;\r\nend;\r\n\r\nfunction TStrings.GetSkipLastLineBreak: Boolean;\r\n\r\nbegin\r\n  CheckSpecialChars;\r\n  Result:=FSkipLastLineBreak;\r\nend;\r\n\r\nprocedure TStrings.SetSkipLastLineBreak(const AValue : Boolean);\r\n\r\nbegin\r\n  CheckSpecialChars;\r\n  FSkipLastLineBreak:=AValue;\r\nend;\r\n\r\nprocedure TStrings.ReadData(Reader: TReader);\r\nbegin\r\n  Reader.ReadListBegin;\r\n  BeginUpdate;\r\n  try\r\n    Clear;\r\n    while not Reader.EndOfList do\r\n      Add(Reader.ReadString);\r\n  finally\r\n    EndUpdate;\r\n  end;\r\n  Reader.ReadListEnd;\r\nend;\r\n\r\nprocedure TStrings.WriteData(Writer: TWriter);\r\nvar\r\n  i: Integer;\r\nbegin\r\n  Writer.WriteListBegin;\r\n  for i := 0 to Count - 1 do\r\n    Writer.WriteString(Strings[i]);\r\n  Writer.WriteListEnd;\r\nend;\r\n\r\nprocedure TStrings.DefineProperties(Filer: TFiler);\r\nvar\r\n  HasData: Boolean;\r\nbegin\r\n  if Assigned(Filer.Ancestor) then\r\n    // Only serialize if string list is different from ancestor\r\n    if Filer.Ancestor.InheritsFrom(TStrings) then\r\n      HasData := not Equals(TStrings(Filer.Ancestor))\r\n    else\r\n      HasData := True\r\n  else\r\n    HasData := Count > 0;\r\n  Filer.DefineProperty('Strings', @ReadData, @WriteData, HasData);\r\nend;\r\n\r\nfunction TStrings.GetLBS: TTextLineBreakStyle;\r\nbegin\r\n  CheckSpecialChars;\r\n  Result:=FLBS;\r\nend;\r\n\r\nprocedure TStrings.SetLBS(AValue: TTextLineBreakStyle);\r\nbegin\r\n  CheckSpecialChars;\r\n  FLBS:=AValue;\r\nend;\r\n\r\nprocedure TStrings.SetDelimiter(c:Char);\r\nbegin\r\n  CheckSpecialChars;\r\n  FDelimiter:=c;\r\nend;\r\n\r\nfunction TStrings.GetDelimiter: Char;\r\nbegin\r\n  CheckSpecialChars;\r\n  Result:=FDelimiter;\r\nend;\r\n\r\nprocedure TStrings.SetLineBreak(const S: String);\r\nbegin\r\n  CheckSpecialChars;\r\n  FLineBreak:=S;\r\nend;\r\n\r\nfunction TStrings.GetLineBreak: String;\r\nbegin\r\n  CheckSpecialChars;\r\n  Result:=FLineBreak;\r\nend;\r\n\r\n\r\nprocedure TStrings.SetQuoteChar(c:Char);\r\nbegin\r\n  CheckSpecialChars;\r\n  FQuoteChar:=c;\r\nend;\r\n\r\nfunction TStrings.GetQuoteChar: Char;\r\nbegin\r\n  CheckSpecialChars;\r\n  Result:=FQuoteChar;\r\nend;\r\n\r\nprocedure TStrings.SetNameValueSeparator(c:Char);\r\nbegin\r\n  CheckSpecialChars;\r\n  FNameValueSeparator:=c;\r\nend;\r\n\r\nfunction TStrings.GetNameValueSeparator: Char;\r\nbegin\r\n  CheckSpecialChars;\r\n  Result:=FNameValueSeparator;\r\nend;\r\n\r\n\r\nfunction TStrings.GetCommaText: string;\r\n\r\nVar\r\n  C1,C2 : Char;\r\n  FSD : Boolean;\r\n\r\nbegin\r\n  CheckSpecialChars;\r\n  FSD:=StrictDelimiter;\r\n  C1:=Delimiter;\r\n  C2:=QuoteChar;\r\n  Delimiter:=',';\r\n  QuoteChar:='\"';\r\n  StrictDelimiter:=False;\r\n  Try\r\n    Result:=GetDelimitedText;\r\n  Finally\r\n    Delimiter:=C1;\r\n    QuoteChar:=C2;\r\n    StrictDelimiter:=FSD;\r\n  end;\r\nend;\r\n\r\n\r\nfunction TStrings.GetDelimitedText: string;\r\n\r\nVar\r\n  I: integer;\r\n  RE : string;\r\n  S : String;\r\n  doQuote : Boolean;\r\n\r\nbegin\r\n  CheckSpecialChars;\r\n  result:='';\r\n  RE:=QuoteChar+'|'+Delimiter;\r\n  if not StrictDelimiter then\r\n    RE:=' |'+RE;\r\n  RE:='/'+RE+'/';\r\n  // Check for break characters and quote if required.\r\n  For i:=0 to count-1 do\r\n    begin\r\n    S:=Strings[i];\r\n    doQuote:=FAlwaysQuote or (TJSString(s).search(RE)<>-1);\r\n    if DoQuote then\r\n      Result:=Result+QuoteString(S,QuoteChar)\r\n    else\r\n      Result:=Result+S;\r\n    if I<Count-1 then\r\n      Result:=Result+Delimiter;\r\n    end;\r\n  // Quote empty string:\r\n  If (Length(Result)=0) and (Count=1) then\r\n    Result:=QuoteChar+QuoteChar;\r\nend;\r\n\r\nprocedure TStrings.GetNameValue(Index: Integer; out AName, AValue: String);\r\n\r\nVar L : longint;\r\n\r\nbegin\r\n  CheckSpecialChars;\r\n  AValue:=Strings[Index];\r\n  L:=Pos(FNameValueSeparator,AValue);\r\n  If L<>0 then\r\n    begin\r\n    AName:=Copy(AValue,1,L-1);\r\n    //    System.Delete(AValue,1,L);\r\n    AValue:=Copy(AValue,L+1,length(AValue)-L);\r\n    end\r\n  else\r\n    AName:='';\r\nend;\r\n\r\nprocedure TStrings.LoadFromURL(const aURL: String; Async: Boolean; OnLoaded: TNotifyEventRef; OnError: TStringNotifyEventRef);\r\n\r\n  procedure DoLoaded(const aString : String);\r\n  begin\r\n    Text:=aString;\r\n    if Assigned(OnLoaded) then\r\n      OnLoaded(Self);\r\n  end;\r\n\r\n  procedure DoError(const AError : String);\r\n  begin\r\n    if Assigned(OnError) then\r\n      OnError(Self,aError)\r\n    else\r\n      Raise EInOutError.Create('Failed to load from URL:'+aError);\r\n  end;\r\n\r\nbegin\r\n  CheckLoadHelper;\r\n  GlobalLoadHelper.LoadText(aURL,aSync,@DoLoaded,@DoError);\r\nend;\r\n\r\nprocedure TStrings.LoadFromFile(const aFileName: String; const OnLoaded: TProc; const AError: TProcString);\r\n\r\nbegin\r\n  LoadFromURL(aFileName,False,\r\n  Procedure (Sender : TObject)\r\n  begin\r\n    If Assigned(OnLoaded) then\r\n     OnLoaded\r\n  end,\r\n  Procedure (Sender : TObject; Const ErrorMsg : String)\r\n  begin\r\n    if Assigned(aError) then\r\n      aError(ErrorMsg)\r\n  end);\r\nend;\r\n\r\nfunction TStrings.ExtractName(const S: String): String;\r\nvar\r\n  L: Longint;\r\nbegin\r\n  CheckSpecialChars;\r\n  L:=Pos(FNameValueSeparator,S);\r\n  If L<>0 then\r\n    Result:=Copy(S,1,L-1)\r\n  else\r\n    Result:='';\r\nend;\r\n\r\nfunction TStrings.GetName(Index: Integer): string;\r\n\r\nVar\r\n  V : String;\r\n\r\nbegin\r\n  GetNameValue(Index,Result,V);\r\nend;\r\n\r\nfunction TStrings.GetValue(const Name: string): string;\r\n\r\nVar\r\n  L : longint;\r\n  N : String;\r\n\r\nbegin\r\n  Result:='';\r\n  L:=IndexOfName(Name);\r\n  If L<>-1 then\r\n    GetNameValue(L,N,Result);\r\nend;\r\n\r\nfunction TStrings.GetValueFromIndex(Index: Integer): string;\r\n\r\nVar\r\n  N : String;\r\n\r\nbegin\r\n  GetNameValue(Index,N,Result);\r\nend;\r\n\r\nprocedure TStrings.SetValueFromIndex(Index: Integer; const Value: string);\r\n\r\nbegin\r\n  If (Value='') then\r\n    Delete(Index)\r\n  else\r\n    begin\r\n    If (Index<0) then\r\n      Index:=Add('');\r\n    CheckSpecialChars;\r\n    Strings[Index]:=GetName(Index)+FNameValueSeparator+Value;\r\n    end;\r\nend;\r\n\r\nprocedure TStrings.SetDelimitedText(const AValue: string);\r\nvar i,j:integer;\r\n    aNotFirst:boolean;\r\nbegin\r\n CheckSpecialChars;\r\n BeginUpdate;\r\n\r\n i:=1;\r\n j:=1;\r\n aNotFirst:=false;\r\n\r\n { Paraphrased from Delphi XE2 help:\r\n Strings must be separated by Delimiter characters or spaces.\r\n They may be enclosed in QuoteChars.\r\n QuoteChars in the string must be repeated to distinguish them from the QuoteChars enclosing the string.\r\n }\r\n try\r\n  Clear;\r\n  If StrictDelimiter then\r\n    begin\r\n    while i<=length(AValue) do begin\r\n     // skip delimiter\r\n     if aNotFirst and (i<=length(AValue)) and (AValue[i]=FDelimiter) then inc(i);\r\n\r\n     // read next string\r\n     if i<=length(AValue) then begin\r\n      if AValue[i]=FQuoteChar then begin\r\n       // next string is quoted\r\n       j:=i+1;\r\n       while (j<=length(AValue)) and\r\n             ( (AValue[j]<>FQuoteChar) or\r\n               ( (j+1<=length(AValue)) and (AValue[j+1]=FQuoteChar) ) ) do begin\r\n        if (j<=length(AValue)) and (AValue[j]=FQuoteChar) then inc(j,2)\r\n                                                          else inc(j);\r\n       end;\r\n       // j is position of closing quote\r\n       Add( StringReplace (Copy(AValue,i+1,j-i-1),\r\n                           FQuoteChar+FQuoteChar,FQuoteChar, [rfReplaceAll]));\r\n       i:=j+1;\r\n      end else begin\r\n       // next string is not quoted; read until delimiter\r\n       j:=i;\r\n       while (j<=length(AValue)) and\r\n             (AValue[j]<>FDelimiter) do inc(j);\r\n       Add( Copy(AValue,i,j-i));\r\n       i:=j;\r\n      end;\r\n     end else begin\r\n      if aNotFirst then Add('');\r\n     end;\r\n\r\n     aNotFirst:=true;\r\n    end;\r\n    end\r\n  else\r\n    begin\r\n    while i<=length(AValue) do begin\r\n     // skip delimiter\r\n     if aNotFirst and (i<=length(AValue)) and (AValue[i]=FDelimiter) then inc(i);\r\n\r\n     // skip spaces\r\n     while (i<=length(AValue)) and (Ord(AValue[i])<=Ord(' ')) do inc(i);\r\n\r\n     // read next string\r\n     if i<=length(AValue) then begin\r\n      if AValue[i]=FQuoteChar then begin\r\n       // next string is quoted\r\n       j:=i+1;\r\n       while (j<=length(AValue)) and\r\n             ( (AValue[j]<>FQuoteChar) or\r\n               ( (j+1<=length(AValue)) and (AValue[j+1]=FQuoteChar) ) ) do begin\r\n        if (j<=length(AValue)) and (AValue[j]=FQuoteChar) then inc(j,2)\r\n                                                          else inc(j);\r\n       end;\r\n       // j is position of closing quote\r\n       Add( StringReplace (Copy(AValue,i+1,j-i-1),\r\n                           FQuoteChar+FQuoteChar,FQuoteChar, [rfReplaceAll]));\r\n       i:=j+1;\r\n      end else begin\r\n       // next string is not quoted; read until control character/space/delimiter\r\n       j:=i;\r\n       while (j<=length(AValue)) and\r\n             (Ord(AValue[j])>Ord(' ')) and\r\n             (AValue[j]<>FDelimiter) do inc(j);\r\n       Add( Copy(AValue,i,j-i));\r\n       i:=j;\r\n      end;\r\n     end else begin\r\n      if aNotFirst then Add('');\r\n     end;\r\n\r\n     // skip spaces\r\n     while (i<=length(AValue)) and (Ord(AValue[i])<=Ord(' ')) do inc(i);\r\n\r\n     aNotFirst:=true;\r\n    end;\r\n    end;\r\n finally\r\n   EndUpdate;\r\n end;\r\nend;\r\n\r\nprocedure TStrings.SetCommaText(const Value: string);\r\n\r\nVar\r\n  C1,C2 : Char;\r\n\r\nbegin\r\n  CheckSpecialChars;\r\n  C1:=Delimiter;\r\n  C2:=QuoteChar;\r\n  Delimiter:=',';\r\n  QuoteChar:='\"';\r\n  Try\r\n    SetDelimitedText(Value);\r\n  Finally\r\n    Delimiter:=C1;\r\n    QuoteChar:=C2;\r\n  end;\r\nend;\r\n\r\nprocedure TStrings.SetValue(const Name: String; const Value: string);\r\n\r\nVar L : longint;\r\n\r\nbegin\r\n  CheckSpecialChars;\r\n  L:=IndexOfName(Name);\r\n  if L=-1 then\r\n   Add (Name+FNameValueSeparator+Value)\r\n  else\r\n   Strings[L]:=Name+FNameValueSeparator+value;\r\nend;\r\n\r\n\r\nprocedure TStrings.Error(const Msg: string; Data: Integer);\r\nbegin\r\n  Raise EStringListError.CreateFmt(Msg,[IntToStr(Data)]);\r\nend;\r\n\r\nfunction TStrings.GetCapacity: Integer;\r\n\r\nbegin\r\n  Result:=Count;\r\nend;\r\n\r\n\r\n\r\nfunction TStrings.GetObject(Index: Integer): TObject;\r\n\r\nbegin\r\n  if Index=0 then ;\r\n  Result:=Nil;\r\nend;\r\n\r\nfunction TStrings.GetTextStr: string;\r\n\r\nVar\r\n  I : Longint;\r\n  S,NL : String;\r\n\r\nbegin\r\n  CheckSpecialChars;\r\n  // Determine needed place\r\n  if FLineBreak<>sLineBreak then\r\n    NL:=FLineBreak\r\n  else\r\n    Case FLBS of\r\n      tlbsLF   : NL:=#10;\r\n      tlbsCRLF : NL:=#13#10;\r\n      tlbsCR   : NL:=#13;\r\n    end;\r\n  Result:='';\r\n  For i:=0 To count-1 do\r\n    begin\r\n    S:=Strings[I];\r\n    Result:=Result+S;\r\n    if (I<Count-1) or Not SkipLastLineBreak then\r\n      Result:=Result+NL;\r\n    end;\r\nend;\r\n\r\n\r\n\r\nprocedure TStrings.Put(Index: Integer; const S: string);\r\n\r\nVar Obj : TObject;\r\n\r\nbegin\r\n  Obj:=Objects[Index];\r\n  Delete(Index);\r\n  InsertObject(Index,S,Obj);\r\nend;\r\n\r\n\r\n\r\nprocedure TStrings.PutObject(Index: Integer; AObject: TObject);\r\n\r\nbegin\r\n  // Empty.\r\n  if Index=0 then exit;\r\n  if AObject=nil then exit;\r\nend;\r\n\r\n\r\n\r\nprocedure TStrings.SetCapacity(NewCapacity: Integer);\r\n\r\nbegin\r\n  // Empty.\r\n  if NewCapacity=0 then ;\r\nend;\r\n\r\nfunction TStrings.GetNextLinebreak(const Value: String; out S: String; var P: Integer): Boolean;\r\n\r\nvar\r\n  PPLF,PPCR,PP,PL: Integer;\r\n\r\nbegin\r\n  S:='';\r\n  Result:=False;\r\n  If ((Length(Value)-P)<0) then\r\n    Exit;\r\n  PPLF:=TJSString(Value).IndexOf(#10,P-1)+1;\r\n  PPCR:=TJSString(Value).IndexOf(#13,P-1)+1;\r\n  PL:=1;\r\n  if (PPLF>0) and (PPCR>0) then\r\n    begin\r\n    if (PPLF-PPCR)=1 then \r\n      PL:=2;\r\n    if PPLF<PPCR then\r\n      PP:=PPLF\r\n    else\r\n      PP:=PPCR;\r\n    end\r\n  else if (PPLF>0) and (PPCR<1) then\r\n    PP:=PPLF\r\n  else if (PPCR > 0) and (PPLF<1) then\r\n    PP:=PPCR\r\n  else \r\n    PP:=Length(Value)+1;\r\n  S:=Copy(Value,P,PP-P);\r\n  P:=PP+PL;\r\n  Result:=True;\r\nend;\r\n\r\nprocedure TStrings.DoSetTextStr(const Value: string; DoClear: Boolean);\r\n\r\nVar\r\n  S : String;\r\n  P : Integer;\r\n\r\nbegin\r\n  Try\r\n    BeginUpdate;\r\n    if DoClear then\r\n      Clear;\r\n    P:=1;\r\n    While GetNextLineBreak (Value,S,P) do\r\n      Add(S);\r\n  finally\r\n    EndUpdate;\r\n  end;\r\nend;\r\n\r\nprocedure TStrings.SetTextStr(const Value: string);\r\n\r\nbegin\r\n  CheckSpecialChars;\r\n  DoSetTextStr(Value,True);\r\nend;\r\n\r\nprocedure TStrings.AddText(const S: String);\r\n\r\nbegin\r\n  CheckSpecialChars;\r\n  DoSetTextStr(S,False);\r\nend;\r\n\r\nprocedure TStrings.SetUpdateState(Updating: Boolean);\r\n\r\nbegin\r\n  // FPONotifyObservers(Self,ooChange,Nil);\r\n  if Updating then ;\r\nend;\r\n\r\ndestructor TStrings.Destroy;\r\n\r\nbegin\r\n  inherited destroy;\r\nend;\r\n\r\nconstructor TStrings.Create;\r\nbegin\r\n  inherited Create;\r\n  FAlwaysQuote:=False;\r\nend;\r\n\r\nfunction TStrings.ToObjectArray: TObjectDynArray;\r\n\r\nbegin\r\n  Result:=ToObjectArray(0,Count-1);\r\nend;\r\n\r\nfunction TStrings.ToObjectArray(aStart,aEnd : Integer): TObjectDynArray;\r\nVar\r\n  I : Integer;\r\n\r\nbegin\r\n  Result:=Nil;\r\n  if aStart>aEnd then exit;\r\n  SetLength(Result,aEnd-aStart+1);\r\n  For I:=aStart to aEnd do\r\n    Result[i-aStart]:=Objects[i];\r\nend;\r\n\r\nfunction TStrings.ToStringArray: TStringDynArray;\r\n\r\nbegin\r\n  Result:=ToStringArray(0,Count-1);\r\nend;\r\n\r\nfunction TStrings.ToStringArray(aStart,aEnd : Integer): TStringDynArray;\r\n\r\nVar\r\n  I : Integer;\r\n\r\nbegin\r\n  Result:=Nil;\r\n  if aStart>aEnd then exit;\r\n  SetLength(Result,aEnd-aStart+1);\r\n  For I:=aStart to aEnd do\r\n    Result[i-aStart]:=Strings[i];\r\nend;\r\n\r\nfunction TStrings.Add(const S: string): Integer;\r\n\r\nbegin\r\n  Result:=Count;\r\n  Insert (Count,S);\r\nend;\r\n\r\n\r\nfunction TStrings.Add(const Fmt: string; const Args: array of const): Integer;\r\n\r\nbegin\r\n  Result:=Add(Format(Fmt,Args));\r\nend;\r\n\r\nfunction TStrings.AddFmt(const Fmt: string; const Args: array of const): Integer;\r\n\r\nbegin\r\n  Result:=Add(Format(Fmt,Args));\r\nend;\r\n\r\n\r\nfunction TStrings.AddObject(const S: string; AObject: TObject): Integer;\r\n\r\nbegin\r\n  Result:=Add(S);\r\n  Objects[result]:=AObject;\r\nend;\r\n\r\nfunction TStrings.AddObject(const Fmt: string; Args: array of const; AObject: TObject): Integer;\r\n\r\nbegin\r\n  Result:=AddObject(Format(Fmt,Args),AObject);\r\nend;\r\n\r\nprocedure TStrings.Append(const S: string);\r\n\r\nbegin\r\n  Add (S);\r\nend;\r\n\r\n\r\n\r\nprocedure TStrings.AddStrings(TheStrings: TStrings; ClearFirst: Boolean);\r\n\r\n\r\nbegin\r\n  beginupdate;\r\n  try\r\n    if ClearFirst then\r\n      Clear;\r\n    AddStrings(TheStrings);\r\n  finally\r\n    EndUpdate;\r\n  end;\r\nend;\r\n\r\nprocedure TStrings.AddStrings(TheStrings: TStrings);\r\n\r\nVar Runner : longint;\r\nbegin\r\n  For Runner:=0 to TheStrings.Count-1 do\r\n    self.AddObject (Thestrings[Runner],TheStrings.Objects[Runner]);\r\nend;\r\n\r\nprocedure TStrings.AddStrings(const TheStrings: array of string);\r\n\r\nVar Runner : longint;\r\nbegin\r\n  if Count + High(TheStrings)+1 > Capacity then\r\n    Capacity := Count + High(TheStrings)+1;\r\n  For Runner:=Low(TheStrings) to High(TheStrings) do\r\n    self.Add(Thestrings[Runner]);\r\nend;\r\n\r\n\r\nprocedure TStrings.AddStrings(const TheStrings: array of string; ClearFirst: Boolean);\r\n\r\nbegin\r\n  beginupdate;\r\n  try\r\n    if ClearFirst then\r\n      Clear;\r\n    AddStrings(TheStrings);\r\n  finally\r\n    EndUpdate;\r\n  end;\r\nend;\r\n\r\n\r\nfunction TStrings.AddPair(const AName, AValue: string): TStrings;\r\n\r\nbegin\r\n  Result:=AddPair(AName,AValue,Nil);\r\nend;\r\n\r\nfunction TStrings.AddPair(const AName, AValue: string; AObject: TObject): TStrings;\r\n\r\nbegin\r\n  Result := Self;\r\n  AddObject(AName+NameValueSeparator+AValue, AObject);\r\nend;\r\n\r\n\r\nprocedure TStrings.Assign(Source: TPersistent);\r\n\r\nVar\r\n  S : TStrings;\r\n\r\nbegin\r\n  If Source is TStrings then\r\n    begin\r\n    S:=TStrings(Source);\r\n    BeginUpdate;\r\n    Try\r\n      clear;\r\n      FSpecialCharsInited:=S.FSpecialCharsInited;\r\n      FQuoteChar:=S.FQuoteChar;\r\n      FDelimiter:=S.FDelimiter;\r\n      FNameValueSeparator:=S.FNameValueSeparator;\r\n      FLBS:=S.FLBS;\r\n      FLineBreak:=S.FLineBreak;\r\n      AddStrings(S);\r\n    finally\r\n      EndUpdate;\r\n    end;\r\n    end\r\n  else\r\n    Inherited Assign(Source);\r\nend;\r\n\r\n\r\n\r\nprocedure TStrings.BeginUpdate;\r\n\r\nbegin\r\n   if FUpdateCount = 0 then SetUpdateState(true);\r\n   inc(FUpdateCount);\r\nend;\r\n\r\n\r\n\r\nprocedure TStrings.EndUpdate;\r\n\r\nbegin\r\n  If FUpdateCount>0 then\r\n     Dec(FUpdateCount);\r\n  if FUpdateCount=0 then\r\n    SetUpdateState(False);\r\nend;\r\n\r\n\r\n\r\nfunction TStrings.Equals(Obj: TObject): Boolean;\r\n\r\nbegin\r\n  if Obj is TStrings then\r\n    Result := Equals(TStrings(Obj))\r\n  else\r\n    Result := inherited Equals(Obj);\r\nend;\r\n\r\n\r\n\r\nfunction TStrings.Equals(TheStrings: TStrings): Boolean;\r\n\r\nVar Runner,Nr : Longint;\r\n\r\nbegin\r\n  Result:=False;\r\n  Nr:=Self.Count;\r\n  if Nr<>TheStrings.Count then exit;\r\n  For Runner:=0 to Nr-1 do\r\n    If Strings[Runner]<>TheStrings[Runner] then exit;\r\n  Result:=True;\r\nend;\r\n\r\n\r\n\r\nprocedure TStrings.Exchange(Index1, Index2: Integer);\r\n\r\nVar\r\n  Obj : TObject;\r\n  Str : String;\r\n\r\nbegin\r\n  beginUpdate;\r\n  Try\r\n    Obj:=Objects[Index1];\r\n    Str:=Strings[Index1];\r\n    Objects[Index1]:=Objects[Index2];\r\n    Strings[Index1]:=Strings[Index2];\r\n    Objects[Index2]:=Obj;\r\n    Strings[Index2]:=Str;\r\n  finally\r\n    EndUpdate;\r\n  end;\r\nend;\r\n\r\n\r\nfunction TStrings.GetEnumerator: TStringsEnumerator;\r\nbegin\r\n  Result:=TStringsEnumerator.Create(Self);\r\nend;\r\n\r\n\r\nfunction TStrings.DoCompareText(const s1, s2: string): PtrInt;\r\nbegin\r\n  result:=CompareText(s1,s2);\r\nend;\r\n\r\n\r\nfunction TStrings.IndexOf(const S: string): Integer;\r\nbegin\r\n  Result:=0;\r\n  While (Result<Count) and (DoCompareText(Strings[Result],S)<>0) do Result:=Result+1;\r\n  if Result=Count then Result:=-1;\r\nend;\r\n\r\n\r\nfunction TStrings.IndexOfName(const Name: string): Integer;\r\nVar\r\n  len : longint;\r\n  S : String;\r\nbegin\r\n  CheckSpecialChars;\r\n  Result:=0;\r\n  while (Result<Count) do\r\n    begin\r\n    S:=Strings[Result];\r\n    len:=pos(FNameValueSeparator,S)-1;\r\n    if (len>=0) and (DoCompareText(Name,Copy(S,1,Len))=0) then\r\n      exit;\r\n    inc(result);\r\n    end;\r\n  result:=-1;\r\nend;\r\n\r\n\r\nfunction TStrings.IndexOfObject(AObject: TObject): Integer;\r\nbegin\r\n  Result:=0;\r\n  While (Result<count) and (Objects[Result]<>AObject) do Result:=Result+1;\r\n  If Result=Count then Result:=-1;\r\nend;\r\n\r\n\r\nprocedure TStrings.InsertObject(Index: Integer; const S: string; AObject: TObject);\r\n\r\nbegin\r\n  Insert (Index,S);\r\n  Objects[Index]:=AObject;\r\nend;\r\n\r\nprocedure TStrings.Move(CurIndex, NewIndex: Integer);\r\nVar\r\n  Obj : TObject;\r\n  Str : String;\r\nbegin\r\n  BeginUpdate;\r\n  Try\r\n    Obj:=Objects[CurIndex];\r\n    Str:=Strings[CurIndex];\r\n    Objects[CurIndex]:=Nil; // Prevent Delete from freeing.\r\n    Delete(Curindex);\r\n    InsertObject(NewIndex,Str,Obj);\r\n  finally\r\n    EndUpdate;\r\n    end;\r\nend;\r\n\r\n\r\n{****************************************************************************}\r\n{*                             TStringList                                  *}\r\n{****************************************************************************}\r\n\r\n\r\nprocedure TStringList.ExchangeItemsInt(Index1, Index2: Integer);\r\n\r\nVar\r\n  S : String;\r\n  O : TObject;\r\n\r\nbegin\r\n  S:=Flist[Index1].FString;\r\n  O:=Flist[Index1].FObject;\r\n  Flist[Index1].Fstring:=Flist[Index2].Fstring;\r\n  Flist[Index1].FObject:=Flist[Index2].FObject;\r\n  Flist[Index2].Fstring:=S;\r\n  Flist[Index2].FObject:=O;\r\nend;\r\n\r\nfunction TStringList.GetSorted: Boolean;\r\nbegin\r\n  Result:=FSortStyle in [sslUser,sslAuto];\r\nend;\r\n\r\n\r\nprocedure TStringList.ExchangeItems(Index1, Index2: Integer);\r\nbegin\r\n  ExchangeItemsInt(Index1, Index2);\r\nend;\r\n\r\n\r\nprocedure TStringList.Grow;\r\n\r\nVar\r\n  NC : Integer;\r\n\r\nbegin\r\n  NC:=Capacity;\r\n  If NC>=256 then\r\n    NC:=NC+(NC Div 4)\r\n  else if NC=0 then\r\n    NC:=4\r\n  else\r\n    NC:=NC*4;\r\n  SetCapacity(NC);\r\nend;\r\n\r\nprocedure TStringList.InternalClear(FromIndex: Integer; ClearOnly: Boolean);\r\n\r\nVar\r\n  I: Integer;\r\n\r\nbegin\r\n  if FromIndex < FCount then\r\n    begin\r\n      if FOwnsObjects then\r\n        begin\r\n          For I:=FromIndex to FCount-1 do\r\n            begin\r\n              Flist[I].FString:='';\r\n              freeandnil(Flist[i].FObject);\r\n            end;\r\n        end\r\n      else\r\n        begin\r\n          For I:=FromIndex to FCount-1 do\r\n            Flist[I].FString:='';\r\n        end;\r\n      FCount:=FromIndex;\r\n    end;\r\n  if Not ClearOnly then\r\n    SetCapacity(0);\r\nend;\r\n\r\n\r\nprocedure TStringList.QuickSort(L, R: Integer; CompareFn: TStringListSortCompare\r\n  );\r\n\r\n\r\nvar\r\n  Pivot, vL, vR: Integer;\r\n\r\nbegin\r\n  //if ExchangeItems is override call that, else call (faster) ExchangeItemsInt\r\n\r\n  if R - L <= 1 then begin // a little bit of time saver\r\n    if L < R then\r\n      if CompareFn(Self, L, R) > 0 then\r\n        ExchangeItems(L, R);\r\n\r\n    Exit;\r\n  end;\r\n\r\n  vL := L;\r\n  vR := R;\r\n\r\n  Pivot := L + Random(R - L); // they say random is best\r\n\r\n  while vL < vR do begin\r\n    while (vL < Pivot) and (CompareFn(Self, vL, Pivot) <= 0) do\r\n      Inc(vL);\r\n\r\n    while (vR > Pivot) and (CompareFn(Self, vR, Pivot) > 0) do\r\n      Dec(vR);\r\n\r\n    ExchangeItems(vL, vR);\r\n\r\n    if Pivot = vL then // swap pivot if we just hit it from one side\r\n      Pivot := vR\r\n    else if Pivot = vR then\r\n      Pivot := vL;\r\n  end;\r\n\r\n  if Pivot - 1 >= L then\r\n    QuickSort(L, Pivot - 1, CompareFn);\r\n  if Pivot + 1 <= R then\r\n    QuickSort(Pivot + 1, R, CompareFn);\r\nend;\r\n\r\n\r\nprocedure TStringList.InsertItem(Index: Integer; const S: string);\r\nbegin\r\n  InsertItem(Index, S, nil);\r\nend;\r\n\r\n\r\nprocedure TStringList.InsertItem(Index: Integer; const S: string; O: TObject);\r\n\r\nVar\r\n  It : TStringItem;\r\n  \r\nbegin\r\n  Changing;\r\n  If FCount=Capacity then Grow;\r\n  it.FString:=S;\r\n  it.FObject:=O;\r\n  TJSArray(FList).Splice(Index,0,It);\r\n  Inc(FCount);\r\n  Changed;\r\nend;\r\n\r\n\r\nprocedure TStringList.SetSorted(Value: Boolean);\r\n\r\nbegin\r\n  If Value then\r\n    SortStyle:=sslAuto\r\n  else\r\n    SortStyle:=sslNone\r\nend;\r\n\r\n\r\n\r\nprocedure TStringList.Changed;\r\n\r\nbegin\r\n  If (FUpdateCount=0) Then\r\n   begin\r\n   If Assigned(FOnChange) then\r\n     FOnchange(Self);\r\n   end;\r\nend;\r\n\r\n\r\n\r\nprocedure TStringList.Changing;\r\n\r\nbegin\r\n  If FUpdateCount=0 then\r\n    if Assigned(FOnChanging) then\r\n      FOnchanging(Self);\r\nend;\r\n\r\n\r\n\r\nfunction TStringList.Get(Index: Integer): string;\r\n\r\nbegin\r\n  CheckIndex(Index);\r\n  Result:=Flist[Index].FString;\r\nend;\r\n\r\n\r\n\r\nfunction TStringList.GetCapacity: Integer;\r\n\r\nbegin\r\n  Result:=Length(FList);\r\nend;\r\n\r\n\r\n\r\nfunction TStringList.GetCount: Integer;\r\n\r\nbegin\r\n  Result:=FCount;\r\nend;\r\n\r\n\r\n\r\nfunction TStringList.GetObject(Index: Integer): TObject;\r\n\r\nbegin\r\n  CheckIndex(Index);\r\n  Result:=Flist[Index].FObject;\r\nend;\r\n\r\n\r\n\r\nprocedure TStringList.Put(Index: Integer; const S: string);\r\n\r\nbegin\r\n  If Sorted then\r\n    Error(SSortedListError,0);\r\n  CheckIndex(Index);\r\n  Changing;\r\n  Flist[Index].FString:=S;\r\n  Changed;\r\nend;\r\n\r\n\r\n\r\nprocedure TStringList.PutObject(Index: Integer; AObject: TObject);\r\n\r\nbegin\r\n  CheckIndex(Index);\r\n  Changing;\r\n  Flist[Index].FObject:=AObject;\r\n  Changed;\r\nend;\r\n\r\n\r\n\r\nprocedure TStringList.SetCapacity(NewCapacity: Integer);\r\n\r\nbegin\r\n  If (NewCapacity<0) then\r\n     Error (SListCapacityError,NewCapacity);\r\n  If NewCapacity<>Capacity then\r\n    SetLength(FList,NewCapacity)\r\nend;\r\n\r\n\r\n\r\nprocedure TStringList.SetUpdateState(Updating: Boolean);\r\n\r\nbegin\r\n  If Updating then\r\n    Changing\r\n  else\r\n    Changed\r\nend;\r\n\r\n\r\n\r\ndestructor TStringList.Destroy;\r\n\r\nbegin\r\n  InternalClear;\r\n  Inherited destroy;\r\nend;\r\n\r\n\r\n\r\nfunction TStringList.Add(const S: string): Integer;\r\n\r\nbegin\r\n  If Not (SortStyle=sslAuto) then\r\n    Result:=FCount\r\n  else\r\n    If Find (S,Result) then\r\n      Case DUplicates of\r\n        DupIgnore : Exit;\r\n        DupError : Error(SDuplicateString,0)\r\n      end;\r\n   InsertItem (Result,S);\r\nend;\r\n\r\nprocedure TStringList.Clear;\r\n\r\nbegin\r\n  if FCount = 0 then Exit;\r\n  Changing;\r\n  InternalClear;\r\n  Changed;\r\nend;\r\n\r\nprocedure TStringList.Delete(Index: Integer);\r\n\r\nbegin\r\n  CheckIndex(Index);\r\n  Changing;\r\n  if FOwnsObjects then\r\n    FreeAndNil(Flist[Index].FObject);\r\n  TJSArray(FList).splice(Index,1);  \r\n  FList[Count-1].FString:='';\r\n  Flist[Count-1].FObject:=Nil;\r\n  Dec(FCount);\r\n  Changed;\r\nend;\r\n\r\nprocedure TStringList.Exchange(Index1, Index2: Integer);\r\n\r\nbegin\r\n  CheckIndex(Index1);\r\n  CheckIndex(Index2);\r\n  Changing;\r\n  ExchangeItemsInt(Index1,Index2);\r\n  changed;\r\nend;\r\n\r\nprocedure TStringList.SetCaseSensitive(b : boolean);\r\nbegin\r\n  if b=FCaseSensitive then\r\n    Exit;\r\n  FCaseSensitive:=b;\r\n  if FSortStyle=sslAuto then\r\n    begin\r\n    FForceSort:=True;\r\n    try\r\n      Sort;\r\n    finally\r\n      FForceSort:=False;\r\n    end;\r\n    end;\r\nend;\r\n\r\nprocedure TStringList.SetSortStyle(AValue: TStringsSortStyle);\r\nbegin\r\n  if FSortStyle=AValue then Exit;\r\n  if (AValue=sslAuto) then\r\n    Sort;\r\n  FSortStyle:=AValue;\r\nend;\r\n\r\nprocedure TStringList.CheckIndex(AIndex: Integer);\r\nbegin\r\n  If (AIndex<0) or (AIndex>=FCount) then\r\n    Error(SListIndexError,AIndex);\r\nend;\r\n\r\n\r\nfunction TStringList.DoCompareText(const s1, s2: string): PtrInt;\r\nbegin\r\n  if FCaseSensitive then\r\n    result:=CompareStr(s1,s2)\r\n  else\r\n    result:=CompareText(s1,s2);\r\nend;\r\n\r\n\r\nfunction TStringList.CompareStrings(const s1,s2 : string) : Integer;\r\nbegin\r\n  Result := DoCompareText(s1, s2);\r\nend;\r\n\r\n\r\nfunction TStringList.Find(const S: string; out Index: Integer): Boolean;\r\n\r\nvar\r\n  L, R, I: Integer;\r\n  CompareRes: PtrInt;\r\nbegin\r\n  Result := false;\r\n  Index:=-1;\r\n  if Not Sorted then\r\n    Raise EListError.Create(SErrFindNeedsSortedList);\r\n  // Use binary search.\r\n  L := 0;\r\n  R := Count - 1;\r\n  while (L<=R) do\r\n  begin\r\n    I := L + (R - L) div 2;\r\n    CompareRes := DoCompareText(S, Flist[I].FString);\r\n    if (CompareRes>0) then\r\n      L := I+1\r\n    else begin\r\n      R := I-1;\r\n      if (CompareRes=0) then begin\r\n         Result := true;\r\n         if (Duplicates<>dupAccept) then\r\n            L := I; // forces end of while loop\r\n      end;\r\n    end;\r\n  end;\r\n  Index := L;\r\nend;\r\n\r\n\r\n\r\nfunction TStringList.IndexOf(const S: string): Integer;\r\n\r\nbegin\r\n  If Not Sorted then\r\n    Result:=Inherited indexOf(S)\r\n  else\r\n    // faster using binary search...\r\n    If Not Find (S,Result) then\r\n      Result:=-1;\r\nend;\r\n\r\n\r\n\r\nprocedure TStringList.Insert(Index: Integer; const S: string);\r\n\r\nbegin\r\n  If SortStyle=sslAuto then\r\n    Error (SSortedListError,0)\r\n  else\r\n    begin\r\n    If (Index<0) or (Index>FCount) then\r\n      Error(SListIndexError,Index); // Cannot use CheckIndex, because there >= FCount...\r\n    InsertItem (Index,S);\r\n    end;\r\nend;\r\n\r\n\r\nprocedure TStringList.CustomSort(CompareFn: TStringListSortCompare);\r\n\r\nbegin\r\n  If (FForceSort or (Not (FSortStyle=sslAuto))) and (FCount>1) then\r\n    begin\r\n    Changing;\r\n    QuickSort(0,FCount-1, CompareFn);\r\n    Changed;\r\n    end;\r\nend;\r\n\r\nfunction StringListAnsiCompare(List: TStringList; Index1, Index: Integer): Integer;\r\n\r\nbegin\r\n  Result := List.DoCompareText(List.FList[Index1].FString,\r\n                               List.FList[Index].FString);\r\nend;\r\n\r\nprocedure TStringList.Sort;\r\n\r\nbegin\r\n  CustomSort(@StringListAnsiCompare);\r\nend;\r\n\r\n{****************************************************************************}\r\n{*                             TCollectionItem                              *}\r\n{****************************************************************************}\r\n\r\n\r\nfunction TCollectionItem.GetIndex: Integer;\r\n\r\nbegin\r\n  if Assigned(FCollection) then\r\n    Result:=FCollection.FItems.IndexOf(Self)\r\n  else\r\n    Result:=-1;\r\nend;\r\n\r\n\r\n\r\nprocedure TCollectionItem.SetCollection(Value: TCollection);\r\n\r\nbegin\r\n  IF Value<>FCollection then\r\n    begin\r\n    if Assigned(FCollection) then FCollection.RemoveItem(Self);\r\n    if Assigned(Value) then Value.InsertItem(Self);\r\n    end;\r\nend;\r\n\r\n\r\n\r\nprocedure TCollectionItem.Changed(AllItems: Boolean);\r\n\r\nbegin\r\n If (FCollection<>Nil) and (FCollection.UpdateCount=0) then\r\n  begin\r\n  If AllItems then\r\n    FCollection.Update(Nil)\r\n  else\r\n    FCollection.Update(Self);\r\n  end;\r\nend;\r\n\r\n\r\n\r\nfunction TCollectionItem.GetNamePath: string;\r\n\r\nbegin\r\n  If FCollection<>Nil then\r\n    Result:=FCollection.GetNamePath+'['+IntToStr(Index)+']'\r\n  else\r\n    Result:=ClassName;\r\nend;\r\n\r\n\r\nfunction TCollectionItem.GetOwner: TPersistent;\r\n\r\nbegin\r\n  Result:=FCollection;\r\nend;\r\n\r\n\r\n\r\nfunction TCollectionItem.GetDisplayName: string;\r\n\r\nbegin\r\n  Result:=ClassName;\r\nend;\r\n\r\n\r\n\r\nprocedure TCollectionItem.SetIndex(Value: Integer);\r\n\r\nVar Temp : Longint;\r\n\r\nbegin\r\n  Temp:=GetIndex;\r\n  If (Temp>-1) and (Temp<>Value) then\r\n    begin\r\n    FCollection.FItems.Move(Temp,Value);\r\n    Changed(True);\r\n    end;\r\nend;\r\n\r\n\r\nprocedure TCollectionItem.SetDisplayName(const Value: string);\r\n\r\nbegin\r\n  Changed(False);\r\n  if Value='' then ;\r\nend;\r\n\r\n\r\n\r\nconstructor TCollectionItem.Create(ACollection: TCollection);\r\n\r\nbegin\r\n  Inherited Create;\r\n  SetCollection(ACollection);\r\nend;\r\n\r\n\r\n\r\ndestructor TCollectionItem.Destroy;\r\n\r\nbegin\r\n  SetCollection(Nil);\r\n  Inherited Destroy;\r\nend;\r\n\r\n{****************************************************************************}\r\n{*                          TCollectionEnumerator                           *}\r\n{****************************************************************************}\r\n\r\nconstructor TCollectionEnumerator.Create(ACollection: TCollection);\r\nbegin\r\n  inherited Create;\r\n  FCollection := ACollection;\r\n  FPosition := -1;\r\nend;\r\n\r\nfunction TCollectionEnumerator.GetCurrent: TCollectionItem;\r\nbegin\r\n  Result := FCollection.Items[FPosition];\r\nend;\r\n\r\nfunction TCollectionEnumerator.MoveNext: Boolean;\r\nbegin\r\n  Inc(FPosition);\r\n  Result := FPosition < FCollection.Count;\r\nend;\r\n\r\n\r\n{****************************************************************************}\r\n{*                             TCollection                                  *}\r\n{****************************************************************************}\r\n\r\nfunction TCollection.Owner: TPersistent;\r\nbegin\r\n  result:=getowner;\r\nend;\r\n\r\n\r\nfunction TCollection.GetCount: Integer;\r\n\r\nbegin\r\n  Result:=FItems.Count;\r\nend;\r\n\r\n\r\nProcedure TCollection.SetPropName;\r\n\r\n{\r\nVar\r\n  TheOwner : TPersistent;\r\n  PropList : PPropList;\r\n  I, PropCount : Integer;\r\n}\r\nbegin\r\n  FPropName:='';\r\n{\r\n  TheOwner:=GetOwner;\r\n  // TODO: This needs to wait till Mattias finishes typeinfo.\r\n  // It's normally only used in the designer so should not be a problem currently.\r\n  if (TheOwner=Nil) Or (TheOwner.Classinfo=Nil) Then Exit;\r\n  // get information from the owner RTTI\r\n  PropCount:=GetPropList(TheOwner, PropList);\r\n  Try\r\n    For I:=0 To PropCount-1 Do\r\n      If (PropList^[i]^.PropType^.Kind=tkClass) And\r\n         (GetObjectProp(TheOwner, PropList^[i], ClassType)=Self) Then\r\n        Begin\r\n          FPropName:=PropList^[i]^.Name;\r\n          Exit;\r\n        End;\r\n  Finally\r\n    FreeMem(PropList);\r\n  End;\r\n}\r\nend;\r\n\r\n\r\nfunction TCollection.GetPropName: string;\r\n\r\n{Var\r\n  TheOwner : TPersistent;}\r\n\r\nbegin\r\n  Result:=FPropNAme;\r\n//  TheOwner:=GetOwner;\r\n//  If (Result<>'') or (TheOwner=Nil) Or (TheOwner.Classinfo=Nil) then exit;\r\n  SetPropName;\r\n  Result:=FPropName;\r\nend;\r\n\r\n\r\nprocedure TCollection.InsertItem(Item: TCollectionItem);\r\nbegin\r\n  If Not(Item Is FitemClass) then\r\n    exit;\r\n  FItems.add(Item);\r\n  Item.FCollection:=Self;\r\n  Item.FID:=FNextID;\r\n  inc(FNextID);\r\n  SetItemName(Item);\r\n  Notify(Item,cnAdded);\r\n  Changed;\r\nend;\r\n\r\n\r\nprocedure TCollection.RemoveItem(Item: TCollectionItem);\r\n\r\nVar\r\n  I : Integer;\r\n\r\nbegin\r\n  Notify(Item,cnExtracting);\r\n  I:=FItems.IndexOfItem(Item,fromEnd);\r\n  If (I<>-1) then\r\n    FItems.Delete(I);\r\n  Item.FCollection:=Nil;\r\n  Changed;\r\nend;\r\n\r\n\r\nfunction TCollection.GetAttrCount: Integer;\r\nbegin\r\n  Result:=0;\r\nend;\r\n\r\n\r\nfunction TCollection.GetAttr(Index: Integer): string;\r\nbegin\r\n  Result:='';\r\n  if Index=0 then ;\r\nend;\r\n\r\n\r\nfunction TCollection.GetItemAttr(Index, ItemIndex: Integer): string;\r\nbegin\r\n  Result:=TCollectionItem(FItems.Items[ItemIndex]).DisplayName;\r\n  if Index=0 then ;\r\nend;\r\n\r\n\r\nfunction TCollection.GetEnumerator: TCollectionEnumerator;\r\nbegin\r\n  Result := TCollectionEnumerator.Create(Self);\r\nend;\r\n\r\n\r\nfunction TCollection.GetNamePath: string;\r\nvar o : TPersistent;\r\nbegin\r\n  o:=getowner;\r\n  if assigned(o) and (propname<>'') then\r\n     result:=o.getnamepath+'.'+propname\r\n   else\r\n     result:=classname;\r\nend;\r\n\r\n\r\nprocedure TCollection.Changed;\r\nbegin\r\n  if FUpdateCount=0 then\r\n    Update(Nil);\r\nend;\r\n\r\n\r\nfunction TCollection.GetItem(Index: Integer): TCollectionItem;\r\nbegin\r\n  Result:=TCollectionItem(FItems.Items[Index]);\r\nend;\r\n\r\n\r\nprocedure TCollection.SetItem(Index: Integer; Value: TCollectionItem);\r\nbegin\r\n  TCollectionItem(FItems.items[Index]).Assign(Value);\r\nend;\r\n\r\n\r\nprocedure TCollection.SetItemName(Item: TCollectionItem);\r\nbegin\r\n  if Item=nil then ;\r\nend;\r\n\r\nprocedure TCollection.Update(Item: TCollectionItem);\r\nbegin\r\n  if Item=nil then ;\r\nend;\r\n\r\n\r\nconstructor TCollection.Create(AItemClass: TCollectionItemClass);\r\nbegin\r\n  inherited create;\r\n  FItemClass:=AItemClass;\r\n  FItems:=TFpList.Create;\r\nend;\r\n\r\n\r\ndestructor TCollection.Destroy;\r\nbegin\r\n  FUpdateCount:=1; // Prevent OnChange\r\n  try\r\n    DoClear;\r\n  Finally\r\n    FUpdateCount:=0;\r\n  end;\r\n  if assigned(FItems) then\r\n    FItems.Destroy;\r\n  Inherited Destroy;\r\nend;\r\n\r\n\r\nfunction TCollection.Add: TCollectionItem;\r\nbegin\r\n  Result:=FItemClass.Create(Self);\r\nend;\r\n\r\n\r\nprocedure TCollection.Assign(Source: TPersistent);\r\nVar I : Longint;\r\nbegin\r\n  If Source is TCollection then\r\n    begin\r\n    Clear;\r\n    For I:=0 To TCollection(Source).Count-1 do\r\n     Add.Assign(TCollection(Source).Items[I]);\r\n    exit;\r\n    end\r\n  else\r\n    Inherited Assign(Source);\r\nend;\r\n\r\n\r\nprocedure TCollection.BeginUpdate;\r\nbegin\r\n  inc(FUpdateCount);\r\nend;\r\n\r\n\r\nprocedure TCollection.Clear;\r\nbegin\r\n  if FItems.Count=0 then\r\n    exit; // Prevent Changed\r\n  BeginUpdate;\r\n  try\r\n    DoClear;\r\n  finally\r\n    EndUpdate;\r\n  end;\r\nend;\r\n\r\n\r\nprocedure TCollection.DoClear;\r\nvar\r\n  Item: TCollectionItem;\r\nbegin\r\n  While FItems.Count>0 do\r\n    begin\r\n    Item:=TCollectionItem(FItems.Last);\r\n    if Assigned(Item) then\r\n      Item.Destroy;\r\n    end;\r\nend;\r\n\r\n\r\nprocedure TCollection.EndUpdate;\r\nbegin\r\n  if FUpdateCount>0 then\r\n    dec(FUpdateCount);\r\n  if FUpdateCount=0 then\r\n    Changed;\r\nend;\r\n\r\n\r\nfunction TCollection.FindItemID(ID: Integer): TCollectionItem;\r\nVar\r\n          I : Longint;\r\nbegin\r\n  For I:=0 to Fitems.Count-1 do\r\n   begin\r\n     Result:=TCollectionItem(FItems.items[I]);\r\n     If Result.Id=Id then\r\n       exit;\r\n   end;\r\n  Result:=Nil;\r\nend;\r\n\r\n\r\nprocedure TCollection.Delete(Index: Integer);\r\nVar\r\n  Item : TCollectionItem;\r\nbegin\r\n  Item:=TCollectionItem(FItems[Index]);\r\n  Notify(Item,cnDeleting);\r\n  If assigned(Item) then\r\n    Item.Destroy;\r\nend;\r\n\r\n\r\nfunction TCollection.Insert(Index: Integer): TCollectionItem;\r\nbegin\r\n  Result:=Add;\r\n  Result.Index:=Index;\r\nend;\r\n\r\n\r\nprocedure TCollection.Notify(Item: TCollectionItem;Action: TCollectionNotification);\r\nbegin\r\n  if Item=nil then ;\r\n  if Action=cnAdded then ;\r\nend;\r\n\r\nprocedure TCollection.Sort(Const Compare : TCollectionSortCompare);\r\n\r\nbegin\r\n  BeginUpdate;\r\n  try\r\n    FItems.Sort(TListSortCompare(Compare));\r\n  Finally\r\n    EndUpdate;\r\n  end;\r\nend;\r\n\r\nprocedure TCollection.SortList(const Compare: TCollectionSortCompareFunc);\r\n\r\nbegin\r\n  BeginUpdate;\r\n  try\r\n    FItems.SortList(TListSortCompareFunc(Compare));\r\n  Finally\r\n    EndUpdate;\r\n  end;\r\nend;\r\n\r\nprocedure TCollection.Exchange(Const Index1, index2: integer);\r\n\r\nbegin\r\n  FItems.Exchange(Index1,Index2);\r\nend;\r\n\r\n\r\n{****************************************************************************}\r\n{*                             TOwnedCollection                             *}\r\n{****************************************************************************}\r\n\r\n\r\n\r\nConstructor TOwnedCollection.Create(AOwner: TPersistent; AItemClass: TCollectionItemClass);\r\n\r\nBegin\r\n  FOwner := AOwner;\r\n  inherited Create(AItemClass);\r\nend;\r\n\r\nFunction TOwnedCollection.GetOwner: TPersistent;\r\n\r\nbegin\r\n  Result:=FOwner;\r\nend;\r\n\r\n{****************************************************************************}\r\n{*                             TComponent                                   *}\r\n{****************************************************************************}\r\n\r\n\r\nfunction TComponent.GetComponent(AIndex: Integer): TComponent;\r\n\r\nbegin\r\n  If not assigned(FComponents) then\r\n    Result:=Nil\r\n  else\r\n    Result:=TComponent(FComponents.Items[Aindex]);\r\nend;\r\n\r\nfunction TComponent.GetComponentCount: Integer;\r\n\r\nbegin\r\n  If not assigned(FComponents) then\r\n    result:=0\r\n  else\r\n    Result:=FComponents.Count;\r\nend;\r\n\r\n\r\nfunction TComponent.GetComponentIndex: Integer;\r\n\r\nbegin\r\n  If Assigned(FOwner) and Assigned(FOwner.FComponents) then\r\n    Result:=FOWner.FComponents.IndexOf(Self)\r\n  else\r\n    Result:=-1;\r\nend;\r\n\r\n\r\nprocedure TComponent.Insert(AComponent: TComponent);\r\n\r\nbegin\r\n  If not assigned(FComponents) then\r\n    FComponents:=TFpList.Create;\r\n  FComponents.Add(AComponent);\r\n  AComponent.FOwner:=Self;\r\nend;\r\n\r\n\r\nprocedure TComponent.ReadLeft(AReader: TReader);\r\n\r\nbegin\r\n  FDesignInfo := (FDesignInfo and $ffff0000) or (AReader.ReadInteger and $ffff);\r\nend;\r\n\r\n\r\nprocedure TComponent.ReadTop(AReader: TReader);\r\n\r\nbegin\r\n  FDesignInfo := ((AReader.ReadInteger and $ffff) shl 16) or (FDesignInfo and $ffff);\r\nend;\r\n\r\n\r\nprocedure TComponent.Remove(AComponent: TComponent);\r\n\r\nbegin\r\n  AComponent.FOwner:=Nil;\r\n  If assigned(FCOmponents) then\r\n    begin\r\n    FComponents.Remove(AComponent);\r\n    IF FComponents.Count=0 then\r\n      begin\r\n      FComponents.Destroy;\r\n      FComponents:=Nil;\r\n      end;\r\n    end;\r\nend;\r\n\r\n\r\nprocedure TComponent.RemoveNotification(AComponent: TComponent);\r\n\r\nbegin\r\n  if FFreeNotifies<>nil then\r\n    begin\r\n    FFreeNotifies.Remove(AComponent);\r\n    if FFreeNotifies.Count=0 then\r\n      begin\r\n      FFreeNotifies.Destroy;\r\n      FFreeNotifies:=nil;\r\n      Exclude(FComponentState,csFreeNotification);\r\n      end;\r\n    end;\r\nend;\r\n\r\n\r\nprocedure TComponent.SetComponentIndex(Value: Integer);\r\n\r\nVar Temp,Count : longint;\r\n\r\nbegin\r\n  If Not assigned(Fowner) then exit;\r\n  Temp:=getcomponentindex;\r\n  If temp<0 then exit;\r\n  If value<0 then value:=0;\r\n  Count:=Fowner.FComponents.Count;\r\n  If Value>=Count then value:=count-1;\r\n  If Value<>Temp then\r\n    begin\r\n    FOWner.FComponents.Delete(Temp);\r\n    FOwner.FComponents.Insert(Value,Self);\r\n    end;\r\nend;\r\n\r\n\r\nprocedure TComponent.ChangeName(const NewName: TComponentName);\r\n\r\nbegin\r\n  FName:=NewName;\r\nend;\r\n\r\n\r\nprocedure TComponent.DefineProperties(Filer: TFiler);\r\n\r\nvar\r\n  Temp: LongInt;\r\n  Ancestor: TComponent;\r\nbegin\r\n  Ancestor := TComponent(Filer.Ancestor);\r\n  if Assigned(Ancestor) then\r\n    Temp := Ancestor.FDesignInfo\r\n  else\r\n    Temp := 0;\r\n  Filer.DefineProperty('Left', @ReadLeft, @WriteLeft, (FDesignInfo and $ffff) <> (Temp and $ffff));\r\n  Filer.DefineProperty('Top', @ReadTop, @WriteTop, (FDesignInfo and $ffff0000) <> (Temp and $ffff0000));\r\nend;\r\n\r\n\r\nprocedure TComponent.GetChildren(Proc: TGetChildProc; Root: TComponent);\r\n\r\nbegin\r\n  // Does nothing.\r\n  if Proc=nil then ;\r\n  if Root=nil then ;\r\nend;\r\n\r\n\r\nfunction TComponent.GetChildOwner: TComponent;\r\n\r\nbegin\r\n Result:=Nil;\r\nend;\r\n\r\n\r\nfunction TComponent.GetChildParent: TComponent;\r\n\r\nbegin\r\n  Result:=Self;\r\nend;\r\n\r\n\r\nfunction TComponent.GetNamePath: string;\r\n\r\nbegin\r\n  Result:=FName;\r\nend;\r\n\r\n\r\nfunction TComponent.GetOwner: TPersistent;\r\n\r\nbegin\r\n  Result:=FOwner;\r\nend;\r\n\r\n\r\nprocedure TComponent.Loaded;\r\n\r\nbegin\r\n  Exclude(FComponentState,csLoading);\r\nend;\r\n\r\nprocedure TComponent.Loading;\r\n\r\nbegin\r\n  Include(FComponentState,csLoading);\r\nend;\r\n\r\nprocedure TComponent.SetWriting(Value: Boolean);\r\nbegin\r\n  If Value then\r\n    Include(FComponentState,csWriting)\r\n  else\r\n    Exclude(FComponentState,csWriting);\r\nend;\r\n\r\nprocedure TComponent.SetReading(Value: Boolean);\r\nbegin\r\n  If Value then\r\n    Include(FComponentState,csReading)\r\n  else\r\n    Exclude(FComponentState,csReading);\r\nend;\r\n\r\n\r\nprocedure TComponent.Notification(AComponent: TComponent; Operation: TOperation);\r\n\r\nVar\r\n  C : Longint;\r\n\r\nbegin\r\n  If (Operation=opRemove) then\r\n    RemoveFreeNotification(AComponent);\r\n  If Not assigned(FComponents) then\r\n    exit;\r\n  C:=FComponents.Count-1;\r\n  While (C>=0) do\r\n    begin\r\n    TComponent(FComponents.Items[C]).Notification(AComponent,Operation);\r\n    Dec(C);\r\n    if C>=FComponents.Count then\r\n      C:=FComponents.Count-1;\r\n    end;\r\nend;\r\n\r\n\r\nprocedure TComponent.PaletteCreated;\r\nbegin\r\nend;\r\n\r\nprocedure TComponent.ReadState(Reader: TReader);\r\n\r\nbegin\r\n  Reader.ReadData(Self);\r\nend;\r\n\r\n\r\nprocedure TComponent.SetAncestor(Value: Boolean);\r\n\r\nVar Runner : Longint;\r\n\r\nbegin\r\n  If Value then\r\n    Include(FComponentState,csAncestor)\r\n  else\r\n    Exclude(FCOmponentState,csAncestor);\r\n  if Assigned(FComponents) then\r\n    For Runner:=0 To FComponents.Count-1 do\r\n      TComponent(FComponents.Items[Runner]).SetAncestor(Value);\r\nend;\r\n\r\n\r\nprocedure TComponent.SetDesigning(Value: Boolean; SetChildren: Boolean);\r\n\r\nVar Runner : Longint;\r\n\r\nbegin\r\n  If Value then\r\n    Include(FComponentState,csDesigning)\r\n  else\r\n    Exclude(FComponentState,csDesigning);\r\n  if Assigned(FComponents) and SetChildren then\r\n    For Runner:=0 To FComponents.Count - 1 do\r\n      TComponent(FComponents.items[Runner]).SetDesigning(Value);\r\nend;\r\n\r\nprocedure TComponent.SetDesignInstance(Value: Boolean);\r\n\r\nbegin\r\n  If Value then\r\n    Include(FComponentState,csDesignInstance)\r\n  else\r\n    Exclude(FComponentState,csDesignInstance);\r\nend;\r\n\r\nprocedure TComponent.SetInline(Value: Boolean);\r\n\r\nbegin\r\n  If Value then\r\n    Include(FComponentState,csInline)\r\n  else\r\n    Exclude(FComponentState,csInline);\r\nend;\r\n\r\n\r\nprocedure TComponent.SetName(const NewName: TComponentName);\r\n\r\nbegin\r\n  If FName=NewName then exit;\r\n  If (NewName<>'') and not IsValidIdent(NewName) then\r\n    Raise EComponentError.CreateFmt(SInvalidName,[NewName]);\r\n  If Assigned(FOwner) Then\r\n    FOwner.ValidateRename(Self,FName,NewName)\r\n  else\r\n    ValidateRename(Nil,FName,NewName);\r\n  SetReference(False);\r\n  ChangeName(NewName);\r\n  SetReference(True);\r\nend;\r\n\r\n\r\nprocedure TComponent.SetChildOrder(Child: TComponent; Order: Integer);\r\n\r\nbegin\r\n  // does nothing\r\n  if Child=nil then ;\r\n  if Order=0 then ;\r\nend;\r\n\r\n\r\nprocedure TComponent.SetParentComponent(Value: TComponent);\r\n\r\nbegin\r\n  // Does nothing\r\n  if Value=nil then ;\r\nend;\r\n\r\n\r\nprocedure TComponent.Updating;\r\n\r\nbegin\r\n  Include (FComponentState,csUpdating);\r\nend;\r\n\r\n\r\nprocedure TComponent.Updated;\r\n\r\nbegin\r\n  Exclude(FComponentState,csUpdating);\r\nend;\r\n\r\n\r\nprocedure TComponent.ValidateRename(AComponent: TComponent; const CurName, NewName: string);\r\n\r\nbegin\r\n//!! This contradicts the Delphi manual.\r\n  If (AComponent<>Nil) and (CompareText(CurName,NewName)<>0) and (AComponent.Owner = Self) and\r\n     (FindComponent(NewName)<>Nil) then\r\n      raise EComponentError.Createfmt(SDuplicateName,[newname]);\r\n  If (csDesigning in FComponentState) and (FOwner<>Nil) then\r\n    FOwner.ValidateRename(AComponent,Curname,Newname);\r\nend;\r\n\r\nProcedure TComponent.SetReference(Enable: Boolean);\r\n\r\nvar\r\n  aField, aValue, aOwner : Pointer;\r\n\r\nbegin\r\n  if Name='' then\r\n    exit;\r\n  if Assigned(Owner) then\r\n  begin\r\n    aOwner:=Owner; // so as not to depend on low-level names\r\n    aField := Owner.FieldAddress(Name);\r\n    if Assigned(aField) then\r\n      begin\r\n      if Enable then\r\n        aValue:= Self\r\n      else\r\n        aValue := nil;\r\n      TJSObject(aOwner)[String(TJSObject(aField)['name'])]:=aValue;\r\n      end;\r\n  end;\r\nend;\r\n\r\n\r\nprocedure TComponent.WriteLeft(AWriter: TWriter);\r\n\r\nbegin\r\n  AWriter.WriteInteger(FDesignInfo and $ffff);\r\nend;\r\n\r\n\r\nprocedure TComponent.WriteTop(AWriter: TWriter);\r\n\r\nbegin\r\n  AWriter.WriteInteger((FDesignInfo shr 16) and $ffff);\r\nend;\r\n\r\n\r\nprocedure TComponent.ValidateContainer(AComponent: TComponent);\r\n\r\nbegin\r\n  AComponent.ValidateInsert(Self);\r\nend;\r\n\r\n\r\nprocedure TComponent.ValidateInsert(AComponent: TComponent);\r\n\r\nbegin\r\n  // Does nothing.\r\n  if AComponent=nil then ;\r\nend;\r\n\r\nfunction TComponent._AddRef: Integer;\r\nbegin\r\n  Result:=-1;\r\nend;\r\n\r\nfunction TComponent._Release: Integer;\r\nbegin\r\n  Result:=-1;\r\nend;\r\n\r\n\r\nconstructor TComponent.Create(AOwner: TComponent);\r\n\r\nbegin\r\n  FComponentStyle:=[csInheritable];\r\n  If Assigned(AOwner) then AOwner.InsertComponent(Self);\r\nend;\r\n\r\n\r\ndestructor TComponent.Destroy;\r\n\r\nVar\r\n  I : Integer;\r\n  C : TComponent;\r\n\r\nbegin\r\n  Destroying;\r\n  If Assigned(FFreeNotifies) then\r\n    begin\r\n    I:=FFreeNotifies.Count-1;\r\n    While (I>=0) do\r\n      begin\r\n      C:=TComponent(FFreeNotifies.Items[I]);\r\n      // Delete, so one component is not notified twice, if it is owned.\r\n      FFreeNotifies.Delete(I);\r\n      C.Notification (self,opRemove);\r\n      If (FFreeNotifies=Nil) then\r\n        I:=0\r\n      else if (I>FFreeNotifies.Count) then\r\n        I:=FFreeNotifies.Count;\r\n      dec(i);\r\n      end;\r\n    FreeAndNil(FFreeNotifies);\r\n    end;\r\n  DestroyComponents;\r\n  If FOwner<>Nil Then FOwner.RemoveComponent(Self);\r\n  inherited destroy;\r\nend;\r\n\r\n\r\nprocedure TComponent.BeforeDestruction;\r\nbegin\r\n  if not(csDestroying in FComponentstate) then\r\n    Destroying;\r\nend;\r\n\r\n\r\nprocedure TComponent.DestroyComponents;\r\n\r\nVar acomponent: TComponent;\r\n\r\nbegin\r\n  While assigned(FComponents) do\r\n    begin\r\n    aComponent:=TComponent(FComponents.Last);\r\n    Remove(aComponent);\r\n    Acomponent.Destroy;\r\n    end;\r\nend;\r\n\r\n\r\nprocedure TComponent.Destroying;\r\n\r\nVar Runner : longint;\r\n\r\nbegin\r\n  If csDestroying in FComponentstate Then Exit;\r\n  include (FComponentState,csDestroying);\r\n  If Assigned(FComponents) then\r\n    for Runner:=0 to FComponents.Count-1 do\r\n      TComponent(FComponents.Items[Runner]).Destroying;\r\nend;\r\n\r\nfunction TComponent.QueryInterface(const IID: TGUID; out Obj): HRESULT;\r\nbegin\r\n  if GetInterface(IID, Obj) then\r\n    Result := S_OK\r\n  else\r\n    Result := E_NOINTERFACE;\r\n\r\nend;\r\n\r\nprocedure TComponent.WriteState(Writer: TWriter);\r\nbegin\r\n  Writer.WriteComponentData(Self);\r\nend;\r\n\r\n\r\nfunction TComponent.FindComponent(const AName: string): TComponent;\r\n\r\nVar I : longint;\r\n\r\nbegin\r\n  Result:=Nil;\r\n  If (AName='') or Not assigned(FComponents) then exit;\r\n  For i:=0 to FComponents.Count-1 do\r\n    if (CompareText(TComponent(FComponents[I]).Name,AName)=0) then\r\n      begin\r\n      Result:=TComponent(FComponents.Items[I]);\r\n      exit;\r\n      end;\r\nend;\r\n\r\n\r\nprocedure TComponent.FreeNotification(AComponent: TComponent);\r\n\r\nbegin\r\n  If (Owner<>Nil) and (AComponent=Owner) then exit;\r\n  If not (Assigned(FFreeNotifies)) then\r\n    FFreeNotifies:=TFpList.Create;\r\n  If FFreeNotifies.IndexOf(AComponent)=-1 then\r\n    begin\r\n    FFreeNotifies.Add(AComponent);\r\n    AComponent.FreeNotification (self);\r\n    end;\r\nend;\r\n\r\n\r\nprocedure TComponent.RemoveFreeNotification(AComponent: TComponent);\r\nbegin\r\n  RemoveNotification(AComponent);\r\n  AComponent.RemoveNotification (self);\r\nend;\r\n\r\n\r\nfunction TComponent.GetParentComponent: TComponent;\r\n\r\nbegin\r\n  Result:=Nil;\r\nend;\r\n\r\n\r\nfunction TComponent.HasParent: Boolean;\r\n\r\nbegin\r\n  Result:=False;\r\nend;\r\n\r\n\r\nprocedure TComponent.InsertComponent(AComponent: TComponent);\r\n\r\nbegin\r\n  AComponent.ValidateContainer(Self);\r\n  ValidateRename(AComponent,'',AComponent.FName);\r\n  if AComponent.FOwner <> nil then\r\n    AComponent.FOwner.RemoveComponent(AComponent);\r\n  Insert(AComponent);\r\n  If csDesigning in FComponentState then\r\n    AComponent.SetDesigning(true);\r\n  Notification(AComponent,opInsert);\r\nend;\r\n\r\n\r\nprocedure TComponent.RemoveComponent(AComponent: TComponent);\r\n\r\nbegin\r\n  Notification(AComponent,opRemove);\r\n  Remove(AComponent);\r\n  Acomponent.Setdesigning(False);\r\n  ValidateRename(AComponent,AComponent.FName,'');\r\nend;\r\n\r\nprocedure TComponent.SetSubComponent(ASubComponent: Boolean);\r\nbegin\r\n  if ASubComponent then\r\n    Include(FComponentStyle, csSubComponent)\r\n  else\r\n    Exclude(FComponentStyle, csSubComponent);\r\nend;\r\n\r\nfunction TComponent.GetEnumerator: TComponentEnumerator;\r\nbegin\r\n  Result:=TComponentEnumerator.Create(Self);\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n  TStream\r\n  ---------------------------------------------------------------------}\r\n\r\nResourcestring\r\n  SStreamInvalidSeek = 'Seek is not implemented for class %s';\r\n  SStreamNoReading = 'Stream reading is not implemented for class %s';\r\n  SStreamNoWriting = 'Stream writing is not implemented for class %s';\r\n  SReadError = 'Could not read data from stream';\r\n  SWriteError = 'Could not write data to stream';\r\n  SMemoryStreamError = 'Could not allocate memory';\r\n  SerrInvalidStreamSize = 'Invalid Stream size';\r\n\r\nprocedure TStream.ReadNotImplemented;\r\nbegin\r\n  raise EStreamError.CreateFmt(SStreamNoReading, [ClassName]);\r\nend;\r\n\r\nprocedure TStream.WriteNotImplemented;\r\nbegin\r\n  raise EStreamError.CreateFmt(SStreamNoWriting, [ClassName]);\r\nend;\r\n\r\nfunction TStream.Read(var Buffer: TBytes; Count: Longint): Longint;\r\nbegin\r\n  Result:=Read(Buffer,0,Count);\r\nend;\r\n\r\n\r\n\r\nfunction TStream.Write(const Buffer: TBytes; Count: Longint): Longint;\r\nbegin\r\n  Result:=Self.Write(Buffer,0,Count);\r\nend;\r\n\r\n\r\n\r\nfunction TStream.GetPosition: NativeInt;\r\n\r\nbegin\r\n   Result:=Seek(0,soCurrent);\r\nend;\r\n\r\nprocedure TStream.SetPosition(const Pos: NativeInt);\r\n\r\nbegin\r\n   Seek(pos,soBeginning);\r\nend;\r\n\r\nprocedure TStream.SetSize64(const NewSize: NativeInt);\r\n\r\nbegin\r\n  // Required because can't use overloaded functions in properties\r\n  SetSize(NewSize);\r\nend;\r\n\r\nfunction TStream.GetSize: NativeInt;\r\n\r\nvar\r\n   p : NativeInt;\r\n\r\nbegin\r\n   p:=Seek(0,soCurrent);\r\n   GetSize:=Seek(0,soEnd);\r\n   Seek(p,soBeginning);\r\nend;\r\n\r\nprocedure TStream.SetSize(const NewSize: NativeInt);\r\n\r\nbegin\r\n  if NewSize<0 then\r\n    Raise EStreamError.Create(SerrInvalidStreamSize);\r\nend;\r\n\r\nprocedure TStream.Discard(const Count: NativeInt);\r\n\r\nconst\r\n  CSmallSize      =255;\r\n  CLargeMaxBuffer =32*1024; // 32 KiB\r\n\r\nvar\r\n  Buffer: TBytes;\r\n\r\nbegin\r\n  if Count=0 then\r\n    Exit;\r\n  if (Count<=CSmallSize) then\r\n    begin\r\n    SetLength(Buffer,CSmallSize);\r\n    ReadBuffer(Buffer,Count)\r\n    end\r\n  else\r\n    DiscardLarge(Count,CLargeMaxBuffer);\r\nend;\r\n\r\nprocedure TStream.DiscardLarge(Count: NativeInt; const MaxBufferSize: Longint);\r\n\r\nvar\r\n  Buffer: TBytes;\r\n\r\nbegin\r\n  if Count=0 then\r\n     Exit;\r\n  if Count>MaxBufferSize then\r\n    SetLength(Buffer,MaxBufferSize)\r\n  else\r\n    SetLength(Buffer,Count);\r\n  while (Count>=Length(Buffer)) do\r\n    begin\r\n    ReadBuffer(Buffer,Length(Buffer));\r\n    Dec(Count,Length(Buffer));\r\n    end;\r\n  if Count>0 then\r\n    ReadBuffer(Buffer,Count);\r\nend;\r\n\r\nprocedure TStream.InvalidSeek;\r\n\r\nbegin\r\n  raise EStreamError.CreateFmt(SStreamInvalidSeek, [ClassName]);\r\nend;\r\n\r\nprocedure TStream.FakeSeekForward(Offset: NativeInt;  const Origin: TSeekOrigin; const Pos: NativeInt);\r\n\r\nbegin\r\n  if Origin=soBeginning then\r\n     Dec(Offset,Pos);\r\n  if (Offset<0) or (Origin=soEnd) then\r\n    InvalidSeek;\r\n  if Offset>0 then\r\n    Discard(Offset);\r\n end;\r\n\r\nfunction TStream.ReadData({var} Buffer: TBytes; Count: NativeInt): NativeInt;\r\nbegin\r\n Result:=Read(Buffer,0,Count);\r\nend;\r\n\r\n\r\nfunction TStream.ReadMaxSizeData(Buffer : TBytes; aSize,aCount : NativeInt) : NativeInt;\r\n\r\nVar\r\n  CP : NativeInt;\r\n\r\nbegin\r\n  if aCount<=aSize then\r\n    Result:=read(Buffer,aCount)\r\n  else\r\n    begin\r\n    Result:=Read(Buffer,aSize);\r\n    CP:=Position;\r\n    Result:=Result+Seek(aCount-aSize,soCurrent)-CP;\r\n    end\r\nend;\r\n\r\nfunction TStream.WriteMaxSizeData(const Buffer : TBytes; aSize,aCount : NativeInt) : NativeInt;\r\nVar\r\n  CP : NativeInt;\r\n\r\nbegin\r\n  if aCount<=aSize then\r\n    Result:=Self.Write(Buffer,aCount)\r\n  else\r\n    begin\r\n    Result:=Self.Write(Buffer,aSize);\r\n    CP:=Position;\r\n    Result:=Result+Seek(aCount-aSize,soCurrent)-CP;\r\n    end\r\nend;\r\n\r\nprocedure TStream.WriteExactSizeData(const Buffer : TBytes; aSize, aCount: NativeInt);\r\nbegin\r\n  // Embarcadero docs mentions no exception. Does not seem very logical\r\n  WriteMaxSizeData(Buffer,aSize,ACount);\r\nend;\r\n\r\nprocedure TStream.ReadExactSizeData(Buffer : TBytes; aSize, aCount: NativeInt);\r\nbegin\r\n  if ReadMaxSizeData(Buffer,aSize,ACount)<>aCount then\r\n     Raise EReadError.Create(SReadError);\r\nend;\r\n\r\n\r\nfunction TStream.ReadData(var Buffer: Boolean): NativeInt;\r\n\r\nVar\r\n  B : Byte;\r\n\r\nbegin\r\n  Result:=ReadData(B,1);\r\n  if Result=1 then\r\n    Buffer:=B<>0;\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: Boolean; Count: NativeInt): NativeInt;\r\n\r\nVar\r\n  B : TBytes;\r\n\r\nbegin\r\n  SetLength(B,Count);\r\n  Result:=ReadMaxSizeData(B,1,Count);\r\n  if Result>0 then\r\n    Buffer:=B[0]<>0\r\nend;\r\n\r\n\r\nfunction TStream.ReadData(var Buffer: WideChar): NativeInt;\r\nbegin\r\n  Result:=ReadData(Buffer,2);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: WideChar; Count: NativeInt): NativeInt;\r\n\r\nVar\r\n  W : Word;\r\n\r\nbegin\r\n  Result:=ReadData(W,Count);\r\n  if Result=2 then\r\n    Buffer:=WideChar(W);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: Int8): NativeInt;\r\nbegin\r\n  Result:=ReadData(Buffer,1);\r\nend;\r\n\r\nFunction TStream.MakeInt(B : TBytes; aSize : Integer; Signed : Boolean) : NativeInt;\r\n\r\nVar\r\n  Mem : TJSArrayBuffer;\r\n  A : TJSUInt8Array;\r\n  D : TJSDataView;\r\n  isLittle : Boolean;\r\n\r\nbegin\r\n  IsLittle:=(Endian=TEndian.Little);\r\n  Mem:=TJSArrayBuffer.New(Length(B));\r\n  A:=TJSUInt8Array.new(Mem);\r\n  A._set(B);\r\n  D:=TJSDataView.New(Mem);\r\n  if Signed then\r\n    case aSize of\r\n      1 : Result:=D.getInt8(0);\r\n      2 : Result:=D.getInt16(0,IsLittle);\r\n      4 : Result:=D.getInt32(0,IsLittle);\r\n      // Todo : fix sign\r\n      8 : Result:=Round(D.getFloat64(0,IsLittle));\r\n    end\r\n  else\r\n    case aSize of\r\n      1 : Result:=D.getUInt8(0);\r\n      2 : Result:=D.getUInt16(0,IsLittle);\r\n      4 : Result:=D.getUInt32(0,IsLittle);\r\n      8 : Result:=Round(D.getFloat64(0,IsLittle));\r\n    end\r\nend;\r\n\r\nfunction TStream.MakeBytes(B: NativeInt; aSize: Integer; Signed: Boolean): TBytes;\r\n\r\n\r\nVar\r\n  Mem : TJSArrayBuffer;\r\n  A : TJSUInt8Array;\r\n  D : TJSDataView;\r\n  isLittle : Boolean;\r\n\r\nbegin\r\n  IsLittle:=(Endian=TEndian.Little);\r\n  Mem:=TJSArrayBuffer.New(aSize);\r\n  D:=TJSDataView.New(Mem);\r\n  if Signed then\r\n    case aSize of\r\n      1 : D.setInt8(0,B);\r\n      2 : D.setInt16(0,B,IsLittle);\r\n      4 : D.setInt32(0,B,IsLittle);\r\n      8 : D.setFloat64(0,B,IsLittle);\r\n    end\r\n  else\r\n    case aSize of\r\n      1 : D.SetUInt8(0,B);\r\n      2 : D.SetUInt16(0,B,IsLittle);\r\n      4 : D.SetUInt32(0,B,IsLittle);\r\n      8 : D.setFloat64(0,B,IsLittle);\r\n    end;\r\n  SetLength(Result,aSize);\r\n  A:=TJSUInt8Array.new(Mem);\r\n  Result:=TMemoryStream.MemoryToBytes(A);\r\nend;\r\n\r\n\r\nfunction TStream.ReadData(var Buffer: Int8; Count: NativeInt): NativeInt;\r\n\r\nVar\r\n  B : TBytes;\r\nbegin\r\n  SetLength(B,Count);\r\n  Result:=ReadMaxSizeData(B,1,Count);\r\n  if Result>=1 then\r\n    Buffer:=MakeInt(B,1,True);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: UInt8): NativeInt;\r\nbegin\r\n  Result:=ReadData(Buffer,1);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: UInt8; Count: NativeInt): NativeInt;\r\nVar\r\n  B : TBytes;\r\nbegin\r\n  SetLength(B,Count);\r\n  Result:=ReadMaxSizeData(B,1,Count);\r\n  if Result>=1 then\r\n    Buffer:=MakeInt(B,1,False);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: Int16): NativeInt;\r\nbegin\r\n  Result:=ReadData(Buffer,2);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: Int16; Count: NativeInt): NativeInt;\r\nVar\r\n  B : TBytes;\r\nbegin\r\n  SetLength(B,Count);\r\n  Result:=ReadMaxSizeData(B,2,Count);\r\n  if Result>=2 then\r\n    Buffer:=MakeInt(B,2,True);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: UInt16): NativeInt;\r\nbegin\r\n  Result:=ReadData(Buffer,2);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: UInt16; Count: NativeInt): NativeInt;\r\nVar\r\n  B : TBytes;\r\nbegin\r\n  SetLength(B,Count);\r\n  Result:=ReadMaxSizeData(B,2,Count);\r\n  if Result>=2 then\r\n    Buffer:=MakeInt(B,2,False);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: Int32): NativeInt;\r\nbegin\r\n  Result:=ReadData(Buffer,4);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: Int32; Count: NativeInt): NativeInt;\r\nVar\r\n  B : TBytes;\r\nbegin\r\n  SetLength(B,Count);\r\n  Result:=ReadMaxSizeData(B,4,Count);\r\n  if Result>=4 then\r\n    Buffer:=MakeInt(B,4,True);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: UInt32): NativeInt;\r\nbegin\r\n  Result:=ReadData(Buffer,4);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: UInt32; Count: NativeInt): NativeInt;\r\n\r\nVar\r\n  B : TBytes;\r\nbegin\r\n  SetLength(B,Count);\r\n  Result:=ReadMaxSizeData(B,4,Count);\r\n  if Result>=4 then\r\n    Buffer:=MakeInt(B,4,False);\r\nend;\r\n\r\n\r\nfunction TStream.ReadData(var Buffer: NativeInt): NativeInt;\r\n\r\nbegin\r\n  Result:=ReadData(Buffer,8);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: NativeInt; Count: NativeInt): NativeInt;\r\n\r\nVar\r\n  B : TBytes;\r\n\r\nbegin\r\n  SetLength(B,Count);\r\n  Result:=ReadMaxSizeData(B,8,8);\r\n  if Result>=8 then\r\n    Buffer:=MakeInt(B,8,True);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: NativeLargeUInt): NativeInt;\r\nbegin\r\n  Result:=ReadData(Buffer,8);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: NativeLargeUInt; Count: NativeInt): NativeInt;\r\n\r\nVar\r\n  B : TBytes;\r\n  B1 : Integer;\r\nbegin\r\n  SetLength(B,Count);\r\n  Result:=ReadMaxSizeData(B,4,4);\r\n  if Result>=4 then\r\n    begin\r\n    B1:=MakeInt(B,4,False);\r\n    Result:=Result+ReadMaxSizeData(B,4,4);\r\n    Buffer:=MakeInt(B,4,False);\r\n    Buffer:=(Buffer shl 32) or B1;\r\n    end;\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: Double): NativeInt;\r\nbegin\r\n  Result:=ReadData(Buffer,8);\r\nend;\r\n\r\nfunction TStream.ReadData(var Buffer: Double; Count: NativeInt): NativeInt;\r\n\r\nVar\r\n  B : TBytes;\r\n  Mem : TJSArrayBuffer;\r\n  A : TJSUInt8Array;\r\n  D : TJSDataView;\r\n\r\nbegin\r\n  SetLength(B,Count);\r\n  Result:=ReadMaxSizeData(B,8,Count);\r\n  if Result>=8 then\r\n    begin\r\n    Mem:=TJSArrayBuffer.New(8);\r\n    A:=TJSUInt8Array.new(Mem);\r\n    A._set(B);\r\n    D:=TJSDataView.New(Mem);\r\n    Buffer:=D.getFloat64(0);\r\n    end;\r\nend;\r\n\r\nprocedure TStream.ReadBuffer(var Buffer: TBytes; Count: NativeInt);\r\nbegin\r\n  ReadBuffer(Buffer,0,Count);\r\nend;\r\n\r\nprocedure TStream.ReadBuffer(var Buffer: TBytes; Offset, Count: NativeInt);\r\nbegin\r\n  if Read(Buffer,OffSet,Count)<>Count then\r\n    Raise EStreamError.Create(SReadError);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: Boolean);\r\nbegin\r\n  ReadBufferData(Buffer,1);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: Boolean; Count: NativeInt);\r\nbegin\r\n  if (ReadData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SReadError);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: WideChar);\r\nbegin\r\n  ReadBufferData(Buffer,2);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: WideChar; Count: NativeInt);\r\nbegin\r\n  if (ReadData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SReadError);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: Int8);\r\nbegin\r\n  ReadBufferData(Buffer,1);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: Int8; Count: NativeInt);\r\nbegin\r\n  if (ReadData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SReadError);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: UInt8);\r\nbegin\r\n  ReadBufferData(Buffer,1);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: UInt8; Count: NativeInt);\r\nbegin\r\n  if (ReadData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SReadError);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: Int16);\r\nbegin\r\n  ReadBufferData(Buffer,2);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: Int16; Count: NativeInt);\r\nbegin\r\n  if (ReadData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SReadError);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: UInt16);\r\nbegin\r\n  ReadBufferData(Buffer,2);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: UInt16; Count: NativeInt);\r\nbegin\r\n  if (ReadData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SReadError);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: Int32);\r\nbegin\r\n  ReadBufferData(Buffer,4);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: Int32; Count: NativeInt);\r\nbegin\r\n  if (ReadData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SReadError);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: UInt32);\r\nbegin\r\n  ReadBufferData(Buffer,4);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: UInt32; Count: NativeInt);\r\nbegin\r\n  if (ReadData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SReadError);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: NativeLargeInt);\r\nbegin\r\n  ReadBufferData(Buffer,8)\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: NativeLargeInt; Count: NativeInt);\r\nbegin\r\n  if (ReadData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SReadError);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: NativeLargeUInt);\r\nbegin\r\n  ReadBufferData(Buffer,8);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: NativeLargeUInt; Count: NativeInt);\r\nbegin\r\n  if (ReadData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SReadError);\r\nend;\r\n\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: Double);\r\nbegin\r\n  ReadBufferData(Buffer,8);\r\nend;\r\n\r\nprocedure TStream.ReadBufferData(var Buffer: Double; Count: NativeInt);\r\nbegin\r\n  if (ReadData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SReadError);\r\nend;\r\n\r\nprocedure TStream.WriteBuffer(const Buffer: TBytes; Count: NativeInt);\r\nbegin\r\n  WriteBuffer(Buffer,0,Count);\r\nend;\r\n\r\nprocedure TStream.WriteBuffer(const Buffer: TBytes; Offset, Count: NativeInt);\r\nbegin\r\n  if Self.Write(Buffer,Offset,Count)<>Count then\r\n     Raise EStreamError.Create(SWriteError);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: TBytes; Count: NativeInt): NativeInt;\r\nbegin\r\n  Result:=Self.Write(Buffer, 0, Count);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: Boolean): NativeInt;\r\nbegin\r\n  Result:=WriteData(Buffer,1);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: Boolean; Count: NativeInt): NativeInt;\r\n\r\nVar\r\n  B : Int8;\r\n\r\nbegin\r\n  B:=Ord(Buffer);\r\n  Result:=WriteData(B,Count);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: WideChar): NativeInt;\r\n\r\nbegin\r\n  Result:=WriteData(Buffer,2);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: WideChar; Count: NativeInt): NativeInt;\r\nVar\r\n  U : UInt16;\r\nbegin\r\n  U:=Ord(Buffer);\r\n  Result:=WriteData(U,Count);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: Int8): NativeInt;\r\n\r\nbegin\r\n  Result:=WriteData(Buffer,1);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: Int8; Count: NativeInt): NativeInt;\r\nbegin\r\n  Result:=WriteMaxSizeData(MakeBytes(Buffer,1,True),1,Count);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: UInt8): NativeInt;\r\nbegin\r\n  Result:=WriteData(Buffer,1);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: UInt8; Count: NativeInt): NativeInt;\r\nbegin\r\n  Result:=WriteMaxSizeData(MakeBytes(Buffer,1,False),1,Count);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: Int16): NativeInt;\r\nbegin\r\n  Result:=WriteData(Buffer,2);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: Int16; Count: NativeInt): NativeInt;\r\nbegin\r\n  Result:=WriteMaxSizeData(MakeBytes(Buffer,2,True),2,Count);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: UInt16): NativeInt;\r\nbegin\r\n  Result:=WriteData(Buffer,2);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: UInt16; Count: NativeInt): NativeInt;\r\nbegin\r\n  Result:=WriteMaxSizeData(MakeBytes(Buffer,2,True),2,Count);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: Int32): NativeInt;\r\nbegin\r\n  Result:=WriteData(Buffer,4);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: Int32; Count: NativeInt): NativeInt;\r\nbegin\r\n  Result:=WriteMaxSizeData(MakeBytes(Buffer,4,True),4,Count);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: UInt32): NativeInt;\r\nbegin\r\n  Result:=WriteData(Buffer,4);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: UInt32; Count: NativeInt): NativeInt;\r\nbegin\r\n  Result:=WriteMaxSizeData(MakeBytes(Buffer,4,False),4,Count);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: NativeLargeInt): NativeInt;\r\nbegin\r\n  Result:=WriteData(Buffer,8);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: NativeLargeInt; Count: NativeInt): NativeInt;\r\nbegin\r\n  Result:=WriteMaxSizeData(MakeBytes(Buffer,8,True),8,Count);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: NativeLargeUInt): NativeInt;\r\nbegin\r\n  Result:=WriteData(Buffer,8);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: NativeLargeUInt; Count: NativeInt): NativeInt;\r\nbegin\r\n  Result:=WriteMaxSizeData(MakeBytes(Buffer,8,False),8,Count);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: Double): NativeInt;\r\nbegin\r\n  Result:=WriteData(Buffer,8);\r\nend;\r\n\r\nfunction TStream.WriteData(const Buffer: Double; Count: NativeInt): NativeInt;\r\n\r\nVar\r\n  Mem : TJSArrayBuffer;\r\n  A : TJSUint8array;\r\n  D : TJSDataview;\r\n  B : TBytes;\r\n  I : Integer;\r\n\r\nbegin\r\n  Mem:=TJSArrayBuffer.New(8);\r\n  D:=TJSDataView.new(Mem);\r\n  D.setFloat64(0,Buffer);\r\n  SetLength(B,8);\r\n  A:=TJSUint8array.New(Mem);\r\n  For I:=0 to 7 do\r\n    B[i]:=A[i];\r\n  Result:=WriteMaxSizeData(B,8,Count);\r\nend;\r\n\r\n\r\nprocedure TStream.WriteBufferData(Buffer: Int32);\r\nbegin\r\n  WriteBufferData(Buffer,4);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: Int32; Count: NativeInt);\r\nbegin\r\n  if (WriteData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SWriteError);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: Boolean);\r\nbegin\r\n  WriteBufferData(Buffer,1);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: Boolean; Count: NativeInt);\r\nbegin\r\n  if (WriteData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SWriteError);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: WideChar);\r\nbegin\r\n  WriteBufferData(Buffer,2);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: WideChar; Count: NativeInt);\r\nbegin\r\n  if (WriteData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SWriteError);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: Int8);\r\nbegin\r\n  WriteBufferData(Buffer,1);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: Int8; Count: NativeInt);\r\nbegin\r\n  if (WriteData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SWriteError);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: UInt8);\r\nbegin\r\n  WriteBufferData(Buffer,1);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: UInt8; Count: NativeInt);\r\nbegin\r\n  if (WriteData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SWriteError);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: Int16);\r\nbegin\r\n  WriteBufferData(Buffer,2);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: Int16; Count: NativeInt);\r\nbegin\r\n  if (WriteData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SWriteError);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: UInt16);\r\nbegin\r\n  WriteBufferData(Buffer,2);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: UInt16; Count: NativeInt);\r\nbegin\r\n  if (WriteData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SWriteError);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: UInt32);\r\nbegin\r\n  WriteBufferData(Buffer,4);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: UInt32; Count: NativeInt);\r\nbegin\r\n  if (WriteData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SWriteError);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: NativeInt);\r\nbegin\r\n  WriteBufferData(Buffer,8);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: NativeInt; Count: NativeInt);\r\nbegin\r\n  if (WriteData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SWriteError);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: NativeLargeUInt);\r\nbegin\r\n  WriteBufferData(Buffer,8);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: NativeLargeUInt; Count: NativeInt);\r\nbegin\r\n  if (WriteData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SWriteError);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: Double);\r\nbegin\r\n  WriteBufferData(Buffer,8);\r\nend;\r\n\r\nprocedure TStream.WriteBufferData(Buffer: Double; Count: NativeInt);\r\nbegin\r\n  if (WriteData(Buffer,Count)<>Count) then\r\n    Raise EStreamError.Create(SWriteError);\r\nend;\r\n\r\n\r\n\r\nfunction TStream.CopyFrom(Source: TStream; Count: NativeInt): NativeInt;\r\n\r\nvar\r\n   Buffer: TBytes;\r\n   BufferSize, i: LongInt;\r\n\r\nconst\r\n   MaxSize = $20000;\r\nbegin\r\n   Result:=0;\r\n   if Count=0 then\r\n     Source.Position:=0;   // This WILL fail for non-seekable streams...\r\n   BufferSize:=MaxSize;\r\n   if (Count>0) and (Count<BufferSize) then\r\n     BufferSize:=Count;    // do not allocate more than needed\r\n   SetLength(Buffer,BufferSize);\r\n   if Count=0 then\r\n     repeat\r\n       i:=Source.Read(Buffer,BufferSize);\r\n       if i>0 then\r\n         WriteBuffer(Buffer,i);\r\n       Inc(Result,i);\r\n     until i<BufferSize\r\n   else\r\n     while Count>0 do\r\n       begin\r\n       if Count>BufferSize then\r\n         i:=BufferSize\r\n       else\r\n         i:=Count;\r\n       Source.ReadBuffer(Buffer,i);\r\n       WriteBuffer(Buffer,i);\r\n       Dec(count,i);\r\n       Inc(Result,i);\r\n       end;\r\nend;\r\n\r\nfunction TStream.ReadComponent(Instance: TComponent): TComponent;\r\n\r\nvar\r\n  Reader: TReader;\r\n\r\nbegin\r\n  Reader := TReader.Create(Self);\r\n  try\r\n    Result := Reader.ReadRootComponent(Instance);\r\n  finally\r\n    Reader.Free;\r\n  end;\r\nend;\r\n\r\nfunction TStream.ReadComponentRes(Instance: TComponent): TComponent;\r\n\r\nbegin\r\n  ReadResHeader;\r\n  Result := ReadComponent(Instance);\r\nend;\r\n\r\nprocedure TStream.WriteComponent(Instance: TComponent);\r\n\r\nbegin\r\n  WriteDescendent(Instance, nil);\r\nend;\r\n\r\nprocedure TStream.WriteComponentRes(const ResName: string; Instance: TComponent);\r\n\r\nbegin\r\n  WriteDescendentRes(ResName, Instance, nil);\r\nend;\r\n\r\nprocedure TStream.WriteDescendent(Instance, Ancestor: TComponent);\r\n\r\nvar\r\n  Driver : TAbstractObjectWriter;\r\n  Writer : TWriter;\r\n\r\nbegin\r\n  Driver := TBinaryObjectWriter.Create(Self);\r\n  Try\r\n    Writer := TWriter.Create(Driver);\r\n    Try\r\n      Writer.WriteDescendent(Instance, Ancestor);\r\n    Finally\r\n      Writer.Destroy;\r\n    end;\r\n  Finally\r\n    Driver.Free;\r\n  end;\r\nend;\r\n\r\nprocedure TStream.WriteDescendentRes(const ResName: string; Instance, Ancestor: TComponent);\r\n\r\nvar\r\n  FixupInfo: Longint;\r\n\r\nbegin\r\n  { Write a resource header }\r\n  WriteResourceHeader(ResName, FixupInfo);\r\n  { Write the instance itself }\r\n  WriteDescendent(Instance, Ancestor);\r\n  { Insert the correct resource size into the resource header }\r\n  FixupResourceHeader(FixupInfo);\r\nend;\r\n\r\n\r\nprocedure TStream.WriteResourceHeader(const ResName: string; {!!!: out} var FixupInfo: Longint);\r\n  var\r\n    ResType, Flags : word;\r\n    B : Byte;\r\n    I : Integer;\r\n\r\n  begin\r\n     ResType:=Word($000A);\r\n     Flags:=Word($1030);\r\n     { Note: This is a Windows 16 bit resource }\r\n     { Numeric resource type }\r\n     WriteByte($ff);\r\n     { Application defined data }\r\n     WriteWord(ResType);\r\n     { write the name as asciiz }\r\n     For I:=1 to Length(ResName) do\r\n        begin\r\n        B:=Ord(ResName[i]);\r\n        WriteByte(B);\r\n        end;\r\n     WriteByte(0);\r\n     { Movable, Pure and Discardable }\r\n     WriteWord(Flags);\r\n     { Placeholder for the resource size }\r\n     WriteDWord(0);\r\n     { Return current stream position so that the resource size can be\r\n       inserted later }\r\n     FixupInfo := Position;\r\n  end;\r\n\r\nprocedure TStream.FixupResourceHeader(FixupInfo: Longint);\r\n\r\nvar\r\n   ResSize,TmpResSize : Longint;\r\n\r\nbegin\r\n\r\n  ResSize := Position - FixupInfo;\r\n  TmpResSize := longword(ResSize);\r\n\r\n  { Insert the correct resource size into the placeholder written by\r\n    WriteResourceHeader }\r\n  Position := FixupInfo - 4;\r\n  WriteDWord(TmpResSize);\r\n  { Seek back to the end of the resource }\r\n  Position := FixupInfo + ResSize;\r\n\r\nend;\r\n\r\nprocedure TStream.ReadResHeader;\r\n  var\r\n    ResType, Flags : word;\r\n  begin\r\n     try\r\n       { Note: This is a Windows 16 bit resource }\r\n       { application specific resource ? }\r\n       if ReadByte<>$ff then\r\n         raise EInvalidImage.Create(SInvalidImage);\r\n       ResType:=ReadWord;\r\n       if ResType<>$000a then\r\n         raise EInvalidImage.Create(SInvalidImage);\r\n       { read name }\r\n       while ReadByte<>0 do\r\n         ;\r\n       { check the access specifier }\r\n       Flags:=ReadWord;\r\n       if Flags<>$1030 then\r\n         raise EInvalidImage.Create(SInvalidImage);\r\n       { ignore the size }\r\n       ReadDWord;\r\n     except\r\n       on EInvalidImage do\r\n         raise;\r\n       else\r\n         raise EInvalidImage.create(SInvalidImage);\r\n     end;\r\n  end;\r\n\r\n\r\nfunction TStream.ReadByte : Byte;\r\n\r\nbegin\r\n  ReadBufferData(Result,1);\r\nend;\r\n\r\nfunction TStream.ReadWord : Word;\r\n\r\nbegin\r\n  ReadBufferData(Result,2);\r\nend;\r\n\r\nfunction TStream.ReadDWord : Cardinal;\r\n\r\nbegin\r\n  ReadBufferData(Result,4);\r\nend;\r\n\r\nfunction TStream.ReadQWord: NativeLargeUInt;\r\n\r\nbegin\r\n  ReadBufferData(Result,8);\r\nend;\r\n\r\n\r\nprocedure TStream.WriteByte(b : Byte);\r\n\r\nbegin\r\n  WriteBufferData(b,1);\r\nend;\r\n\r\nprocedure TStream.WriteWord(w : Word);\r\n\r\nbegin\r\n  WriteBufferData(W,2);\r\nend;\r\n\r\nprocedure TStream.WriteDWord(d : Cardinal);\r\n\r\nbegin\r\n  WriteBufferData(d,4);\r\nend;\r\n\r\nprocedure TStream.WriteQWord(q: NativeLargeUInt);\r\nbegin\r\n  WriteBufferData(q,8);\r\nend;\r\n\r\n{****************************************************************************}\r\n{*                             TCustomMemoryStream                          *}\r\n{****************************************************************************}\r\n\r\nprocedure TCustomMemoryStream.SetPointer(Ptr: TJSArrayBuffer; ASize: PtrInt);\r\n\r\nbegin\r\n  FMemory:=Ptr;\r\n  FSize:=ASize;\r\n  FDataView:=Nil;\r\n  FDataArray:=Nil;\r\nend;\r\n\r\n\r\nclass function TCustomMemoryStream.MemoryToBytes(Mem: TJSArrayBuffer): TBytes;\r\n\r\nbegin\r\n  Result:=MemoryToBytes(TJSUint8Array.New(Mem));\r\nend;\r\n\r\nclass function TCustomMemoryStream.MemoryToBytes(Mem: TJSUint8Array): TBytes;\r\n\r\nVar\r\n  I : Integer;\r\n\r\nbegin\r\n  // This must be improved, but needs some asm or TJSFunction.call() to implement answers in\r\n  // https://stackoverflow.com/questions/29676635/convert-uint8array-to-array-in-javascript\r\n  SetLength(Result, Mem.Length);\r\n  for i:=0 to mem.length-1 do\r\n    Result[i]:=Mem[i];\r\nend;\r\n\r\nclass function TCustomMemoryStream.BytesToMemory(aBytes: TBytes): TJSArrayBuffer;\r\n\r\nVar\r\n  a : TJSUint8Array;\r\n\r\nbegin\r\n  Result:=TJSArrayBuffer.new(Length(aBytes));\r\n  A:=TJSUint8Array.New(Result);\r\n  A._set(aBytes);\r\nend;\r\n\r\nfunction TCustomMemoryStream.GetDataArray: TJSUint8Array;\r\nbegin\r\n  if FDataArray=Nil then\r\n    FDataArray:=TJSUint8Array.new(Memory);\r\n  Result:=FDataArray;\r\nend;\r\n\r\nfunction TCustomMemoryStream.GetDataView: TJSDataview;\r\nbegin\r\n  if FDataView=Nil then\r\n    FDataView:=TJSDataView.New(Memory);\r\n  Result:=FDataView;\r\nend;\r\n\r\nfunction TCustomMemoryStream.GetSize: NativeInt;\r\n\r\nbegin\r\n  Result:=FSize;\r\nend;\r\n\r\nfunction TCustomMemoryStream.GetPosition: NativeInt;\r\nbegin\r\n  Result:=FPosition;\r\nend;\r\n\r\n\r\nfunction TCustomMemoryStream.Read(Buffer: TBytes; Offset, Count: LongInt): LongInt;\r\n\r\nVar\r\n  I,Src,Dest : Integer;\r\n\r\nbegin\r\n  Result:=0;\r\n  If (FSize>0) and (FPosition<Fsize) and (FPosition>=0) then\r\n    begin\r\n    Result:=Count;\r\n    If (Result>(FSize-FPosition)) then\r\n      Result:=(FSize-FPosition);\r\n    Src:=FPosition;\r\n    Dest:=Offset;\r\n    I:=0;\r\n    While I<Result do\r\n      begin\r\n      Buffer[Dest]:=DataView.getUint8(Src);\r\n      inc(Src);\r\n      inc(Dest);\r\n      inc(I);\r\n      end;\r\n    FPosition:=Fposition+Result;\r\n    end;\r\nend;\r\n\r\n\r\nfunction TCustomMemoryStream.Seek(const Offset: NativeInt; Origin: TSeekOrigin): NativeInt;\r\n\r\nbegin\r\n  Case Origin of\r\n    soBeginning : FPosition:=Offset;\r\n    soEnd       : FPosition:=FSize+Offset;\r\n    soCurrent   : FPosition:=FPosition+Offset;\r\n  end;\r\n  if SizeBoundsSeek and (FPosition>FSize) then\r\n    FPosition:=FSize;\r\n  Result:=FPosition;\r\n  {$IFDEF DEBUG}\r\n  if Result < 0 then\r\n    raise Exception.Create('TCustomMemoryStream');\r\n  {$ENDIF}\r\nend;\r\n\r\n\r\nprocedure TCustomMemoryStream.SaveToStream(Stream: TStream);\r\n\r\nbegin\r\n  if FSize>0 then\r\n    Stream.WriteBuffer(TMemoryStream.MemoryToBytes(Memory),FSize);\r\nend;\r\n\r\nprocedure TCustomMemoryStream.LoadFromURL(const aURL: String; Async: Boolean; OnLoaded: TNotifyEventRef; OnError: TStringNotifyEventRef = Nil);\r\n\r\n  procedure DoLoaded(const abytes : TJSArrayBuffer);\r\n  begin\r\n    SetPointer(aBytes,aBytes.byteLength);\r\n    if Assigned(OnLoaded) then\r\n      OnLoaded(Self);\r\n  end;\r\n\r\n  procedure DoError(const AError : String);\r\n  begin\r\n    if Assigned(OnError) then\r\n      OnError(Self,aError)\r\n    else\r\n      Raise EInOutError.Create('Failed to load from URL:'+aError);\r\n  end;\r\n\r\nbegin\r\n  CheckLoadHelper;\r\n  GlobalLoadHelper.LoadBytes(aURL,aSync,@DoLoaded,@DoError);\r\nend;\r\n\r\nprocedure TCustomMemoryStream.LoadFromFile(const aFileName: String; const OnLoaded: TProc; const AError: TProcString);\r\n\r\nbegin\r\n  LoadFromURL(aFileName,False,\r\n    Procedure (Sender : TObject)\r\n    begin\r\n      If Assigned(OnLoaded) then\r\n       OnLoaded\r\n    end,\r\n    Procedure (Sender : TObject; Const ErrorMsg : String)\r\n    begin\r\n      if Assigned(aError) then\r\n        aError(ErrorMsg)\r\n    end);\r\nend;\r\n\r\n\r\n\r\n{****************************************************************************}\r\n{*                             TMemoryStream                                *}\r\n{****************************************************************************}\r\n\r\n\r\nConst TMSGrow = 4096; { Use 4k blocks. }\r\n\r\nprocedure TMemoryStream.SetCapacity(NewCapacity: PtrInt);\r\n\r\nbegin\r\n  SetPointer (Realloc(NewCapacity),Fsize);\r\n  FCapacity:=NewCapacity;\r\nend;\r\n\r\n\r\nfunction TMemoryStream.Realloc(var NewCapacity: PtrInt): TJSArrayBuffer;\r\n\r\nVar\r\n  GC : PtrInt;\r\n  DestView : TJSUInt8array;\r\n\r\nbegin\r\n  If NewCapacity<0 Then\r\n    NewCapacity:=0\r\n  else\r\n    begin\r\n      GC:=FCapacity + (FCapacity div 4);\r\n      // if growing, grow at least a quarter\r\n      if (NewCapacity>FCapacity) and (NewCapacity < GC) then\r\n        NewCapacity := GC;\r\n      // round off to block size.\r\n      NewCapacity := (NewCapacity + (TMSGrow-1)) and not (TMSGROW-1);\r\n    end;\r\n  // Only now check !\r\n  If NewCapacity=FCapacity then\r\n    Result:=FMemory\r\n  else if NewCapacity=0 then\r\n    Result:=Nil\r\n  else\r\n    begin\r\n    // New buffer\r\n    Result:=TJSArrayBuffer.New(NewCapacity);\r\n    If (Result=Nil)  then\r\n      Raise EStreamError.Create(SMemoryStreamError);\r\n    // Transfer\r\n    DestView:=TJSUInt8array.New(Result);\r\n    Destview._Set(Self.DataArray);\r\n    end;\r\nend;\r\n\r\n\r\ndestructor TMemoryStream.Destroy;\r\n\r\nbegin\r\n  Clear;\r\n  Inherited Destroy;\r\nend;\r\n\r\n\r\nprocedure TMemoryStream.Clear;\r\n\r\nbegin\r\n  FSize:=0;\r\n  FPosition:=0;\r\n  SetCapacity (0);\r\nend;\r\n\r\n\r\nprocedure TMemoryStream.LoadFromStream(Stream: TStream);\r\n\r\nbegin\r\n  Position:=0;\r\n  Stream.Position:=0;\r\n  SetSize(Stream.Size);\r\n  If (Size>0) then\r\n    CopyFrom(Stream,0);\r\nend;\r\n\r\nprocedure TMemoryStream.SetSize(const NewSize: NativeInt);\r\n\r\nbegin\r\n  SetCapacity (NewSize);\r\n  FSize:=NewSize;\r\n  IF FPosition>FSize then\r\n    FPosition:=FSize;\r\nend;\r\n\r\nfunction TMemoryStream.Write(Const Buffer : TBytes; OffSet, Count: LongInt): LongInt;\r\n\r\nVar NewPos : PtrInt;\r\n\r\nbegin\r\n  If (Count=0) or (FPosition<0) then\r\n    exit(0);\r\n  NewPos:=FPosition+Count;\r\n  If NewPos>Fsize then\r\n    begin\r\n    IF NewPos>FCapacity then\r\n      SetCapacity (NewPos);\r\n    FSize:=Newpos;\r\n    end;\r\n  DataArray._set(Copy(Buffer,Offset,Count),FPosition);\r\n  FPosition:=NewPos;\r\n  Result:=Count;\r\nend;\r\n\r\n{****************************************************************************}\r\n{*                              TBytesStream                                *}\r\n{****************************************************************************}\r\n\r\nconstructor TBytesStream.Create(const ABytes: TBytes);\r\nbegin\r\n  inherited Create;\r\n  SetPointer(TMemoryStream.BytesToMemory(aBytes),Length(ABytes));\r\n  FCapacity:=Length(ABytes);\r\nend;\r\n\r\nfunction TBytesStream.GetBytes: TBytes;\r\nbegin\r\n  Result:=TMemoryStream.MemoryToBytes(Memory);\r\nend;\r\n\r\n{ *********************************************************************\r\n  *                         TFiler                                    *\r\n  *********************************************************************}\r\n\r\nprocedure TFiler.SetRoot(ARoot: TComponent);\r\nbegin\r\n  FRoot := ARoot;\r\nend;\r\n\r\n\r\n{\r\n    This file is part of the Free Component Library (FCL)\r\n    Copyright (c) 1999-2000 by the Free Pascal development team\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n\r\n{****************************************************************************}\r\n{*                       TBinaryObjectReader                                *}\r\n{****************************************************************************}\r\n\r\n\r\nfunction TBinaryObjectReader.ReadWord : word;\r\nbegin\r\n  FStream.ReadBufferData(Result);\r\nend;\r\n\r\nfunction TBinaryObjectReader.ReadDWord : longword;\r\nbegin\r\n  FStream.ReadBufferData(Result);\r\nend;\r\n\r\n\r\nconstructor TBinaryObjectReader.Create(Stream: TStream);\r\nbegin\r\n  inherited Create;\r\n  If (Stream=Nil) then\r\n    Raise EReadError.Create(SEmptyStreamIllegalReader);\r\n  FStream := Stream;\r\nend;\r\n\r\nfunction TBinaryObjectReader.ReadValue: TValueType;\r\nvar\r\n  b: byte;\r\nbegin\r\n  FStream.ReadBufferData(b);\r\n  Result := TValueType(b);\r\nend;\r\n\r\nfunction TBinaryObjectReader.NextValue: TValueType;\r\nbegin\r\n  Result := ReadValue;\r\n  { We only 'peek' at the next value, so seek back to unget the read value: }\r\n  FStream.Seek(-1,soCurrent);\r\nend;\r\n\r\nprocedure TBinaryObjectReader.BeginRootComponent;\r\nbegin\r\n  { Read filer signature }\r\n  ReadSignature;\r\nend;\r\n\r\nprocedure TBinaryObjectReader.BeginComponent(var Flags: TFilerFlags;\r\n  var AChildPos: Integer; var CompClassName, CompName: String);\r\nvar\r\n  Prefix: Byte;\r\n  ValueType: TValueType;\r\nbegin\r\n  { Every component can start with a special prefix: }\r\n  Flags := [];\r\n  if (Byte(NextValue) and $f0) = $f0 then\r\n  begin\r\n    Prefix := Byte(ReadValue);\r\n    Flags:=[];\r\n    if (Prefix and $01)<>0 then\r\n      Include(Flags,ffInherited);\r\n    if (Prefix and $02)<>0 then\r\n      Include(Flags,ffChildPos);\r\n    if (Prefix and $04)<>0 then\r\n      Include(Flags,ffInline);\r\n    if ffChildPos in Flags then\r\n    begin\r\n      ValueType := ReadValue;\r\n      case ValueType of\r\n        vaInt8:\r\n          AChildPos := ReadInt8;\r\n        vaInt16:\r\n          AChildPos := ReadInt16;\r\n        vaInt32:\r\n          AChildPos := ReadInt32;\r\n        vaNativeInt:\r\n          AChildPos := ReadNativeInt;\r\n        else\r\n          raise EReadError.Create(SInvalidPropertyValue);\r\n      end;\r\n    end;\r\n  end;\r\n\r\n  CompClassName := ReadStr;\r\n  CompName := ReadStr;\r\nend;\r\n\r\nfunction TBinaryObjectReader.BeginProperty: String;\r\nbegin\r\n  Result := ReadStr;\r\nend;\r\n\r\nprocedure TBinaryObjectReader.Read(var Buffer: TBytes; Count: Longint);\r\nbegin\r\n  FStream.Read(Buffer,Count);\r\nend;\r\n\r\nprocedure TBinaryObjectReader.ReadBinary(const DestData: TMemoryStream);\r\nvar\r\n  BinSize: LongInt;\r\nbegin\r\n  BinSize:=LongInt(ReadDWord);\r\n  DestData.Size := BinSize;\r\n  DestData.CopyFrom(FStream,BinSize);\r\nend;\r\n\r\nfunction TBinaryObjectReader.ReadFloat: Extended;\r\nbegin\r\n  FStream.ReadBufferData(Result);\r\nend;\r\n\r\nfunction TBinaryObjectReader.ReadCurrency: Currency;\r\n\r\nbegin\r\n  Result:=ReadFloat;\r\nend;\r\n\r\nfunction TBinaryObjectReader.ReadIdent(ValueType: TValueType): String;\r\nvar\r\n  i: Byte;\r\n  c : Char;\r\nbegin\r\n  case ValueType of\r\n    vaIdent:\r\n      begin\r\n        FStream.ReadBufferData(i);\r\n        SetLength(Result,i);\r\n        For I:=1 to Length(Result) do\r\n          begin\r\n          FStream.ReadBufferData(C);\r\n          Result[I]:=C;\r\n          end;\r\n      end;\r\n    vaNil:\r\n      Result := 'nil';\r\n    vaFalse:\r\n      Result := 'False';\r\n    vaTrue:\r\n      Result := 'True';\r\n    vaNull:\r\n      Result := 'Null';\r\n  end;\r\nend;\r\n\r\nfunction TBinaryObjectReader.ReadInt8: ShortInt;\r\nbegin\r\n  FStream.ReadBufferData(Result);\r\nend;\r\n\r\nfunction TBinaryObjectReader.ReadInt16: SmallInt;\r\nbegin\r\n  FStream.ReadBufferData(Result);\r\nend;\r\n\r\nfunction TBinaryObjectReader.ReadInt32: LongInt;\r\nbegin\r\n  FStream.ReadBufferData(Result);\r\nend;\r\n\r\nfunction TBinaryObjectReader.ReadNativeInt : NativeInt;\r\nbegin\r\n  FStream.ReadBufferData(Result);\r\nend;\r\n\r\n\r\nfunction TBinaryObjectReader.ReadSet(EnumType: TTypeInfoEnum): Integer;\r\n\r\nvar\r\n  Name: String;\r\n  Value: Integer;\r\n\r\nbegin\r\n  try\r\n    Result := 0;\r\n    while True do\r\n      begin\r\n      Name := ReadStr;\r\n      if Length(Name) = 0 then\r\n        break;\r\n      Value:=EnumType.EnumType.NameToInt[Name];\r\n      if Value=-1 then\r\n        raise EReadError.Create(SInvalidPropertyValue);\r\n      Result:=Result or (1 shl Value);\r\n      end;\r\n  except\r\n    SkipSetBody;\r\n    raise;\r\n  end;\r\nend;\r\n\r\n\r\nConst\r\n  // Integer version of 4 chars 'TPF0'\r\n  FilerSignatureInt = 809914452;\r\n\r\nprocedure TBinaryObjectReader.ReadSignature;\r\n\r\nvar\r\n  Signature: LongInt;\r\n\r\nbegin\r\n  FStream.ReadBufferData(Signature);\r\n  if Signature <> FilerSignatureInt then\r\n    raise EReadError.Create(SInvalidImage);\r\nend;\r\n\r\nfunction TBinaryObjectReader.ReadStr: String;\r\nvar\r\n  l,i: Byte;\r\n  c : Char;\r\nbegin\r\n  FStream.ReadBufferData(L);\r\n  SetLength(Result,L);\r\n  For I:=1 to L do\r\n    begin\r\n    FStream.ReadBufferData(C);\r\n    Result[i]:=C;\r\n    end;\r\nend;\r\n\r\nfunction TBinaryObjectReader.ReadString(StringType: TValueType): String;\r\nvar\r\n  i: Integer;\r\n  C : Char;\r\n\r\nbegin\r\n  Result:='';\r\n  if StringType<>vaString then\r\n    Raise EFilerError.Create('Invalid string type passed to ReadString');\r\n  i:=ReadDWord;\r\n  SetLength(Result, i);\r\n  for I:=1 to Length(Result) do\r\n    begin\r\n    FStream.ReadbufferData(C);\r\n    Result[i]:=C;\r\n    end;\r\nend;\r\n\r\n\r\nfunction TBinaryObjectReader.ReadWideString: WideString;\r\nbegin\r\n  Result:=ReadString(vaWString);\r\nend;\r\n\r\nfunction TBinaryObjectReader.ReadUnicodeString: UnicodeString;\r\n\r\nbegin\r\n  Result:=ReadString(vaWString);\r\nend;\r\n\r\nprocedure TBinaryObjectReader.SkipComponent(SkipComponentInfos: Boolean);\r\nvar\r\n  Flags: TFilerFlags;\r\n  Dummy: Integer;\r\n  CompClassName, CompName: String;\r\nbegin\r\n  if SkipComponentInfos then\r\n    { Skip prefix, component class name and component object name }\r\n    BeginComponent(Flags, Dummy, CompClassName, CompName);\r\n\r\n  { Skip properties }\r\n  while NextValue <> vaNull do\r\n    SkipProperty;\r\n  ReadValue;\r\n\r\n  { Skip children }\r\n  while NextValue <> vaNull do\r\n    SkipComponent(True);\r\n  ReadValue;\r\nend;\r\n\r\nprocedure TBinaryObjectReader.SkipValue;\r\n\r\n  procedure SkipBytes(Count: LongInt);\r\n  var\r\n    Dummy: TBytes;\r\n    SkipNow: Integer;\r\n  begin\r\n    while Count > 0 do\r\n    begin\r\n      if Count > 1024 then\r\n        SkipNow := 1024\r\n      else\r\n        SkipNow := Count;\r\n      SetLength(Dummy,SkipNow);\r\n      Read(Dummy, SkipNow);\r\n      Dec(Count, SkipNow);\r\n    end;\r\n  end;\r\n\r\nvar\r\n  Count: LongInt;\r\nbegin\r\n  case ReadValue of\r\n    vaNull, vaFalse, vaTrue, vaNil: ;\r\n    vaList:\r\n      begin\r\n        while NextValue <> vaNull do\r\n          SkipValue;\r\n        ReadValue;\r\n      end;\r\n    vaInt8:\r\n      SkipBytes(1);\r\n    vaInt16:\r\n      SkipBytes(2);\r\n    vaInt32:\r\n      SkipBytes(4);\r\n    vaInt64,\r\n    vaDouble:\r\n      SkipBytes(8);\r\n    vaIdent:\r\n      ReadStr;\r\n    vaString:\r\n      ReadString(vaString);\r\n    vaBinary:\r\n      begin\r\n        Count:=LongInt(ReadDWord);\r\n        SkipBytes(Count);\r\n      end;\r\n    vaSet:\r\n      SkipSetBody;\r\n    vaCollection:\r\n      begin\r\n        while NextValue <> vaNull do\r\n        begin\r\n          { Skip the order value if present }\r\n          if NextValue in [vaInt8, vaInt16, vaInt32] then\r\n            SkipValue;\r\n          SkipBytes(1);\r\n          while NextValue <> vaNull do\r\n            SkipProperty;\r\n          ReadValue;\r\n        end;\r\n        ReadValue;\r\n      end;\r\n  end;\r\nend;\r\n\r\n{ private methods }\r\n\r\n\r\nprocedure TBinaryObjectReader.SkipProperty;\r\nbegin\r\n  { Skip property name, then the property value }\r\n  ReadStr;\r\n  SkipValue;\r\nend;\r\n\r\nprocedure TBinaryObjectReader.SkipSetBody;\r\nbegin\r\n  while Length(ReadStr) > 0 do;\r\nend;\r\n\r\n\r\n  // Quadruple representing an unresolved component property.\r\nType\r\n  { TUnresolvedReference }\r\n\r\n  TUnresolvedReference = class(TlinkedListItem)\r\n  Private\r\n    FRoot: TComponent;     // Root component when streaming\r\n    FPropInfo: TTypeMemberProperty;  // Property to set.\r\n    FGlobal,               // Global component.\r\n    FRelative : string;    // Path relative to global component.\r\n    Function Resolve(Instance : TPersistent) : Boolean; // Resolve this reference\r\n    Function RootMatches(ARoot : TComponent) : Boolean; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE} // True if Froot matches or ARoot is nil.\r\n    Function NextRef : TUnresolvedReference; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n  end;\r\n\r\n  TLocalUnResolvedReference = class(TUnresolvedReference)\r\n    Finstance : TPersistent;\r\n  end;\r\n\r\n  // Linked list of TPersistent items that have unresolved properties.\r\n\r\n  { TUnResolvedInstance }\r\n\r\n  TUnResolvedInstance = Class(TLinkedListItem)\r\n  Public\r\n    Instance : TPersistent; // Instance we're handling unresolveds for\r\n    FUnresolved : TLinkedList; // The list\r\n    Destructor Destroy; override;\r\n    Function AddReference(ARoot : TComponent; APropInfo : TTypeMemberProperty; AGlobal,ARelative : String) : TUnresolvedReference;\r\n    Function RootUnresolved : TUnresolvedReference; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE} // Return root element in list.\r\n    Function ResolveReferences : Boolean; // Return true if all unresolveds were resolved.\r\n  end;\r\n\r\n  // Builds a list of TUnResolvedInstances, removes them from global list on free.\r\n  TBuildListVisitor = Class(TLinkedListVisitor)\r\n  Private\r\n    List : TFPList;\r\n  Public\r\n    Procedure Add(Item : TlinkedListItem); // Add TUnResolvedInstance item to list. Create list if needed\r\n    Destructor Destroy; override; // All elements in list (if any) are removed from the global list.\r\n  end;\r\n\r\n  // Visitor used to try and resolve instances in the global list\r\n  TResolveReferenceVisitor = Class(TBuildListVisitor)\r\n    Function Visit(Item : TLinkedListItem) : Boolean; override;\r\n  end;\r\n\r\n  // Visitor used to remove all references to a certain component.\r\n  TRemoveReferenceVisitor = Class(TBuildListVisitor)\r\n  Private\r\n    FRef : String;\r\n    FRoot : TComponent;\r\n  Public\r\n    Constructor Create(ARoot : TComponent;Const ARef : String);\r\n    Function Visit(Item : TLinkedListItem) : Boolean; override;\r\n  end;\r\n\r\n  // Visitor used to collect reference names.\r\n  TReferenceNamesVisitor = Class(TLinkedListVisitor)\r\n  Private\r\n    FList : TStrings;\r\n    FRoot : TComponent;\r\n  Public\r\n    Function Visit(Item : TLinkedListItem) : Boolean; override;\r\n    Constructor Create(ARoot : TComponent;AList : TStrings);\r\n  end;\r\n\r\n  // Visitor used to collect instance names.\r\n  TReferenceInstancesVisitor = Class(TLinkedListVisitor)\r\n  Private\r\n    FList : TStrings;\r\n    FRef  : String;\r\n    FRoot : TComponent;\r\n  Public\r\n    Function Visit(Item : TLinkedListItem) : Boolean; override;\r\n    Constructor Create(ARoot : TComponent;Const ARef : String; AList : TStrings);\r\n  end;\r\n\r\n  // Visitor used to redirect links to another root component.\r\n  TRedirectReferenceVisitor = Class(TLinkedListVisitor)\r\n  Private\r\n    FOld,\r\n    FNew : String;\r\n    FRoot : TComponent;\r\n  Public\r\n    Function Visit(Item : TLinkedListItem) : Boolean; override;\r\n    Constructor Create(ARoot : TComponent;Const AOld,ANew : String);\r\n  end;\r\n\r\nvar\r\n  NeedResolving : TLinkedList;\r\n\r\n// Add an instance to the global list of instances which need resolving.\r\nFunction FindUnresolvedInstance(AInstance: TPersistent) : TUnResolvedInstance;\r\n\r\nbegin\r\n  Result:=Nil;\r\n{$ifdef FPC_HAS_FEATURE_THREADING}\r\n  EnterCriticalSection(ResolveSection);\r\n  Try\r\n{$endif}\r\n    If Assigned(NeedResolving) then\r\n      begin\r\n      Result:=TUnResolvedInstance(NeedResolving.Root);\r\n      While (Result<>Nil) and (Result.Instance<>AInstance) do\r\n        Result:=TUnResolvedInstance(Result.Next);\r\n      end;\r\n{$ifdef FPC_HAS_FEATURE_THREADING}\r\n  finally\r\n    LeaveCriticalSection(ResolveSection);\r\n  end;\r\n{$endif}\r\nend;\r\n\r\nFunction AddtoResolveList(AInstance: TPersistent) : TUnResolvedInstance;\r\n\r\nbegin\r\n  Result:=FindUnresolvedInstance(AInstance);\r\n  If (Result=Nil) then\r\n    begin\r\n{$ifdef FPC_HAS_FEATURE_THREADING}\r\n    EnterCriticalSection(ResolveSection);\r\n    Try\r\n{$endif}\r\n      If not Assigned(NeedResolving) then\r\n        NeedResolving:=TLinkedList.Create(TUnResolvedInstance);\r\n      Result:=NeedResolving.Add as TUnResolvedInstance;\r\n      Result.Instance:=AInstance;\r\n{$ifdef FPC_HAS_FEATURE_THREADING}\r\n    finally\r\n      LeaveCriticalSection(ResolveSection);\r\n    end;\r\n{$endif}\r\n    end;\r\nend;\r\n\r\n// Walk through the global list of instances to be resolved.\r\n\r\nProcedure VisitResolveList(V : TLinkedListVisitor);\r\n\r\nbegin\r\n{$ifdef FPC_HAS_FEATURE_THREADING}\r\n  EnterCriticalSection(ResolveSection);\r\n  Try\r\n{$endif}\r\n    try\r\n      NeedResolving.Foreach(V);\r\n    Finally\r\n      FreeAndNil(V);\r\n    end;\r\n{$ifdef FPC_HAS_FEATURE_THREADING}\r\n  Finally\r\n    LeaveCriticalSection(ResolveSection);\r\n  end;\r\n{$endif}\r\nend;\r\n\r\nprocedure GlobalFixupReferences;\r\n\r\nbegin\r\n  If (NeedResolving=Nil) then\r\n    Exit;\r\n{$ifdef FPC_HAS_FEATURE_THREADING}\r\n  GlobalNameSpace.BeginWrite;\r\n  try\r\n{$endif}\r\n    VisitResolveList(TResolveReferenceVisitor.Create);\r\n{$ifdef FPC_HAS_FEATURE_THREADING}\r\n  finally\r\n    GlobalNameSpace.EndWrite;\r\n  end;\r\n{$endif}\r\nend;\r\n\r\n\r\nprocedure GetFixupReferenceNames(Root: TComponent; Names: TStrings);\r\n\r\nbegin\r\n  If (NeedResolving=Nil) then\r\n    Exit;\r\n  VisitResolveList(TReferenceNamesVisitor.Create(Root,Names));\r\nend;\r\n\r\nprocedure GetFixupInstanceNames(Root: TComponent; const ReferenceRootName: string; Names: TStrings);\r\n\r\nbegin\r\n  If (NeedResolving=Nil) then\r\n    Exit;\r\n  VisitResolveList(TReferenceInstancesVisitor.Create(Root,ReferenceRootName,Names));\r\nend;\r\n\r\nprocedure ObjectBinaryToText(aInput, aOutput: TStream);\r\nbegin\r\n  ObjectBinaryToText(aInput,aOutput,oteLFM);\r\nend;\r\n\r\nprocedure ObjectBinaryToText(aInput, aOutput: TStream; aEncoding: TObjectTextEncoding);\r\n\r\nvar\r\n  Conv : TObjectStreamConverter;\r\n\r\nbegin\r\n  Conv:=TObjectStreamConverter.Create;\r\n  try\r\n    Conv.ObjectBinaryToText(aInput,aOutput,aEncoding);\r\n  finally\r\n    Conv.Free;\r\n  end;\r\nend;\r\n\r\nprocedure RedirectFixupReferences(Root: TComponent; const OldRootName, NewRootName: string);\r\n\r\nbegin\r\n  If (NeedResolving=Nil) then\r\n      Exit;\r\n  VisitResolveList(TRedirectReferenceVisitor.Create(Root,OldRootName,NewRootName));\r\nend;\r\n\r\nprocedure RemoveFixupReferences(Root: TComponent; const RootName: string);\r\n\r\nbegin\r\n  If (NeedResolving=Nil) then\r\n      Exit;\r\n  VisitResolveList(TRemoveReferenceVisitor.Create(Root,RootName));\r\nend;\r\n\r\n\r\n{ TUnresolvedReference }\r\n\r\nFunction TUnresolvedReference.Resolve(Instance : TPersistent) : Boolean;\r\n\r\nVar\r\n  C : TComponent;\r\n\r\nbegin\r\n  C:=FindGlobalComponent(FGlobal);\r\n  Result:=(C<>Nil);\r\n  If Result then\r\n    begin\r\n    C:=FindNestedComponent(C,FRelative);\r\n    Result:=C<>Nil;\r\n    If Result then\r\n      SetObjectProp(Instance, FPropInfo,C);\r\n    end;\r\nend;\r\n\r\nFunction TUnresolvedReference.RootMatches(ARoot : TComponent) : Boolean; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n\r\nbegin\r\n  Result:=(ARoot=Nil) or (ARoot=FRoot);\r\nend;\r\n\r\nFunction TUnResolvedReference.NextRef : TUnresolvedReference;\r\n\r\nbegin\r\n  Result:=TUnresolvedReference(Next);\r\nend;\r\n\r\n{ TUnResolvedInstance }\r\n\r\ndestructor TUnResolvedInstance.Destroy;\r\nbegin\r\n  FUnresolved.Free;\r\n  inherited Destroy;\r\nend;\r\n\r\nfunction TUnResolvedInstance.AddReference(ARoot: TComponent; APropInfo : TTypeMemberProperty; AGlobal, ARelative: String): TUnresolvedReference;\r\nbegin\r\n  If (FUnResolved=Nil) then\r\n    FUnResolved:=TLinkedList.Create(TUnresolvedReference);\r\n  Result:=FUnResolved.Add as TUnresolvedReference;\r\n  Result.FGlobal:=AGLobal;\r\n  Result.FRelative:=ARelative;\r\n  Result.FPropInfo:=APropInfo;\r\n  Result.FRoot:=ARoot;\r\nend;\r\n\r\nFunction TUnResolvedInstance.RootUnresolved : TUnresolvedReference;\r\n\r\nbegin\r\n  Result:=Nil;\r\n  If Assigned(FUnResolved) then\r\n    Result:=TUnresolvedReference(FUnResolved.Root);\r\nend;\r\n\r\nFunction TUnResolvedInstance.ResolveReferences:Boolean;\r\n\r\nVar\r\n  R,RN : TUnresolvedReference;\r\n\r\nbegin\r\n  R:=RootUnResolved;\r\n  While (R<>Nil) do\r\n    begin\r\n    RN:=R.NextRef;\r\n    If R.Resolve(Self.Instance) then\r\n      FUnresolved.RemoveItem(R,True);\r\n    R:=RN;\r\n    end;\r\n  Result:=RootUnResolved=Nil;\r\nend;\r\n\r\n{ TReferenceNamesVisitor }\r\n\r\nConstructor TReferenceNamesVisitor.Create(ARoot : TComponent;AList : TStrings);\r\n\r\nbegin\r\n  FRoot:=ARoot;\r\n  FList:=AList;\r\nend;\r\n\r\nFunction TReferenceNamesVisitor.Visit(Item : TLinkedListItem) : Boolean;\r\n\r\nVar\r\n  R : TUnresolvedReference;\r\n\r\nbegin\r\n  R:=TUnResolvedInstance(Item).RootUnresolved;\r\n  While (R<>Nil) do\r\n    begin\r\n    If R.RootMatches(FRoot) then\r\n      If (FList.IndexOf(R.FGlobal)=-1) then\r\n        FList.Add(R.FGlobal);\r\n    R:=R.NextRef;\r\n    end;\r\n  Result:=True;\r\nend;\r\n\r\n{ TReferenceInstancesVisitor }\r\n\r\nConstructor TReferenceInstancesVisitor.Create(ARoot : TComponent; Const ARef : String;AList : TStrings);\r\n\r\nbegin\r\n  FRoot:=ARoot;\r\n  FRef:=UpperCase(ARef);\r\n  FList:=AList;\r\nend;\r\n\r\nFunction TReferenceInstancesVisitor.Visit(Item : TLinkedListItem) : Boolean;\r\n\r\nVar\r\n  R : TUnresolvedReference;\r\n\r\nbegin\r\n  R:=TUnResolvedInstance(Item).RootUnresolved;\r\n  While (R<>Nil) do\r\n    begin\r\n    If (FRoot=R.FRoot) and (FRef=UpperCase(R.FGLobal)) Then\r\n      If Flist.IndexOf(R.FRelative)=-1 then\r\n        Flist.Add(R.FRelative);\r\n    R:=R.NextRef;\r\n    end;\r\n  Result:=True;\r\nend;\r\n\r\n{ TRedirectReferenceVisitor }\r\n\r\nConstructor TRedirectReferenceVisitor.Create(ARoot : TComponent; Const AOld,ANew  : String);\r\n\r\nbegin\r\n  FRoot:=ARoot;\r\n  FOld:=UpperCase(AOld);\r\n  FNew:=ANew;\r\nend;\r\n\r\nFunction TRedirectReferenceVisitor.Visit(Item : TLinkedListItem) : Boolean;\r\n\r\nVar\r\n  R : TUnresolvedReference;\r\n\r\nbegin\r\n  R:=TUnResolvedInstance(Item).RootUnresolved;\r\n  While (R<>Nil) do\r\n    begin\r\n    If R.RootMatches(FRoot) and (FOld=UpperCase(R.FGLobal)) Then\r\n      R.FGlobal:=FNew;\r\n    R:=R.NextRef;\r\n    end;\r\n  Result:=True;\r\nend;\r\n\r\n{ TRemoveReferenceVisitor }\r\n\r\nConstructor TRemoveReferenceVisitor.Create(ARoot : TComponent; Const ARef  : String);\r\n\r\nbegin\r\n  FRoot:=ARoot;\r\n  FRef:=UpperCase(ARef);\r\nend;\r\n\r\nFunction TRemoveReferenceVisitor.Visit(Item : TLinkedListItem) : Boolean;\r\n\r\nVar\r\n  I : Integer;\r\n  UI : TUnResolvedInstance;\r\n  R : TUnresolvedReference;\r\n  L : TFPList;\r\n\r\nbegin\r\n  UI:=TUnResolvedInstance(Item);\r\n  R:=UI.RootUnresolved;\r\n  L:=Nil;\r\n  Try\r\n    // Collect all matches.\r\n    While (R<>Nil) do\r\n      begin\r\n      If R.RootMatches(FRoot) and ((FRef = '') or (FRef=UpperCase(R.FGLobal))) Then\r\n        begin\r\n        If Not Assigned(L) then\r\n          L:=TFPList.Create;\r\n        L.Add(R);\r\n        end;\r\n      R:=R.NextRef;\r\n      end;\r\n    // Remove all matches.\r\n    IF Assigned(L) then\r\n      begin\r\n      For I:=0 to L.Count-1 do\r\n        UI.FUnresolved.RemoveItem(TLinkedListitem(L[i]),True);\r\n      end;\r\n    // If any references are left, leave them.\r\n    If UI.FUnResolved.Root=Nil then\r\n      begin\r\n      If List=Nil then\r\n        List:=TFPList.Create;\r\n      List.Add(UI);\r\n      end;\r\n  Finally\r\n    L.Free;\r\n  end;\r\n  Result:=True;\r\nend;\r\n\r\n{ TBuildListVisitor }\r\n\r\nProcedure TBuildListVisitor.Add(Item : TlinkedListItem);\r\n\r\nbegin\r\n  If (List=Nil) then\r\n    List:=TFPList.Create;\r\n  List.Add(Item);\r\nend;\r\n\r\nDestructor TBuildListVisitor.Destroy;\r\n\r\nVar\r\n  I : Integer;\r\n\r\nbegin\r\n  If Assigned(List) then\r\n    For I:=0 to List.Count-1 do\r\n      NeedResolving.RemoveItem(TLinkedListItem(List[I]),True);\r\n  FreeAndNil(List);\r\n  Inherited;\r\nend;\r\n\r\n{ TResolveReferenceVisitor }\r\n\r\nFunction TResolveReferenceVisitor.Visit(Item : TLinkedListItem) : Boolean;\r\n\r\nbegin\r\n  If TUnResolvedInstance(Item).ResolveReferences then\r\n    Add(Item);\r\n  Result:=True;\r\nend;\r\n\r\n\r\n\r\n{****************************************************************************}\r\n{*                             TREADER                                      *}\r\n{****************************************************************************}\r\n\r\n\r\nconstructor TReader.Create(Stream: TStream);\r\nbegin\r\n  inherited Create;\r\n  If (Stream=Nil) then\r\n    Raise EReadError.Create(SEmptyStreamIllegalReader);\r\n  FDriver := CreateDriver(Stream);\r\nend;\r\n\r\ndestructor TReader.Destroy;\r\nbegin\r\n  FDriver.Free;\r\n  inherited Destroy;\r\nend;\r\n\r\n\r\nprocedure TReader.FlushBuffer;\r\nbegin\r\n  Driver.FlushBuffer;\r\nend;\r\n\r\nfunction TReader.CreateDriver(Stream: TStream): TAbstractObjectReader;\r\nbegin\r\n  Result := TBinaryObjectReader.Create(Stream);\r\nend;\r\n\r\nprocedure TReader.BeginReferences;\r\nbegin\r\n  FLoaded := TFpList.Create;\r\nend;\r\n\r\nprocedure TReader.CheckValue(Value: TValueType);\r\nbegin\r\n  if FDriver.NextValue <> Value then\r\n    raise EReadError.Create(SInvalidPropertyValue)\r\n  else\r\n    FDriver.ReadValue;\r\nend;\r\n\r\nprocedure TReader.DefineProperty(const Name: String; AReadData: TReaderProc;\r\n  WriteData: TWriterProc; HasData: Boolean);\r\nbegin\r\n  if Assigned(AReadData) and SameText(Name,FPropName) then\r\n  begin\r\n    AReadData(Self);\r\n    SetLength(FPropName, 0);\r\n  end else if assigned(WriteData) and HasData then\r\n    ;\r\nend;\r\n\r\nprocedure TReader.DefineBinaryProperty(const Name: String;\r\n  AReadData, WriteData: TStreamProc; HasData: Boolean);\r\nvar\r\n  MemBuffer: TMemoryStream;\r\nbegin\r\n  if Assigned(AReadData) and SameText(Name,FPropName) then\r\n  begin\r\n    { Check if the next property really is a binary property}\r\n    if FDriver.NextValue <> vaBinary then\r\n    begin\r\n      FDriver.SkipValue;\r\n      FCanHandleExcepts := True;\r\n      raise EReadError.Create(SInvalidPropertyValue);\r\n    end else\r\n      FDriver.ReadValue;\r\n\r\n    MemBuffer := TMemoryStream.Create;\r\n    try\r\n      FDriver.ReadBinary(MemBuffer);\r\n      FCanHandleExcepts := True;\r\n      AReadData(MemBuffer);\r\n    finally\r\n      MemBuffer.Free;\r\n    end;\r\n    SetLength(FPropName, 0);\r\n  end else if assigned(WriteData) and HasData then ;\r\nend;\r\n\r\nfunction TReader.EndOfList: Boolean;\r\nbegin\r\n  Result := FDriver.NextValue = vaNull;\r\nend;\r\n\r\nprocedure TReader.EndReferences;\r\nbegin\r\n  FLoaded.Free;\r\n  FLoaded := nil;\r\nend;\r\n\r\nfunction TReader.Error(const Message: String): Boolean;\r\nbegin\r\n  Result := False;\r\n  if Assigned(FOnError) then\r\n    FOnError(Self, Message, Result);\r\nend;\r\n\r\nfunction TReader.FindMethod(ARoot: TComponent; const AMethodName: String): CodePointer;\r\nvar\r\n  ErrorResult: Boolean;\r\nbegin\r\n  Result:=nil;\r\n  if (ARoot=Nil) or (aMethodName='') then\r\n    exit;\r\n  Result := ARoot.MethodAddress(AMethodName);\r\n  ErrorResult := Result = nil;\r\n\r\n  { always give the OnFindMethod callback a chance to locate the method }\r\n  if Assigned(FOnFindMethod) then\r\n    FOnFindMethod(Self, AMethodName, Result, ErrorResult);\r\n\r\n  if ErrorResult then\r\n    raise EReadError.Create(SInvalidPropertyValue);\r\nend;\r\n\r\nprocedure TReader.DoFixupReferences;\r\n\r\nVar\r\n  R,RN : TLocalUnresolvedReference;\r\n  G : TUnresolvedInstance;\r\n  Ref : String;\r\n  C : TComponent;\r\n  P : integer;\r\n  L : TLinkedList;\r\n\r\nbegin\r\n  If Assigned(FFixups) then\r\n    begin\r\n    L:=TLinkedList(FFixups);\r\n    R:=TLocalUnresolvedReference(L.Root);\r\n    While (R<>Nil) do\r\n      begin\r\n      RN:=TLocalUnresolvedReference(R.Next);\r\n      Ref:=R.FRelative;\r\n      If Assigned(FOnReferenceName) then\r\n        FOnReferenceName(Self,Ref);\r\n      C:=FindNestedComponent(R.FRoot,Ref);\r\n      If Assigned(C) then\r\n        if R.FPropInfo.TypeInfo.Kind = tkInterface then\r\n          SetInterfaceProp(R.FInstance,R.FPropInfo,C)\r\n        else\r\n          SetObjectProp(R.FInstance,R.FPropInfo,C)\r\n      else\r\n        begin\r\n        P:=Pos('.',R.FRelative);\r\n        If (P<>0) then\r\n          begin\r\n          G:=AddToResolveList(R.FInstance);\r\n          G.Addreference(R.FRoot,R.FPropInfo,Copy(R.FRelative,1,P-1),Copy(R.FRelative,P+1,Length(R.FRelative)-P));\r\n          end;\r\n        end;\r\n      L.RemoveItem(R,True);\r\n      R:=RN;\r\n      end;\r\n    FreeAndNil(FFixups);\r\n    end;\r\nend;\r\n\r\nprocedure TReader.FixupReferences;\r\nvar\r\n  i: Integer;\r\nbegin\r\n  DoFixupReferences;\r\n  GlobalFixupReferences;\r\n  for i := 0 to FLoaded.Count - 1 do\r\n    TComponent(FLoaded[I]).Loaded;\r\nend;\r\n\r\n\r\nfunction TReader.NextValue: TValueType;\r\nbegin\r\n  Result := FDriver.NextValue;\r\nend;\r\n\r\nprocedure TReader.Read(var Buffer : TBytes; Count: LongInt);\r\nbegin\r\n  //This should give an exception if read is not implemented (i.e. TTextObjectReader)\r\n  //but should work with TBinaryObjectReader.\r\n  Driver.Read(Buffer, Count);\r\nend;\r\n\r\nprocedure TReader.PropertyError;\r\nbegin\r\n  FDriver.SkipValue;\r\n  raise EReadError.CreateFmt(SUnknownProperty,[FPropName]);\r\nend;\r\n\r\nfunction TReader.ReadBoolean: Boolean;\r\nvar\r\n  ValueType: TValueType;\r\nbegin\r\n  ValueType := FDriver.ReadValue;\r\n  if ValueType = vaTrue then\r\n    Result := True\r\n  else if ValueType = vaFalse then\r\n    Result := False\r\n  else\r\n    raise EReadError.Create(SInvalidPropertyValue);\r\nend;\r\n\r\nfunction TReader.ReadChar: Char;\r\nvar\r\n  s: String;\r\nbegin\r\n  s := ReadString;\r\n  if Length(s) = 1 then\r\n    Result := s[1]\r\n  else\r\n    raise EReadError.Create(SInvalidPropertyValue);\r\nend;\r\n\r\nfunction TReader.ReadWideChar: WideChar;\r\n\r\nvar\r\n  W: WideString;\r\n\r\nbegin\r\n  W := ReadWideString;\r\n  if Length(W) = 1 then\r\n    Result := W[1]\r\n  else\r\n    raise EReadError.Create(SInvalidPropertyValue);\r\nend;\r\n\r\nfunction TReader.ReadUnicodeChar: UnicodeChar;\r\n\r\nvar\r\n  U: UnicodeString;\r\n\r\nbegin\r\n  U := ReadUnicodeString;\r\n  if Length(U) = 1 then\r\n    Result := U[1]\r\n  else\r\n    raise EReadError.Create(SInvalidPropertyValue);\r\nend;\r\n\r\nprocedure TReader.ReadCollection(Collection: TCollection);\r\nvar\r\n  Item: TCollectionItem;\r\nbegin\r\n  Collection.BeginUpdate;\r\n  if not EndOfList then\r\n    Collection.Clear;\r\n  while not EndOfList do begin\r\n    ReadListBegin;\r\n    Item := Collection.Add;\r\n    while NextValue<>vaNull do\r\n      ReadProperty(Item);\r\n    ReadListEnd;\r\n  end;\r\n  Collection.EndUpdate;\r\n  ReadListEnd;\r\nend;\r\n\r\nfunction TReader.ReadComponent(Component: TComponent): TComponent;\r\nvar\r\n  Flags: TFilerFlags;\r\n\r\n  function Recover(E : Exception; var aComponent: TComponent): Boolean;\r\n  begin\r\n    Result := False;\r\n    if not ((ffInherited in Flags) or Assigned(Component)) then\r\n      aComponent.Free;\r\n    aComponent := nil;\r\n    FDriver.SkipComponent(False);\r\n    Result := Error(E.Message);\r\n  end;\r\n\r\nvar\r\n  CompClassName, Name: String;\r\n  n, ChildPos: Integer;\r\n  SavedParent, SavedLookupRoot: TComponent;\r\n  ComponentClass: TComponentClass;\r\n  C, NewComponent: TComponent;\r\n  SubComponents: TList;\r\nbegin\r\n  FDriver.BeginComponent(Flags, ChildPos, CompClassName, Name);\r\n  SavedParent := Parent;\r\n  SavedLookupRoot := FLookupRoot;\r\n  SubComponents := nil;\r\n  try\r\n    Result := Component;\r\n    if not Assigned(Result) then\r\n      try\r\n        if ffInherited in Flags then\r\n        begin\r\n          { Try to locate the existing ancestor component }\r\n\r\n          if Assigned(FLookupRoot) then\r\n            Result := FLookupRoot.FindComponent(Name)\r\n          else\r\n            Result := nil;\r\n\r\n          if not Assigned(Result) then\r\n          begin\r\n            if Assigned(FOnAncestorNotFound) then\r\n              FOnAncestorNotFound(Self, Name,\r\n                FindComponentClass(CompClassName), Result);\r\n            if not Assigned(Result) then\r\n              raise EReadError.CreateFmt(SAncestorNotFound, [Name]);\r\n          end;\r\n\r\n          Parent := Result.GetParentComponent;\r\n          if not Assigned(Parent) then\r\n            Parent := Root;\r\n        end else\r\n        begin\r\n          Result := nil;\r\n          ComponentClass := FindComponentClass(CompClassName);\r\n          if Assigned(FOnCreateComponent) then\r\n            FOnCreateComponent(Self, ComponentClass, Result);\r\n          if not Assigned(Result) then\r\n          begin\r\n           asm\r\n           NewComponent = Object.create(ComponentClass);\r\n           NewComponent.$init();\r\n           end;\r\n            if ffInline in Flags then\r\n              NewComponent.FComponentState :=\r\n                NewComponent.FComponentState + [csLoading, csInline];\r\n            NewComponent.Create(Owner);\r\n            NewComponent.AfterConstruction;\r\n\r\n            { Don't set Result earlier because else we would come in trouble\r\n              with the exception recover mechanism! (Result should be NIL if\r\n              an error occurred) }\r\n            Result := NewComponent;\r\n          end;\r\n          Include(Result.FComponentState, csLoading);\r\n        end;\r\n      except\r\n        On E: Exception do\r\n          if not Recover(E,Result) then\r\n            raise;\r\n      end;\r\n\r\n    if Assigned(Result) then\r\n      try\r\n        Include(Result.FComponentState, csLoading);\r\n\r\n        { create list of subcomponents and set loading}\r\n        SubComponents := TList.Create;\r\n        for n := 0 to Result.ComponentCount - 1 do\r\n        begin\r\n          C := Result.Components[n];\r\n          if csSubcomponent in C.ComponentStyle\r\n          then begin\r\n            SubComponents.Add(C);\r\n            Include(C.FComponentState, csLoading);\r\n          end;\r\n        end;\r\n\r\n        if not (ffInherited in Flags) then\r\n          try\r\n            Result.SetParentComponent(Parent);\r\n            if Assigned(FOnSetName) then\r\n              FOnSetName(Self, Result, Name);\r\n            Result.Name := Name;\r\n            if FindGlobalComponent(Name) = Result then\r\n              Include(Result.FComponentState, csInline);\r\n          except\r\n            On E : Exception do\r\n              if not Recover(E,Result) then\r\n                raise;\r\n          end;\r\n        if not Assigned(Result) then\r\n          exit;\r\n        if csInline in Result.ComponentState then\r\n          FLookupRoot := Result;\r\n\r\n        { Read the component state }\r\n        Include(Result.FComponentState, csReading);\r\n        for n := 0 to Subcomponents.Count - 1 do\r\n          Include(TComponent(Subcomponents[n]).FComponentState, csReading);\r\n\r\n        Result.ReadState(Self);\r\n\r\n        Exclude(Result.FComponentState, csReading);\r\n        for n := 0 to Subcomponents.Count - 1 do\r\n          Exclude(TComponent(Subcomponents[n]).FComponentState, csReading);\r\n\r\n        if ffChildPos in Flags then\r\n          Parent.SetChildOrder(Result, ChildPos);\r\n\r\n        { Add component to list of loaded components, if necessary }\r\n        if (not ((ffInherited in Flags) or (csInline in Result.ComponentState))) or\r\n          (FLoaded.IndexOf(Result) < 0)\r\n          then begin\r\n            for n := 0 to Subcomponents.Count - 1 do\r\n              FLoaded.Add(Subcomponents[n]);\r\n            FLoaded.Add(Result);\r\n          end;\r\n      except\r\n        if ((ffInherited in Flags) or Assigned(Component)) then\r\n          Result.Free;\r\n        raise;\r\n      end;\r\n  finally\r\n    Parent := SavedParent;\r\n    FLookupRoot := SavedLookupRoot;\r\n    Subcomponents.Free;\r\n  end;\r\nend;\r\n\r\nprocedure TReader.ReadData(Instance: TComponent);\r\nvar\r\n  SavedOwner, SavedParent: TComponent;\r\n\r\nbegin\r\n  { Read properties }\r\n  while not EndOfList do\r\n    ReadProperty(Instance);\r\n  ReadListEnd;\r\n\r\n  { Read children }\r\n  SavedOwner := Owner;\r\n  SavedParent := Parent;\r\n  try\r\n    Owner := Instance.GetChildOwner;\r\n    if not Assigned(Owner) then\r\n      Owner := Root;\r\n    Parent := Instance.GetChildParent;\r\n\r\n    while not EndOfList do\r\n      ReadComponent(nil);\r\n    ReadListEnd;\r\n  finally\r\n    Owner := SavedOwner;\r\n    Parent := SavedParent;\r\n  end;\r\n\r\n  { Fixup references if necessary (normally only if this is the root) }\r\n  If (Instance=FRoot) then\r\n    DoFixupReferences;\r\nend;\r\n\r\nfunction TReader.ReadFloat: Extended;\r\nbegin\r\n  if FDriver.NextValue = vaExtended then\r\n  begin\r\n    ReadValue;\r\n    Result := FDriver.ReadFloat\r\n  end else\r\n    Result := ReadNativeInt;\r\nend;\r\n\r\nprocedure TReader.ReadSignature;\r\nbegin\r\n  FDriver.ReadSignature;\r\nend;\r\n\r\n\r\nfunction TReader.ReadCurrency: Currency;\r\nbegin\r\n  if FDriver.NextValue = vaCurrency then\r\n  begin\r\n    FDriver.ReadValue;\r\n    Result := FDriver.ReadCurrency;\r\n  end else\r\n    Result := ReadInteger;\r\nend;\r\n\r\n\r\nfunction TReader.ReadIdent: String;\r\nvar\r\n  ValueType: TValueType;\r\nbegin\r\n  ValueType := FDriver.ReadValue;\r\n  if ValueType in [vaIdent, vaNil, vaFalse, vaTrue, vaNull] then\r\n    Result := FDriver.ReadIdent(ValueType)\r\n  else\r\n    raise EReadError.Create(SInvalidPropertyValue);\r\nend;\r\n\r\n\r\nfunction TReader.ReadInteger: LongInt;\r\nbegin\r\n  case FDriver.ReadValue of\r\n    vaInt8:\r\n      Result := FDriver.ReadInt8;\r\n    vaInt16:\r\n      Result := FDriver.ReadInt16;\r\n    vaInt32:\r\n      Result := FDriver.ReadInt32;\r\n  else\r\n    raise EReadError.Create(SInvalidPropertyValue);\r\n  end;\r\nend;\r\n\r\nfunction TReader.ReadNativeInt: NativeInt;\r\nbegin\r\n  if FDriver.NextValue = vaInt64 then\r\n  begin\r\n    FDriver.ReadValue;\r\n    Result := FDriver.ReadNativeInt;\r\n  end else\r\n    Result := ReadInteger;\r\nend;\r\n\r\nfunction TReader.ReadSet(EnumType: Pointer): Integer;\r\nbegin\r\n  if FDriver.NextValue = vaSet then\r\n    begin\r\n      FDriver.ReadValue;\r\n      Result := FDriver.ReadSet(enumtype);\r\n    end\r\n  else\r\n    Result := ReadInteger;\r\nend;\r\n\r\nprocedure TReader.ReadListBegin;\r\nbegin\r\n  CheckValue(vaList);\r\nend;\r\n\r\nprocedure TReader.ReadListEnd;\r\nbegin\r\n  CheckValue(vaNull);\r\nend;\r\n\r\nfunction TReader.ReadVariant: JSValue;\r\nvar\r\n  nv: TValueType;\r\nbegin\r\n  nv:=NextValue;\r\n  case nv of\r\n    vaNil:\r\n      begin\r\n        Result:=Undefined;\r\n        readvalue;\r\n      end;\r\n    vaNull:\r\n      begin\r\n        Result:=Nil;\r\n        readvalue;\r\n      end;\r\n    { all integer sizes must be split for big endian systems }\r\n    vaInt8,vaInt16,vaInt32:\r\n      begin\r\n        Result:=ReadInteger;\r\n      end;\r\n    vaInt64:\r\n      begin\r\n        Result:=ReadNativeInt;\r\n      end;\r\n{\r\n    vaQWord:\r\n      begin\r\n        Result:=QWord(ReadInt64);\r\n      end;\r\n}    vaFalse,vaTrue:\r\n      begin\r\n        Result:=(nv<>vaFalse);\r\n        readValue;\r\n      end;\r\n    vaCurrency:\r\n      begin\r\n        Result:=ReadCurrency;\r\n      end;\r\n    vaDouble:\r\n      begin\r\n        Result:=ReadFloat;\r\n      end;\r\n    vaString:\r\n      begin\r\n        Result:=ReadString;\r\n      end;\r\n    else\r\n      raise EReadError.CreateFmt(SUnsupportedPropertyVariantType, [Ord(nv)]);\r\n  end;\r\nend;\r\n\r\nprocedure TReader.ReadProperty(AInstance: TPersistent);\r\nvar\r\n  Path: String;\r\n  Instance: TPersistent;\r\n  PropInfo: TTypeMemberProperty;\r\n  Obj: TObject;\r\n  Name: String;\r\n  Skip: Boolean;\r\n  Handled: Boolean;\r\n  OldPropName: String;\r\n  DotPos : String;\r\n  NextPos: Integer;\r\n\r\n  function HandleMissingProperty(IsPath: Boolean): boolean;\r\n  begin\r\n    Result:=true;\r\n    if Assigned(OnPropertyNotFound) then begin\r\n      // user defined property error handling\r\n      OldPropName:=FPropName;\r\n      Handled:=false;\r\n      Skip:=false;\r\n      OnPropertyNotFound(Self,Instance,FPropName,IsPath,Handled,Skip);\r\n      if Handled and (not Skip) and (OldPropName<>FPropName) then\r\n        // try alias property\r\n        PropInfo := GetPropInfo(Instance.ClassType, FPropName);\r\n      if Skip then begin\r\n        FDriver.SkipValue;\r\n        Result:=false;\r\n        exit;\r\n      end;\r\n    end;\r\n  end;\r\n\r\nbegin\r\n  try\r\n    Path := FDriver.BeginProperty;\r\n    try\r\n      Instance := AInstance;\r\n      FCanHandleExcepts := True;\r\n      DotPos := Path;\r\n      while True do\r\n      begin\r\n        NextPos := Pos('.',DotPos);\r\n        if NextPos>0 then\r\n          FPropName := Copy(DotPos, 1, NextPos-1)\r\n        else\r\n        begin\r\n          FPropName := DotPos;\r\n          break;\r\n        end;\r\n        Delete(DotPos,1,NextPos);\r\n\r\n        PropInfo := GetPropInfo(Instance.ClassType, FPropName);\r\n        if not Assigned(PropInfo) then begin\r\n          if not HandleMissingProperty(true) then exit;\r\n          if not Assigned(PropInfo) then\r\n            PropertyError;\r\n        end;\r\n\r\n        if PropInfo.TypeInfo.Kind = tkClass then\r\n          Obj := TObject(GetObjectProp(Instance, PropInfo))\r\n        //else if PropInfo^.PropType^.Kind = tkInterface then\r\n        //  Obj := TObject(GetInterfaceProp(Instance, PropInfo))\r\n        else\r\n          Obj := nil;\r\n\r\n        if not (Obj is TPersistent) then\r\n        begin\r\n          { All path elements must be persistent objects! }\r\n          FDriver.SkipValue;\r\n          raise EReadError.Create(SInvalidPropertyPath);\r\n        end;\r\n        Instance := TPersistent(Obj);\r\n      end;\r\n\r\n      PropInfo := GetPropInfo(Instance.ClassType, FPropName);\r\n      if Assigned(PropInfo) then\r\n        ReadPropValue(Instance, PropInfo)\r\n      else\r\n      begin\r\n        FCanHandleExcepts := False;\r\n        Instance.DefineProperties(Self);\r\n        FCanHandleExcepts := True;\r\n        if Length(FPropName) > 0 then begin\r\n          if not HandleMissingProperty(false) then exit;\r\n          if not Assigned(PropInfo) then\r\n            PropertyError;\r\n        end;\r\n      end;\r\n    except\r\n      on e: Exception do\r\n      begin\r\n        SetLength(Name, 0);\r\n        if AInstance.InheritsFrom(TComponent) then\r\n          Name := TComponent(AInstance).Name;\r\n        if Length(Name) = 0 then\r\n          Name := AInstance.ClassName;\r\n        raise EReadError.CreateFmt(SPropertyException, [Name, '.', Path, e.Message]);\r\n      end;\r\n    end;\r\n  except\r\n    on e: Exception do\r\n      if not FCanHandleExcepts or not Error(E.Message) then\r\n        raise;\r\n  end;\r\nend;\r\n\r\nprocedure TReader.ReadPropValue(Instance: TPersistent; PropInfo: TTypeMemberProperty);\r\nconst\r\n  NullMethod: TMethod = (Code: nil; Data: nil);\r\nvar\r\n  PropType: TTypeInfo;\r\n  Value: LongInt;\r\n{  IdentToIntFn: TIdentToInt; }\r\n  Ident: String;\r\n  Method: TMethod;\r\n  Handled: Boolean;\r\n  TmpStr: String;\r\nbegin\r\n  if (PropInfo.Setter='') then\r\n    raise EReadError.Create(SReadOnlyProperty);\r\n\r\n  PropType := PropInfo.TypeInfo;\r\n  case PropType.Kind of\r\n    tkInteger:\r\n      case FDriver.NextValue of\r\n        vaIdent :\r\n          begin\r\n          Ident := ReadIdent;\r\n          if GlobalIdentToInt(Ident,Value) then\r\n            SetOrdProp(Instance, PropInfo, Value)\r\n          else\r\n            raise EReadError.Create(SInvalidPropertyValue);\r\n          end;\r\n        vaNativeInt :\r\n          SetOrdProp(Instance, PropInfo, ReadNativeInt);\r\n        vaCurrency:\r\n          SetFloatProp(Instance, PropInfo, ReadCurrency);\r\n      else\r\n        SetOrdProp(Instance, PropInfo, ReadInteger);\r\n      end;\r\n    tkBool:\r\n      SetBoolProp(Instance, PropInfo, ReadBoolean);\r\n    tkChar:\r\n      SetOrdProp(Instance, PropInfo, Ord(ReadChar));\r\n    tkEnumeration:\r\n      begin\r\n        Value := GetEnumValue(TTypeInfoEnum(PropType), ReadIdent);\r\n        if Value = -1 then\r\n          raise EReadError.Create(SInvalidPropertyValue);\r\n        SetOrdProp(Instance, PropInfo, Value);\r\n      end;\r\n{$ifndef FPUNONE}\r\n    tkFloat:\r\n      SetFloatProp(Instance, PropInfo, ReadFloat);\r\n{$endif}\r\n    tkSet:\r\n      begin\r\n        CheckValue(vaSet);\r\n        if TTypeInfoSet(PropType).CompType.Kind=tkEnumeration then\r\n          SetOrdProp(Instance, PropInfo, FDriver.ReadSet(TTypeInfoEnum(TTypeInfoSet(PropType).CompType)));\r\n      end;\r\n    tkMethod, tkRefToProcVar:\r\n      if FDriver.NextValue = vaNil then\r\n      begin\r\n        FDriver.ReadValue;\r\n        SetMethodProp(Instance, PropInfo, NullMethod);\r\n      end else\r\n      begin\r\n        Handled:=false;\r\n        Ident:=ReadIdent;\r\n        if Assigned(OnSetMethodProperty) then\r\n          OnSetMethodProperty(Self,Instance,PropInfo,Ident,Handled);\r\n        if not Handled then begin\r\n          Method.Code := FindMethod(Root, Ident);\r\n          Method.Data := Root;\r\n          if Assigned(Method.Code) then\r\n            SetMethodProp(Instance, PropInfo, Method);\r\n        end;\r\n      end;\r\n    tkString:\r\n      begin\r\n        TmpStr:=ReadString;\r\n        if Assigned(FOnReadStringProperty) then\r\n          FOnReadStringProperty(Self,Instance,PropInfo,TmpStr);\r\n        SetStrProp(Instance, PropInfo, TmpStr);\r\n      end;\r\n    tkJSValue:\r\n      begin\r\n        SetJSValueProp(Instance,PropInfo,ReadVariant);\r\n      end;\r\n    tkClass, tkInterface:\r\n      case FDriver.NextValue of\r\n        vaNil:\r\n          begin\r\n            FDriver.ReadValue;\r\n            SetObjectProp(Instance, PropInfo, nil)\r\n          end;\r\n        vaCollection:\r\n          begin\r\n            FDriver.ReadValue;\r\n            ReadCollection(TCollection(GetObjectProp(Instance, PropInfo)));\r\n          end\r\n        else\r\n          begin\r\n          If Not Assigned(FFixups) then\r\n            FFixups:=TLinkedList.Create(TLocalUnresolvedReference);\r\n          With TLocalUnresolvedReference(TLinkedList(FFixups).Add) do\r\n            begin\r\n            FInstance:=Instance;\r\n            FRoot:=Root;\r\n            FPropInfo:=PropInfo;\r\n            FRelative:=ReadIdent;\r\n            end;\r\n          end;\r\n      end;\r\n    {tkint64:\r\n      SetInt64Prop(Instance, PropInfo, ReadInt64);}\r\n    else\r\n      raise EReadError.CreateFmt(SUnknownPropertyType, [Str(PropType.Kind)]);\r\n  end;\r\nend;\r\n\r\nfunction TReader.ReadRootComponent(ARoot: TComponent): TComponent;\r\nvar\r\n  Dummy, i: Integer;\r\n  Flags: TFilerFlags;\r\n  CompClassName, CompName, ResultName: String;\r\nbegin\r\n  FDriver.BeginRootComponent;\r\n  Result := nil;\r\n  {!!!: GlobalNameSpace.BeginWrite;  // Loading from stream adds to name space\r\n  try}\r\n    try\r\n      FDriver.BeginComponent(Flags, Dummy, CompClassName, CompName);\r\n      if not Assigned(ARoot) then\r\n      begin\r\n        { Read the class name and the object name and create a new object: }\r\n        Result := TComponentClass(FindClass(CompClassName)).Create(nil);\r\n        Result.Name := CompName;\r\n      end else\r\n      begin\r\n        Result := ARoot;\r\n\r\n        if not (csDesigning in Result.ComponentState) then\r\n        begin\r\n          Result.FComponentState :=\r\n            Result.FComponentState + [csLoading, csReading];\r\n\r\n          { We need an unique name }\r\n          i := 0;\r\n          { Don't use Result.Name directly, as this would influence\r\n            FindGlobalComponent in successive loop runs }\r\n          ResultName := CompName;\r\n            while Assigned(FindGlobalComponent(ResultName)) do\r\n            begin\r\n              Inc(i);\r\n              ResultName := CompName + '_' + IntToStr(i);\r\n            end;\r\n            Result.Name := ResultName;\r\n        end;\r\n      end;\r\n\r\n      FRoot := Result;\r\n      FLookupRoot := Result;\r\n      if Assigned(GlobalLoaded) then\r\n        FLoaded := GlobalLoaded\r\n      else\r\n        FLoaded := TFpList.Create;\r\n\r\n      try\r\n        if FLoaded.IndexOf(FRoot) < 0 then\r\n          FLoaded.Add(FRoot);\r\n        FOwner := FRoot;\r\n        FRoot.FComponentState := FRoot.FComponentState + [csLoading, csReading];\r\n        FRoot.ReadState(Self);\r\n        Exclude(FRoot.FComponentState, csReading);\r\n\r\n        if not Assigned(GlobalLoaded) then\r\n          for i := 0 to FLoaded.Count - 1 do\r\n            TComponent(FLoaded[i]).Loaded;\r\n\r\n      finally\r\n        if not Assigned(GlobalLoaded) then\r\n          FLoaded.Free;\r\n        FLoaded := nil;\r\n      end;\r\n      GlobalFixupReferences;\r\n    except\r\n      RemoveFixupReferences(ARoot, '');\r\n      if not Assigned(ARoot) then\r\n        Result.Free;\r\n      raise;\r\n    end;\r\n  {finally\r\n    GlobalNameSpace.EndWrite;\r\n  end;}\r\nend;\r\n\r\nprocedure TReader.ReadComponents(AOwner, AParent: TComponent;\r\n  Proc: TReadComponentsProc);\r\nvar\r\n  Component: TComponent;\r\nbegin\r\n  Root := AOwner;\r\n  Owner := AOwner;\r\n  Parent := AParent;\r\n  BeginReferences;\r\n  try\r\n    while not EndOfList do\r\n    begin\r\n      FDriver.BeginRootComponent;\r\n      Component := ReadComponent(nil);\r\n      if Assigned(Proc) then\r\n        Proc(Component);\r\n    end;\r\n    ReadListEnd;\r\n    FixupReferences;\r\n  finally\r\n    EndReferences;\r\n  end;\r\nend;\r\n\r\n\r\nfunction TReader.ReadString: String;\r\nvar\r\n  StringType: TValueType;\r\nbegin\r\n  StringType := FDriver.ReadValue;\r\n  if StringType=vaString then\r\n    Result := FDriver.ReadString(StringType)\r\n  else\r\n    raise EReadError.Create(SInvalidPropertyValue);\r\nend;\r\n\r\n\r\nfunction TReader.ReadWideString: WideString;\r\n\r\nbegin\r\n  Result:=ReadString;\r\nend;\r\n\r\nfunction TReader.ReadUnicodeString: UnicodeString;\r\n\r\nbegin\r\n  Result:=ReadString;\r\nend;\r\n\r\nfunction TReader.ReadValue: TValueType;\r\nbegin\r\n  Result := FDriver.ReadValue;\r\nend;\r\n\r\nprocedure TReader.CopyValue(Writer: TWriter);\r\n\r\n(*\r\nprocedure CopyBytes(Count: Integer);\r\n{  var\r\n    Buffer: array[0..1023] of Byte; }\r\n  begin\r\n{!!!:    while Count > 1024 do\r\n    begin\r\n      FDriver.Read(Buffer, 1024);\r\n      Writer.Driver.Write(Buffer, 1024);\r\n      Dec(Count, 1024);\r\n    end;\r\n    if Count > 0 then\r\n    begin\r\n      FDriver.Read(Buffer, Count);\r\n      Writer.Driver.Write(Buffer, Count);\r\n    end;}\r\n  end;\r\n*)\r\n\r\n{var\r\n  s: String;\r\n  Count: LongInt; }\r\nbegin\r\n  case FDriver.NextValue of\r\n    vaNull:\r\n      Writer.WriteIdent('NULL');\r\n    vaFalse:\r\n      Writer.WriteIdent('FALSE');\r\n    vaTrue:\r\n      Writer.WriteIdent('TRUE');\r\n    vaNil:\r\n      Writer.WriteIdent('NIL');\r\n    {!!!: vaList, vaCollection:\r\n      begin\r\n        Writer.WriteValue(FDriver.ReadValue);\r\n        while not EndOfList do\r\n          CopyValue(Writer);\r\n        ReadListEnd;\r\n        Writer.WriteListEnd;\r\n      end;}\r\n    vaInt8, vaInt16, vaInt32:\r\n      Writer.WriteInteger(ReadInteger);\r\n{$ifndef FPUNONE}\r\n    vaExtended:\r\n      Writer.WriteFloat(ReadFloat);\r\n{$endif}\r\n    vaString:\r\n      Writer.WriteString(ReadString);\r\n    vaIdent:\r\n      Writer.WriteIdent(ReadIdent);\r\n    {!!!: vaBinary, vaLString, vaWString:\r\n      begin\r\n        Writer.WriteValue(FDriver.ReadValue);\r\n        FDriver.Read(Count, SizeOf(Count));\r\n        Writer.Driver.Write(Count, SizeOf(Count));\r\n        CopyBytes(Count);\r\n      end;}\r\n    {!!!: vaSet:\r\n      Writer.WriteSet(ReadSet);}\r\n    {!!!: vaCurrency:\r\n      Writer.WriteCurrency(ReadCurrency);}\r\n    vaInt64:\r\n      Writer.WriteInteger(ReadNativeInt);\r\n  end;\r\nend;\r\n\r\nfunction TReader.FindComponentClass(const AClassName: String): TComponentClass;\r\n\r\nvar\r\n  PersistentClass: TPersistentClass;\r\n\r\n  function FindClassInFieldTable(Instance: TComponent): TComponentClass;\r\n  var\r\n    aClass: TClass;\r\n    i: longint;\r\n    ClassTI, MemberClassTI: TTypeInfoClass;\r\n    MemberTI: TTypeInfo;\r\n  begin\r\n    aClass:=Instance.ClassType;\r\n    while aClass<>nil do\r\n      begin\r\n      ClassTI:=typeinfo(aClass);\r\n      for i:=0 to ClassTI.FieldCount-1 do\r\n        begin\r\n        MemberTI:=ClassTI.GetField(i).TypeInfo;\r\n        if MemberTI.Kind=tkClass then\r\n          begin\r\n          MemberClassTI:=TTypeInfoClass(MemberTI);\r\n          if SameText(MemberClassTI.Name,aClassName)\r\n              and (MemberClassTI.ClassType is TComponent) then\r\n            exit(TComponentClass(MemberClassTI.ClassType));\r\n          end;\r\n        end;\r\n      aClass:=aClass.ClassParent;\r\n      end;\r\n  end;\r\n\r\nbegin\r\n  Result := nil;\r\n  Result:=FindClassInFieldTable(Root);\r\n\r\n  if (Result=nil) and assigned(LookupRoot) and (LookupRoot<>Root) then\r\n    Result:=FindClassInFieldTable(LookupRoot);\r\n\r\n  if (Result=nil) then begin\r\n    PersistentClass := GetClass(AClassName);\r\n    if Assigned(PersistentClass) and PersistentClass.InheritsFrom(TComponent) then\r\n      Result := TComponentClass(PersistentClass);\r\n  end;\r\n\r\n  if (Result=nil) and assigned(OnFindComponentClass) then\r\n    OnFindComponentClass(Self, AClassName, Result);\r\n\r\n  if (Result=nil) or (not Result.InheritsFrom(TComponent)) then\r\n    raise EClassNotFound.CreateFmt(SClassNotFound, [AClassName]);\r\nend;\r\n\r\n\r\n{ TAbstractObjectReader }\r\n\r\nprocedure TAbstractObjectReader.FlushBuffer;\r\nbegin\r\n  // Do nothing\r\nend;\r\n\r\n\r\n{\r\n    This file is part of the Free Component Library (FCL)\r\n    Copyright (c) 1999-2000 by the Free Pascal development team\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n\r\n\r\n{****************************************************************************}\r\n{*                         TBinaryObjectWriter                              *}\r\n{****************************************************************************}\r\n\r\n\r\nprocedure TBinaryObjectWriter.WriteWord(w : word);\r\nbegin\r\n  FStream.WriteBufferData(w);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteDWord(lw : longword);\r\nbegin\r\n  FStream.WriteBufferData(lw);\r\nend;\r\n\r\nconstructor TBinaryObjectWriter.Create(Stream: TStream);\r\nbegin\r\n  inherited Create;\r\n  If (Stream=Nil) then\r\n    Raise EWriteError.Create(SEmptyStreamIllegalWriter);\r\n  FStream := Stream;\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.BeginCollection;\r\nbegin\r\n  WriteValue(vaCollection);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteSignature;\r\n\r\nbegin\r\n  FStream.WriteBufferData(FilerSignatureInt);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.BeginComponent(Component: TComponent;\r\n  Flags: TFilerFlags; ChildPos: Integer);\r\nvar\r\n  Prefix: Byte;\r\nbegin\r\n\r\n  { Only write the flags if they are needed! }\r\n  if Flags <> [] then\r\n  begin\r\n    Prefix:=0;\r\n    if ffInherited in Flags then\r\n     Prefix:=Prefix or $01;\r\n    if ffChildPos in Flags then\r\n     Prefix:=Prefix or $02;\r\n    if ffInline in Flags then\r\n     Prefix:=Prefix or $04;\r\n    Prefix := Prefix  or $f0;\r\n    FStream.WriteBufferData(Prefix);\r\n    if ffChildPos in Flags then\r\n      WriteInteger(ChildPos);\r\n  end;\r\n\r\n  WriteStr(Component.ClassName);\r\n  WriteStr(Component.Name);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.BeginList;\r\nbegin\r\n  WriteValue(vaList);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.EndList;\r\nbegin\r\n  WriteValue(vaNull);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.BeginProperty(const PropName: String);\r\nbegin\r\n  WriteStr(PropName);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.EndProperty;\r\nbegin\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.FlushBuffer;\r\nbegin\r\n  // Do nothing;\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteBinary(const Buffer : TBytes; Count: LongInt);\r\nbegin\r\n  WriteValue(vaBinary);\r\n  WriteDWord(longword(Count));\r\n  FStream.Write(Buffer, Count);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteBoolean(Value: Boolean);\r\nbegin\r\n  if Value then\r\n    WriteValue(vaTrue)\r\n  else\r\n    WriteValue(vaFalse);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteFloat(const Value: Extended);\r\nbegin\r\n  WriteValue(vaDouble);\r\n  FStream.WriteBufferData(Value);\r\nend;\r\n\r\n\r\nprocedure TBinaryObjectWriter.WriteCurrency(const Value: Currency);\r\n\r\nVar\r\n  F : Double;\r\nbegin\r\n  WriteValue(vaCurrency);\r\n  F:=Value;\r\n  FStream.WriteBufferData(F);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteIdent(const Ident: string);\r\nbegin\r\n  { Check if Ident is a special identifier before trying to just write\r\n    Ident directly }\r\n  if UpperCase(Ident) = 'NIL' then\r\n    WriteValue(vaNil)\r\n  else if UpperCase(Ident) = 'FALSE' then\r\n    WriteValue(vaFalse)\r\n  else if UpperCase(Ident) = 'TRUE' then\r\n    WriteValue(vaTrue)\r\n  else if UpperCase(Ident) = 'NULL' then\r\n    WriteValue(vaNull) else\r\n  begin\r\n    WriteValue(vaIdent);\r\n    WriteStr(Ident);\r\n  end;\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteInteger(Value: NativeInt);\r\nvar\r\n  s: ShortInt;\r\n  i: SmallInt;\r\n  l: Longint;\r\nbegin\r\n  { Use the smallest possible integer type for the given value: }\r\n  if (Value >= -128) and (Value <= 127) then\r\n  begin\r\n    WriteValue(vaInt8);\r\n    s := Value;\r\n    FStream.WriteBufferData(s);\r\n  end else if (Value >= -32768) and (Value <= 32767) then\r\n  begin\r\n    WriteValue(vaInt16);\r\n    i := Value;\r\n    WriteWord(word(i));\r\n  end else if (Value >= -$80000000) and (Value <= $7fffffff) then\r\n  begin\r\n    WriteValue(vaInt32);\r\n    l := Value;\r\n    WriteDWord(longword(l));\r\n  end else\r\n  begin\r\n    WriteValue(vaInt64);\r\n    FStream.WriteBufferData(Value);\r\n  end;\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteNativeInt(Value: NativeInt);\r\nvar\r\n  s: Int8;\r\n  i: Int16;\r\n  l: Int32;\r\nbegin\r\n  { Use the smallest possible integer type for the given value: }\r\n  if (Value <= 127) then\r\n  begin\r\n    WriteValue(vaInt8);\r\n    s := Value;\r\n    FStream.WriteBufferData(s);\r\n  end else if (Value <= 32767) then\r\n  begin\r\n    WriteValue(vaInt16);\r\n    i := Value;\r\n    WriteWord(word(i));\r\n  end else if (Value <= $7fffffff) then\r\n  begin\r\n    WriteValue(vaInt32);\r\n    l := Value;\r\n    WriteDWord(longword(l));\r\n  end else\r\n  begin\r\n    WriteValue(vaQWord);\r\n    FStream.WriteBufferData(Value);\r\n  end;\r\nend;\r\n\r\n\r\nprocedure TBinaryObjectWriter.WriteMethodName(const Name: String);\r\nbegin\r\n  if Length(Name) > 0 then\r\n  begin\r\n    WriteValue(vaIdent);\r\n    WriteStr(Name);\r\n  end else\r\n    WriteValue(vaNil);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteSet(Value: LongInt; SetType: Pointer);\r\nvar\r\n  i: Integer;\r\n  b : Integer;\r\nbegin\r\n  WriteValue(vaSet);\r\n  B:=1;\r\n  for i:=0 to 31 do\r\n    begin\r\n    if (Value and b) <>0 then\r\n      begin\r\n      WriteStr(GetEnumName(PTypeInfo(SetType), i));\r\n      end;\r\n    b:=b shl 1;\r\n    end;\r\n  WriteStr('');\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteString(const Value: String);\r\n\r\nvar\r\n  i, len: Integer;\r\nbegin\r\n  len := Length(Value);\r\n  WriteValue(vaString);\r\n  WriteDWord(len);\r\n  For I:=1 to len do\r\n    FStream.WriteBufferData(Value[i]);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteWideString(const Value: WideString);\r\n\r\nbegin\r\n  WriteString(Value);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteUnicodeString(const Value: UnicodeString);\r\n\r\nbegin\r\n  WriteString(Value);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteVariant(const VarValue: JSValue);\r\nbegin\r\n  if isUndefined(varValue) then\r\n    WriteValue(vaNil)\r\n  else if IsNull(VarValue) then\r\n    WriteValue(vaNull)\r\n  else if IsNumber(VarValue) then\r\n    begin\r\n    if Frac(Double(varValue))=0 then\r\n      WriteInteger(NativeInt(VarValue))\r\n     else\r\n      WriteFloat(Double(varValue))\r\n    end\r\n  else if isBoolean(varValue) then\r\n    WriteBoolean(Boolean(VarValue))\r\n  else if isString(varValue) then\r\n    WriteString(String(VarValue))\r\n  else\r\n    raise EWriteError.Create(SUnsupportedPropertyVariantType);\r\nend;\r\n\r\n\r\nprocedure TBinaryObjectWriter.Write(const Buffer : TBytes; Count: LongInt);\r\n\r\nbegin\r\n  FStream.Write(Buffer,Count);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteValue(Value: TValueType);\r\nvar\r\n  b: uint8;\r\nbegin\r\n  b := uint8(Value);\r\n  FStream.WriteBufferData(b);\r\nend;\r\n\r\nprocedure TBinaryObjectWriter.WriteStr(const Value: String);\r\nvar\r\n  len,i: integer;\r\n  b: uint8;\r\nbegin\r\n  len:= Length(Value);\r\n  if len > 255 then\r\n    len := 255;\r\n  b := len;\r\n  FStream.WriteBufferData(b);\r\n  For I:=1 to len do\r\n    FStream.WriteBufferData(Value[i]);\r\nend;\r\n\r\n\r\n\r\n{****************************************************************************}\r\n{*                             TWriter                                      *}\r\n{****************************************************************************}\r\n\r\n\r\nconstructor TWriter.Create(ADriver: TAbstractObjectWriter);\r\nbegin\r\n  inherited Create;\r\n  FDriver := ADriver;\r\nend;\r\n\r\nconstructor TWriter.Create(Stream: TStream);\r\nbegin\r\n  inherited Create;\r\n  If (Stream=Nil) then\r\n    Raise EWriteError.Create(SEmptyStreamIllegalWriter);\r\n  FDriver := CreateDriver(Stream);\r\n  FDestroyDriver := True;\r\nend;\r\n\r\ndestructor TWriter.Destroy;\r\nbegin\r\n  if FDestroyDriver then\r\n    FDriver.Free;\r\n  inherited Destroy;\r\nend;\r\n\r\nfunction TWriter.CreateDriver(Stream: TStream): TAbstractObjectWriter;\r\nbegin\r\n  Result := TBinaryObjectWriter.Create(Stream);\r\nend;\r\n\r\nType\r\n  TPosComponent = Class(TObject)\r\n  Private\r\n    FPos : Integer;\r\n    FComponent : TComponent;\r\n  Public\r\n    Constructor Create(APos : Integer; AComponent : TComponent);\r\n  end;\r\n\r\nConstructor TPosComponent.Create(APos : Integer; AComponent : TComponent);\r\n\r\nbegin\r\n  FPos:=APos;\r\n  FComponent:=AComponent;\r\nend;\r\n\r\n// Used as argument for calls to TComponent.GetChildren:\r\nprocedure TWriter.AddToAncestorList(Component: TComponent);\r\nbegin\r\n  FAncestors.AddObject(Component.Name,TPosComponent.Create(FAncestors.Count,Component));\r\nend;\r\n\r\nprocedure TWriter.DefineProperty(const Name: String;\r\n  ReadData: TReaderProc; AWriteData: TWriterProc; HasData: Boolean);\r\nbegin\r\n  if HasData and Assigned(AWriteData) then\r\n  begin\r\n    // Write the property name and then the data itself\r\n    Driver.BeginProperty(FPropPath + Name);\r\n    AWriteData(Self);\r\n    Driver.EndProperty;\r\n  end else if assigned(ReadData) then ;\r\nend;\r\n\r\nprocedure TWriter.DefineBinaryProperty(const Name: String;\r\n  ReadData, AWriteData: TStreamProc; HasData: Boolean);\r\nbegin\r\n  if HasData and Assigned(AWriteData) then\r\n  begin\r\n    // Write the property name and then the data itself\r\n    Driver.BeginProperty(FPropPath + Name);\r\n    WriteBinary(AWriteData);\r\n    Driver.EndProperty;\r\n  end else if assigned(ReadData) then ;\r\nend;\r\n\r\nprocedure TWriter.FlushBuffer;\r\nbegin\r\n  Driver.FlushBuffer;\r\nend;\r\n\r\nprocedure TWriter.Write(const Buffer : TBytes; Count: Longint);\r\nbegin\r\n  //This should give an exception if write is not implemented (i.e. TTextObjectWriter)\r\n  //but should work with TBinaryObjectWriter.\r\n  Driver.Write(Buffer, Count);\r\nend;\r\n\r\nprocedure TWriter.SetRoot(ARoot: TComponent);\r\nbegin\r\n  inherited SetRoot(ARoot);\r\n  // Use the new root as lookup root too\r\n  FLookupRoot := ARoot;\r\nend;\r\n\r\nprocedure TWriter.WriteSignature;\r\n\r\nbegin\r\n  FDriver.WriteSignature;\r\nend;\r\n\r\nprocedure TWriter.WriteBinary(AWriteData: TStreamProc);\r\nvar\r\n  MemBuffer: TBytesStream;\r\nbegin\r\n  { First write the binary data into a memory stream, then copy this buffered\r\n    stream into the writing destination. This is necessary as we have to know\r\n    the size of the binary data in advance (we're assuming that seeking within\r\n    the writer stream is not possible) }\r\n  MemBuffer := TBytesStream.Create;\r\n  try\r\n    AWriteData(MemBuffer);\r\n    Driver.WriteBinary(MemBuffer.Bytes, MemBuffer.Size);\r\n  finally\r\n    MemBuffer.Free;\r\n  end;\r\nend;\r\n\r\nprocedure TWriter.WriteBoolean(Value: Boolean);\r\nbegin\r\n  Driver.WriteBoolean(Value);\r\nend;\r\n\r\nprocedure TWriter.WriteChar(Value: Char);\r\nbegin\r\n  WriteString(Value);\r\nend;\r\n\r\nprocedure TWriter.WriteWideChar(Value: WideChar);\r\nbegin\r\n  WriteWideString(Value);\r\nend;\r\n\r\nprocedure TWriter.WriteCollection(Value: TCollection);\r\nvar\r\n  i: Integer;\r\nbegin\r\n  Driver.BeginCollection;\r\n  if Assigned(Value) then\r\n    for i := 0 to Value.Count - 1 do\r\n    begin\r\n      { Each collection item needs its own ListBegin/ListEnd tag, or else the\r\n        reader wouldn't be able to know where an item ends and where the next\r\n        one starts }\r\n      WriteListBegin;\r\n      WriteProperties(Value.Items[i]);\r\n      WriteListEnd;\r\n    end;\r\n  WriteListEnd;\r\nend;\r\n\r\nprocedure TWriter.DetermineAncestor(Component : TComponent);\r\n\r\nVar\r\n  I : Integer;\r\n\r\nbegin\r\n  // Should be set only when we write an inherited with children.\r\n  if Not Assigned(FAncestors) then\r\n    exit;\r\n  I:=FAncestors.IndexOf(Component.Name);\r\n  If (I=-1) then\r\n    begin\r\n    FAncestor:=Nil;\r\n    FAncestorPos:=-1;\r\n    end\r\n  else\r\n    With TPosComponent(FAncestors.Objects[i]) do\r\n      begin\r\n      FAncestor:=FComponent;\r\n      FAncestorPos:=FPos;\r\n      end;\r\nend;\r\n\r\nprocedure TWriter.DoFindAncestor(Component : TComponent);\r\n\r\nVar\r\n  C : TComponent;\r\n\r\nbegin\r\n  if Assigned(FOnFindAncestor) then\r\n    if (Ancestor=Nil) or (Ancestor is TComponent) then\r\n      begin\r\n      C:=TComponent(Ancestor);\r\n      FOnFindAncestor(Self,Component,Component.Name,C,FRootAncestor);\r\n      Ancestor:=C;\r\n      end;\r\nend;\r\n\r\nprocedure TWriter.WriteComponent(Component: TComponent);\r\n\r\nvar\r\n  SA : TPersistent;\r\n  SR, SRA : TComponent;\r\nbegin\r\n  SR:=FRoot;\r\n  SA:=FAncestor;\r\n  SRA:=FRootAncestor;\r\n  Try\r\n    Component.FComponentState:=Component.FComponentState+[csWriting];\r\n    Try\r\n      // Possibly set ancestor.\r\n      DetermineAncestor(Component);\r\n      DoFindAncestor(Component); // Mainly for IDE when a parent form had an ancestor renamed...\r\n      // Will call WriteComponentData.\r\n      Component.WriteState(Self);\r\n      FDriver.EndList;\r\n    Finally\r\n      Component.FComponentState:=Component.FComponentState-[csWriting];\r\n    end;\r\n  Finally\r\n    FAncestor:=SA;\r\n    FRoot:=SR;\r\n    FRootAncestor:=SRA;\r\n  end;\r\nend;\r\n\r\nprocedure TWriter.WriteChildren(Component : TComponent);\r\n\r\nVar\r\n  SRoot, SRootA : TComponent;\r\n  SList : TStringList;\r\n  SPos, I , SAncestorPos: Integer;\r\n  O : TObject;\r\n\r\nbegin\r\n  // Write children list.\r\n  // While writing children, the ancestor environment must be saved\r\n  // This is recursive...\r\n  SRoot:=FRoot;\r\n  SRootA:=FRootAncestor;\r\n  SList:=FAncestors;\r\n  SPos:=FCurrentPos;\r\n  SAncestorPos:=FAncestorPos;\r\n  try\r\n    FAncestors:=Nil;\r\n    FCurrentPos:=0;\r\n    FAncestorPos:=-1;\r\n    if csInline in Component.ComponentState then\r\n       FRoot:=Component;\r\n    if (FAncestor is TComponent) then\r\n       begin\r\n       FAncestors:=TStringList.Create;\r\n       if csInline in TComponent(FAncestor).ComponentState then\r\n         FRootAncestor := TComponent(FAncestor);\r\n       TComponent(FAncestor).GetChildren(@AddToAncestorList,FRootAncestor);\r\n       FAncestors.Sorted:=True;\r\n       end;\r\n    try\r\n      Component.GetChildren(@WriteComponent, FRoot);\r\n    Finally\r\n      If Assigned(Fancestors) then\r\n        For I:=0 to FAncestors.Count-1 do\r\n          begin\r\n          O:=FAncestors.Objects[i];\r\n          FAncestors.Objects[i]:=Nil;\r\n          O.Free;\r\n          end;\r\n      FreeAndNil(FAncestors);\r\n    end;\r\n  finally\r\n    FAncestors:=Slist;\r\n    FRoot:=SRoot;\r\n    FRootAncestor:=SRootA;\r\n    FCurrentPos:=SPos;\r\n    FAncestorPos:=SAncestorPos;\r\n  end;\r\nend;\r\n\r\nprocedure TWriter.WriteComponentData(Instance: TComponent);\r\nvar\r\n  Flags: TFilerFlags;\r\nbegin\r\n  Flags := [];\r\n  If (Assigned(FAncestor)) and  //has ancestor\r\n     (not (csInline in Instance.ComponentState) or // no inline component\r\n      // .. or the inline component is inherited\r\n      (csAncestor in Instance.Componentstate) and (FAncestors <> nil)) then\r\n    Flags:=[ffInherited]\r\n  else If csInline in Instance.ComponentState then\r\n    Flags:=[ffInline];\r\n  If (FAncestors<>Nil) and ((FCurrentPos<>FAncestorPos) or (FAncestor=Nil)) then\r\n    Include(Flags,ffChildPos);\r\n  FDriver.BeginComponent(Instance,Flags,FCurrentPos);\r\n  If (FAncestors<>Nil) then\r\n    Inc(FCurrentPos);\r\n  WriteProperties(Instance);\r\n  WriteListEnd;\r\n  // Needs special handling of ancestor.\r\n  If not IgnoreChildren then\r\n    WriteChildren(Instance);\r\nend;\r\n\r\nprocedure TWriter.WriteDescendent(ARoot: TComponent; AAncestor: TComponent);\r\nbegin\r\n  FRoot := ARoot;\r\n  FAncestor := AAncestor;\r\n  FRootAncestor := AAncestor;\r\n  FLookupRoot := ARoot;\r\n  WriteSignature;\r\n  WriteComponent(ARoot);\r\nend;\r\n\r\nprocedure TWriter.WriteFloat(const Value: Extended);\r\nbegin\r\n  Driver.WriteFloat(Value);\r\nend;\r\n\r\n\r\nprocedure TWriter.WriteCurrency(const Value: Currency);\r\nbegin\r\n  Driver.WriteCurrency(Value);\r\nend;\r\n\r\n\r\nprocedure TWriter.WriteIdent(const Ident: string);\r\nbegin\r\n  Driver.WriteIdent(Ident);\r\nend;\r\n\r\nprocedure TWriter.WriteInteger(Value: LongInt);\r\nbegin\r\n  Driver.WriteInteger(Value);\r\nend;\r\n\r\nprocedure TWriter.WriteInteger(Value: NativeInt);\r\nbegin\r\n  Driver.WriteInteger(Value);\r\nend;\r\n\r\nprocedure TWriter.WriteSet(Value: LongInt; SetType: Pointer);\r\n\r\nbegin\r\n  Driver.WriteSet(Value,SetType);\r\nend;\r\n\r\nprocedure TWriter.WriteVariant(const VarValue: JSValue);\r\nbegin\r\n  Driver.WriteVariant(VarValue);\r\nend;\r\n\r\nprocedure TWriter.WriteListBegin;\r\nbegin\r\n  Driver.BeginList;\r\nend;\r\n\r\nprocedure TWriter.WriteListEnd;\r\nbegin\r\n  Driver.EndList;\r\nend;\r\n\r\nprocedure TWriter.WriteProperties(Instance: TPersistent);\r\n\r\nvar\r\n  PropCount,i : integer;\r\n  PropList  : TTypeMemberPropertyDynArray;\r\n\r\nbegin\r\n  PropList:=GetPropList(Instance);\r\n  PropCount:=Length(PropList);\r\n  if PropCount>0 then\r\n    for i := 0 to PropCount-1 do\r\n      if IsStoredProp(Instance,PropList[i]) then\r\n        WriteProperty(Instance,PropList[i]);\r\n  Instance.DefineProperties(Self);\r\nend;\r\n\r\n\r\nprocedure TWriter.WriteProperty(Instance: TPersistent; PropInfo: TTypeMemberProperty);\r\nvar\r\n  HasAncestor: Boolean;\r\n  PropType: TTypeInfo;\r\n  N,Value, DefValue: LongInt;\r\n  Ident: String;\r\n  IntToIdentFn: TIntToIdent;\r\n{$ifndef FPUNONE}\r\n  FloatValue, DefFloatValue: Extended;\r\n{$endif}\r\n  MethodValue: TMethod;\r\n  DefMethodValue: TMethod;\r\n  StrValue, DefStrValue: String;\r\n  AncestorObj: TObject;\r\n  C,Component: TComponent;\r\n  ObjValue: TObject;\r\n  SavedAncestor: TPersistent;\r\n  Key, SavedPropPath, Name, lMethodName: String;\r\n  VarValue, DefVarValue : JSValue;\r\n  BoolValue, DefBoolValue: boolean;\r\n  Handled: Boolean;\r\n  O : TJSObject;\r\nbegin\r\n  // do not stream properties without getter\r\n  if PropInfo.Getter='' then\r\n    exit;\r\n  // properties without setter are only allowed, if they are subcomponents\r\n  PropType := PropInfo.TypeInfo;\r\n  if (PropInfo.Setter='') then\r\n    begin\r\n    if PropType.Kind<>tkClass then\r\n      exit;\r\n    ObjValue := TObject(GetObjectProp(Instance, PropInfo));\r\n    if not ObjValue.InheritsFrom(TComponent) or\r\n       not (csSubComponent in TComponent(ObjValue).ComponentStyle) then\r\n      exit;\r\n    end;\r\n\r\n  { Check if the ancestor can be used }\r\n  HasAncestor := Assigned(Ancestor) and ((Instance = Root) or\r\n    (Instance.ClassType = Ancestor.ClassType));\r\n  //writeln('TWriter.WriteProperty Name=',PropType^.Name,' Kind=',GetEnumName(TypeInfo(TTypeKind),ord(PropType^.Kind)),' HasAncestor=',HasAncestor);\r\n\r\n  case PropType.Kind of\r\n    tkInteger, tkChar, tkEnumeration, tkSet:\r\n      begin\r\n        Value := GetOrdProp(Instance, PropInfo);\r\n        if HasAncestor then\r\n          DefValue := GetOrdProp(Ancestor, PropInfo)\r\n        else\r\n          begin\r\n          if PropType.Kind<>tkSet then\r\n            DefValue := Longint(PropInfo.Default)\r\n          else\r\n            begin\r\n            o:=TJSObject(PropInfo.Default);\r\n            DefValue:=0;\r\n            for Key in o do\r\n              begin\r\n              n:=parseInt(Key,10);\r\n              if n<32 then\r\n                DefValue:=DefValue+(1 shl n);\r\n              end;\r\n            end;\r\n          end;\r\n        // writeln(PPropInfo(PropInfo)^.Name, ', HasAncestor=', ord(HasAncestor), ', Value=', Value, ', Default=', DefValue);\r\n        if (Value <> DefValue) or (DefValue=longint($80000000)) then\r\n        begin\r\n          Driver.BeginProperty(FPropPath + PropInfo.Name);\r\n          case PropType.Kind of\r\n            tkInteger:\r\n              begin\r\n                // Check if this integer has a string identifier\r\n                IntToIdentFn := FindIntToIdent(PropInfo.TypeInfo);\r\n                if Assigned(IntToIdentFn) and IntToIdentFn(Value, Ident) then\r\n                  // Integer can be written a human-readable identifier\r\n                  WriteIdent(Ident)\r\n                else\r\n                  // Integer has to be written just as number\r\n                  WriteInteger(Value);\r\n              end;\r\n            tkChar:\r\n              WriteChar(Chr(Value));\r\n            tkSet:\r\n              begin\r\n              Driver.WriteSet(Value, TTypeInfoSet(PropType).CompType);\r\n              end;\r\n            tkEnumeration:\r\n              WriteIdent(GetEnumName(TTypeInfoEnum(PropType), Value));\r\n          end;\r\n          Driver.EndProperty;\r\n        end;\r\n      end;\r\n{$ifndef FPUNONE}\r\n    tkFloat:\r\n      begin\r\n        FloatValue := GetFloatProp(Instance, PropInfo);\r\n        if HasAncestor then\r\n          DefFloatValue := GetFloatProp(Ancestor, PropInfo)\r\n        else\r\n          begin\r\n          // This is really ugly..\r\n          DefFloatValue:=Double(PropInfo.Default);\r\n          end;\r\n        if (FloatValue<>DefFloatValue) or (not HasAncestor and (int(DefFloatValue)=longint($80000000))) then\r\n        begin\r\n          Driver.BeginProperty(FPropPath + PropInfo.Name);\r\n          WriteFloat(FloatValue);\r\n          Driver.EndProperty;\r\n        end;\r\n      end;\r\n{$endif}\r\n    tkMethod:\r\n      begin\r\n        MethodValue := GetMethodProp(Instance, PropInfo);\r\n        if HasAncestor then\r\n          DefMethodValue := GetMethodProp(Ancestor, PropInfo)\r\n        else begin\r\n          DefMethodValue.Data := nil;\r\n          DefMethodValue.Code := nil;\r\n        end;\r\n\r\n        Handled:=false;\r\n        if Assigned(OnWriteMethodProperty) then\r\n          OnWriteMethodProperty(Self,Instance,PropInfo,MethodValue,\r\n            DefMethodValue,Handled);\r\n        if isString(MethodValue.Code) then\r\n          lMethodName:=String(MethodValue.Code)\r\n        else\r\n          lMethodName:=FLookupRoot.MethodName(MethodValue.Code);\r\n        //Writeln('Writeln A: ',lMethodName);\r\n        if (not Handled) and\r\n          (MethodValue.Code <> DefMethodValue.Code) and\r\n          ((not Assigned(MethodValue.Code)) or\r\n          ((Length(lMethodName) > 0))) then\r\n        begin\r\n          //Writeln('Writeln B',FPropPath + PropInfo.Name);\r\n          Driver.BeginProperty(FPropPath + PropInfo.Name);\r\n          if Assigned(MethodValue.Code) then\r\n            Driver.WriteMethodName(lMethodName)\r\n          else\r\n            Driver.WriteMethodName('');\r\n          Driver.EndProperty;\r\n        end;\r\n      end;\r\n    tkString: // tkSString, tkLString, tkAString are not supported\r\n      begin\r\n        StrValue := GetStrProp(Instance, PropInfo);\r\n        if HasAncestor then\r\n          DefStrValue := GetStrProp(Ancestor, PropInfo)\r\n        else\r\n        begin\r\n          DefValue :=Longint(PropInfo.Default);\r\n          SetLength(DefStrValue, 0);\r\n        end;\r\n\r\n        if (StrValue<>DefStrValue) or (not HasAncestor and (DefValue=longint($80000000))) then\r\n        begin\r\n          Driver.BeginProperty(FPropPath + PropInfo.Name);\r\n          if Assigned(FOnWriteStringProperty) then\r\n            FOnWriteStringProperty(Self,Instance,PropInfo,StrValue);\r\n          WriteString(StrValue);\r\n          Driver.EndProperty;\r\n        end;\r\n      end;\r\n    tkJSValue:\r\n      begin\r\n        { Ensure that a Variant manager is installed }\r\n        VarValue := GetJSValueProp(Instance, PropInfo);\r\n        if HasAncestor then\r\n          DefVarValue := GetJSValueProp(Ancestor, PropInfo)\r\n        else\r\n          DefVarValue:=null;\r\n\r\n        if (VarValue<>DefVarValue) then\r\n          begin\r\n            Driver.BeginProperty(FPropPath + PropInfo.Name);\r\n            { can't use variant() typecast, pulls in variants unit }\r\n            WriteVariant(VarValue);\r\n            Driver.EndProperty;\r\n          end;\r\n      end;\r\n    tkClass:\r\n      begin\r\n        ObjValue := TObject(GetObjectProp(Instance, PropInfo));\r\n        if HasAncestor then\r\n        begin\r\n          AncestorObj := TObject(GetObjectProp(Ancestor, PropInfo));\r\n          if (AncestorObj is TComponent) and\r\n             (ObjValue is TComponent) then\r\n          begin\r\n            //writeln('TWriter.WriteProperty AncestorObj=',TComponent(AncestorObj).Name,' OwnerFit=',TComponent(AncestorObj).Owner = FRootAncestor,' ',TComponent(ObjValue).Name,' OwnerFit=',TComponent(ObjValue).Owner = Root);\r\n            if (AncestorObj<> ObjValue) and\r\n             (TComponent(AncestorObj).Owner = FRootAncestor) and\r\n             (TComponent(ObjValue).Owner = Root) and\r\n             (UpperCase(TComponent(AncestorObj).Name) = UpperCase(TComponent(ObjValue).Name)) then\r\n            begin\r\n              // different components, but with the same name\r\n              // treat it like an override\r\n              AncestorObj := ObjValue;\r\n            end;\r\n          end;\r\n        end else\r\n          AncestorObj := nil;\r\n\r\n        if not Assigned(ObjValue) then\r\n          begin\r\n          if ObjValue <> AncestorObj then\r\n            begin\r\n            Driver.BeginProperty(FPropPath + PropInfo.Name);\r\n            Driver.WriteIdent('NIL');\r\n            Driver.EndProperty;\r\n            end\r\n          end\r\n        else if ObjValue.InheritsFrom(TPersistent) then\r\n          begin\r\n          { Subcomponents are streamed the same way as persistents }\r\n          if ObjValue.InheritsFrom(TComponent)\r\n            and ((not (csSubComponent in TComponent(ObjValue).ComponentStyle))\r\n                 or ((TComponent(ObjValue).Owner<>Instance) and (TComponent(ObjValue).Owner<>Nil))) then\r\n            begin\r\n            Component := TComponent(ObjValue);\r\n            if (ObjValue <> AncestorObj)\r\n                and not (csTransient in Component.ComponentStyle) then\r\n              begin\r\n              Name:= '';\r\n              C:= Component;\r\n              While (C<>Nil) and (C.Name<>'') do\r\n                begin\r\n                If (Name<>'') Then\r\n                  Name:='.'+Name;\r\n                if C.Owner = LookupRoot then\r\n                  begin\r\n                  Name := C.Name+Name;\r\n                  break;\r\n                  end\r\n                else if C = LookupRoot then\r\n                  begin\r\n                  Name := 'Owner' + Name;\r\n                  break;\r\n                  end;\r\n                Name:=C.Name + Name;\r\n                C:= C.Owner;\r\n                end;\r\n              if (C=nil) and (Component.Owner=nil) then\r\n                if (Name<>'') then              //foreign root\r\n                  Name:=Name+'.Owner';\r\n              if Length(Name) > 0 then\r\n                begin\r\n                Driver.BeginProperty(FPropPath + PropInfo.Name);\r\n                WriteIdent(Name);\r\n                Driver.EndProperty;\r\n                end;  // length Name>0\r\n              end; //(ObjValue <> AncestorObj)\r\n            end // ObjValue.InheritsFrom(TComponent)\r\n          else\r\n            begin\r\n            SavedAncestor := Ancestor;\r\n            SavedPropPath := FPropPath;\r\n            try\r\n              FPropPath := FPropPath + PropInfo.Name + '.';\r\n              if HasAncestor then\r\n                Ancestor := TPersistent(GetObjectProp(Ancestor, PropInfo));\r\n              WriteProperties(TPersistent(ObjValue));\r\n            finally\r\n              Ancestor := SavedAncestor;\r\n              FPropPath := SavedPropPath;\r\n            end;\r\n            if ObjValue.InheritsFrom(TCollection) then\r\n              begin\r\n              if (not HasAncestor) or (not CollectionsEqual(TCollection(ObjValue),\r\n                TCollection(GetObjectProp(Ancestor, PropInfo)),root,rootancestor)) then\r\n                begin\r\n                Driver.BeginProperty(FPropPath + PropInfo.Name);\r\n                SavedPropPath := FPropPath;\r\n                try\r\n                  SetLength(FPropPath, 0);\r\n                  WriteCollection(TCollection(ObjValue));\r\n                finally\r\n                  FPropPath := SavedPropPath;\r\n                  Driver.EndProperty;\r\n                end;\r\n                end;\r\n              end // Tcollection\r\n            end;\r\n          end; // Inheritsfrom(TPersistent)\r\n      end;\r\n{    tkInt64, tkQWord:\r\n      begin\r\n        Int64Value := GetInt64Prop(Instance, PropInfo);\r\n        if HasAncestor then\r\n          DefInt64Value := GetInt64Prop(Ancestor, PropInfo)\r\n        else\r\n          DefInt64Value := 0;\r\n        if Int64Value <> DefInt64Value then\r\n        begin\r\n          Driver.BeginProperty(FPropPath + PPropInfo(PropInfo)^.Name);\r\n          WriteInteger(Int64Value);\r\n          Driver.EndProperty;\r\n        end;\r\n      end;}\r\n    tkBool:\r\n      begin\r\n        BoolValue := GetOrdProp(Instance, PropInfo)<>0;\r\n        if HasAncestor then\r\n          DefBoolValue := GetOrdProp(Ancestor, PropInfo)<>0\r\n        else\r\n          begin\r\n          DefBoolValue := PropInfo.Default<>0;\r\n          DefValue:=Longint(PropInfo.Default);\r\n          end;\r\n        // writeln(PropInfo.Name, ', HasAncestor=', ord(HasAncestor), ', Value=', Value, ', Default=', DefBoolValue);\r\n        if (BoolValue<>DefBoolValue) or (DefValue=longint($80000000)) then\r\n          begin\r\n          Driver.BeginProperty(FPropPath + PropInfo.Name);\r\n          WriteBoolean(BoolValue);\r\n          Driver.EndProperty;\r\n          end;\r\n      end;\r\n    tkInterface:\r\n      begin\r\n{        IntfValue := GetInterfaceProp(Instance, PropInfo);\r\n      if Assigned(IntfValue) and Supports(IntfValue, IInterfaceComponentReference, CompRef) then\r\n          begin\r\n          Component := CompRef.GetComponent;\r\n          if HasAncestor then\r\n          begin\r\n            AncestorObj := TObject(GetObjectProp(Ancestor, PropInfo));\r\n            if (AncestorObj is TComponent) then\r\n            begin\r\n              //writeln('TWriter.WriteProperty AncestorObj=',TComponent(AncestorObj).Name,' OwnerFit=',TComponent(AncestorObj).Owner = FRootAncestor,' ',TComponent(ObjValue).Name,' OwnerFit=',TComponent(ObjValue).Owner = Root);\r\n              if (AncestorObj<> Component) and\r\n               (TComponent(AncestorObj).Owner = FRootAncestor) and\r\n               (Component.Owner = Root) and\r\n               (UpperCase(TComponent(AncestorObj).Name) = UpperCase(Component.Name)) then\r\n              begin\r\n                // different components, but with the same name\r\n                // treat it like an override\r\n                AncestorObj := Component;\r\n              end;\r\n            end;\r\n          end else\r\n            AncestorObj := nil;\r\n\r\n          if not Assigned(Component) then\r\n            begin\r\n            if Component <> AncestorObj then\r\n              begin\r\n              Driver.BeginProperty(FPropPath + PropInfo.Name);\r\n              Driver.WriteIdent('NIL');\r\n              Driver.EndProperty;\r\n              end\r\n            end\r\n          else if ((not (csSubComponent in Component.ComponentStyle))\r\n                 or ((Component.Owner<>Instance) and (Component.Owner<>Nil))) then\r\n            begin\r\n            if (Component <> AncestorObj)\r\n                and not (csTransient in Component.ComponentStyle) then\r\n              begin\r\n              Name:= '';\r\n              C:= Component;\r\n              While (C<>Nil) and (C.Name<>'') do\r\n                begin\r\n                If (Name<>'') Then\r\n                  Name:='.'+Name;\r\n                if C.Owner = LookupRoot then\r\n                  begin\r\n                  Name := C.Name+Name;\r\n                  break;\r\n                  end\r\n                else if C = LookupRoot then\r\n                  begin\r\n                  Name := 'Owner' + Name;\r\n                  break;\r\n                  end;\r\n                Name:=C.Name + Name;\r\n                C:= C.Owner;\r\n                end;\r\n              if (C=nil) and (Component.Owner=nil) then\r\n                if (Name<>'') then              //foreign root\r\n                  Name:=Name+'.Owner';\r\n              if Length(Name) > 0 then\r\n                begin\r\n                Driver.BeginProperty(FPropPath + PropInfo.Name);\r\n                WriteIdent(Name);\r\n                Driver.EndProperty;\r\n                end;  // length Name>0\r\n              end; //(Component <> AncestorObj)\r\n            end;\r\n          end; //Assigned(IntfValue) and Supports(IntfValue,..\r\n               //else write NIL ?\r\n}      end;\r\n  end;\r\nend;\r\n\r\nprocedure TWriter.WriteRootComponent(ARoot: TComponent);\r\nbegin\r\n  WriteDescendent(ARoot, nil);\r\nend;\r\n\r\nprocedure TWriter.WriteString(const Value: String);\r\nbegin\r\n  Driver.WriteString(Value);\r\nend;\r\n\r\nprocedure TWriter.WriteWideString(const Value: WideString);\r\nbegin\r\n  Driver.WriteWideString(Value);\r\nend;\r\n\r\nprocedure TWriter.WriteUnicodeString(const Value: UnicodeString);\r\nbegin\r\n  Driver.WriteUnicodeString(Value);\r\nend;\r\n\r\n{ TAbstractObjectWriter }\r\n\r\n\r\n{ ---------------------------------------------------------------------\r\n  Global routines\r\n  ---------------------------------------------------------------------}\r\nType\r\n  TInitHandler = Class(TObject)\r\n    AHandler : TInitComponentHandler;\r\n    AClass : TComponentClass;\r\n  end;\r\n\r\nvar\r\n  ClassList : TJSObject;\r\n  InitHandlerList : TList;\r\n  FindGlobalComponentList : TFPList;\r\n\r\nProcedure RegisterClass(AClass : TPersistentClass);\r\n\r\nbegin\r\n  ClassList[AClass.ClassName]:=AClass;\r\nend;\r\n\r\nProcedure RegisterClasses(AClasses : specialize TArray<TPersistentClass>);\r\nvar\r\n  AClass : TPersistentClass;\r\n\r\nbegin\r\n  for AClass in AClasses do\r\n    RegisterClass(AClass);\r\nend;\r\n\r\nFunction GetClass(AClassName : string) : TPersistentClass;\r\n\r\nbegin\r\n  Result:=nil;\r\n  if AClassName='' then exit;\r\n  if not ClassList.hasOwnProperty(AClassName) then exit;\r\n  Result:=TPersistentClass(ClassList[AClassName]);\r\nend;\r\n\r\n\r\nprocedure RegisterFindGlobalComponentProc(AFindGlobalComponent: TFindGlobalComponent);\r\n  begin\r\n    if not(assigned(FindGlobalComponentList)) then\r\n      FindGlobalComponentList:=TFPList.Create;\r\n    if FindGlobalComponentList.IndexOf(CodePointer(AFindGlobalComponent))<0 then\r\n      FindGlobalComponentList.Add(CodePointer(AFindGlobalComponent));\r\n  end;\r\n\r\n\r\nprocedure UnregisterFindGlobalComponentProc(AFindGlobalComponent: TFindGlobalComponent);\r\n  begin\r\n    if assigned(FindGlobalComponentList) then\r\n      FindGlobalComponentList.Remove(CodePointer(AFindGlobalComponent));\r\n  end;\r\n\r\n\r\nfunction FindGlobalComponent(const Name: string): TComponent;\r\n\r\nvar\r\n      i : sizeint;\r\nbegin\r\n  Result:=nil;\r\n  if assigned(FindGlobalComponentList) then\r\n    begin\r\n      for i:=FindGlobalComponentList.Count-1 downto 0 do\r\n      \tbegin\r\n      \t  FindGlobalComponent:=TFindGlobalComponent(FindGlobalComponentList[i])(name);\r\n      \t  if assigned(Result) then\r\n      \t    break;\r\n      \tend;\r\n    end;\r\nend;\r\n\r\nFunction FindNestedComponent(Root : TComponent; APath : String; CStyle : Boolean = True) : TComponent;\r\n\r\n  Function GetNextName : String; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\n\r\n  Var\r\n    P : Integer;\r\n    CM : Boolean;\r\n\r\n  begin\r\n    P:=Pos('.',APath);\r\n    CM:=False;\r\n    If (P=0) then\r\n      begin\r\n      If CStyle then\r\n        begin\r\n        P:=Pos('->',APath);\r\n        CM:=P<>0;\r\n        end;\r\n      If (P=0) Then\r\n        P:=Length(APath)+1;\r\n      end;\r\n    Result:=Copy(APath,1,P-1);\r\n    Delete(APath,1,P+Ord(CM));\r\n  end;\r\n\r\nVar\r\n  C : TComponent;\r\n  S : String;\r\nbegin\r\n  If (APath='') then\r\n    Result:=Nil\r\n  else\r\n    begin\r\n    Result:=Root;\r\n    While (APath<>'') And (Result<>Nil) do\r\n      begin\r\n      C:=Result;\r\n      S:=Uppercase(GetNextName);\r\n      Result:=C.FindComponent(S);\r\n      If (Result=Nil) And (S='OWNER') then\r\n        Result:=C;\r\n      end;\r\n    end;\r\nend;\r\n\r\nfunction FindInitComponentHandler(const ComponentClass: TComponentClass; var Handler: TInitHandler): Boolean;\r\nvar\r\n  A: Integer;\r\n\r\nbegin\r\n  Result := False;\r\n\r\n  if not Assigned(InitHandlerList) then\r\n    InitHandlerList := TList.Create;\r\n\r\n  for A := 0 to Pred(InitHandlerList.Count) do\r\n  begin\r\n    Handler := TInitHandler(InitHandlerList.Items[A]);\r\n\r\n    if Handler.AClass = ComponentClass then\r\n      Exit(True);\r\n  end;\r\nend;\r\n\r\nfunction AddInitComponentHandler(const ComponentClass: TComponentClass; const Handler: TInitComponentHandler; const ForceInsert: Boolean): TInitHandler;\r\nbegin\r\n  if ForceInsert or not FindInitComponentHandler(ComponentClass, Result) then\r\n  begin\r\n    Result := TInitHandler.Create;\r\n    Result.AClass := ComponentClass;\r\n\r\n    InitHandlerList.Add(Result);\r\n  end;\r\n\r\n  Result.AHandler := Handler;\r\nend;\r\n\r\nfunction InitInheritedComponent(Instance: TComponent; RootAncestor: TClass): Boolean;\r\nvar\r\n  Handler: TInitHandler;\r\n\r\n  ComponentClass: TComponentClass;\r\n\r\nbegin\r\n  Handler := nil;\r\n  Result := not Assigned(InitHandlerList);\r\n\r\n  if not Result then\r\n  begin\r\n    ComponentClass := TComponentClass(Instance.ClassType);\r\n\r\n    if not FindInitComponentHandler(ComponentClass, Handler) then\r\n      Handler := AddInitComponentHandler(ComponentClass, @DefaultInitHandler, True);\r\n\r\n    Result := Handler.AHandler(Instance,RootAncestor);\r\n  end;\r\nend;\r\n\r\nprocedure RegisterInitComponentHandler(ComponentClass: TComponentClass; Handler: TInitComponentHandler);\r\nbegin\r\n  AddInitComponentHandler(ComponentClass, Handler, False);\r\nend;\r\n\r\n\r\nprocedure TObjectStreamConverter.OutStr(s: String);\r\n\r\nVar\r\n  I : integer;\r\n\r\nbegin\r\n  For I:=1 to Length(S) do\r\n    Output.WriteBufferData(s[i]);\r\nend;\r\n\r\nprocedure TObjectStreamConverter.OutLn(s: String);\r\nbegin\r\n  OutStr(s + LineEnding);\r\nend;\r\n\r\n\r\nprocedure TObjectStreamConverter.Outchars(S: String);\r\n\r\nvar\r\n  res, NewStr: String;\r\n  i,len,w: Cardinal;\r\n  InString, NewInString: Boolean;\r\n  SObj : TJSString absolute s;\r\n\r\nbegin\r\n if S = '' then\r\n   res:= ''''''\r\n else\r\n   begin\r\n   res := '';\r\n   InString := False;\r\n   len:= Length(S);\r\n   i:=0;\r\n   while i < Len do\r\n     begin\r\n     NewInString := InString;\r\n     w := SObj.charCodeAt(i);\r\n     if w = ord('''') then\r\n       begin //quote char\r\n       if not InString then\r\n         NewInString := True;\r\n       NewStr := '''''';\r\n       end\r\n     else if (w >= 32) and (w < 127) then\r\n       begin //printable ascii or bytes\r\n       if not InString then\r\n         NewInString := True;\r\n       NewStr := TJSString.FromCharCode(w);\r\n       end\r\n    else\r\n       begin //ascii control chars, non ascii\r\n       if InString then\r\n         NewInString := False;\r\n       NewStr := '#' + IntToStr(w);\r\n       end;\r\n    if NewInString <> InString then\r\n      begin\r\n      NewStr := '''' + NewStr;\r\n      InString := NewInString;\r\n      end;\r\n    res := res + NewStr;\r\n    Inc(i);\r\n    end;\r\n  if InString then\r\n    res := res + '''';\r\n  end;\r\n OutStr(res);\r\nend;\r\n\r\n\r\nprocedure TObjectStreamConverter.OutString(s: String);\r\nbegin\r\n  OutChars(S);\r\nend;\r\n\r\n\r\n(*\r\nprocedure TObjectStreamConverter.OutUtf8Str(s: String);\r\nbegin\r\n  if Encoding=oteLFM then\r\n    OutChars(Pointer(S),PChar(S)+Length(S),@CharToOrd)\r\n  else\r\n    OutChars(Pointer(S),PChar(S)+Length(S),@Utf8ToOrd);\r\nend;\r\n*)\r\n\r\nfunction TObjectStreamConverter.ReadWord : word; {$ifdef CLASSESINLINE}inline;{$endif CLASSESINLINE}\r\nbegin\r\n  Input.ReadBufferData(Result);\r\nend;\r\n\r\nfunction TObjectStreamConverter.ReadDWord : longword; {$ifdef CLASSESINLINE}inline;{$endif CLASSESINLINE}\r\nbegin\r\n  Input.ReadBufferData(Result);\r\nend;\r\n\r\nfunction TObjectStreamConverter.ReadNativeInt : NativeInt; {$ifdef CLASSESINLINE}inline;{$endif CLASSESINLINE}\r\nbegin\r\n  Input.ReadBufferData(Result);\r\nend;\r\n\r\nfunction TObjectStreamConverter.ReadInt(ValueType: TValueType): NativeInt;\r\nbegin\r\n  case ValueType of\r\n    vaInt8: Result := ShortInt(Input.ReadByte);\r\n    vaInt16: Result := SmallInt(ReadWord);\r\n    vaInt32: Result := LongInt(ReadDWord);\r\n    vaNativeInt: Result := ReadNativeInt;\r\n  end;\r\nend;\r\n\r\nfunction TObjectStreamConverter.ReadInt: NativeInt;\r\nbegin\r\n  Result := ReadInt(TValueType(Input.ReadByte));\r\nend;\r\n\r\n\r\nfunction TObjectStreamConverter.ReadDouble : Double;\r\n\r\nbegin\r\n  Input.ReadBufferData(Result);\r\nend;\r\n\r\nfunction TObjectStreamConverter.ReadStr: String;\r\n\r\nvar\r\n  l,i: Byte;\r\n  c : Char;\r\n\r\nbegin\r\n  Input.ReadBufferData(L);\r\n  SetLength(Result,L);\r\n  For I:=1 to L do\r\n    begin\r\n    Input.ReadBufferData(C);\r\n    Result[i]:=C;\r\n    end;\r\nend;\r\n\r\nfunction TObjectStreamConverter.ReadString(StringType: TValueType): String;\r\n\r\nvar\r\n  i: Integer;\r\n  C : Char;\r\n\r\nbegin\r\n  Result:='';\r\n  if StringType<>vaString then\r\n    Raise EFilerError.Create('Invalid string type passed to ReadString');\r\n  i:=ReadDWord;\r\n  SetLength(Result, i);\r\n  for I:=1 to Length(Result) do\r\n    begin\r\n    Input.ReadbufferData(C);\r\n    Result[i]:=C;\r\n    end;\r\nend;\r\n\r\nprocedure TObjectStreamConverter.ProcessBinary;\r\n\r\nvar\r\n  ToDo, DoNow, i: LongInt;\r\n  lbuf: TBytes;\r\n  s: String;\r\n\r\nbegin\r\n  ToDo := ReadDWord;\r\n  SetLength(lBuf,32);\r\n  OutLn('{');\r\n  while ToDo > 0 do\r\n    begin\r\n    DoNow := ToDo;\r\n    if DoNow > 32 then\r\n      DoNow := 32;\r\n    Dec(ToDo, DoNow);\r\n    s := Indent + '  ';\r\n    Input.ReadBuffer(lbuf, DoNow);\r\n    for i := 0 to DoNow - 1 do\r\n      s := s + IntToHex(lbuf[i], 2);\r\n    OutLn(s);\r\n  end;\r\n  OutLn(indent + '}');\r\nend;\r\n\r\nprocedure TObjectStreamConverter.ProcessValue(ValueType: TValueType; Indent: String);\r\n\r\n\r\nvar\r\n  s: String;\r\n{      len: LongInt; }\r\n  IsFirst: Boolean;\r\n{$ifndef FPUNONE}\r\n  ext: Extended;\r\n{$endif}\r\n\r\nbegin\r\n  case ValueType of\r\n    vaList: begin\r\n        OutStr('(');\r\n        IsFirst := True;\r\n        while True do begin\r\n          ValueType := TValueType(Input.ReadByte);\r\n          if ValueType = vaNull then break;\r\n          if IsFirst then begin\r\n            OutLn('');\r\n            IsFirst := False;\r\n          end;\r\n          OutStr(Indent + '  ');\r\n          ProcessValue(ValueType, Indent + '  ');\r\n        end;\r\n        OutLn(Indent + ')');\r\n      end;\r\n    vaInt8: OutLn(IntToStr(ShortInt(Input.ReadByte)));\r\n    vaInt16: OutLn( IntToStr(SmallInt(ReadWord)));\r\n    vaInt32: OutLn(IntToStr(LongInt(ReadDWord)));\r\n    vaNativeInt: OutLn(IntToStr(ReadNativeInt));\r\n    vaDouble: begin\r\n        ext:=ReadDouble;\r\n        Str(ext,S);// Do not use localized strings.\r\n        OutLn(S);\r\n      end;\r\n    vaString: begin\r\n        if PlainStrings then\r\n          OutStr( ''''+StringReplace(ReadString(vaString),'''','''''',[rfReplaceAll])+'''')\r\n        else\r\n          OutString(ReadString(vaString) {''''+StringReplace(ReadString(vaString),'''','''''',[rfReplaceAll])+''''});\r\n        OutLn('');\r\n      end;\r\n    vaIdent: OutLn(ReadStr);\r\n    vaFalse: OutLn('False');\r\n    vaTrue: OutLn('True');\r\n    vaBinary: ProcessBinary;\r\n    vaSet: begin\r\n        OutStr('[');\r\n        IsFirst := True;\r\n        while True do begin\r\n          s := ReadStr;\r\n          if Length(s) = 0 then break;\r\n          if not IsFirst then OutStr(', ');\r\n          IsFirst := False;\r\n          OutStr(s);\r\n        end;\r\n        OutLn(']');\r\n      end;\r\n    vaNil:\r\n      OutLn('nil');\r\n    vaCollection: begin\r\n        OutStr('<');\r\n        while Input.ReadByte <> 0 do begin\r\n          OutLn(Indent);\r\n          Input.Seek(-1, soCurrent);\r\n          OutStr(indent + '  item');\r\n          ValueType := TValueType(Input.ReadByte);\r\n          if ValueType <> vaList then\r\n            OutStr('[' + IntToStr(ReadInt(ValueType)) + ']');\r\n          OutLn('');\r\n          ReadPropList(indent + '    ');\r\n          OutStr(indent + '  end');\r\n        end;\r\n        OutLn('>');\r\n      end;\r\n    {vaSingle: begin OutLn('!!Single!!'); exit end;\r\n    vaCurrency: begin OutLn('!!Currency!!'); exit end;\r\n    vaDate: begin OutLn('!!Date!!'); exit end;}\r\n    else\r\n      Raise EReadError.CreateFmt(SErrInvalidPropertyType,[Ord(ValueType)]);\r\n  end;\r\nend;\r\n\r\n\r\nprocedure TObjectStreamConverter.ReadPropList(indent: String);\r\n\r\n\r\nbegin\r\n  while Input.ReadByte <> 0 do begin\r\n    Input.Seek(-1, soCurrent);\r\n    OutStr(indent + ReadStr + ' = ');\r\n    ProcessValue(TValueType(Input.ReadByte), Indent);\r\n  end;\r\nend;\r\n\r\nprocedure TObjectStreamConverter.ReadObject(indent: String);\r\n\r\nvar\r\n  b: Byte;\r\n  ObjClassName, ObjName: String;\r\n  ChildPos: LongInt;\r\n\r\nbegin\r\n  // Check for FilerFlags\r\n  b := Input.ReadByte;\r\n  if (b and $f0) = $f0 then begin\r\n    if (b and 2) <> 0 then ChildPos := ReadInt;\r\n  end else begin\r\n    b := 0;\r\n    Input.Seek(-1, soCurrent);\r\n  end;\r\n\r\n  ObjClassName := ReadStr;\r\n  ObjName := ReadStr;\r\n\r\n  OutStr(Indent);\r\n  if (b and 1) <> 0 then OutStr('inherited')\r\n  else\r\n   if (b and 4) <> 0 then OutStr('inline')\r\n   else OutStr('object');\r\n  OutStr(' ');\r\n  if ObjName <> '' then\r\n    OutStr(ObjName + ': ');\r\n  OutStr(ObjClassName);\r\n  if (b and 2) <> 0 then OutStr('[' + IntToStr(ChildPos) + ']');\r\n  OutLn('');\r\n\r\n  ReadPropList(indent + '  ');\r\n\r\n  while Input.ReadByte <> 0 do begin\r\n    Input.Seek(-1, soCurrent);\r\n    ReadObject(indent + '  ');\r\n  end;\r\n  OutLn(indent + 'end');\r\nend;\r\n\r\nprocedure TObjectStreamConverter.ObjectBinaryToText(aInput, aOutput: TStream; aEncoding: TObjectTextEncoding);\r\n\r\nbegin\r\n  FInput:=aInput;\r\n  FOutput:=aOutput;\r\n  FEncoding:=aEncoding;\r\n  Execute;\r\nend;\r\n\r\nprocedure TObjectStreamConverter.Execute;\r\n\r\nvar\r\n  Signature: LongInt;\r\n\r\nbegin\r\n  if FIndent = '' then FInDent:='  ';\r\n  If Not Assigned(Input) then\r\n    raise EReadError.Create('Missing input stream');\r\n  If Not Assigned(Output) then\r\n    raise EReadError.Create('Missing output stream');\r\n  FInput.ReadBufferData(Signature);\r\n  if Signature <> FilerSignatureInt then\r\n    raise EReadError.Create(SInvalidImage);\r\n  ReadObject('');\r\nend;\r\n\r\nprocedure TObjectStreamConverter.ObjectBinaryToText(aInput, aOutput: TStream);\r\nbegin\r\n  ObjectBinaryToText(aInput,aOutput,oteDFM);\r\nend;\r\n\r\n{\r\n    This file is part of the Free Component Library (FCL)\r\n    Copyright (c) 1999-2007 by the Free Pascal development team\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n\r\n{****************************************************************************}\r\n{*                             TParser                                      *}\r\n{****************************************************************************}\r\n\r\nconst\r\n{$ifdef CPU16}\r\n  { Avoid too big local stack use for\r\n    MSDOS tiny memory model that uses less than 4096\r\n    bytes for total stack by default. }\r\n  ParseBufSize     = 512;\r\n{$else not CPU16}\r\n  ParseBufSize     = 4096;\r\n{$endif not CPU16}\r\n\r\n  TokNames : array[TParserToken] of string = (\r\n    '?',\r\n    'EOF',\r\n    'Symbol',\r\n    'String',\r\n    'Integer',\r\n    'Float',\r\n    '-',\r\n    '[',\r\n    '(',\r\n    '<',\r\n    '{',\r\n    ']',\r\n    ')',\r\n    '>',\r\n    '}',\r\n    ',',\r\n    '.',\r\n    '=',\r\n    ':',\r\n    '+'\r\n  );\r\n\r\nfunction TParser.GetTokenName(aTok: TParserToken): string;\r\nbegin\r\n  Result:=TokNames[aTok]\r\nend;\r\n\r\nprocedure TParser.LoadBuffer;\r\n\r\nvar\r\n  CharsRead,i: integer;\r\n\r\nbegin\r\n  CharsRead:=0;\r\n  for I:=0 to ParseBufSize-1 do\r\n  begin\r\n    if FStream.ReadData(FBuf[i])<>2 then\r\n      Break;\r\n    Inc(CharsRead);\r\n  end;\r\n  Inc(FDeltaPos, CharsRead);\r\n  FPos := 0;\r\n  FBufLen := CharsRead;\r\n  FEofReached:=CharsRead = 0;\r\nend;\r\n\r\nprocedure TParser.CheckLoadBuffer; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\nbegin\r\n  if fPos>=FBufLen then\r\n    LoadBuffer;\r\nend;\r\n\r\nprocedure TParser.ProcessChar; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\nbegin\r\n  fLastTokenStr:=fLastTokenStr+fBuf[fPos];\r\n\r\n  GotoToNextChar;\r\nend;\r\n\r\nfunction TParser.IsNumber: boolean; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\nbegin\r\n  Result:=fBuf[fPos] in ['0'..'9'];\r\nend;\r\n\r\nfunction TParser.IsHexNum: boolean; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\nbegin\r\n  Result:=fBuf[fPos] in ['0'..'9','A'..'F','a'..'f'];\r\nend;\r\n\r\nfunction TParser.IsAlpha: boolean; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\nbegin\r\n  Result:=fBuf[fPos] in ['_','A'..'Z','a'..'z'];\r\nend;\r\n\r\nfunction TParser.IsAlphaNum: boolean; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\nbegin\r\n  Result:=IsAlpha or IsNumber;\r\nend;\r\n\r\nfunction TParser.GetHexValue(c: char): byte; {$ifdef CLASSESINLINE} inline; {$endif CLASSESINLINE}\r\nbegin\r\n  case c of\r\n    '0'..'9' : Result:=ord(c)-$30;\r\n    'A'..'F' : Result:=ord(c)-$37; //-$41+$0A\r\n    'a'..'f' : Result:=ord(c)-$57; //-$61+$0A\r\n  end;\r\nend;\r\n\r\nfunction TParser.GetAlphaNum: string;\r\nbegin\r\n  if not IsAlpha then\r\n    ErrorFmt(SParserExpected,[GetTokenName(toSymbol)]);\r\n  Result:='';\r\n  while (not fEofReached) and IsAlphaNum do\r\n  begin\r\n    Result:=Result+fBuf[fPos];\r\n    GotoToNextChar;\r\n  end;\r\nend;\r\n\r\nprocedure TParser.HandleNewLine;\r\nbegin\r\n  if fBuf[fPos]=#13 then //CR\r\n    GotoToNextChar;\r\n\r\n  if (not fEOFReached) and (fBuf[fPos]=#10) then //LF\r\n    GotoToNextChar;\r\n\r\n  inc(fSourceLine);\r\n  fDeltaPos:=-(fPos-1);\r\nend;\r\n\r\nprocedure TParser.SkipBOM;\r\n\r\nbegin\r\n  // No BOM support\r\nend;\r\n\r\nprocedure TParser.SkipSpaces;\r\nbegin\r\n  while not FEofReached and (fBuf[fPos] in [' ',#9]) do GotoToNextChar;\r\nend;\r\n\r\nprocedure TParser.SkipWhitespace;\r\nbegin\r\n  while not FEofReached do\r\n  begin\r\n    case fBuf[fPos] of\r\n      ' ',#9  : SkipSpaces;\r\n      #10,#13 : HandleNewLine\r\n      else break;\r\n    end;\r\n  end;\r\nend;\r\n\r\nprocedure TParser.HandleEof;\r\nbegin\r\n  fToken:=toEOF;\r\n  fLastTokenStr:='';\r\nend;\r\n\r\nprocedure TParser.HandleAlphaNum;\r\nbegin\r\n  fLastTokenStr:=GetAlphaNum;\r\n  fToken:=toSymbol;\r\nend;\r\n\r\nprocedure TParser.HandleNumber;\r\ntype\r\n  floatPunct = (fpDot,fpE);\r\n  floatPuncts = set of floatPunct;\r\nvar\r\n  allowed : floatPuncts;\r\nbegin\r\n  fLastTokenStr:='';\r\n  while IsNumber do\r\n    ProcessChar;\r\n  fToken:=toInteger;\r\n  if (fBuf[fPos] in ['.','e','E']) then\r\n  begin\r\n    fToken:=toFloat;\r\n    allowed:=[fpDot,fpE];\r\n    while (fBuf[fPos] in ['.','e','E','0'..'9']) do\r\n    begin\r\n      case fBuf[fPos] of\r\n        '.'     : if fpDot in allowed then Exclude(allowed,fpDot) else break;\r\n        'E','e' : if fpE in allowed then\r\n                  begin\r\n                    allowed:=[];\r\n                    ProcessChar;\r\n                    if (fBuf[fPos] in ['+','-']) then ProcessChar;\r\n                    if not (fBuf[fPos] in ['0'..'9']) then\r\n                      ErrorFmt(SParserInvalidFloat,[fLastTokenStr+fBuf[fPos]]);\r\n                  end\r\n                  else break;\r\n      end;\r\n      ProcessChar;\r\n    end;\r\n  end;\r\n  if (fBuf[fPos] in ['s','S','d','D','c','C']) then //single, date, currency\r\n  begin\r\n    fFloatType:=fBuf[fPos];\r\n\r\n    GotoToNextChar;\r\n\r\n    fToken:=toFloat;\r\n  end\r\n  else fFloatType:=#0;\r\nend;\r\n\r\nprocedure TParser.HandleHexNumber;\r\nvar valid : boolean;\r\nbegin\r\n  fLastTokenStr:='$';\r\n  GotoToNextChar;\r\n  valid:=false;\r\n  while IsHexNum do\r\n  begin\r\n    valid:=true;\r\n    ProcessChar;\r\n  end;\r\n  if not valid then\r\n    ErrorFmt(SParserInvalidInteger,[fLastTokenStr]);\r\n  fToken:=toInteger;\r\nend;\r\n\r\nfunction TParser.HandleQuotedString: string;\r\nbegin\r\n  Result:='';\r\n  GotoToNextChar;\r\n\r\n  while true do\r\n  begin\r\n    case fBuf[fPos] of\r\n      #0     : ErrorStr(SParserUnterminatedString);\r\n      #13,#10 : ErrorStr(SParserUnterminatedString);\r\n      ''''   : begin\r\n                 GotoToNextChar;\r\n                 if fBuf[fPos]<>'''' then exit;\r\n               end;\r\n    end;\r\n    Result:=Result+fBuf[fPos];\r\n    GotoToNextChar;\r\n  end;\r\nend;\r\n\r\nFunction TParser.HandleDecimalCharacter : Char;\r\n\r\nvar\r\n   i : integer;\r\n\r\nbegin\r\n  GotoToNextChar;\r\n  // read a word number\r\n  i:=0;\r\n  while IsNumber and (i<high(word)) do\r\n    begin\r\n    i:=i*10+Ord(fBuf[fPos])-ord('0');\r\n    GotoToNextChar;\r\n    end;\r\n  if i>high(word) then i:=0;\r\n  Result:=Char(i);\r\nend;\r\n\r\nprocedure TParser.HandleString;\r\n\r\nvar\r\n  s: string;\r\n\r\nbegin\r\n  fLastTokenStr:='';\r\n  while true do\r\n  begin\r\n    case fBuf[fPos] of\r\n      '''' :\r\n        begin\r\n          s:=HandleQuotedString;\r\n          fLastTokenStr:=fLastTokenStr+s;\r\n        end;\r\n      '#'  :\r\n        begin\r\n          fLastTokenStr:=fLastTokenStr+HandleDecimalCharacter;\r\n        end;\r\n      else break;\r\n    end;\r\n  end;\r\n  fToken:=TParserToken.toString\r\nend;\r\n\r\nprocedure TParser.HandleMinus;\r\nbegin\r\n  GotoToNextChar;\r\n  if IsNumber then\r\n  begin\r\n    HandleNumber;\r\n    fLastTokenStr:='-'+fLastTokenStr;\r\n  end\r\n  else\r\n  begin\r\n    fToken:=toMinus;\r\n    fLastTokenStr:='-';\r\n  end;\r\nend;\r\n\r\nprocedure TParser.HandleUnknown;\r\nbegin\r\n  fToken:=toUnknown;\r\n  fLastTokenStr:=fBuf[fPos];\r\n  GotoToNextChar;\r\nend;\r\n\r\nconstructor TParser.Create(Stream: TStream);\r\nbegin\r\n  fStream:=Stream;\r\n  SetLength(fBuf,ParseBufSize);\r\n  fBufLen:=0;\r\n  fPos:=0;\r\n  fDeltaPos:=1;\r\n  fSourceLine:=1;\r\n  fEofReached:=false;\r\n  fLastTokenStr:='';\r\n  fFloatType:=#0;\r\n  fToken:=toEOF;\r\n  LoadBuffer;\r\n  SkipBom;\r\n  NextToken;\r\nend;\r\n\r\nprocedure TParser.GotoToNextChar;\r\nbegin\r\n  Inc(FPos);\r\n\r\n  CheckLoadBuffer;\r\nend;\r\n\r\ndestructor TParser.Destroy;\r\n\r\nVar\r\n  aCount : Integer;\r\n\r\nbegin\r\n  aCount:=Length(fLastTokenStr)*2;\r\n  fStream.Position:=SourcePos-aCount;\r\nend;\r\n\r\nprocedure TParser.CheckToken(T: tParserToken);\r\nbegin\r\n  if fToken<>T then\r\n    ErrorFmt(SParserWrongTokenType,[GetTokenName(T),GetTokenName(fToken)]);\r\nend;\r\n\r\nprocedure TParser.CheckTokenSymbol(const S: string);\r\nbegin\r\n  CheckToken(toSymbol);\r\n  if CompareText(fLastTokenStr,S)<>0 then\r\n    ErrorFmt(SParserWrongTokenSymbol,[s,fLastTokenStr]);\r\nend;\r\n\r\nprocedure TParser.Error(const Ident: string);\r\nbegin\r\n  ErrorStr(Ident);\r\nend;\r\n\r\nprocedure TParser.ErrorFmt(const Ident: string; const Args: array of const);\r\nbegin\r\n  ErrorStr(Format(Ident,Args));\r\nend;\r\n\r\nprocedure TParser.ErrorStr(const Message: string);\r\nbegin\r\n  raise EParserError.CreateFmt(Message+SParserLocInfo,[SourceLine,fPos+fDeltaPos,SourcePos]);\r\nend;\r\n\r\nprocedure TParser.HexToBinary(Stream: TStream);\r\n\r\nvar\r\n  outbuf : TBytes;\r\n  b : byte;\r\n  i : integer;\r\n\r\nbegin\r\n  SetLength(OutBuf,ParseBufSize);\r\n  i:=0;\r\n  SkipWhitespace;\r\n  while IsHexNum do\r\n  begin\r\n    b:=(GetHexValue(fBuf[fPos]) shl 4);\r\n    GotoToNextChar;\r\n    if not IsHexNum then\r\n      Error(SParserUnterminatedBinValue);\r\n    b:=b or GetHexValue(fBuf[fPos]);\r\n    GotoToNextChar;\r\n    outbuf[i]:=b;\r\n    inc(i);\r\n    if i>=ParseBufSize then\r\n    begin\r\n      Stream.WriteBuffer(outbuf,i);\r\n      i:=0;\r\n    end;\r\n    SkipWhitespace;\r\n  end;\r\n  if i>0 then\r\n    Stream.WriteBuffer(outbuf,i);\r\n  NextToken;\r\nend;\r\n\r\nfunction TParser.NextToken: TParserToken;\r\n\r\n  Procedure SetToken(aToken : TParserToken);\r\n  begin\r\n    FToken:=aToken;\r\n    GotoToNextChar;\r\n  end;\r\n\r\nbegin\r\n  SkipWhiteSpace;\r\n  if fEofReached then\r\n    HandleEof\r\n  else\r\n    case fBuf[fPos] of\r\n      '_','A'..'Z','a'..'z' : HandleAlphaNum;\r\n      '$'                   : HandleHexNumber;\r\n      '-'                   : HandleMinus;\r\n      '0'..'9'              : HandleNumber;\r\n      '''','#'              : HandleString;\r\n      '[' : SetToken(toSetStart);\r\n      '(' : SetToken(toListStart);\r\n      '<' : SetToken(toCollectionStart);\r\n      '{' : SetToken(toBinaryStart);\r\n      ']' : SetToken(toSetEnd);\r\n      ')' : SetToken(toListEnd);\r\n      '>' : SetToken(toCollectionEnd);\r\n      '}' : SetToken(toBinaryEnd);\r\n      ',' : SetToken(toComma);\r\n      '.' : SetToken(toDot);\r\n      '=' : SetToken(toEqual);\r\n      ':' : SetToken(toColon);\r\n      '+' : SetToken(toPlus);\r\n      else\r\n        HandleUnknown;\r\n    end;\r\n  Result:=fToken;\r\nend;\r\n\r\nfunction TParser.SourcePos: Longint;\r\nbegin\r\n  Result:=fStream.Position-fBufLen+fPos;\r\nend;\r\n\r\nfunction TParser.TokenComponentIdent: string;\r\nbegin\r\n  if fToken<>toSymbol then\r\n    ErrorFmt(SParserExpected,[GetTokenName(toSymbol)]);\r\n  CheckLoadBuffer;\r\n  while fBuf[fPos]='.' do\r\n  begin\r\n    ProcessChar;\r\n    fLastTokenStr:=fLastTokenStr+GetAlphaNum;\r\n  end;\r\n  Result:=fLastTokenStr;\r\nend;\r\n\r\nFunction TParser.TokenFloat: double;\r\n\r\nvar\r\n  errcode : integer;\r\n\r\nbegin\r\n  Val(fLastTokenStr,Result,errcode);\r\n  if errcode<>0 then\r\n    ErrorFmt(SParserInvalidFloat,[fLastTokenStr]);\r\nend;\r\n\r\nFunction TParser.TokenInt: NativeInt;\r\nbegin\r\n  if not TryStrToInt64(fLastTokenStr,Result) then\r\n    Result:=StrToQWord(fLastTokenStr); //second chance for malformed files\r\nend;\r\n\r\nfunction TParser.TokenString: string;\r\nbegin\r\n  case fToken of\r\n    toFloat : if fFloatType<>#0 then\r\n                Result:=fLastTokenStr+fFloatType\r\n              else Result:=fLastTokenStr;\r\n    else\r\n      Result:=fLastTokenStr;\r\n  end;\r\nend;\r\n\r\n\r\nfunction TParser.TokenSymbolIs(const S: string): Boolean;\r\nbegin\r\n  Result:=(fToken=toSymbol) and (CompareText(fLastTokenStr,S)=0);\r\nend;\r\n\r\n\r\nprocedure TObjectTextConverter.WriteWord(w : word); {$ifdef CLASSESINLINE}inline;{$endif CLASSESINLINE}\r\nbegin\r\n  Output.WriteBufferData(w);\r\nend;\r\n\r\nprocedure TObjectTextConverter.WriteDWord(lw : longword); {$ifdef CLASSESINLINE}inline;{$endif CLASSESINLINE}\r\nbegin\r\n  Output.WriteBufferData(lw);\r\nend;\r\n\r\nprocedure TObjectTextConverter.WriteQWord(q : NativeInt); {$ifdef CLASSESINLINE}inline;{$endif CLASSESINLINE}\r\nbegin\r\n  Output.WriteBufferData(q);\r\nend;\r\n\r\nprocedure TObjectTextConverter.WriteDouble(e : double);\r\nbegin\r\n  Output.WriteBufferData(e);\r\nend;\r\n\r\nprocedure TObjectTextConverter.WriteString(s: String);\r\n\r\nvar\r\n  i,size : byte;\r\n\r\nbegin\r\n  if length(s)>255 then\r\n    size:=255\r\n  else\r\n    size:=length(s);\r\n  Output.WriteByte(size);\r\n  For I:=1 to Length(S) do\r\n     Output.WriteBufferData(s[i]);\r\nend;\r\n\r\nprocedure TObjectTextConverter.WriteWString(Const s: WideString);\r\n\r\nvar\r\n  i : Integer;\r\nbegin\r\n  WriteDWord(Length(s));\r\n  For I:=1 to Length(S) do\r\n    Output.WriteBufferData(s[i]);\r\nend;\r\n\r\nprocedure TObjectTextConverter.WriteInteger(value: NativeInt);\r\n\r\nbegin\r\n  if (value >= -128) and (value <= 127) then begin\r\n    Output.WriteByte(Ord(vaInt8));\r\n    Output.WriteByte(byte(value));\r\n  end else if (value >= -32768) and (value <= 32767) then begin\r\n    Output.WriteByte(Ord(vaInt16));\r\n    WriteWord(word(value));\r\n  end else if (value >= -2147483648) and (value <= 2147483647) then begin\r\n    Output.WriteByte(Ord(vaInt32));\r\n    WriteDWord(longword(value));\r\n  end else begin\r\n    Output.WriteByte(ord(vaInt64));\r\n    WriteQWord(NativeUInt(value));\r\n  end;\r\nend;\r\n\r\nprocedure TObjectTextConverter.ProcessWideString(const left : string);\r\n\r\nvar\r\n   ws : string;\r\nbegin\r\n  ws:=left+parser.TokenString;\r\n  while parser.NextToken = toPlus do\r\n    begin\r\n    parser.NextToken;   // Get next string fragment\r\n    if not (parser.Token=TParserToken.toString) then\r\n      parser.CheckToken(TParserToken.toString);\r\n    ws:=ws+parser.TokenString;\r\n    end;\r\n  Output.WriteByte(Ord(vaWstring));\r\n  WriteWString(ws);\r\nend;\r\n\r\n\r\nprocedure TObjectTextConverter.ProcessValue;\r\nvar\r\n  flt: double;\r\n  stream: TBytesStream;\r\nbegin\r\n  case parser.Token of\r\n    toInteger:\r\n      begin\r\n        WriteInteger(parser.TokenInt);\r\n        parser.NextToken;\r\n      end;\r\n    toFloat:\r\n      begin\r\n        Output.WriteByte(Ord(vaExtended));\r\n        flt := Parser.TokenFloat;\r\n        WriteDouble(flt);\r\n        parser.NextToken;\r\n      end;\r\n    TParserToken.toString:\r\n      ProcessWideString('');\r\n    toSymbol:\r\n      begin\r\n        if CompareText(parser.TokenString, 'True') = 0 then\r\n          Output.WriteByte(Ord(vaTrue))\r\n        else if CompareText(parser.TokenString, 'False') = 0 then\r\n          Output.WriteByte(Ord(vaFalse))\r\n        else if CompareText(parser.TokenString, 'nil') = 0 then\r\n          Output.WriteByte(Ord(vaNil))\r\n        else\r\n        begin\r\n          Output.WriteByte(Ord(vaIdent));\r\n          WriteString(parser.TokenComponentIdent);\r\n        end;\r\n        Parser.NextToken;\r\n      end;\r\n    // Set\r\n    toSetStart:\r\n      begin\r\n        parser.NextToken;\r\n        Output.WriteByte(Ord(vaSet));\r\n        if parser.Token <> toSetEnd then\r\n          while True do\r\n          begin\r\n            parser.CheckToken(toSymbol);\r\n            WriteString(parser.TokenString);\r\n            parser.NextToken;\r\n            if parser.Token = toSetEnd then\r\n              break;\r\n            parser.CheckToken(toComma);\r\n            parser.NextToken;\r\n          end;\r\n        Output.WriteByte(0);\r\n        parser.NextToken;\r\n      end;\r\n    // List\r\n    toListStart:\r\n      begin\r\n        parser.NextToken;\r\n        Output.WriteByte(Ord(vaList));\r\n        while parser.Token <> toListEnd do\r\n          ProcessValue;\r\n        Output.WriteByte(0);\r\n        parser.NextToken;\r\n      end;\r\n    // Collection\r\n    toCollectionStart:\r\n      begin\r\n        parser.NextToken;\r\n        Output.WriteByte(Ord(vaCollection));\r\n        while parser.Token <> toCollectionEnd do\r\n        begin\r\n          parser.CheckTokenSymbol('item');\r\n          parser.NextToken;\r\n          // ConvertOrder\r\n          Output.WriteByte(Ord(vaList));\r\n          while not parser.TokenSymbolIs('end') do\r\n            ProcessProperty;\r\n          parser.NextToken;   // Skip 'end'\r\n          Output.WriteByte(0);\r\n        end;\r\n        Output.WriteByte(0);\r\n        parser.NextToken;\r\n      end;\r\n    // Binary data\r\n    toBinaryStart:\r\n      begin\r\n        Output.WriteByte(Ord(vaBinary));\r\n        stream := TBytesStream.Create;\r\n        try\r\n          parser.HexToBinary(stream);\r\n          WriteDWord(stream.Size);\r\n          Output.WriteBuffer(Stream.Bytes,Stream.Size);\r\n        finally\r\n          stream.Free;\r\n        end;\r\n        parser.NextToken;\r\n      end;\r\n    else\r\n      parser.Error(SParserInvalidProperty);\r\n  end;\r\nend;\r\n\r\nprocedure TObjectTextConverter.ProcessProperty;\r\nvar\r\n  name: String;\r\nbegin\r\n  // Get name of property\r\n  parser.CheckToken(toSymbol);\r\n  name := parser.TokenString;\r\n  while True do begin\r\n    parser.NextToken;\r\n    if parser.Token <> toDot then break;\r\n    parser.NextToken;\r\n    parser.CheckToken(toSymbol);\r\n    name := name + '.' + parser.TokenString;\r\n  end;\r\n  WriteString(name);\r\n  parser.CheckToken(toEqual);\r\n  parser.NextToken;\r\n  ProcessValue;\r\nend;\r\n\r\nprocedure TObjectTextConverter.ProcessObject;\r\nvar\r\n  Flags: Byte;\r\n  ObjectName, ObjectType: String;\r\n  ChildPos: Integer;\r\nbegin\r\n  if parser.TokenSymbolIs('OBJECT') then\r\n    Flags :=0  { IsInherited := False }\r\n  else begin\r\n    if parser.TokenSymbolIs('INHERITED') then\r\n      Flags := 1 { IsInherited := True; }\r\n    else begin\r\n      parser.CheckTokenSymbol('INLINE');\r\n      Flags := 4;\r\n    end;\r\n  end;\r\n  parser.NextToken;\r\n  parser.CheckToken(toSymbol);\r\n  ObjectName := '';\r\n  ObjectType := parser.TokenString;\r\n  parser.NextToken;\r\n  if parser.Token = toColon then begin\r\n    parser.NextToken;\r\n    parser.CheckToken(toSymbol);\r\n    ObjectName := ObjectType;\r\n    ObjectType := parser.TokenString;\r\n    parser.NextToken;\r\n    if parser.Token = toSetStart then begin\r\n      parser.NextToken;\r\n      ChildPos := parser.TokenInt;\r\n      parser.NextToken;\r\n      parser.CheckToken(toSetEnd);\r\n      parser.NextToken;\r\n      Flags := Flags or 2;\r\n    end;\r\n  end;\r\n  if Flags <> 0 then begin\r\n    Output.WriteByte($f0 or Flags);\r\n    if (Flags and 2) <> 0 then\r\n      WriteInteger(ChildPos);\r\n  end;\r\n  WriteString(ObjectType);\r\n  WriteString(ObjectName);\r\n\r\n  // Convert property list\r\n  while not (parser.TokenSymbolIs('END') or\r\n    parser.TokenSymbolIs('OBJECT') or\r\n    parser.TokenSymbolIs('INHERITED') or\r\n    parser.TokenSymbolIs('INLINE')) do\r\n    ProcessProperty;\r\n  Output.WriteByte(0);        // Terminate property list\r\n\r\n  // Convert child objects\r\n  while not parser.TokenSymbolIs('END') do ProcessObject;\r\n  parser.NextToken;           // Skip end token\r\n  Output.WriteByte(0);        // Terminate property list\r\nend;\r\n\r\nprocedure TObjectTextConverter.ObjectTextToBinary(aInput, aOutput: TStream);\r\n\r\nbegin\r\n  FinPut:=aInput;\r\n  FOutput:=aOutput;\r\n  Execute;\r\nend;\r\n\r\nprocedure TObjectTextConverter.Execute;\r\nbegin\r\n  If Not Assigned(Input) then\r\n    raise EReadError.Create('Missing input stream');\r\n  If Not Assigned(Output) then\r\n    raise EReadError.Create('Missing output stream');\r\n  FParser := TParser.Create(Input);\r\n  try\r\n    Output.WriteBufferData(FilerSignatureInt);\r\n    ProcessObject;\r\n  finally\r\n    FParser.Free;\r\n  end;\r\nend;\r\n\r\nprocedure ObjectTextToBinary(aInput, aOutput: TStream);\r\n\r\nvar\r\n  Conv : TObjectTextConverter;\r\n\r\nbegin\r\n  Conv:=TObjectTextConverter.Create;\r\n  try\r\n    Conv.ObjectTextToBinary(aInput, aOutput);\r\n  finally\r\n    Conv.free;\r\n  end;\r\nend;\r\n\r\n\r\n{ ----------------------------------------------------------------------\r\n  TDatamodule\r\n  ----------------------------------------------------------------------}\r\n\r\nconstructor TDataModule.Create(AOwner: TComponent);\r\nbegin\r\n  CreateNew(AOwner);\r\n  if (ClassType <> TDataModule) and\r\n     not (csDesigning in ComponentState) then\r\n    begin\r\n    if not InitInheritedComponent(Self, TDataModule) then\r\n      raise EStreamError.CreateFmt(SErrNoSTreaming, [ClassName]);\r\n    if OldCreateOrder then\r\n      DoCreate;\r\n    end;\r\nend;\r\n\r\nconstructor TDataModule.CreateNew(AOwner: TComponent);\r\n\r\nbegin\r\n  CreateNew(AOwner,0);\r\nend;\r\n\r\nconstructor TDataModule.CreateNew(AOwner: TComponent; CreateMode: Integer);\r\nbegin\r\n  inherited Create(AOwner);\r\n  FDPPI := 96;\r\n  if Assigned(AddDataModule) and (CreateMode>=0) then\r\n    AddDataModule(Self);\r\nend;\r\n\r\nclass constructor TDataModule.ClassCreate;\r\nbegin\r\n  RegisterInitComponentHandler(TDataModule,@DefaultInitHandler);\r\nend;\r\n\r\nprocedure TDataModule.AfterConstruction;\r\nbegin\r\n   If not OldCreateOrder then\r\n     DoCreate;\r\nend;\r\n\r\nprocedure TDataModule.BeforeDestruction;\r\nbegin\r\n  Destroying;\r\n  RemoveFixupReferences(Self, '');\r\n  if not OldCreateOrder then\r\n    DoDestroy;\r\nend;\r\n\r\ndestructor TDataModule.Destroy;\r\nbegin\r\n  if OldCreateOrder then\r\n    DoDestroy;\r\n  if Assigned(RemoveDataModule) then\r\n    RemoveDataModule(Self);\r\n  inherited Destroy;\r\nend;\r\n\r\nprocedure TDataModule.DoCreate;\r\nbegin\r\n  if Assigned(FOnCreate) then\r\n    try\r\n      FOnCreate(Self);\r\n    except\r\n      if not HandleCreateException then\r\n        raise;\r\n    end;\r\nend;\r\n\r\nprocedure TDataModule.DoDestroy;\r\nbegin\r\n  if Assigned(FOnDestroy) then\r\n    try\r\n      FOnDestroy(Self);\r\n    except\r\n      if Assigned(ApplicationHandleException) then\r\n        ApplicationHandleException(Self);\r\n    end;\r\nend;\r\n\r\nprocedure TDataModule.DefineProperties(Filer: TFiler);\r\n\r\nvar\r\n  Ancestor : TDataModule;\r\n  HaveData,\r\n  HavePPIData: Boolean;\r\n\r\nbegin\r\n  inherited DefineProperties(Filer);\r\n  Ancestor := TDataModule(Filer.Ancestor);\r\n  HaveData:=(Ancestor=Nil) or\r\n            (FDSize.X<>Ancestor.FDSize.X) or\r\n            (FDSize.Y<>Ancestor.FDSize.Y) or\r\n            (FDPos.Y<>Ancestor.FDPos.Y) or\r\n            (FDPos.X<>Ancestor.FDPos.X);\r\n  HavePPIData:=(Assigned(Ancestor) and (FDPPI<>Ancestor.FDPPI)) or\r\n               (not Assigned(Ancestor) and (FDPPI<>96));\r\n  Filer.DefineProperty('Height', @ReadH, @WriteH, HaveData);\r\n  Filer.DefineProperty('HorizontalOffset', @ReadL, @WriteL, HaveData);\r\n  Filer.DefineProperty('VerticalOffset', @ReadT,@WriteT, HaveData);\r\n  Filer.DefineProperty('Width', @ReadW, @WriteW, HaveData);\r\n  Filer.DefineProperty('PPI', @ReadP, @WriteP,HavePPIData);\r\nend;\r\n\r\nprocedure TDataModule.GetChildren(Proc: TGetChildProc; Root: TComponent);\r\n\r\nvar\r\n  I : Integer;\r\n\r\nbegin\r\n  inherited GetChildren(Proc, Root);\r\n  if (Root=Self) then\r\n    for I:=0 to ComponentCount-1 do\r\n      If Not Components[I].HasParent then\r\n         Proc(Components[i]);\r\nend;\r\n\r\n\r\nfunction TDataModule.HandleCreateException: Boolean;\r\nbegin\r\n  Result:=Assigned(ApplicationHandleException);\r\n  if Result then\r\n    ApplicationHandleException(Self);\r\nend;\r\n\r\nprocedure TDataModule.ReadP(Reader: TReader);\r\nbegin\r\n  FDPPI := Reader.ReadInteger;\r\nend;\r\n\r\nprocedure TDataModule.ReadState(Reader: TReader);\r\nbegin\r\n  FOldOrder := false;\r\n  inherited ReadState(Reader);\r\nend;\r\n\r\nprocedure TDataModule.ReadT(Reader: TReader);\r\nbegin\r\n  FDPos.Y := Reader.ReadInteger;\r\nend;\r\n\r\nprocedure TDataModule.WriteT(Writer: TWriter);\r\nbegin\r\n  Writer.WriteInteger(FDPos.Y);\r\nend;\r\n\r\nprocedure TDataModule.ReadL(Reader: TReader);\r\nbegin\r\n  FDPos.X := Reader.ReadInteger;\r\nend;\r\n\r\nprocedure TDataModule.WriteL(Writer: TWriter);\r\nbegin\r\n  Writer.WriteInteger(FDPos.X);\r\nend;\r\n\r\nprocedure TDataModule.ReadW(Reader: TReader);\r\nbegin\r\n  FDSIze.X := Reader.ReadInteger;\r\nend;\r\n\r\nprocedure TDataModule.WriteP(Writer: TWriter);\r\nbegin\r\n  Writer.WriteInteger(FDPPI);\r\nend;\r\n\r\nprocedure TDataModule.WriteW(Writer: TWriter);\r\nbegin\r\n  Writer.WriteInteger(FDSIze.X);\r\nend;\r\n\r\nprocedure TDataModule.ReadH(Reader: TReader);\r\nbegin\r\n  FDSIze.Y := Reader.ReadInteger;\r\nend;\r\n\r\nprocedure TDataModule.WriteH(Writer: TWriter);\r\nbegin\r\n  Writer.WriteInteger(FDSIze.Y);\r\nend;\r\n\r\ninitialization\r\n  ClassList:=TJSObject.New;\r\nend.\r\n\r\n","{\r\n    This file is part of the Pas2JS run time library.\r\n    Copyright (c) 2022 by Michael Van Canneyt\r\n    \r\n    Browser Worker and Window API definitions\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n\r\n{$IFNDEF FPC_DOTTEDUNITS}\r\nunit weborworker;\r\n{$ENDIF}\r\n\r\n{$mode objfpc}\r\n{$modeswitch externalclass}\r\n\r\ninterface\r\n\r\nuses\r\n{$IFDEF FPC_DOTTEDUNITS}\r\n  JSApi.JS, System.Types;\r\n{$ELSE}\r\n  JS, types;\r\n{$ENDIF}\r\n\r\ntype\r\n  // Forward declarations\r\n\r\n  TJSCryptoKey = Class;\r\n  TJSSubtleCrypto = Class;\r\n  TJSEventTarget = class;\r\n  TIDBDatabase = class;\r\n  TJSIDBObjectStore = class;\r\n  TJSIDBRequest = class;\r\n  TJSServiceWorker = class;\r\n  TJSReadableStream = class;\r\n  TJSClient = class;\r\n  TJSFileSystemHandle = class;\r\n  TJSFileSystemFileHandle = class;\r\n  TJSFileSystemDirectoryHandle = class;\r\n  TJSFileSystemWritableFileStream = class;\r\n  TJSFileSystemSyncAccessHandle = class;\r\n  TFileSystemHandleKind = String;\r\n  TWriteCommandType = String;\r\n\r\n\r\n  TJSFileSystemFileHandleArray = array of TJSFileSystemFileHandle;\r\n  TJSFileSystemDirectoryHandleArray = array of TJSFileSystemDirectoryHandle;\r\n\r\n\r\n{ ----------------------------------------------------------------------\r\n  Console\r\n  ----------------------------------------------------------------------}\r\n\r\n\r\n  TJSConsole = class external name 'Console'  (TJSObject)\r\n  Public\r\n    procedure assert(anAssertion : string; Obj1 : JSValue); varargs;\r\n    Procedure clear;\r\n    procedure count; overload;\r\n    procedure count(aCounter : String);\r\n    procedure debug(Obj1 : JSValue); varargs of JSValue;\r\n    procedure error(Obj1 : JSValue); varargs of JSValue;\r\n    procedure group; overload;\r\n    procedure group(aLabel : String); overload;\r\n    procedure groupCollapsed; overload;\r\n    procedure groupCollapsed(aLabel : String);overload;\r\n    procedure groupEnd;\r\n    procedure info(Obj1 : JSValue); varargs of JSValue;\r\n    procedure log(Obj1 : JSValue); varargs of JSValue;\r\n    procedure table(args: array of JSValue); overload;\r\n    procedure table(args: array of JSValue; Columns : Array of string);\r\n    procedure table(args: TJSObject); overload;\r\n    procedure table(args: TJSObject; Columns : Array of string); overload;\r\n    procedure time(aName : string);\r\n    procedure timeEnd(aName : string);\r\n    procedure trace;\r\n    procedure warn(Obj1 : JSValue); varargs of JSValue;\r\n  end;\r\n\r\n{ ----------------------------------------------------------------------\r\n  Events\r\n  ----------------------------------------------------------------------}\r\n\r\n\r\n  TJSTimerCallBack = reference to procedure; safecall;\r\n\r\n  TJSEventInit = record\r\n    bubbles : boolean;\r\n    cancelable : boolean;\r\n    scoped : boolean;\r\n    composed : boolean;\r\n  end;\r\n\r\n  TJSEvent = class external name 'Event'  (TJSObject)\r\n  Private\r\n    FBubbles : Boolean; external name 'bubbles';\r\n    FCancelable : Boolean; external name 'cancelable';\r\n    FComposed : Boolean; external name 'composed';\r\n    FCurrentTarget : TJSEventTarget; external name 'currentTarget';\r\n    FdefaultPrevented : Boolean; external name 'defaultPrevented';\r\n    FEventPhase : NativeInt; external name 'eventPhase';\r\n    FTarget : TJSEventTarget; external name 'target';\r\n    FTimeStamp : NativeInt; external name 'timestamp';\r\n    FType : String; external name 'type';\r\n    FIsTrusted : Boolean; external name 'isTrusted';\r\n  Public\r\n    Const\r\n      NONE = 0;\r\n      CAPTURING_PHASE = 1;\r\n      AT_TARGET  = 2;\r\n      BUBBLING_PHASE = 3;\r\n  public\r\n    cancelBubble : Boolean;\r\n    constructor new (aType : String; const aInit : TJSEventInit); overload;\r\n    constructor new (aType : String); overload;\r\n    procedure preventDefault;\r\n    procedure stopImmediatePropagation;\r\n    procedure stopPropagation;\r\n    Property bubbles : Boolean Read FBubbles;\r\n    Property cancelable : Boolean Read FCancelable;\r\n    Property composed : Boolean Read FComposed;\r\n    property currentTarget : TJSEventTarget Read FCurrentTarget;\r\n    property defaultPrevented : Boolean Read FdefaultPrevented;\r\n    property eventPhase : NativeInt Read FEventPhase;\r\n    property target : TJSEventTarget Read FTarget;\r\n    Property timestamp : NativeInt Read FTimeStamp;\r\n    property _type : string read FType;\r\n    property isTrusted : Boolean Read FIsTrusted;\r\n  end;\r\n\r\n  TJSExtendableEvent = class external name 'ExtendableEvent' (TJSEvent)\r\n    Procedure waitUntil(aPromise : TJSPromise);\r\n  end;\r\n\r\n\r\n  TJSEventHandler = reference to function(Event: TJSEvent): boolean; safecall;\r\n  TJSRawEventHandler = reference to Procedure(Event: TJSEvent); safecall;\r\n\r\n  TJSEventTarget = class external name 'EventTarget' (TJSObject)\r\n  public\r\n    procedure addEventListener(aname : string; aListener : TJSEventHandler);\r\n    procedure addEventListener(aname : string; aListener : TJSRawEventHandler);\r\n    procedure addEventListener(aname : string; aListener : JSValue);\r\n    function dispatchEvent(event : JSValue) : Boolean;\r\n    procedure removeEventListener(aname : string; aListener : TJSEventHandler);\r\n    procedure removeEventListener(aname : string; aListener : TJSRawEventHandler);\r\n    procedure removeEventListener(aname : string; aListener : JSValue);\r\n  end;\r\n\r\n\r\n  TJSMessagePort = class external name 'MessagePort' (TJSEventTarget)\r\n  Public\r\n    procedure close;\r\n    procedure postMessage(aValue : JSValue);\r\n    procedure postMessage(aValue : JSValue; aList : TJSValueDynArray);\r\n    procedure start;\r\n  end;\r\n  TJSMessagePortDynArray = Array of TJSMessagePort;\r\n\r\n  { TJSMessageEvent }\r\n\r\n  TJSMessageEvent = class external name 'MessageEvent' (TJSEvent)\r\n  private\r\n    FData: JSValue; external name 'data';\r\n    FLastEventID: String; external name 'lastEventID';\r\n    FOrigin: String;  external name 'origin';\r\n    FPorts: TJSMessagePortDynArray; external name 'ports';\r\n  Public\r\n    Property Data : JSValue Read FData;\r\n    Property LastEventID : String Read FLastEventID;\r\n    Property Origin : String Read FOrigin;\r\n    Property Ports : TJSMessagePortDynArray Read FPorts;\r\n  end;\r\n\r\n  { TJSExtendableMessageEvent }\r\n\r\n  TJSExtendableMessageEvent = class external name 'ExtendableMessageEvent' (TJSExtendableEvent)\r\n  private\r\n    FData: JSValue; external name 'data';\r\n    FLastEventID: String; external name 'lastEventId';\r\n    FOrigin: String; external name 'origin';\r\n    FPorts: TJSMessagePortDynArray; external name 'ports';\r\n    FSource: TJSObject; external name 'source';\r\n    FSourceClient: TJSClient; external name 'source';\r\n    FSourcePort: TJSMessagePort; external name 'source';\r\n    FSourceServiceWorker: TJSServiceWorker; external name 'source';\r\n  Public\r\n    Property Data : JSValue Read FData;\r\n    Property LastEventID : String Read FLastEventID;\r\n    Property Origin : String Read FOrigin;\r\n    Property Ports : TJSMessagePortDynArray Read FPorts;\r\n    Property Source : TJSObject Read FSource;\r\n    // Possible types for Source\r\n    Property SourceServiceWorker : TJSServiceWorker Read FSourceServiceWorker;\r\n    Property SourcePort : TJSMessagePort Read FSourcePort;\r\n    Property SourceClient : TJSClient Read FSourceClient;\r\n  end;\r\n\r\n\r\n  { TJSClient }\r\n\r\n  TJSClient = class external name 'Client' (TJSObject)\r\n  private\r\n    FFrameType: String; external name 'frameType';\r\n    FID: String; external name 'id';\r\n    FType: String; external name 'type';\r\n    FURL: String; external name 'url';\r\n  Public\r\n    procedure postMessage(aValue : JSValue);\r\n    procedure postMessage(aValue : JSValue; aList : TJSValueDynArray);\r\n    Property Id : String Read FID;\r\n    Property Type_ : String Read FType;\r\n    Property FrameType : String Read FFrameType;\r\n    Property URL : String Read FURL;\r\n  end;\r\n\r\n\r\n{ ----------------------------------------------------------------------\r\n  Fetch & Streams\r\n  ----------------------------------------------------------------------}\r\n\r\n\r\n  TJSStructuredSerializeOptions = class external name 'Object' (TJSObject)\r\n    transfer : TJSValueDynArray;\r\n  end;\r\n\r\n  TJSReadableStreamDefaultReader = class external name 'ReadableStreamDefaultReader' (TJSObject)\r\n   private\r\n     fclosed: TJSPromise; external name 'closed';\r\n   public\r\n     property closed: TJSPromise read fclosed;\r\n     constructor new(stream: TJSReadableStream);\r\n     function cancel(): TJSPromise; overload;\r\n     function cancel(reason: string): TJSPromise; overload;\r\n     function read(): TJSPromise;\r\n     function releaseLock(): TJSPromise;\r\n   end;\r\n\r\n\r\n  TJSReadableStream = class external name 'ReadableStream' (TJSObject)\r\n  private\r\n    flocked: Boolean; external name 'locked';\r\n  public\r\n    property locked: Boolean read flocked;\r\n    constructor new(underlyingSource: TJSObject);\r\n    constructor new(underlyingSource, queueingStrategy: TJSObject);\r\n    function cancel(reason: String): TJSPromise;\r\n    function getReader(): TJSReadableStreamDefaultReader; overload;\r\n    function getReader(mode: TJSObject): TJSReadableStreamDefaultReader; overload;\r\n    function pipeThrough(transformStream: TJSObject): TJSReadableStream; overload;\r\n    function pipeThrough(transformStream, options: TJSObject): TJSReadableStream; overload;\r\n    function pipeTo(destination: TJSObject): TJSPromise; overload;\r\n    function pipeTo(destination, options: TJSObject): TJSPromise; overload;\r\n    function tee(): TJSArray; // array containing two TJSReadableStream instances\r\n  end;\r\n\r\n  TJSWritableStream = class external name 'WritableStream' (TJSObject)\r\n  private\r\n    FLocked: Boolean; external name 'locked';\r\n  public\r\n    function abort(reason: String): TJSPromise;\r\n    function close: TJSPromise;\r\n    function getWriter: TJSObject;\r\n    property locked: Boolean read FLocked;\r\n  end;\r\n\r\n\r\n  TJSBlob = class external name 'Blob' (TJSEventTarget)\r\n  private\r\n    FSize: NativeInt; external name 'size';\r\n    FType: string; external name  'type';\r\n  Public\r\n    constructor New(AArray: JSValue); overload;\r\n    constructor New(AArray: JSValue; AOptions: TJSObject); overload;\r\n    procedure close;\r\n    function slice : TJSBlob; overload;\r\n    function slice(aStart : NativeInt) : TJSBlob; overload;\r\n    function slice(aStart,aEnd : NativeInt) : TJSBlob; overload;\r\n    function slice(aStart,aEnd : NativeInt; AContentType : String) : TJSBlob; overload;\r\n    function arrayBuffer : TJSPromise;\r\n    property size : NativeInt read FSize;\r\n    property _type : string read FType; deprecated;\r\n    property type_ : string read FType;\r\n  end;\r\n\r\n  TJSFileNewOptions = class external name 'Object' (TJSObject)\r\n    type_ : string; external name 'type';\r\n    lastModifier : NativeInt;\r\n  end;\r\n\r\n  { TJSFile }\r\n\r\n  TJSFile = class external name 'File' (TJSBlob)\r\n  private\r\n    fLastModified: NativeInt; external name 'lastModified';\r\n    fname: String; external name 'fname';\r\n  public\r\n    constructor new(Bits : TJSArray; const aName: string);\r\n    constructor new(Bits: TJSDataView; const aName : string);\r\n    constructor new(Bits : TJSArray; const aName: string; aOptions : TJSFileNewOptions);\r\n    constructor new(Bits: TJSDataView; const aName : string; aOptions : TJSFileNewOptions);\r\n    property Name : String  read fname;\r\n    property lastModified : NativeInt Read fLastModified;\r\n  end;\r\n\r\n  TJSBody = class external name 'Body' (TJSObject)\r\n  private\r\n    fbody: TJSReadableStream; external name 'body';\r\n    fbodyUsed: Boolean; external name 'bodyUsed';\r\n  public\r\n    property body: TJSReadableStream read fbody;\r\n    property bodyUsed: Boolean read fbodyUsed;\r\n    function arrayBuffer(): TJSPromise; // resolves to TJSArrayBuffer\r\n    function blobPromise(): TJSPromise; // resolves to TJSBlob\r\n    function blob: TJSBlob; {$IFNDEF SkipAsync}async;{$ENDIF}\r\n    function json(): TJSPromise; // resolves to JSON / TJSValue\r\n    //function text(): TJSPromise; // resolves to USVString, always decoded using UTF-8\r\n    function text(): string; {$IFNDEF SkipAsync}async;{$ENDIF}\r\n  end;\r\n\r\n  Theader = Array [0..1] of String;\r\n  THeaderArray = Array of Theader;\r\n\r\n  TJSHTMLHeaders = Class external name 'Headers' (TJSObject)\r\n  Public\r\n    constructor new(values : THeaderArray); overload;\r\n    procedure append(aName, aValue : String);\r\n    procedure delete(aName : String);\r\n    function entries : TJSIterator;\r\n    Function get(aName: String): string;  // string, but can be Null. Only use after Has returned true.\r\n    function getRaw(const aName : string): JSValue; external name 'get'; // can return null\r\n    Function has(aName: String): Boolean;\r\n    function keys : TJSIterator; reintroduce;\r\n    function values : TJSIterator; reintroduce;\r\n    procedure set_(aName, aValue : String);\r\n    Property Headers[aName : string] : string Read Get Write Set_;\r\n  end;\r\n\r\n  TJSResponseInit = class external name 'Object'\r\n    status : Integer;\r\n    statusText : String;\r\n    headersObj : TJSObject;\r\n    headers : TJSHTMLHeaders;\r\n  end;\r\n\r\n  TJSResponse = class external name 'Response' (TJSBody)\r\n  private\r\n    fheaders: TJSHTMLHeaders; external name 'headers';\r\n    fok: Boolean; external name 'ok';\r\n    fredirected: Boolean; external name 'redirected';\r\n    fstatus: NativeInt; external name 'status';\r\n    fstatusText: String; external name 'statusText';\r\n    ftype: String; external name 'type';\r\n    furl: String; external name 'url';\r\n    fuseFinalUrl: Boolean; external name 'useFinalUrl';\r\n  public\r\n    constructor new(body: TJSObject); overload; external name 'new';\r\n    constructor new(body: TJSObject; init: TJSObject); overload; external name 'new'; deprecated;\r\n    constructor new(body: TJSObject; init: TJSResponseInit); overload; external name 'new';\r\n    constructor new(Msg: string); overload; external name 'new';\r\n    constructor new(Msg: string; init: TJSObject); overload; external name 'new';   deprecated;\r\n    constructor new(Msg: string; init: TJSResponseInit); overload; external name 'new';\r\n\r\n    function clone(): TJSResponse;\r\n    function error(): TJSResponse;\r\n    function redirect(url: String; Status: NativeInt): TJSResponse;\r\n    property headers: TJSHTMLHeaders read fheaders; //\r\n    property ok: Boolean read fok;\r\n    property redirected: Boolean read fredirected;\r\n    property status: NativeInt read fstatus;\r\n    property statusText: String read fstatusText; //\r\n    property type_: String read ftype; //\r\n    property url: String read furl; //\r\n    property useFinalUrl: Boolean read fuseFinalUrl write fuseFinalUrl;\r\n  end;\r\n\r\n  TJSFormData = class external name 'FormData' (TJSObject)\r\n  public\r\n    procedure append(const aName, aValue: string); overload;\r\n    procedure append(const aName: string; const aValue: TJSBlob); overload;\r\n    procedure append(const aName: string; const aValue: TJSBlob; const aFileName: string); overload;\r\n    procedure delete(const aName: string);\r\n    function entries : TJSIterator;\r\n    function get(const aName : string): JSValue; //string or TJSFile\r\n    function getAll: TJSArray; // of FormDataEntryValue(string or TJSFile)\r\n    function has(const aName : string): Boolean;\r\n    function keys: TJSIterator; reintroduce;\r\n    procedure set_(const aName, aValue: string); overload; external name 'set';\r\n    procedure set_(const aName, aValue, aFileName: string); overload; external name 'set';\r\n    procedure set_(const aName: string; const aValue: TJSBlob); overload; external name 'set';\r\n    procedure set_(const aName: string; const aValue: TJSBlob; const aFileName: string); overload; external name 'set';\r\n    function values: TJSIterator; reintroduce;\r\n  end;\r\n\r\n  { TJSRequest }\r\n\r\n  TJSRequest = class external name 'Request' (TJSObject)\r\n  private\r\n    FBody: TJSReadableStream; external name 'body';\r\n    FBodyUsed: Boolean; external name 'bodyUsed';\r\n    FCache: String; external name 'cache';\r\n    FCredentials: TJSObject; external name 'credentials';\r\n    FDestination: String; external name 'destination';\r\n    FHeaders: TJSHTMLHeaders; external name 'headers';\r\n    FIntegrity: String; external name 'integrity';\r\n    FMethod: String; external name 'method';\r\n    FMode: String; external name 'mode';\r\n    FReferrer: string; external name 'referrer';\r\n    FReferrerPolicy: string; external name 'referrerPolicy';\r\n    FURL: String;external name 'url';\r\n  Public\r\n    constructor new(aInput: string); overload;\r\n    constructor new(aInput: string; aOptions: TJSObject); overload;\r\n    function arrayBuffer: TJSPromise; // TJSArrayBuffer\r\n    function blob: TJSPromise; // TJSBlob\r\n    function clone: TJSRequest;\r\n    function formData: TJSPromise; // TJSFormData\r\n    function json: TJSPromise; // TJSJSON\r\n    function text: TJSPromise; // string\r\n    Property body : TJSReadableStream Read FBody;\r\n    property bodyUsed : Boolean Read FBodyUsed;\r\n    Property Cache : String Read FCache;\r\n    Property Credentials : TJSObject Read FCredentials;\r\n    Property Destination : String Read FDestination;\r\n    Property Headers : TJSHTMLHeaders Read FHeaders;\r\n    Property Integrity : String Read FIntegrity;\r\n    Property Method : String Read FMethod;\r\n    Property Mode : String Read FMode;\r\n    Property Referrer : string Read FReferrer;\r\n    Property ReferrerPolicy : string Read FReferrerPolicy;\r\n    Property URL : String Read FURL;\r\n  end;\r\n  TJSRequestDynArray = array of TJSRequest;\r\n\r\n  { TJSFetchEvent }\r\n\r\n  TJSFetchEvent = class external name 'FetchEvent' (TJSExtendableEvent)\r\n  private\r\n    FClientID: String; external name 'clientId';\r\n    FReplacesClientID: String; external name 'replacesClientId';\r\n    FRequest: TJSRequest; external name 'request';\r\n    FResultingClientID: String; external name 'resultingClientId';\r\n    FPreloadResponse: TJSPromise; external name 'preloadResponse';\r\n  Public\r\n    Procedure respondWith(aPromise : TJSPromise);\r\n    Procedure respondWith(aResponse : TJSResponse);\r\n    Property ClientId : String Read FClientID;\r\n    Property PreloadResponse : TJSPromise Read FPreloadResponse;\r\n    Property ReplacesClientID : String Read FReplacesClientID;\r\n    Property ResultingClientID : String Read FResultingClientID;\r\n    Property request : TJSRequest Read FRequest;\r\n  end;\r\n\r\n{ ----------------------------------------------------------------------\r\n  IndexedDB\r\n  ----------------------------------------------------------------------}\r\n\r\n\r\n  TJSIDBTransactionMode = class\r\n  const\r\n    readonly = 'readonly';\r\n    readwrite = 'readwrite';\r\n    versionchange = 'versionchange';\r\n  end;\r\n\r\n\r\n  { TJSIDBTransaction }\r\n\r\n  TJSIDBTransaction = class external name 'IDBTransaction'  (TJSEventTarget)\r\n  private\r\n    FDB : TIDBDatabase; external name 'db';\r\n    FError: JSValue; external name 'error';\r\n    FMode: String; external name 'mode';\r\n    FObjectStoreNames: TStringDynArray; external name 'objectStoreNames';\r\n  public\r\n    procedure abort;\r\n    function objectStore(aName : String) : TJSIDBObjectStore;\r\n    property db : TIDBDatabase read FDB;\r\n    property mode : String read FMode;\r\n    property objectStoreNames : TStringDynArray read FObjectStoreNames;\r\n    property error : JSValue read FError;\r\n  end;\r\n\r\n\r\n  { TJSIDBKeyRange }\r\n\r\n  TJSIDBKeyRange = class external name 'IDBKeyRange'  (TJSObject)\r\n  private\r\n    FLower: JSValue;\r\n    FLowerOpen: Boolean;\r\n    FUpper: JSValue;\r\n    FUpperOpen: Boolean;\r\n  Public\r\n    Class Function bound(aLower,aUpper : JSValue) : TJSIDBKeyRange; overload;\r\n    Class Function bound(aLower,aUpper : JSValue; aLowerOpen : Boolean) : TJSIDBKeyRange; overload;\r\n    Class Function bound(aLower,aUpper : JSValue; aLowerOpen,aUpperOpen : Boolean) : TJSIDBKeyRange; overload;\r\n    Class Function lowerBound(aLower : JSValue) : TJSIDBKeyRange; overload;\r\n    Class Function lowerBound(aLower : JSValue; aOpen: Boolean) : TJSIDBKeyRange; overload;\r\n    Class Function only(aValue : JSValue) : TJSIDBKeyRange;\r\n    Class Function upperBound(aUpper : JSValue) : TJSIDBKeyRange; overload;\r\n    Class Function upperBound(aUpper : JSValue; aOpen: Boolean) : TJSIDBKeyRange; overload;\r\n    function includes (aValue : JSValue) : Boolean;\r\n    property lower : JSValue read FLower;\r\n    property lowerOpen : Boolean read FLowerOpen;\r\n    property upper : JSValue read FUpper;\r\n    property upperOpen : Boolean read FUpperOpen;\r\n  end;\r\n\r\n  TJSIDBIndexParameters = record\r\n    unique : boolean;\r\n    multiEntry : boolean;\r\n    locale : string;\r\n  end;\r\n\r\n\r\n  { TJSIDBIndex }\r\n\r\n  TJSIDBIndex = class external name 'IDBIndex'  (TJSObject)\r\n  private\r\n    FKeyPath: JSValue; external name 'keyPath';\r\n    FMultiEntry: Boolean; external name 'multiEntry';\r\n    FObjectStore: TJSIDBObjectStore; external name 'objectStore';\r\n    FUnique: boolean; external name 'unique';\r\n  public\r\n    name : string;\r\n    function count : TJSIDBRequest;\r\n    function get(aKey : jsValue) : TJSIDBRequest; overload;\r\n    function get(aKey : TJSIDBKeyRange) : TJSIDBRequest; overload;\r\n    function getAll(aKey : jsValue) : TJSIDBRequest; overload;\r\n    function getAll(aKey : TJSIDBKeyRange) : TJSIDBRequest; overload;\r\n    function getAll(aKey : jsValue; ACount : NativeInt) : TJSIDBRequest; overload;\r\n    function getAll(aKey : TJSIDBKeyRange; ACount : NativeInt) : TJSIDBRequest; overload;\r\n    function getAllKeys(aKey : jsValue) : TJSIDBRequest; overload;\r\n    function getAllKeys(aKey : TJSIDBKeyRange) : TJSIDBRequest; overload;\r\n    function getAllKeys(aKey : jsValue; ACount : NativeInt) : TJSIDBRequest; overload;\r\n    function getAllKeys(aKey : TJSIDBKeyRange; ACount : NativeInt) : TJSIDBRequest; overload;\r\n    function getKey(aKey : jsValue) : TJSIDBRequest;\r\n    function openCursor : TJSIDBRequest; overload;\r\n    function openCursor(aKeyRange : TJSIDBKeyRange) : TJSIDBRequest; overload;\r\n    function openCursor(aKeyRange : TJSIDBKeyRange; ADirection : String) : TJSIDBRequest;overload;\r\n    function openKeyCursor : TJSIDBRequest;overload;\r\n    function openKeyCursor(aKeyRange : TJSIDBKeyRange) : TJSIDBRequest;overload;\r\n    function openKeyCursor(aKeyRange : TJSIDBKeyRange; ADirection : String) : TJSIDBRequest;overload;\r\n    Property keyPath : JSValue Read FKeyPath;\r\n    property multiEntry : Boolean read FMultiEntry;\r\n    property objectStore : TJSIDBObjectStore read FObjectStore;\r\n    property unique : boolean read FUnique;\r\n  end;\r\n\r\n  TJSIDBCursorDirection = class external name 'IDBCursorDirection'  (TJSObject)\r\n  Const\r\n    next = 'next';\r\n    nextUnique = 'nextUnique';\r\n    prev = 'prev';\r\n    prevUnique = 'prevUnique';\r\n  end;\r\n\r\n\r\n  { TJSIDBCursor }\r\n\r\n  TJSIDBCursor = class external name 'IDBCursor'  (TJSObject)\r\n  private\r\n    FDirection: string; external name 'direction';\r\n    FKey: JSValue; external name 'key';\r\n    FValue : JSValue; external name 'value';\r\n    FPrimaryKey: JSValue; external name 'primaryKey';\r\n    FSource: JSValue; external name 'source';\r\n    FSourceAsIndex: TJSIDBIndex; external name 'source';\r\n    FSourceAsStore: TJSIDBObjectStore; external name 'source';\r\n  Public\r\n    procedure advance(aCount : NativeInt); overload;\r\n    procedure advance(aKey : JSValue); overload;\r\n    procedure continue(aKey : JSValue); overload;\r\n    procedure continue; overload;\r\n    procedure continuePrimaryKey(aKey : JSValue); overload;\r\n    procedure continuePrimaryKey(aKey,aPrimaryKey : JSValue); overload;\r\n    procedure delete;\r\n    procedure update(aValue : JSValue);\r\n    property source : JSValue read FSource;\r\n    property sourceAsStore : TJSIDBObjectStore read FSourceAsStore;\r\n    property sourceAsIndex : TJSIDBIndex read FSourceAsIndex;\r\n    property key : JSValue read FKey;\r\n    Property Value : JSValue Read FValue;\r\n    property primaryKey : JSValue read FPrimaryKey;\r\n    property direction : string read FDirection;\r\n  end;\r\n\r\n  TJSIDBObjectStore = class external name 'IDBObjectStore'  (TJSEventTarget)\r\n  public\r\n    function add(aValue : JSValue; aKey : String) : TJSIDBRequest;\r\n    function add(aValue : JSValue) : TJSIDBRequest;\r\n    function clear : TJSIDBRequest;\r\n    function delete(aKey : string) : TJSIDBRequest;\r\n    function delete(aKeyRange : TJSIDBKeyRange) : TJSIDBRequest;\r\n    function get(aKey : string) : TJSIDBRequest; overload;\r\n    function get(aKeyRange : TJSIDBKeyRange) : TJSIDBRequest; overload;\r\n    function getKey(aKey : string) : TJSIDBRequest; overload;\r\n    function getKey(aKeyRange : TJSIDBKeyRange) : TJSIDBRequest; overload;\r\n    function getAll : TJSIDBRequest; overload;\r\n    function getAll(aKey : String) : TJSIDBRequest; overload;\r\n    function getAll(aKeyRange : TJSIDBKeyRange) : TJSIDBRequest; overload;\r\n    function getAll(aKey : String; aCount: NativeInt) : TJSIDBRequest; overload;\r\n    function getAll(aKeyRange : TJSIDBKeyRange; aCount: NativeInt) : TJSIDBRequest; overload;\r\n    function getAllKeys(aKey : String) : TJSIDBRequest; overload;\r\n    function getAllKeys(aKeyRange : TJSIDBKeyRange) : TJSIDBRequest; overload;\r\n    function getAllKeys(aKey : String; aCount: NativeInt) : TJSIDBRequest; overload;\r\n    function getAllKeys(aKeyRange : TJSIDBKeyRange; aCount: NativeInt) : TJSIDBRequest; overload;\r\n    function createIndex (aIndexName : String; KeyPath : String)  : TJSIDBIndex; overload;\r\n    function createIndex (aIndexName : String; KeyPath : String; Options : TJSIDBIndexParameters)  : TJSIDBIndex; overload;\r\n    function createIndex (aIndexName : String; KeyPath : Array of String)  : TJSIDBIndex; overload;\r\n    function createIndex (aIndexName : String; KeyPath : Array of String; Options : TJSIDBIndexParameters)  : TJSIDBIndex; overload;\r\n    Procedure deleteIndex (aIndexName : String);\r\n    function index (aIndexName : String)  : TJSIDBIndex;\r\n    function put(aValue : JSValue; aKey : String) : TJSIDBRequest; overload;\r\n    function put(aValue : JSValue) : TJSIDBRequest; overload;\r\n    function openCursor : TJSIDBRequest; overload;\r\n    function openCursor(aKey : String) : TJSIDBRequest; overload;\r\n    function openCursor(aKeyRange : TJSIDBKeyRange) : TJSIDBRequest; overload;\r\n    function openCursor(aKey : String; aDirection : string) : TJSIDBRequest; overload;\r\n    function openCursor(aKeyRange : TJSIDBKeyRange; aDirection : string) : TJSIDBRequest; overload;\r\n    function openKeyCursor : TJSIDBRequest; overload;\r\n    function openKeyCursor(aKey : String) : TJSIDBRequest; overload;\r\n    function openKeyCursor(aKeyRange : TJSIDBKeyRange) : TJSIDBRequest; overload;\r\n    function openKeyCursor(aKey : String; aDirection : string) : TJSIDBRequest; overload;\r\n    function openKeyCursor(aKeyRange : TJSIDBKeyRange; aDirection : string) : TJSIDBRequest; overload;\r\n    function count : TJSIDBRequest; overload;\r\n    function count(aKey : String) : TJSIDBRequest; overload;\r\n    function count(aKeyRange : TJSIDBKeyRange) : TJSIDBRequest; overload;\r\n    property Indexes [aIndexName : String] : TJSIDBIndex read index;\r\n  end;\r\n\r\n  { TJSIDBRequest }\r\n\r\n  TJSIDBRequest = class external name 'IDBRequest'  (TJSEventTarget)\r\n  private\r\n    Ferror : JSValue; external name 'error'; // standards are not quite clear on this one\r\n    FReadyState: string; external name 'readyState';\r\n    FResult: JSValue; external name 'result';\r\n    FResultDatabase: TIDBDatabase; external name 'result';\r\n    FResultIndex: TJSIDBIndex; external name 'result';\r\n    FResultObjectStore : TJSIDBObjectStore; external name 'result';\r\n    FResultCursor : TJSIDBCursor; external name 'result';\r\n    FSourceDatabase: TIDBDatabase; external name 'source';\r\n    FSourceIndex: TJSIDBIndex; external name 'source';\r\n    FSourceObjectStore : TJSIDBObjectStore; external name 'source';\r\n    FSourceCursor : TJSIDBCursor; external name 'source';\r\n    FSource: JSValue; external name 'source';\r\n    FTransaction: TJSIDBTransaction; external name 'transaction';\r\n  Public\r\n    onerror : TJSEventHandler;\r\n    onsuccess : TJSEventHandler;\r\n    Property error : JSValue read FError;\r\n    property readyState : string read FReadyState;\r\n\r\n    property result : JSValue read FResult;\r\n    property resultAsObjectStore : TJSIDBObjectStore read FResultObjectStore;\r\n    property resultAsCursor : TJSIDBCursor read FResultCursor;\r\n    property resultAsIndex : TJSIDBIndex read FResultIndex;\r\n    property resultAsDatabase : TIDBDatabase read FResultDatabase;\r\n\r\n    property source : JSValue read FSource;\r\n    property sourceAsObjectStore : TJSIDBObjectStore read FSourceObjectStore;\r\n    property sourceAsCursor : TJSIDBCursor read FSourceCursor;\r\n    property sourceAsIndex : TJSIDBIndex read FSourceIndex;\r\n    property sourceAsDatabase : TIDBDatabase read FSourceDatabase;\r\n\r\n    property transaction : TJSIDBTransaction read FTransaction;\r\n  end;\r\n\r\n  TJSIDBOpenDBRequest = class external name 'IDBOpenDBRequest' (TJSIDBRequest)\r\n  Public\r\n    onblocked : TJSEventHandler;\r\n    onupgradeneeded : TJSEventHandler;\r\n  end;\r\n\r\n  TJSCreateObjectStoreOptions = record\r\n    keyPath : jsValue;\r\n    autoIncrement : boolean;\r\n  end;\r\n\r\n  { TIDBDatabase }\r\n\r\n  TIDBDatabase = class external name 'IDBDatabase' (TJSEventTarget)\r\n  private\r\n    FName: string; external name 'name';\r\n    FobjectStoreNames: TStringDynArray; external name 'objectStoreNames';\r\n    FVersion: integer; external name 'version';\r\n  public\r\n    procedure close;\r\n    function createObjectStore(aName : string) : TJSIDBObjectStore; overload;\r\n    function createObjectStore(aName : string; Options: TJSCreateObjectStoreOptions) : TJSIDBObjectStore; overload;\r\n    procedure deleteObjectStore(aName : string);\r\n    function transaction(aStoreNames : array of string) : TJSIDBTransaction; overload;\r\n    function transaction(aStoreNames : array of string; aMode : string) : TJSIDBTransaction; overload;\r\n    property name : string read FName;\r\n    property version : integer read FVersion;\r\n    property objectStoreNames : TStringDynArray read FobjectStoreNames;\r\n  end;\r\n\r\n  TJSIDBFactory = class external name 'IDBFactory' (TJSEventTarget)\r\n  public\r\n    function open(aName : string) : TJSIDBOpenDBRequest;\r\n    function open(aName : string; aVersion : Integer) : TJSIDBOpenDBRequest;\r\n    function deleteDatabase(aName : string) : TJSIDBOpenDBRequest;\r\n    function cmp (a,b : jsValue) : NativeInt;\r\n  end;\r\n\r\n{ ----------------------------------------------------------------------\r\n  Cache\r\n  ----------------------------------------------------------------------}\r\n\r\n\r\n  TJSCacheDeleteOptions = class external name 'Object' (TJSObject)\r\n    ignoreSearch : Boolean;\r\n    ignoreMethod : Boolean;\r\n    ignoreVary : Boolean;\r\n    cacheName : string;\r\n  end;\r\n\r\n  TJSParamEnumCallBack = reference to procedure (const aKey,aValue : string);\r\n\r\n  TJSURLSearchParams = class external name 'URLSearchParams' (TJSObject)\r\n  Public\r\n    constructor new(aQuery : String);\r\n    Procedure append(const aName,aValue : string);\r\n    Procedure delete(const aName : string);\r\n    Function entries : TJSIterator;\r\n    Procedure foreach(aEnumCallBack : TJSParamEnumCallBack);\r\n    function get(const aName : string) : JSValue;\r\n    // If you're sure the value exists...\r\n    function getString(const aName : string) : string; external name 'get';\r\n    function getAll(const aName : string) : TStringDynArray;\r\n    function has(const aName : string) : Boolean;\r\n    Function keys : TJSIterator; reintroduce;\r\n    Procedure set_(const aName,aValue : string); external name 'set';\r\n    Procedure sort;\r\n    Function values : TJSIterator; reintroduce;\r\n  end;\r\n\r\n  TJSURL = class external name 'URL' (TJSObject)\r\n  Private\r\n    FOrigin : String; external name 'origin';\r\n    FSearchParams : TJSURLSearchParams; external name 'searchParams';\r\n  public\r\n    hash : string;\r\n    host : string;\r\n    hostname : string;\r\n    href : string;\r\n    password : string;\r\n    pathname : string;\r\n    port : string;\r\n    protocol : string;\r\n    search : string;\r\n    username : string;\r\n    constructor new(aURL : String);\r\n    constructor new(aURL,aBase : String);\r\n    class function createObjectURL(const v: JSValue): string;\r\n    class function revokeObjectURL(const S : String): string;\r\n    function toJSON : String;\r\n    Property Origin : String Read FOrigin;\r\n    property SearchParams : TJSURLSearchParams read FSearchParams;\r\n  end;\r\n  TJSURLDynArray = array of TJSURL;\r\n\r\n\r\n  { TJSNavigationPreloadState }\r\n\r\n  TJSNavigationPreloadState = class external name 'navigationPreloadState'\r\n  public\r\n    enabled: boolean;\r\n    headerValue: string;\r\n  end;\r\n\r\n\r\n  { TJSCache }\r\n\r\n  TJSCache = class external name 'Cache' (TJSObject)\r\n  Public\r\n    Function add(aRequest : String) : TJSPromise;\r\n    Function add(aRequest : TJSURL) : TJSPromise;\r\n    Function addAll(aRequests : TJSStringDynArray) : TJSPromise;\r\n    Function addAll(aRequests : TJSURLDynArray) : TJSPromise;\r\n    Function addAll(aRequests : TJSValueDynArray) : TJSPromise;\r\n    Function put(aRequest : String; aResponse : TJSResponse) : TJSPromise;\r\n    Function put(aRequest : TJSRequest; aResponse : TJSResponse) : TJSPromise;\r\n    Function delete(aRequest : String) : TJSPromise;\r\n    Function delete(aRequest : TJSRequest) : TJSPromise;\r\n    Function delete(aRequest : String; aOptions : TJSObject) : TJSPromise;\r\n    Function delete(aRequest : TJSRequest; aOptions : TJSObject) : TJSPromise;\r\n    Function delete(aRequest : String; aOptions : TJSCacheDeleteOptions) : TJSPromise;\r\n    Function delete(aRequest : TJSRequest; aOptions : TJSCacheDeleteOptions) : TJSPromise;\r\n    Function keys : TJSPromise; reintroduce;\r\n    Function match(aRequest : String): TJSPromise;\r\n    Function match(aRequest : TJSRequest): TJSPromise;\r\n    Function matchAll(aRequest : TJSStringDynArray): TJSPromise;\r\n    Function matchAll(aRequest : TJSRequestDynArray): TJSPromise;\r\n    Function matchAll(aRequests : TJSValueDynArray) : TJSPromise;\r\n  end;\r\n\r\n  TJSCacheStorage = class external name 'CacheStorage' (TJSObject)\r\n  Public\r\n    function delete(aName : string) : TJSPromise; // resolves to boolean\r\n    function has(aName : string) : TJSPromise;\r\n    Function keys : TJSPromise; reintroduce;\r\n    Function match(aRequest : String): TJSPromise;\r\n    Function match(aRequest : TJSRequest): TJSPromise;\r\n    function open(aName : string) : TJSPromise;\r\n  end;\r\n\r\n\r\n{ ----------------------------------------------------------------------\r\n  Crypto\r\n  ----------------------------------------------------------------------}\r\n\r\n  { Basic types }\r\n\r\n  TJSCryptoAlgorithmIdentifier = JSValue;\r\n  TJSCryptoNamedCurve = JSValue;\r\n  TJSCryptoBigInteger = TJSUint8Array;\r\n  TJSCryptoKeyUsage = string;\r\n  TJSCryptoKeyType = string;\r\n  TJSCryptoKeyFormat = string;\r\n\r\n  { Algorithm }\r\n\r\n  TJSCryptoAlgorithm = record\r\n    name : String;\r\n  end;\r\n\r\n  { AesCbcParams }\r\n\r\n  TJSCryptoAesCbcParams = record\r\n    iv : TJSBufferSource;\r\n  end;\r\n\r\n  { AesCtrParams }\r\n\r\n  TJSCryptoAesCtrParams = record\r\n    counter : TJSBufferSource;\r\n    length_ : Byte;external name 'length';\r\n  end;\r\n\r\n  { AesGcmParams }\r\n\r\n  TJSCryptoAesGcmParams = record\r\n    iv : TJSBufferSource;\r\n    additionalData : TJSBufferSource;\r\n    tagLength : Byte;\r\n  end;\r\n\r\n  { HmacImportParams }\r\n\r\n  TJSCryptoHmacImportParams = record\r\n    hash : TJSCryptoAlgorithmIdentifier;\r\n  end;\r\n\r\n  { Pbkdf2Params }\r\n\r\n  TJSCryptoPbkdf2Params = record\r\n    salt : TJSBufferSource;\r\n    iterations : NativeInt;\r\n    hash : TJSCryptoAlgorithmIdentifier;\r\n  end;\r\n\r\n  { RsaHashedImportParams }\r\n\r\n  TJSCryptoRsaHashedImportParams = record\r\n    hash : TJSCryptoAlgorithmIdentifier;\r\n  end;\r\n\r\n  { AesKeyGenParams }\r\n\r\n  TJSCryptoAesKeyGenParams = record\r\n    length_ : Integer;external name 'length';\r\n  end;\r\n\r\n  { HmacKeyGenParams }\r\n\r\n  TJSCryptoHmacKeyGenParams = record\r\n    hash : TJSCryptoAlgorithmIdentifier;\r\n    length_ : Integer;external name 'length';\r\n  end;\r\n\r\n  { RsaHashedKeyGenParams }\r\n\r\n  TJSCryptoRsaHashedKeyGenParams = record\r\n    modulusLength : Integer;\r\n    publicExponent : TJSCryptoBigInteger;\r\n    hash : TJSCryptoAlgorithmIdentifier;\r\n  end;\r\n\r\n  { RsaOaepParams }\r\n\r\n  TJSCryptoRsaOaepParams = record\r\n    label_ : TJSBufferSource;external name 'label';\r\n  end;\r\n\r\n  { RsaPssParams }\r\n\r\n  TJSCryptoRsaPssParams = record\r\n    saltLength : Integer;\r\n  end;\r\n\r\n  { DhKeyGenParams }\r\n\r\n  TJSCryptoDhKeyGenParams = record\r\n    prime : TJSCryptoBigInteger;\r\n    generator : TJSCryptoBigInteger;\r\n  end;\r\n\r\n  { EcKeyGenParams }\r\n\r\n  TJSCryptoEcKeyGenParams = record\r\n    _namedCurve : TJSCryptoNamedCurve;external name 'namedCurve';\r\n  end;\r\n\r\n  { AesDerivedKeyParams }\r\n\r\n  TJSCryptoAesDerivedKeyParams = record\r\n    length_ : Integer;external name 'length';\r\n  end;\r\n\r\n  { HmacDerivedKeyParams }\r\n\r\n  TJSCryptoHmacDerivedKeyParams = record\r\n    length_ : Integer;external name 'length';\r\n  end;\r\n\r\n  { EcdhKeyDeriveParams }\r\n\r\n  TJSCryptoEcdhKeyDeriveParams = record\r\n    public_ : TJSCryptoKey; external name 'public';\r\n  end;\r\n\r\n  { DhKeyDeriveParams }\r\n\r\n  TJSCryptoDhKeyDeriveParams = record\r\n    public_ : TJSCryptoKey;  external name 'public';\r\n  end;\r\n\r\n  { DhImportKeyParams }\r\n\r\n  TJSCryptoDhImportKeyParams = record\r\n    prime : TJSCryptoBigInteger;\r\n    generator : TJSCryptoBigInteger;\r\n  end;\r\n\r\n  { EcdsaParams }\r\n\r\n  TJSCryptoEcdsaParams = record\r\n    hash : TJSCryptoAlgorithmIdentifier;\r\n  end;\r\n\r\n  { EcKeyImportParams }\r\n\r\n  TJSCryptoEcKeyImportParams = record\r\n    _namedCurve : TJSCryptoNamedCurve;external name 'namedCurve';\r\n  end;\r\n\r\n  { HkdfParams  }\r\n\r\n  TJSCryptoHkdfParams = record\r\n    hash : TJSCryptoAlgorithmIdentifier;\r\n    salt : TJSBufferSource;\r\n    info : TJSBufferSource;\r\n  end;\r\n\r\n  { RsaOtherPrimesInfo }\r\n\r\n  TJSCryptoRsaOtherPrimesInfo = record\r\n    r : String;\r\n    d : String;\r\n    t : String;\r\n  end;\r\n\r\n  { JsonWebKey }\r\n\r\n  TJSCryptoRsaOtherPrimesInfoDynArray = Array of TJSCryptoRsaOtherPrimesInfo;\r\n  TJSCryptoJsonWebKey = record\r\n    kty : String;\r\n    use : String;\r\n    key_ops : TStringDynArray;\r\n    alg : String;\r\n    ext : boolean;\r\n    crv : String;\r\n    x : String;\r\n    y : String;\r\n    d : String;\r\n    n : String;\r\n    e : String;\r\n    p : String;\r\n    q : String;\r\n    dp : String;\r\n    dq : String;\r\n    qi : String;\r\n    oth : TJSCryptoRsaOtherPrimesInfoDynArray;\r\n    k : String;\r\n  end;\r\n\r\n  { CryptoKeyPair }\r\n\r\n  TJSCryptoKeyPair = record\r\n    publicKey : TJSCryptoKey;\r\n    privateKey : TJSCryptoKey;\r\n  end;\r\n\r\n  { TJSCryptoKey }\r\n\r\n  TJSCryptoKeyUsageDynArray = Array of TJSCryptoKeyUsage;\r\n  TJSCryptoKey = class external name 'CryptoKey'\r\n  Private\r\n    Ftype_ : TJSCryptoKeyType; external name 'type';\r\n    Fextractable : boolean; external name 'extractable';\r\n    Falgorithm : TJSObject; external name 'algorithm';\r\n    Fusages : TJSCryptoKeyUsageDynArray; external name 'usages';\r\n  Public\r\n    Property type_ : TJSCryptoKeyType Read Ftype_;\r\n    Property extractable : boolean Read Fextractable;\r\n    Property algorithm : TJSObject Read Falgorithm;\r\n    Property usages : TJSCryptoKeyUsageDynArray Read Fusages;\r\n  end;\r\n\r\n  { TJSSubtleCrypto }\r\n\r\n  TJSSubtleCrypto = class external name 'SubtleCrypto'\r\n  Private\r\n  Public\r\n    function encrypt(algorithm :  TJSCryptoAlgorithmIdentifier; key : TJSCryptoKey; data : TJSBufferSource): TJSArrayBuffer; async;\r\n    function decrypt(algorithm : TJSCryptoAlgorithmIdentifier; key : TJSCryptoKey; data : TJSBufferSource): TJSArrayBuffer; async;\r\n    function sign(algorithm : TJSCryptoAlgorithmIdentifier; key : TJSCryptoKey; data : TJSBufferSource): TJSArrayBuffer; async;\r\n    function verify(algorithm : TJSCryptoAlgorithmIdentifier; key : TJSCryptoKey; signature : TJSBufferSource; data : TJSBufferSource): Boolean; async;\r\n    function digest(algorithm : TJSCryptoAlgorithmIdentifier; data : TJSBufferSource): TJSArrayBuffer; async;\r\n    function generateKey(algorithm : TJSCryptoAlgorithmIdentifier; extractable : boolean; keyUsages : TJSCryptoKeyUsageDynArray): TJSPromise;\r\n    function deriveKey(algorithm : TJSCryptoAlgorithmIdentifier; baseKey : TJSCryptoKey; derivedKeyType : TJSCryptoAlgorithmIdentifier; extractable : boolean; keyUsages : TJSCryptoKeyUsageDynArray): TJSCryptoKey; async;\r\n    function deriveBits(algorithm : TJSCryptoAlgorithmIdentifier; baseKey : TJSCryptoKey; length_ : NativeInt): TJSArrayBuffer; async;\r\n    function importKey(format : TJSCryptoKeyFormat; keyData : TJSObject; algorithm : TJSCryptoAlgorithmIdentifier; extractable : boolean; keyUsages : TJSCryptoKeyUsageDynArray): TJSCryptoKey; async;\r\n    function exportKey(format : TJSCryptoKeyFormat; key : TJSCryptoKey): TJSPromise;\r\n    function wrapKey(format : TJSCryptoKeyFormat; key : TJSCryptoKey; wrappingKey : TJSCryptoKey; wrapAlgorithm : TJSCryptoAlgorithmIdentifier): TJSArrayBuffer; async;\r\n    function unwrapKey(format : TJSCryptoKeyFormat; wrappedKey : TJSBufferSource; unwrappingKey : TJSCryptoKey; unwrapAlgorithm : TJSCryptoAlgorithmIdentifier; unwrappedKeyAlgorithm : TJSCryptoAlgorithmIdentifier; extractable : boolean; keyUsages : TJSCryptoKeyUsageDynArray): TJSCryptoKey; async;\r\n  end;\r\n\r\n  { TJSCrypto }\r\n\r\n  TJSCrypto = class external name 'Crypto'  (TJSObject)\r\n  private\r\n    Fsubtle: TJSSubtleCrypto; external name 'subtle';\r\n  Public\r\n    procedure getRandomValues (anArray : TJSTypedArray);\r\n    property subtle : TJSSubtleCrypto Read Fsubtle;\r\n  end;\r\n\r\n  TJSEventSourceOptions = class external name 'Object' (TJSObject)\r\n    withCredentials: boolean;\r\n  end;\r\n\r\n  TJSEventSource = class external name 'EventSource' (TJSEventTarget)\r\n  Private\r\n    FReadyState : Integer; external name 'readyState';\r\n    fURL : String; external name 'url';\r\n    fwithCredentials : Boolean; external name 'withCredentials';\r\n  Public\r\n    constructor new(aURL : String);\r\n    constructor new(aURL : String; options: TJSEventSourceOptions);\r\n    procedure close;\r\n    property readyState : Integer Read FReadyState;\r\n    property url : String Read fURL;\r\n    property withCredentials: boolean Read FwithCredentials;\r\n  end;\r\n\r\n\r\n  { ----------------------------------------------------------------------\r\n    Service Worker\r\n    ----------------------------------------------------------------------}\r\n\r\n  { TJSNavigationPreload }\r\n\r\n  TJSNavigationPreload = class external name 'navigationPreload' (TJSObject)\r\n  public\r\n    function enable: boolean; async;\r\n    function disable: boolean; async;\r\n    function setHeaderValue(Value: string): TJSPromise;\r\n    function getState: TJSNavigationPreloadState; async;\r\n  end;\r\n\r\n\r\n  TJSWorker = class external name 'Worker' (TJSEventTarget)\r\n  public\r\n    constructor new(aURL : string);\r\n    procedure postMessage(aValue : JSValue);\r\n    procedure postMessage(aValue : JSValue; aList : TJSValueDynArray);\r\n  end;\r\n\r\n\r\n  { TJSServiceWorkerRegistration }\r\n\r\n  TJSServiceWorkerRegistration = class external name 'ServiceWorkerRegistration'  (TJSObject)\r\n  private\r\n    FActive: TJSServiceWorker; external name 'active';\r\n    FInstalling: TJSServiceWorker; external name 'installing';\r\n    FScope: string; external name 'scope';\r\n    FWaiting: TJSServiceWorker; external name 'waiting';\r\n    FNavigationPreload: TJSNavigationPreload; external name 'navigationPreload';\r\n  public\r\n    function unregister : TJSPromise;\r\n    procedure update;\r\n    property Active : TJSServiceWorker read FActive;\r\n    property Scope : string read FScope;\r\n    property Waiting : TJSServiceWorker read FWaiting;\r\n    property Installing : TJSServiceWorker read FInstalling;\r\n    property NavigationPreload: TJSNavigationPreload read FNavigationPreload;\r\n  end;\r\n\r\n  { TJSServiceWorker }\r\n\r\n  TJSServiceWorker = class external name 'ServiceWorker' (TJSWorker)\r\n  private\r\n    FRegistration: TJSServiceWorkerRegistration; external name 'registration';\r\n    FScriptURL: String;  external name 'scriptURL';\r\n    FState: string;  external name 'state';\r\n  Public\r\n    property State : string read FState;\r\n    property ScriptURL : String Read FscriptURL;\r\n    property Registration: TJSServiceWorkerRegistration read FRegistration;\r\n  end;\r\n\r\n  TOnChangeProcedure = reference to procedure;\r\n\r\n  TJSPermissionDescriptor = class external name 'Object' (TJSObject)\r\n  public\r\n    name: String;\r\n    userVisibleOnly: Boolean;\r\n    sysex: Boolean;\r\n  end;\r\n\r\n  TJSPermissionStatus = class external name 'PermissionStatus' (TJSObject)\r\n  private\r\n    FState: String; external name 'state';\r\n  public\r\n    onchange: TOnChangeProcedure;\r\n    property state: String read FState;\r\n  end;\r\n\r\n  TJSPermissions = class external name 'Permissions' (TJSObject)\r\n  public\r\n    function query(descriptor: TJSPermissionDescriptor): TJSPermissionStatus; async;\r\n  end;\r\n\r\n  TJSFileSystemHandlePermissionDescriptor = class external name 'Object' (TJSObject)\r\n  public\r\n    mode: String;\r\n  end;\r\n\r\n   // Union of BufferSource, Blob, USVString, WriteParams\r\n   TJSFileSystemWriteChunkType = JSValue;\r\n\r\n   { --------------------------------------------------------------------\r\n     FileSystemCreateWritableOptions\r\n     --------------------------------------------------------------------}\r\n\r\n   TJSFileSystemCreateWritableOptions = record\r\n     keepExistingData: Boolean;\r\n   end;\r\n\r\n   { --------------------------------------------------------------------\r\n     FileSystemGetFileOptions\r\n     --------------------------------------------------------------------}\r\n\r\n   TJSFileSystemGetFileOptions = record\r\n     create: Boolean;\r\n   end;\r\n\r\n   { --------------------------------------------------------------------\r\n     FileSystemGetDirectoryOptions\r\n     --------------------------------------------------------------------}\r\n\r\n   TJSFileSystemGetDirectoryOptions = record\r\n     create: Boolean;\r\n   end;\r\n\r\n   { --------------------------------------------------------------------\r\n     FileSystemRemoveOptions\r\n     --------------------------------------------------------------------}\r\n\r\n   TJSFileSystemRemoveOptions = record\r\n     recursive: Boolean;\r\n   end;\r\n\r\n   { --------------------------------------------------------------------\r\n     WriteParams\r\n     --------------------------------------------------------------------}\r\n\r\n   TJSWriteParams = record\r\n     type_: TWriteCommandType;external name 'type';\r\n     size: NativeInt;\r\n     position: NativeInt;\r\n     data: JSValue;\r\n   end;\r\n\r\n   { --------------------------------------------------------------------\r\n     FileSystemReadWriteOptions\r\n     --------------------------------------------------------------------}\r\n\r\n   TJSFileSystemReadWriteOptions = record\r\n     at: NativeInt;\r\n   end;\r\n\r\n   { --------------------------------------------------------------------\r\n     TJSWritableStream\r\n     --------------------------------------------------------------------}\r\n\r\n\r\n   { --------------------------------------------------------------------\r\n     TJSFileSystemHandle\r\n     --------------------------------------------------------------------}\r\n   TJSBooleanPromise = specialize TGPromise<boolean>;\r\n   TJSValuePromise = specialize TGPromise<JSValue>;\r\n   TJSUndefinedPromise = TJSValuePromise;\r\n   TJSFilePromise = specialize TGPromise<TJSFile>;\r\n\r\n   TJSFileSystemHandle = class external name 'FileSystemHandle'\r\n   Private\r\n     Fkind: TFileSystemHandleKind; external name 'kind';\r\n     Fname: String; external name 'name';\r\n   Public\r\n     function isSameEntry(aOther: TJSFileSystemHandle): TJSBooleanPromise;\r\n     Property kind: TFileSystemHandleKind Read Fkind;\r\n     Property name: String Read Fname;\r\n   end;\r\n\r\n\r\n   { --------------------------------------------------------------------\r\n     TJSFileSystemSyncAccessHandle\r\n     --------------------------------------------------------------------}\r\n\r\n   TJSFileSystemSyncAccessHandle = class external name 'FileSystemSyncAccessHandle'\r\n   Private\r\n   Public\r\n     function read(aBuffer: TJSBufferSource; const aOptions: TJSFileSystemReadWriteOptions): NativeInt; overload;\r\n     function read(aBuffer: TJSBufferSource): NativeInt; overload;\r\n     function write(aBuffer: TJSBufferSource; const aOptions: TJSFileSystemReadWriteOptions): NativeInt; overload;\r\n     function write(aBuffer: TJSBufferSource): NativeInt; overload;\r\n     function truncate(aNewSize: NativeInt): TJSUndefinedPromise;\r\n     function getSize: NativeInt;\r\n     function flush: TJSUndefinedPromise;\r\n     function close: TJSUndefinedPromise;\r\n   end;\r\n\r\n   { --------------------------------------------------------------------\r\n     TJSFileSystemFileHandle\r\n     --------------------------------------------------------------------}\r\n   TJSFileSystemWritableFileStreamPromise = specialize TGPromise<TJSFileSystemWritableFileStream>;\r\n   TJSFileSystemSyncAccessHandlePromise = specialize TGPromise<TJSFileSystemSyncAccessHandle>;\r\n\r\n   TJSFileSystemFileHandle = class external name 'FileSystemFileHandle' (TJSFileSystemHandle)\r\n   Private\r\n   Public\r\n     function getFile: TJSFilePromise;\r\n     function createWritable(const aOptions: TJSFileSystemCreateWritableOptions): TJSFileSystemWritableFileStreamPromise; overload;\r\n     function createWritable: TJSFileSystemWritableFileStreamPromise; overload;\r\n     function createSyncAccessHandle: TJSFileSystemSyncAccessHandlePromise;\r\n   end;\r\n\r\n   { --------------------------------------------------------------------\r\n     TJSFileSystemDirectoryHandle\r\n     --------------------------------------------------------------------}\r\n   TJSFileSystemFileHandlePromise = specialize TGPromise<TJSFileSystemFileHandle>;\r\n   TJSStringDynArrayPromise = specialize TGPromise<TStringDynArray>;\r\n   TJSFileSystemDirectoryHandlePromise = specialize TGPromise<TJSFileSystemDirectoryHandle>;\r\n\r\n   TJSFileSystemDirectoryHandle = class external name 'FileSystemDirectoryHandle' (TJSFileSystemHandle)\r\n   Private\r\n   Public\r\n     function getFileHandle(aName: String; const aOptions: TJSFileSystemGetFileOptions): TJSFileSystemFileHandlePromise; overload;\r\n     function getFileHandle(aName: String): TJSFileSystemFileHandlePromise; overload;\r\n     function getDirectoryHandle(aName: String; const aOptions: TJSFileSystemGetDirectoryOptions): TJSFileSystemDirectoryHandlePromise; overload;\r\n     function getDirectoryHandle(aName: String): TJSFileSystemDirectoryHandlePromise; overload;\r\n     function removeEntry(aName: String; const aOptions: TJSFileSystemRemoveOptions): TJSUndefinedPromise; overload;\r\n     function removeEntry(aName: String): TJSUndefinedPromise; overload;\r\n     function resolve(aPossibleDescendant: TJSFileSystemHandle): TJSStringDynArrayPromise;\r\n     function entries: TJSObject;\r\n     function values : TJSObject;\r\n   end;\r\n\r\n   { --------------------------------------------------------------------\r\n     TJSFileSystemWritableFileStream\r\n     --------------------------------------------------------------------}\r\n\r\n   TJSFileSystemWritableFileStream = class external name 'FileSystemWritableFileStream' (TJSWritableStream)\r\n   Private\r\n   Public\r\n     function write(aData: TJSFileSystemWriteChunkType): TJSUndefinedPromise;\r\n     function seek(aPosition: NativeInt): TJSUndefinedPromise;\r\n     function truncate(aSize: NativeInt): TJSUndefinedPromise;\r\n   end;\r\n\r\n\r\n  TJSDirectoryPromise = specialize TGPromise<TJSFileSystemDirectoryHandle>;\r\n  TJSStorageManager = class external name 'StorageManager' (TJSObject)\r\n    function estimate : TJSPromise;\r\n    function persist : TJSPromise;\r\n    function persisted : TJSPromise;\r\n    function GetDirectory : TJSDirectoryPromise;\r\n  end;\r\n\r\n  TJSMicrotaskProcedure = reference to Procedure;\r\n\r\n  TJSImageBitmapOptions = class external name 'Object' (TJSObject)\r\n    imageOrientation : string;\r\n    premultiplyAlpha : string;\r\n    colorSpaceConversion : String;\r\n    resizeWidth : NativeInt;\r\n    resizeHeight : NativeInt;\r\n    resizeQuality : String;\r\n  end;\r\n\r\n  { TWindowOrWorkerGlobalScope }\r\n\r\n  TWindowOrWorkerGlobalScope = Class external name 'Object' (TJSEventTarget)\r\n  Private\r\n    FCrypto: TJSCrypto; external name 'crypto';\r\n    FisSecureContext : boolean; external name 'isSecureContext';\r\n    FIDBFactory : TJSIDBFactory; external name 'indexedDB';\r\n    fcaches : TJSCacheStorage; external name 'caches';\r\n  Public\r\n    Function setInterval(ahandler : TJSTimerCallBack; aInterval : NativeUInt) : NativeInt; varargs;\r\n    Function setTimeout(ahandler : TJSTimerCallBack; aTimeout : NativeUInt) : NativeInt; varargs;\r\n    Function setTimeout(ahandler : TJSTimerCallBack) : NativeInt;\r\n    Procedure clearInterval(aID: NativeInt);\r\n    Procedure clearTimeout(aID: NativeInt);\r\n    procedure queueMicrotask(callback : TJSMicrotaskProcedure);\r\n    Function createImageBitmap(Source : JSValue) : TJSPromise;\r\n    Function createImageBitmap(Source : JSValue; aOptions : TJSImageBitmapOptions) : TJSPromise;\r\n    Function createImageBitmap(Source : JSValue; sx,sy,sw,sh : NativeInt; aOptions : TJSImageBitmapOptions) : TJSPromise;\r\n    Function structuredClone(value : JSValue) : JSValue;\r\n    Function structuredClone(value : JSValue; aOptions : TJSStructuredSerializeOptions) : JSValue;\r\n    function fetch(resource: String; init: TJSObject): TJSPromise; overload; external name 'fetch';\r\n    //function fetch(resource: String): TJSPromise; overload; external name 'fetch';\r\n    function fetch(resource: String): TJSResponse; {$IFNDEF SkipAsync}async;{$ENDIF} overload; external name 'fetch';\r\n    function fetch(resource: TJSObject; init: TJSObject): TJSPromise; overload; external name 'fetch';\r\n    function fetch(resource: TJSObject): TJSPromise; overload; external name 'fetch';\r\n    property isSecureContext : Boolean Read FisSecureContext;\r\n    property IDBFactory : TJSIDBFactory Read FIDBFactory;\r\n    property caches : TJSCacheStorage read fcaches;\r\n    property crypto : TJSCrypto Read FCrypto;\r\n  end;\r\n\r\n  { TJSAbortSignal }\r\n\r\n  TJSAbortSignal = class external name 'AbortSignal' (TJSEventTarget)\r\n  private\r\n    FAborted: Boolean; external name 'aborted';\r\n    FReason: JSValue; external name 'reason';\r\n  Public\r\n    Class function abort : TJSAbortSignal;\r\n    Class function any(iterable : TJSIterator) : TJSAbortSignal;\r\n    Class function any(iterable : array of TJSAbortSignal) : TJSAbortSignal;\r\n    Class function timeout(aTimeout : NativeInt) : TJSAbortSignal;\r\n    procedure throwIfAborted;\r\n    Property Aborted : Boolean Read FAborted;\r\n    Property Reason : JSValue Read FReason;\r\n  end;\r\n\r\n  { TJSAbortController }\r\n\r\n  TJSAbortController = class external name 'AbortController' (TJSAbortSignal)\r\n  private\r\n    FSignal: TJSAbortSignal; external name 'signal';\r\n  Public\r\n    Procedure abort; reintroduce;\r\n    Procedure abort(aReason :  JSValue);\r\n    Property signal : TJSAbortSignal Read FSignal;\r\n  end;\r\n\r\nvar\r\n  Console : TJSConsole; external name 'console';\r\n  Crypto: TJSCrypto; external name 'crypto';\r\n  indexedDB : TJSIDBFactory; external name 'indexedDB';\r\n\r\n  function fetch(resource: String; init: TJSObject): TJSPromise; overload; external name 'fetch';\r\n  //function fetch(resource: String): TJSPromise; overload; external name 'fetch';\r\n  function fetch(resource: String): TJSResponse; {$IFNDEF SkipAsync}async;{$ENDIF} overload; external name 'fetch';\r\n  function fetch(resource: TJSObject; init: TJSObject): TJSPromise; overload; external name 'fetch';\r\n  function fetch(resource: TJSObject): TJSPromise; overload; external name 'fetch';\r\n\r\nimplementation\r\n\r\nend.\r\n\r\n","{\r\n    This file is part of the Pas2JS run time library.\r\n    Copyright (c) 2017-2020 by the Pas2JS development team.\r\n\r\n    Browser Window & DOM API definitions\r\n    \r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n\r\n{$IFNDEF FPC_DOTTEDUNITS}\r\nunit Web;\r\n{$ENDIF}\r\n{$mode objfpc}\r\n{$modeswitch externalclass}\r\n\r\ninterface\r\n\r\nUses\r\n{$IFDEF FPC_DOTTEDUNITS}\r\n  System.Types, JSApi.JS, BrowserApi.WebOrWorker;\r\n{$ELSE FPC_DOTTEDUNITS}\r\n  Types, JS, weborworker;\r\n{$ENDIF FPC_DOTTEDUNITS}\r\n\r\nType\r\n  // Forward definitions\r\n  TJSHTMLElement = Class;\r\n  TJSWindow = class;\r\n  TJSDOMTokenList = class;\r\n  TJSXPathResult = CLass;\r\n  TJSNodeList = class;\r\n  TJSDocument = class;\r\n  TJSElement = class;\r\n  TJSCSSStyleSheet = Class;\r\n  TJSNodeFilter = Class;\r\n\r\n  TJSMouseEvent = Class;\r\n  TJSWheelEvent = Class;\r\n  TJSKeyBoardEvent = class;\r\n  TJSPointerEvent = Class;\r\n  TJSUIEvent = class;\r\n  TJSTouchEvent = Class;\r\n  TJSPermissions = weborworker.TJSPermissions;\r\n\r\n{$IFDEF FPC_DOTTEDUNITS}\r\n  TJSServiceWorker = BrowserApi.WebOrWorker.TJSServiceWorker;\r\n  TJSServiceWorkerRegistration = BrowserApi.WebOrWorker.TJSServiceWorkerRegistration;\r\n  TJSMessageEvent = BrowserApi.WebOrWorker.TJSMessageEvent;\r\n  TJSEvent = BrowserApi.WebOrWorker.TJSEvent;\r\n  TJSBlob = BrowserApi.WebOrWorker.TJSBlob;\r\n  TJSEventTarget = BrowserApi.WebOrWorker.TJSEventTarget;\r\n  TJSEventInit = BrowserApi.WebOrWorker.TJSEventInit;\r\n  TJSConsole = BrowserApi.WebOrWorker.TJSConsole;\r\n  KeyType = BrowserApi.WebOrWorker.TJSCryptoKeyType;\r\n  KeyUsage = BrowserApi.WebOrWorker.TJSCryptoKeyUsage;\r\n  NamedCurve = BrowserApi.WebOrWorker.TJSCryptoNamedCurve;\r\n  BigInteger = BrowserApi.WebOrWorker.TJSCryptoBigInteger;\r\n  KeyFormat = BrowserApi.WebOrWorker.TJSCryptoKeyFormat;\r\n  Algorithm = BrowserApi.WebOrWorker.TJSCryptoAlgorithm;\r\n  AesCbcParams = BrowserApi.WebOrWorker.TJSCryptoAesCbcParams;\r\n  AesCtrParams = BrowserApi.WebOrWorker.TJSCryptoAesCtrParams;\r\n  AesGcmParams = BrowserApi.WebOrWorker.TJSCryptoAesGcmParams;\r\n  HmacImportParams = BrowserApi.WebOrWorker.TJSCryptoHmacImportParams;\r\n  Pbkdf2Params = BrowserApi.WebOrWorker.TJSCryptoPbkdf2Params;\r\n  RsaHashedImportParams = BrowserApi.WebOrWorker.TJSCryptoRsaHashedImportParams;\r\n  AesKeyGenParams = BrowserApi.WebOrWorker.TJSCryptoAesKeyGenParams;\r\n  HmacKeyGenParams = BrowserApi.WebOrWorker.TJSCryptoHmacKeyGenParams;\r\n  RsaHashedKeyGenParams = BrowserApi.WebOrWorker.TJSCryptoRsaHashedKeyGenParams;\r\n  RsaOaepParams = BrowserApi.WebOrWorker.TJSCryptoRsaOaepParams;\r\n  RsaPssParams = BrowserApi.WebOrWorker.TJSCryptoRsaPssParams;\r\n  DhKeyGenParams = BrowserApi.WebOrWorker.TJSCryptoDhKeyGenParams;\r\n  EcKeyGenParams = BrowserApi.WebOrWorker.TJSCryptoEcKeyGenParams;\r\n  AesDerivedKeyParams = BrowserApi.WebOrWorker.TJSCryptoAesDerivedKeyParams;\r\n  HmacDerivedKeyParams = BrowserApi.WebOrWorker.TJSCryptoHmacDerivedKeyParams;\r\n  EcdhKeyDeriveParams = BrowserApi.WebOrWorker.TJSCryptoEcdhKeyDeriveParams;\r\n  DhKeyDeriveParams = BrowserApi.WebOrWorker.TJSCryptoDhKeyDeriveParams;\r\n  DhImportKeyParams = BrowserApi.WebOrWorker.TJSCryptoDhImportKeyParams;\r\n  EcdsaParams = BrowserApi.WebOrWorker.TJSCryptoEcdsaParams;\r\n  EcKeyImportParams = BrowserApi.WebOrWorker.TJSCryptoEcKeyImportParams;\r\n  CryptoKeyPair = BrowserApi.WebOrWorker.TJSCryptoKeyPair;\r\n  HkdfParams = BrowserApi.WebOrWorker.TJSCryptoHkdfParams;\r\n  RsaOtherPrimesInfo = BrowserApi.WebOrWorker.TJSCryptoRsaOtherPrimesInfo;\r\n  TRsaOtherPrimesInfoDynArray = BrowserApi.WebOrWorker.TJSCryptoRsaOtherPrimesInfoDynArray;\r\n  TKeyUsageDynArray = BrowserApi.WebOrWorker.TJSCryptoKeyUsageDynArray;\r\n  TJSCryptoKey = BrowserApi.WebOrWorker.TJSCryptoKey;\r\n  TJSSubtleCrypto = BrowserApi.WebOrWorker.TJSSubtleCrypto;\r\n  TJSCrypto = BrowserApi.WebOrWorker.TJSCrypto;\r\n  TJSIDBTransactionMode = BrowserApi.WebOrWorker.TJSIDBTransactionMode;\r\n  TJSIDBTransaction = BrowserApi.WebOrWorker.TJSIDBTransaction;\r\n  TJSIDBKeyRange = BrowserApi.WebOrWorker.TJSIDBKeyRange;\r\n  TJSIDBIndexParameters = BrowserApi.WebOrWorker.TJSIDBIndexParameters;\r\n  TJSIDBIndex = BrowserApi.WebOrWorker.TJSIDBIndex;\r\n  TJSIDBCursorDirection = BrowserApi.WebOrWorker.TJSIDBCursorDirection;\r\n  TJSIDBCursor = BrowserApi.WebOrWorker.TJSIDBCursor;\r\n  TJSIDBObjectStore = BrowserApi.WebOrWorker.TJSIDBObjectStore;\r\n  TJSIDBRequest = BrowserApi.WebOrWorker.TJSIDBRequest;\r\n  TJSIDBOpenDBRequest = BrowserApi.WebOrWorker.TJSIDBOpenDBRequest;\r\n  TJSCreateObjectStoreOptions = BrowserApi.WebOrWorker.TJSCreateObjectStoreOptions;\r\n  TIDBDatabase = BrowserApi.WebOrWorker.TIDBDatabase;\r\n  TJSIDBFactory = BrowserApi.WebOrWorker.TJSIDBFactory;\r\n  TJSWorker = BrowserApi.WebOrWorker.TJSWorker;\r\n  TJSExtendableEvent = BrowserApi.WebOrWorker.TJSExtendableEvent;\r\n  TJSClient = BrowserApi.WebOrWorker.TJSClient;\r\n  TJSExtendableMessageEvent = BrowserApi.WebOrWorker.TJSExtendableMessageEvent;\r\n  TJSURLSearchParams = BrowserApi.WebOrWorker.TJSURLSearchParams;\r\n  TJSURL = BrowserApi.WebOrWorker.TJSURL;\r\n  TJSURLDynArray = BrowserApi.WebOrWorker.TJSURLDynArray;\r\n  TJSTimerCallBack = BrowserApi.WebOrWorker.TJSTimerCallBack;\r\n  TJSReadableStream = BrowserApi.WebOrWorker.TJSReadableStream;\r\n  TJSWritableStream = BrowserApi.WebOrWorker.TJSWritableStream;\r\n  TJSBody = BrowserApi.WebOrWorker.TJSBody;\r\n  TJSResponse = BrowserApi.WebOrWorker.TJSResponse;\r\n  TJSCache = BrowserApi.WebOrWorker.TJSCache;\r\n  TJSCacheStorage = BrowserApi.WebOrWorker.TJSCacheStorage;\r\n{$ELSE}\r\n  TJSServiceWorker = weborworker.TJSServiceWorker;\r\n  TJSServiceWorkerRegistration = weborworker.TJSServiceWorkerRegistration;\r\n  TJSMessageEvent = weborworker.TJSMessageEvent;\r\n  TJSShowOpenFilePickerOptions = class;\r\n  TJSShowSaveFilePickerOptions = class;\r\n\r\n  TJSEvent = weborworker.TJSEvent;\r\n  TJSBlob = weborworker.TJSBlob;\r\n  TJSEventTarget = weborworker.TJSEventTarget;\r\n  TJSEventInit = weborworker.TJSEventInit;\r\n  TJSConsole = weborworker.TJSConsole;\r\n  KeyType = weborworker.TJSCryptoKeyType;\r\n  KeyUsage = weborworker.TJSCryptoKeyUsage;\r\n  NamedCurve = weborworker.TJSCryptoNamedCurve;\r\n  BigInteger = weborworker.TJSCryptoBigInteger;\r\n  KeyFormat = weborworker.TJSCryptoKeyFormat;\r\n  Algorithm = weborworker.TJSCryptoAlgorithm;\r\n  AesCbcParams = weborworker.TJSCryptoAesCbcParams;\r\n  AesCtrParams = weborworker.TJSCryptoAesCtrParams;\r\n  AesGcmParams = weborworker.TJSCryptoAesGcmParams;\r\n  HmacImportParams = weborworker.TJSCryptoHmacImportParams;\r\n  Pbkdf2Params = weborworker.TJSCryptoPbkdf2Params;\r\n  RsaHashedImportParams = weborworker.TJSCryptoRsaHashedImportParams;\r\n  AesKeyGenParams = weborworker.TJSCryptoAesKeyGenParams;\r\n  HmacKeyGenParams = weborworker.TJSCryptoHmacKeyGenParams;\r\n  RsaHashedKeyGenParams = weborworker.TJSCryptoRsaHashedKeyGenParams;\r\n  RsaOaepParams = weborworker.TJSCryptoRsaOaepParams;\r\n  RsaPssParams = weborworker.TJSCryptoRsaPssParams;\r\n  DhKeyGenParams = weborworker.TJSCryptoDhKeyGenParams;\r\n  EcKeyGenParams = weborworker.TJSCryptoEcKeyGenParams;\r\n  AesDerivedKeyParams = weborworker.TJSCryptoAesDerivedKeyParams;\r\n  HmacDerivedKeyParams = weborworker.TJSCryptoHmacDerivedKeyParams;\r\n  EcdhKeyDeriveParams = weborworker.TJSCryptoEcdhKeyDeriveParams;\r\n  DhKeyDeriveParams = weborworker.TJSCryptoDhKeyDeriveParams;\r\n  DhImportKeyParams = weborworker.TJSCryptoDhImportKeyParams;\r\n  EcdsaParams = weborworker.TJSCryptoEcdsaParams;\r\n  EcKeyImportParams = weborworker.TJSCryptoEcKeyImportParams;\r\n  CryptoKeyPair = weborworker.TJSCryptoKeyPair;\r\n  HkdfParams = weborworker.TJSCryptoHkdfParams;\r\n  RsaOtherPrimesInfo = weborworker.TJSCryptoRsaOtherPrimesInfo;\r\n  TRsaOtherPrimesInfoDynArray = weborworker.TJSCryptoRsaOtherPrimesInfoDynArray;\r\n  TKeyUsageDynArray = weborworker.TJSCryptoKeyUsageDynArray;\r\n  TJSCryptoKey = weborworker.TJSCryptoKey;\r\n  TJSSubtleCrypto = weborworker.TJSSubtleCrypto;\r\n  TJSCrypto = weborworker.TJSCrypto;\r\n  TJSIDBTransactionMode = weborworker.TJSIDBTransactionMode;\r\n  TJSIDBTransaction = weborworker.TJSIDBTransaction;\r\n  TJSIDBKeyRange = weborworker.TJSIDBKeyRange;\r\n  TJSIDBIndexParameters = weborworker.TJSIDBIndexParameters;\r\n  TJSIDBIndex = weborworker.TJSIDBIndex;\r\n  TJSIDBCursorDirection = weborworker.TJSIDBCursorDirection;\r\n  TJSIDBCursor = weborworker.TJSIDBCursor;\r\n  TJSIDBObjectStore = weborworker.TJSIDBObjectStore;\r\n  TJSIDBRequest = weborworker.TJSIDBRequest;\r\n  TJSIDBOpenDBRequest = weborworker.TJSIDBOpenDBRequest;\r\n  TJSCreateObjectStoreOptions = weborworker.TJSCreateObjectStoreOptions;\r\n  TIDBDatabase = weborworker.TIDBDatabase;\r\n  TJSIDBFactory = weborworker.TJSIDBFactory;\r\n  TJSWorker = weborworker.TJSWorker;\r\n  TJSExtendableEvent = weborworker.TJSExtendableEvent;\r\n  TJSClient = weborworker.TJSClient;\r\n  TJSExtendableMessageEvent = weborworker.TJSExtendableMessageEvent;\r\n  TJSURLSearchParams = weborworker.TJSURLSearchParams;\r\n  TJSURL = weborworker.TJSURL;\r\n  TJSURLDynArray = weborworker.TJSURLDynArray;\r\n  TJSTimerCallBack = weborworker.TJSTimerCallBack;\r\n  TJSReadableStream = weborworker.TJSReadableStream;\r\n  TJSWritableStream = weborworker.TJSWritableStream;\r\n  TJSBody = weborworker.TJSBody;\r\n  TJSResponse = weborworker.TJSResponse;\r\n  TJSCache = weborworker.TJSCache;\r\n  TJSCacheStorage = weborworker.TJSCacheStorage;\r\n{$ENDIF}\r\n  TJSMessagePortArray = TJSMessagePortDynArray;\r\n  TEventListenerEvent = TJSEvent;\r\n  TJSEventHandler = reference to function(Event: TEventListenerEvent): boolean; safecall;\r\n  TJSRawEventHandler = reference to Procedure(Event: TJSEvent); safecall;\r\n\r\n\r\n  TJSNode = class external name 'Node' (TJSEventTarget)\r\n  Private\r\n    FBaseURI : String; external name 'baseURI';\r\n    FChildNodes: TJSNodeList; external name 'childNodes';\r\n    FFirstChild : TJSNode; external name 'firstChild';\r\n    FNextSibling : TJSNode; external name 'nextSibling';\r\n    FNodeName : String; external name 'nodeName';\r\n    FNodeType : NativeInt; external name 'nodeType';\r\n    FOwnerDocument : TJSDocument; external name 'ownerDocument';\r\n    FParentElement : TJSElement; external name 'parentElement';\r\n    FParentNode : TJSNode; external name 'parentNode';\r\n    FPreviousSibling : TJSNode; external name 'previousSibling';\r\n  Public \r\n    Const\r\n      ELEMENT_NODE \t=1;\r\n      TEXT_NODE \t=3;\r\n      PROCESSING_INSTRUCTION_NODE = \t7;\r\n      COMMENT_NODE \t=8;\r\n      DOCUMENT_NODE \t=9;\r\n      DOCUMENT_TYPE_NODE \t= 10;\r\n      DOCUMENT_FRAGMENT_NODE  = 11;\r\n\r\n      DOCUMENT_POSITION_DISCONNECTED \t= 1;\r\n      DOCUMENT_POSITION_PRECEDING \t= 2;\r\n      DOCUMENT_POSITION_FOLLOWING \t= 4;\r\n      DOCUMENT_POSITION_CONTAINS \t= 8;\r\n      DOCUMENT_POSITION_CONTAINED_BY \t= 16;\r\n      DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;\r\n  Public  \r\n    nodeValue: string;\r\n    innerText : string;\r\n    textContent : string;\r\n    function appendChild(aChild : TJSNode) : TJSNode;\r\n    function cloneNode(deep:  boolean): TJSNode;\r\n    function compareDocumentPosition(aNode : TJSNode) : NativeInt;\r\n    function contains(aNode : TJSNode) : boolean;\r\n    function hasChildNodes : boolean;\r\n    function insertBefore(newNode, referenceNode : TJSNode) : TJSNode;\r\n    function isDefaultNameSpace(aNameSpaceURI : String) : Boolean;\r\n    function isEqualNode(aNode : TJSNode) : boolean;\r\n    function isSameNode(aNode : TJSNode) : boolean;\r\n    function lookupNamespaceURI(aPrefix : string) : string;\r\n    function lookupPrefix(aPrefix : string) : string;\r\n    procedure normalize;\r\n    function removeChild(aChild: TJSNode) : TJSNode;\r\n    function replaceChild(aNewChild, aOldChild : TJSNode) : TJSNode;\r\n    property baseURI : string read FBaseURI;\r\n    property childNodes : TJSNodeList read FChildNodes;\r\n    property firstChild : TJSNode Read FFirstChild;\r\n    property nextSibling : TJSNode Read FNextSibling;\r\n    property nodeName : String Read FNodeName;\r\n    property nodeType : NativeInt Read FNodeType;\r\n    property ownerDocument : TJSDocument read FOwnerDocument;    \r\n    property parentElement : TJSElement read FParentElement;\r\n    property parentNode : TJSNode read FParentNode;\r\n    property previousSibling : TJSNode Read FPreviousSibling;\r\n  end;\r\n\r\n\r\n  TJSNodeListCallBack = reference to procedure (currentValue : TJSNode; currentIndex: NativeInt; list : TJSNodeList);\r\n  TJSNodeListEvent = TJSNodeListCallBack;\r\n\r\n  TJSNodeList = class external name 'NodeList' (TJSObject)\r\n  Private\r\n    FLength : NativeInt; external name 'length';\r\n  Public\r\n    procedure forEach(const aCallBack : TJSNodeListCallBack);\r\n    function item(aIndex : NativeInt) : TJSNode;\r\n    Property length : NativeInt Read FLength;\r\n    Property Nodes [aIndex : NativeInt] : TJSNode Read item; default;\r\n  end;\r\n\r\n  TJSAttr = class external name 'Attr' (TJSNode)\r\n  Private\r\n    fLocalName : String; external name 'localName';\r\n    fNameSpaceURI : String external name 'namespaceURI';\r\n    fPrefix : string; external name 'prefix';\r\n    fName : string; external name 'name';\r\n    fSpecified : Boolean; external name 'specified';\r\n  public\r\n    value : JSValue;\r\n    property localName : String Read fLocalName;\r\n    property namespaceURI : string Read fNameSpaceURI;\r\n    property prefix : string read fPrefix;\r\n    property name : string Read fName;\r\n    property specified : boolean Read fSpecified; // Useless, always true\r\n  end;\r\n\r\n\r\n  TJSNamedNodeMap = class external name 'NamedNodeMap'  (TJSObject)\r\n  Public\r\n    function getNamedItem(aName : string) : TJSAttr;\r\n    Property Attrs[aIndex : String] : TJSattr Read getNamedItem; default;\r\n  end;\r\n  \r\n  TJSHTMLCollection = class external name 'HTMLCollection'  (TJSObject)\r\n  Private\r\n    FLength : NativeInt; external name 'length';\r\n  public\r\n    Function item(aIndex : Integer) : TJSNode;\r\n    Function namedItem(aName : string) : TJSNode;\r\n    property Items[aIndex : Integer] : TJSNode Read item; default;\r\n    property NamedItems[aName : String] : TJSNode Read namedItem; \r\n    Property length : NativeInt Read FLength;\r\n  end;  \r\n  \r\n  TJSDOMString = String;\r\n\r\n  TDOMTokenlistCallBack = Procedure (Current : JSValue; currentIndex : NativeInt; list : TJSDOMTokenList);\r\n  \r\n  // Interface\r\n  TJSDOMTokenList = class external name 'DOMTokenList'  (TJSObject)\r\n  Private\r\n    FLength : NativeInt; external name 'length';\r\n  public\r\n    Procedure add(aToken : TJSDOMString); varargs;\r\n    Procedure remove(aToken : TJSDOMString); varargs;\r\n    function item(aIndex : NativeInt) : String;\r\n    function contains(aToken : TJSDOMString) : Boolean;\r\n    Procedure replace(aOldToken, ANewToken : TJSDOMString);\r\n    function supports(aToken : TJSDOMString) : Boolean;\r\n    function toggle(aToken : TJSDOMString) : Boolean;\r\n    // entries,keys, values\r\n    procedure forEach(const callback: TDOMTokenlistCallBack);\r\n    property length : NativeInt read FLength;\r\n  end;\r\n\r\n  TJSDOMRect = class external name 'DOMRect'  (TJSObject)\r\n  public\r\n    left,top,right,bottom,x,y,width,height : double;\r\n    {$IFDEF FIREFOX}\r\n    constructor New;\r\n    {$ENDIF}\r\n  end;\r\n\r\n  TJSClientRect = record\r\n    left,top,right,bottom : double;\r\n    {$IFDEF FIREFOX}\r\n    width, height: double;\r\n    {$ENDIF}\r\n  end;\r\n  \r\n  TJSClientRectArray = array of TJSClientRect;\r\n  \r\n  TJSElement = class external name 'Element' (TJSNode)\r\n  Private\r\n    FAttributes : TJSNamedNodeMap; external name 'attributes';\r\n    FChildElementCount : NativeInt; external name 'childElementCount';\r\n    FChildren : TJSHTMLCollection; external name 'children';\r\n    FClassList : TJSDOMTokenList; external name 'classList';\r\n    FCLientHeight : NativeInt; external name 'clientHeight';\r\n    FCLientLeft : NativeInt; external name 'clientLeft';\r\n    FCLientTop : NativeInt; external name 'clientTop';\r\n    FCLientWidth : NativeInt; external name 'clientWidth';\r\n    FFirstElementChild : TJSElement; external name 'firstElementChild';\r\n    FLastElementChild : TJSElement; external name 'lastElementChild';\r\n    FLocalName : string; external name 'localName';\r\n    FNameSpaceURI : String; external name 'namespaceURI';\r\n    FNextElementSibling : TJSElement; external name 'nextElementSibling';\r\n    FPreviousElementSibling : TJSElement; external name 'previousElementSibling';\r\n    FPrefix : String; external name 'prefix';\r\n    FScrollHeight : NativeInt; external name 'scrollHeight';\r\n{$IFDEF FIREFOX}\r\n    FScrollLeftMax : NativeInt; external name 'scrollLeftMax';\r\n    FScrollTopMax : NativeInt; external name 'scrollTopMax';\r\n{$endif}\r\n    FScrollWidth : NativeInt; external name 'scrollWidth';\r\n    FTagName : string; external name 'tagName';\r\n  Public\r\n    name : string;\r\n    className : string;\r\n    id : string;\r\n    innerHTML : String;\r\n    outerHTML : string;\r\n    scrollLeft : NativeInt;\r\n    scrollTop : NativeInt;\r\n    procedure append(aText : String); overload;\r\n    procedure append(aNode : TJSElement); overload;\r\n    procedure append(aText : String; aNode : TJSElement); varargs; overload;\r\n    procedure append(aNode1,aNode2: TJSElement); varargs; overload;\r\n    function getAttribute(aName : string) : string;\r\n    function getAttributeNode(aName : string) : TJSAttr;\r\n    function getAttributeNodeNS(aNameSpace, aName : string) : TJSAttr;\r\n    function getAttributeNS(aNameSpace, aName : string) : string;\r\n    function getBoundingClientRect : TJSDOMRect;\r\n    function getClientRects : TJSClientRectArray;\r\n    function getElementsByClassName(aClassName: string) : TJSHTMLCollection;\r\n    function getElementsByTagNameNS(aNameSpace, aTagName : String): TJSHTMLCollection;\r\n    function getElementsByTagName(aTagName : String): TJSHTMLCollection;\r\n    function hasAttribute(aName : String) : Boolean;\r\n    function hasAttributeNS(aNameSpace,aName : String) : Boolean;\r\n    function hasAttributes : Boolean;\r\n    function insertAdjacentElement(aPosition : string; aElement : TJSElement) : TJSElement;\r\n    procedure insertAdjacentHTML(aPosition,aHTML : string);\r\n    procedure insertAdjacentText(aPosition,aText : string);\r\n    function matches(aSelectorString : String) : Boolean;\r\n    function querySelector(aSelectors : String) : TJSElement;\r\n    function querySelectorAll(aSelectors : String) : TJSNodeList;\r\n    procedure remove; overload;\r\n    procedure releasePointerCapture(evID : JSValue);\r\n    procedure removeAttribute(aName: string);\r\n    procedure removeAttributeNS(aNameSpace,aName: string);\r\n    function removeAttributeNode(aAttr : TJSAttr) : TJSAttr;\r\n    procedure setAttribute(aName : string; AValue : String);\r\n    function setAttributeNode(aNode: TJSAttr) : TJSAttr;\r\n    function setAttributeNodeNS(aNode: TJSAttr) : TJSAttr;\r\n    procedure setAttributeNS(aNameSpace,aName : string; AValue : String);\r\n    procedure setCapture(retargetToElement : Boolean);\r\n    procedure setPointerCapture(pointerID : JSValue);\r\n    procedure requestFullScreen;    \r\n    Property attributes : TJSNamedNodeMap read FAttributes;\r\n    Property childElementCount : NativeInt Read FChildElementCount;\r\n    Property children : TJSHTMLCollection Read FChildren;\r\n    Property classList : TJSDOMTokenList read FClassList;\r\n    property clientHeight : NativeInt read FClientHeight;\r\n    property clientLeft : NativeInt read FClientLeft;\r\n    property clientTop : NativeInt read FClientTop;\r\n    property clientWidth : NativeInt read FClientWidth;\r\n    property firstElementChild : TJSElement Read FFirstElementChild;\r\n    property lastElementChild : TJSElement Read FLastElementChild;\r\n    property localName : string Read FLocalName;\r\n    property namespaceURI : String read FNameSpaceURI;\r\n    property nextElementSibling : TJSElement Read FNextElementSibling;\r\n    property previousElementSibling : TJSElement Read FPreviousElementSibling;\r\n    property prefix : String read FPrefix;\r\n    property scrollHeight : NativeInt Read FScrollHeight;\r\n{$IFDEF FIREFOX}\r\n    property scrollLeftMax  : NativeInt Read FScrollLeftMax;\r\n    property scrollTopMax  : NativeInt Read FScrollTopMax;\r\n{$ENDIF}\r\n    property scrollWidth : NativeInt Read FScrollWidth;\r\n    property tagName : String read FTagName;\r\n    Property Attrs[aName : string] : String read getAttribute write setAttribute; default;\r\n  end;\r\n   \r\n  TJSElementCreationOptions = record\r\n    named : string;\r\n  end;\r\n \r\n  TJSDocumentType = class external name 'DocumentType' (TJSNode)\r\n  private\r\n    FName : String; external name 'name';\r\n    FPublicID : String; external name 'publicId';\r\n    FSystemID : String; external name 'systemId';\r\n  public\r\n    property name : String read FName;\r\n    property publicId : String Read FPublicID;\r\n    property systemId : String read FSystemID;\r\n  end;\r\n\r\n  TJSDOMImplementation  = class external name 'DocumentImplementation'  (TJSObject)\r\n  Public  \r\n    function createDocument(aNamespaceURI, aQualifiedNameStr : String; aDocumentType : TJSDocumentType) : TJSDocument;\r\n    function createDocumentType(aQualifiedNameStr,aPublicId,aSystemId : String) : TJSDocumentType;\r\n    function createHTMLDocument(aTitle : String) : TJSDocument;\r\n  end;\r\n\r\n  TJSLocation = class external name 'Location'  (TJSObject)\r\n  Private\r\n    FOrigin : string; external name 'origin';\r\n  Public\r\n    hash : string;\r\n    host : string;\r\n    hostname : string;\r\n    href : string;\r\n    password : string;\r\n    pathname : string;\r\n    port : string;\r\n    protocol : string;\r\n    search : string;\r\n    username : string;\r\n    procedure assign(aURL : String); overload;\r\n    procedure reload(aForce : Boolean);\r\n    procedure replace(aURL : String);\r\n    property origin : string read FOrigin;\r\n  end;\r\n  \r\n  TJSCSSStyleDeclaration = class; // forward\r\n\r\n  TJSStyleSheet = class external name 'StyleSheet' (TJSEventTarget)\r\n  Private\r\n    FHRef : String; external name 'href';\r\n    FOwnerNode : TJSNode; external name 'ownerNode';\r\n    FParentStyleSheet : TJSStyleSheet; external name 'parentStyleSheet';\r\n    FTitle : String; external name 'title';\r\n    FType : String; external name 'type';\r\n  Public\r\n    disabled : String;\r\n    Property href : String read FHRef;\r\n    property ownerNode : TJSNode Read FOwnerNode;\r\n    property parentStyleSheet : TJSStyleSheet read FParentStyleSheet;\r\n    property title : string Read FTitle;\r\n    property _type : String read FType;\r\n  end;\r\n\r\n  TJSCSSRule = class external name 'CSSRule'  (TJSObject)\r\n  Private\r\n    FCSSText : String; external name 'cssText';\r\n    FParentStyleSheet : TJSCSSStyleSheet; external name 'parentStyleSheet';\r\n    FparentRule : TJSCSSRule; external name 'parentRule';\r\n  Public\r\n    property cssText : String Read FCSSText;\r\n    property parentRule : TJSCSSRule read FparentRule;\r\n    property parentStyleSheet : TJSCSSStyleSheet Read FParentStyleSheet;\r\n  end;\r\n\r\n  TJSCSSStyleRule = class external name 'CSSStyleRule' (TJSCSSRule)\r\n  private\r\n    FStyle: TJSCSSStyleDeclaration; external name 'style';\r\n  public\r\n    selectorText: String;\r\n    property style: TJSCSSStyleDeclaration read FStyle;\r\n  end;\r\n  \r\n  TJSCSSRuleList = Class external name 'CSSRuleList'  (TJSObject)\r\n  Private\r\n    FLength : NativeInt; external name 'length';\r\n  Public\r\n    function item(index : NativeInt) : TJSCSSRule;\r\n    property length : NativeInt Read FLength;\r\n    Property items[aIndex : NativeInt] : TJSCSSRule read item; default;\r\n  end;\r\n  \r\n  \r\n  TJSCSSStyleSheet = class external name 'CSSStyleSheet' (TJSStyleSheet)\r\n  Private\r\n    FCSSRules : TJSCSSRuleList; external name 'cssRules';\r\n  Public\r\n    procedure deleteRule(aIndex : NativeInt);\r\n    function insertRule(aRule : String; aIndex : NativeInt) : NativeInt;\r\n    Property cssRules : TJSCSSRuleList read FCSSRules;\r\n  end;\r\n\r\n  TJSStyleSheetList = Class external name 'StyleSheetList'  (TJSObject)\r\n  Private\r\n    FLength : NativeInt; external name 'length';\r\n  Public\r\n    function item(index : NativeInt) : TJSStyleSheet;\r\n    property length : NativeInt Read FLength;\r\n    Property items[aIndex : NativeInt] : TJSStyleSheet read item; default;\r\n  end;\r\n\r\n  { TJSDocumentFragment }\r\n\r\n  TJSDocumentFragment = Class external name 'DocumentFragment' (TJSNode)\r\n  private\r\n    FchildElementCount: Integer; external name 'childElementCount';\r\n    Fchildren: TJSHTMLCollection; external name 'children';\r\n    FfirstElementChild: TJSElement; external name 'firstElementChild';\r\n    FlastElementChild: TJSElement; external name 'lastElementChild';\r\n  public\r\n    constructor new;\r\n    function querySelector(aSelector : String) : TJSElement;\r\n    function querySelectorAll(aSelector : String) : TJSNodeList;\r\n    property childElementCount : Integer read FchildElementCount;\r\n    property children : TJSHTMLCollection read Fchildren;\r\n    property firstElementChild : TJSElement read FfirstElementChild;\r\n    property lastElementChild : TJSElement read FlastElementChild;\r\n  end;\r\n\r\n\r\n  { TJSEventHelper }\r\n\r\n  TJSEventHelper = class helper for TJSEvent\r\n  private\r\n    function GetCurrentTargetElement: TJSElement;\r\n    function GetCurrentTargetHTMLElement: TJSHTMLElement;\r\n    function GetTargetElement: TJSElement;\r\n    function GetTargetHTMLElement: TJSHTMLElement;\r\n  Public\r\n    property currentTargetElement : TJSElement Read GetCurrentTargetElement;\r\n    property currentTargetHTMLElement : TJSHTMLElement Read GetCurrentTargetHTMLElement;\r\n    property targetElement : TJSElement Read GetTargetElement;\r\n    property targetHTMLElement : TJSHTmlElement Read GetTargetHTMLElement;\r\n  end;\r\n\r\n\r\n  TJSXPathExpression = class external name 'XPathExpression'  (TJSObject)\r\n  Public\r\n    function evaluate(contextNode : TJSNode; aType : NativeInt; aResult : TJSXPathResult) : TJSXPathResult;\r\n    function evaluateWithContext(contextNode : TJSNode; aPosition, aSize, aType : NativeInt; aResult : TJSXPathResult) : TJSXPathResult;\r\n  end;\r\n\r\n  TJSXPathNSResolver = class external name 'XPathNSResolver'  (TJSObject)\r\n  Public\r\n    function lookupNamespaceURI(prefix : string) : string;\r\n  end;\r\n\r\n  { TJSCharacterData }\r\n\r\n  TJSCharacterData = class external name 'CharacterData' (TJSNode)\r\n  private\r\n    FnextElementSibling: TJSElement; external name 'nextElementSibling';\r\n    FpreviousElementSibling: TJSElement; external name 'previousElementSibling';\r\n  public\r\n    property nextElementSibling : TJSElement read FnextElementSibling;\r\n    property previousElementSibling : TJSElement read FpreviousElementSibling;\r\n  end;\r\n\r\n\r\n  TJSProcessingInstruction = class external name 'ProcessingInstruction' (TJSCharacterData);\r\n\r\n  { TJSRange }\r\n\r\n  TJSRange = class external name 'Range'  (TJSObject)\r\n  private\r\n    FCollapsed: boolean; external name 'collapsed';\r\n    FcommonAncestorContainer: TJSNode; external name 'commonAncestorContainer';\r\n    FendContainer: TJSNode; external name 'endContainer';\r\n    FEndOffset: NativeInt; external name 'endOffset';\r\n    FstartContainer: TJSNode; external name 'startContainer';\r\n    FstartOffset: NativeInt; external name 'startOffset';\r\n  Public\r\n    const\r\n      END_TO_END     = 0;\r\n      END_TO_START   = 1;\r\n      START_TO_END   = 2;\r\n      START_TO_START = 3;\r\n  Public\r\n    constructor new;\r\n    function cloneContents : TJSDocumentFragment;\r\n    function cloneRange : TJSRange;\r\n    procedure collapse;\r\n    function compareBoundaryPoints(aHow : NativeInt) : NativeInt;\r\n    function createContextualFragment(aTagstring : String) : TJSDocumentFragment;\r\n    procedure deleteContents;\r\n    procedure detach;\r\n    function extractContents : TJSDocumentFragment;\r\n    procedure insertNode(aNode : TJSNode);\r\n    procedure selectNode(aNode : TJSNode);\r\n    procedure selectNodeContents(aNode : TJSNode);\r\n    procedure setEnd(aEndNode : TJSNode; aEndOffset : NativeInt); \r\n    procedure setEndAfter(aEndNode : TJSNode);\r\n    procedure setEndBefore(aEndNode : TJSNode);\r\n    procedure setStart(aStartNode : TJSNode; aStartOffset : NativeInt); \r\n    procedure setStartAfter(aStartNode : TJSNode);\r\n    procedure setStartBefore(aStartNode : TJSNode);\r\n    procedure surroundContents(aNode : TJSNode);\r\n    property collapsed : boolean read FCollapsed;\r\n    property commonAncestorContainer : TJSNode read FcommonAncestorContainer ;\r\n    property endContainer : TJSNode read FendContainer;\r\n    property endOffset : NativeInt Read FEndOffset;\r\n    property startContainer : TJSNode read FstartContainer;\r\n    property startOffset : NativeInt Read FstartOffset;\r\n  end;\r\n\r\n\r\n  { TJSTreeWalker }\r\n\r\n  TJSTreeWalker = class external name 'TreeWalker' (TJSObject)\r\n  private\r\n    FCurrentNode: TJSNode; external name 'currentNode';\r\n    FexpandEntityReference: Boolean; external name 'expandEntityReference';\r\n    FFilter: TJSNodeFilter; external name 'filter';\r\n    FRoot: TJSNode; external name 'root';\r\n    FWhatToShow: NativeInt; external name 'whatToShow';\r\n  Public\r\n    function firstChild : TJSNode;\r\n    function lastChild : TJSNode;\r\n    function nextNode : TJSNode;\r\n    function nextSibling : TJSNode;\r\n    function parentNode : TJSNode;\r\n    function previousNode : TJSNode;\r\n    function previousSibling : TJSNode;\r\n\r\n    property root : TJSNode read FRoot;\r\n    property whatToShow : NativeInt read FWhatToShow;\r\n    property filter : TJSNodeFilter Read FFilter;\r\n    property expandEntityReference : Boolean Read FexpandEntityReference;\r\n    property currentNode : TJSNode Read FCurrentNode;\r\n  end;\r\n\r\n  TJSNodeFilter = class external name 'NodeFilter'  (TJSObject)\r\n    const\r\n      SHOW_ALL                    = -1;\r\n      SHOW_ATTRIBUTE              = 2;\r\n      SHOW_CDATA_SECTION          = 8;\r\n      SHOW_COMMENT                = 128;\r\n      SHOW_DOCUMENT               = 256;\r\n      SHOW_DOCUMENT_FRAGMENT      = 1024;\r\n      SHOW_DOCUMENT_TYPE          = 512;\r\n      SHOW_ELEMENT                = 1;\r\n      SHOW_ENTITY                 = 32;\r\n      SHOW_ENTITY_REFERENCE       = 16;\r\n      SHOW_NOTATION               = 2048;\r\n      SHOW_PROCESSING_INSTRUCTION = 64;\r\n      SHOW_TEXT                   = 4;\r\n    function acceptNode (aNode : TJSNode) : NativeInt;\r\n  end;\r\n\r\n  TJSXPathResult = class external name 'XPathResult'  (TJSObject)\r\n  private class var\r\n    FANY_TYPE : Integer; external name 'ANY_TYPE';\r\n    FNUMBER_TYPE : Integer; external name 'NUMBER_TYPE';\r\n    FSTRING_TYPE : Integer; external name 'STRING_TYPE';\r\n    FBOOLEAN_TYPE : Integer; external name 'BOOLEAN_TYPE';\r\n    FUNORDERED_NODE_ITERATOR_TYPE : Integer; external name 'UNORDERED_NODE_ITERATOR_TYPE';\r\n    FORDERED_NODE_ITERATOR_TYPE : Integer; external name 'ORDERED_NODE_ITERATOR_TYPE';\r\n    FUNORDERED_NODE_SNAPSHOT_TYPE : Integer; external name 'UNORDERED_NODE_SNAPSHOT_TYPE';\r\n    FORDERED_NODE_SNAPSHOT_TYPE : Integer; external name 'ORDERED_NODE_SNAPSHOT_TYPE';\r\n    FANY_UNORDERED_NODE_TYPE : Integer; external name 'ANY_UNORDERED_NODE_TYPE';\r\n    FFIRST_ORDERED_NODE_TYPE : Integer; external name 'FIRST_ORDERED_NODE_TYPE';\r\n  public\r\n    class property ANY_TYPE: Integer read FANY_TYPE;\r\n    class property NUMBER_TYPE: Integer read FNUMBER_TYPE;\r\n    class property STRING_TYPE: Integer read FSTRING_TYPE;\r\n    class property BOOLEAN_TYPE: Integer read FBOOLEAN_TYPE;\r\n    class property UNORDERED_NODE_ITERATOR_TYPE: Integer read FUNORDERED_NODE_ITERATOR_TYPE;\r\n    class property ORDERED_NODE_ITERATOR_TYPE: Integer read FORDERED_NODE_ITERATOR_TYPE;\r\n    class property UNORDERED_NODE_SNAPSHOT_TYPE: Integer read FUNORDERED_NODE_SNAPSHOT_TYPE;\r\n    class property ORDERED_NODE_SNAPSHOT_TYPE: Integer read FORDERED_NODE_SNAPSHOT_TYPE;\r\n    class property ANY_UNORDERED_NODE_TYPE: Integer read FANY_UNORDERED_NODE_TYPE;\r\n    class property FIRST_ORDERED_NODE_TYPE: Integer read FFIRST_ORDERED_NODE_TYPE;\r\n  private\r\n    FBooleanValue : Boolean; external name 'booleanValue';\r\n    FNumberValue : Double; external name 'numberValue';\r\n    FResultType : NativeInt; external name 'resultType';\r\n    FSingleNodeValue : TJSNode;  external name 'singleNodeValue';\r\n    FSnaphotLength : NativeInt; external name 'snapshotLength';\r\n    FStringValue : String; external name 'stringValue';\r\n  public  \r\n    Function iterateNext : TJSNode;\r\n    Function snapshotItem(Index: NativeInt) : TJSNode;\r\n    Property booleanValue : Boolean Read FBooleanValue;\r\n    Property numberValue : Double Read FNumberValue;\r\n    property resultType : NativeInt Read FResultType;\r\n    Property singleNodeValue : TJSNode Read FSingleNodeValue;\r\n    property snapshotLength : NativeInt read FSnaphotLength;\r\n    property stringValue : String Read FStringValue;\r\n  end;\r\n\r\n  TJSSelection = class external name 'Selection'  (TJSObject)\r\n  Private\r\n    FanchorNode : TJSNode ; external name 'anchorNode';\r\n    FanchorOffset : NativeInt ; external name 'anchorOffset';\r\n    FfocusNode : TJSNode ; external name 'focusNode';\r\n    FfocusOffset : NativeInt ; external name 'focusOffset';\r\n    FisCollapsed : Boolean ; external name 'isCollapsed';\r\n    FrangeCount : NativeInt ; external name 'rangeCount';\r\n    Ftype : String ; external name 'type';\r\n  Public\r\n    function getRangeAt(aIndex : NativeInt) : TJSRange;\r\n    procedure collapse(aParentNode : TJSNode; Offset : NativeInt);\r\n    procedure extend(aParentNode : TJSNode; Offset : NativeInt);\r\n    procedure collapseToStart;\r\n    procedure collapseToEnd;\r\n    procedure selectAllChildren(aParentNode : TJSNode);\r\n    procedure addRange(aRange : TJSRange);\r\n    procedure removeRange(aRange : TJSRange);\r\n    procedure removeAllRanges;\r\n    procedure deleteFromDocument;\r\n    function containsNode(aNode : TJSNode; aPartlyContained : Boolean) : Boolean;\r\n    procedure setBaseAndExtent(aAnchorNode : TJSNode; aAnchorOffset : NativeInt; aFocusNode : TJSNode; aFocusOffset : NativeInt);\r\n    property anchorNode : TJSNode read FAnchorNode;\r\n    property anchorOffset : NativeInt read FAnchorOffset;\r\n    property focusNode : TJSNode read FFocusNode;\r\n    property focusOffset : NativeInt read FFocusOffset;\r\n    property isCollapsed : Boolean read FIsCollapsed;\r\n    property rangeCount : NativeInt read FRangeCount;\r\n    property _type : String Read FType;\r\n  end;\r\n  TJSNameSpaceMapperCallback = function (aNameSpace : string ) : String;\r\n\r\n  TJSHTMLFile = class;\r\n  TJSHTMLFileList = Class;\r\n\r\n  { TJSDataTransferItem }\r\n\r\n  TJSDataTransferItemCallBack = reference to Procedure(aData : String); safecall;\r\n\r\n  TJSDataTransferItem = class external name 'DataTransferItem'  (TJSObject)\r\n  private\r\n    FKind: String; external name 'kind';\r\n    FType: string; external name 'type';\r\n  Public\r\n    function getAsFile : TJSHTMLFile;\r\n    Procedure getAsString(aCallBack : TJSDataTransferItemCallBack);\r\n    property Kind : String read FKind;\r\n    property _Type : string read FType;\r\n  end;\r\n\r\n  TJSDataTransferItemList = class external name 'DataTransferItemList'  (TJSObject)\r\n  private\r\n    FLength: NativeInt; external name 'length';\r\n    function getitem(aIndex : nativeInt) : TJSDataTransferItem ; external name '[]';\r\n  Public\r\n    Function add(aData : string; AType: string) : TJSDataTransferItem; overload;\r\n    Function add(aFile : TJSHTMLFile) : TJSDataTransferItem; overload;\r\n    Procedure clear;\r\n    procedure remove(aIndex : integer);\r\n    property length : NativeInt read FLength;\r\n    property Items[aIndex : NativeInt] : TJSDataTransferItem Read getitem; default;\r\n  end;\r\n\r\n  { TJSDataTransfer }\r\n\r\n  TJSDataTransfer = class external name 'DataTransfer'  (TJSObject)\r\n  private\r\n    FFiles: TJSHTMLFileList; external name 'files';\r\n    FItems: TJSDataTransferItemList; external name 'items';\r\n    FTypes: TJSStringDynArray; external name 'types';\r\n  Public\r\n    dropEffect : string;\r\n    effectAllowed : string;\r\n    Procedure clearData; overload;\r\n    Procedure clearData(aFormat : string); overload;\r\n    function getData(aFormat : string) : String;\r\n    procedure setData(aFormat : String; aData : String);\r\n    procedure setDragImage(aImage: TJSElement; xOffset,yOffset : integer);\r\n    property files : TJSHTMLFileList Read FFiles;\r\n    property items : TJSDataTransferItemList read FItems;\r\n    property types : TJSStringDynArray read FTypes;\r\n  end;\r\n\r\n  { TJSDragEvent }\r\n\r\n  TJSDragEvent = class external name 'DragEvent' (TJSEvent)\r\n  Private\r\n    FDataTransfer: TJSDataTransfer; external name 'dataTransfer';\r\n    FrelatedTarget : TJSEventTarget external name 'relatedTarget';\r\n    FscreenX : NativeInt external name 'screenX';\r\n    FscreenY : NativeInt external name 'screenY';\r\n    FclientX : NativeInt external name 'clientX';\r\n    FclientY : NativeInt external name 'clientY';\r\n    Fbutton : NativeInt external name 'button';\r\n    Fbuttons : NativeInt external name 'buttons';\r\n    FctrlKey : Boolean external name 'ctrlKey';\r\n    FshiftKey : Boolean external name 'shiftKey';\r\n    FaltKey  : Boolean external name 'altKey';\r\n    FmetaKey  : Boolean external name 'metaKey';\r\n  Public\r\n    Property relatedTarget : TJSEventTarget Read FRelatedTarget;\r\n    Property screenX : NativeInt Read FScreenX;\r\n    Property screenY : NativeInt Read FScreenY;\r\n    Property clientX : NativeInt Read FClientX;\r\n    Property clientY : NativeInt Read FClientY;\r\n    Property button : NativeInt Read FButton;\r\n    Property buttons : NativeInt Read FButtons;\r\n    Property ctrlKey : Boolean Read FctrlKey;\r\n    Property shiftKey : Boolean Read FshiftKey;\r\n    Property altKey  : Boolean Read FaltKey;\r\n    Property metaKey  : Boolean Read FmetaKey;\r\n    property dataTransfer : TJSDataTransfer Read FDataTransfer;\r\n  end;\r\n  TJSDragDropEventHandler = reference to function(aEvent: TJSDragEvent) : Boolean; safecall;\r\n  THTMLClickEventHandler = reference to function(aEvent : TJSMouseEvent) : boolean; safecall;\r\n\r\n  TJSClipBoardEvent = Class external name 'ClipboardEvent' (TJSEvent)\r\n  Private\r\n    FClipboardData: TJSDataTransfer external name 'clipboardData';\r\n  Public\r\n    Property ClipBoardData : TJSDataTransfer Read FClipBoardData;\r\n  end;\r\n\r\n  { Various events }\r\n\r\n  TJSFocusEvent = Class(TJSEvent)\r\n  private\r\n    FrelatedTarget : TJSElement external name 'relatedTarget';\r\n  public\r\n    property relatedTarget : TJSElement Read FrelatedTarget;\r\n  end;\r\n\r\n  TJSAnimationEvent = Class(TJSEvent);\r\n  TJSLoadEvent = Class(TJSEvent);\r\n\r\n  TJSErrorEvent = class external name 'ErrorEvent' (TJSEvent)\r\n  Private\r\n    Fmessage : String external name 'message';\r\n    Ffilename : string external name 'filename';\r\n    Flineno : integer external name 'lineno';\r\n    Fcolno : integer external name 'colno';\r\n    Ferror : TJSObject external name 'error';\r\n  Public\r\n    Property message : String read FMessage;\r\n    property filename : string Read FFileName;\r\n    property lineno : integer read FLineNo;\r\n    Property colno : integer read FColNo;\r\n    Property error : TJSObject read FError;\r\n  end;\r\n\r\n  TJSPageTransitionEvent = class(TJSEvent)\r\n  end;\r\n\r\n  TJSHashChangeEvent = class external name 'HashChangeEvent' (TJSEvent)\r\n  Private\r\n    FnewURL : String external name 'newURL';\r\n    FoldURL : String external name 'oldURL';\r\n  public\r\n    property newURL : String Read FNewURL;\r\n    property oldURL : String Read FOldURL;\r\n  end;\r\n\r\n  TJSPopStateEvent = class external name 'PopStateEvent'  (TJSEvent)\r\n  Private\r\n    FState : JSValue; external name 'state';\r\n  Public\r\n    property state : JSValue read FState;\r\n  end;\r\n\r\n  TJSStorageEvent = class external name 'StorageEvent' (TJSEvent)\r\n  private\r\n    Fkey : String external name 'key';\r\n    FoldValue : String external name 'oldValue';\r\n    FnewValue : String external name 'newValue';\r\n    Furl : String external name 'url';\r\n    FstorageArea : String external name 'storageArea';\r\n  public\r\n    Property key : String Read FKey;\r\n    Property oldValue : String Read FOldValue;\r\n    Property newValue : String Read FNewValue;\r\n    Property url : String Read FURL;\r\n    Property storageArea : String Read FstorageArea;\r\n  end;\r\n\r\n  { TJSProgressEvent }\r\n\r\n  TJSProgressEvent = class external name 'ProgressEvent' (TJSEvent)\r\n  Private\r\n    FlengthComputable : Boolean external name 'lengthComputable';\r\n    Floaded : NativeUINT external name 'loaded';\r\n    FTotal : NativeUINT external name 'Total';\r\n  Public\r\n    property lengthComputable : Boolean Read FlengthComputable;\r\n    property loaded : NativeUINT Read FLoaded;\r\n    property Total : NativeUINT Read FTotal;\r\n  end;\r\n\r\n  TJSCloseEvent = class external name 'CloseEvent' (TJSEvent)\r\n  private\r\n    fcode: Word; external name 'code';\r\n    freason: TJSDOMString; external name 'reason';\r\n    fwasClean: Boolean; external name 'wasClean';\r\n  public\r\n    property code: Word read fcode;\r\n    property reason: TJSDOMString read freason;\r\n    property wasClean: Boolean read fwasClean;\r\n  end; \r\n\r\n  TJSPageTransitionEventHandler = reference to function(aEvent : TJsPageTransitionEvent) : boolean; safecall;\r\n  TJSHashChangeEventhandler = reference to function(aEvent : TJSHashChangeEvent) : boolean; safecall;\r\n  TJSMouseWheelEventHandler = reference to function(aEvent : TJSWheelEvent) : boolean; safecall;\r\n  TJSMouseEventHandler = reference to function(aEvent : TJSMouseEvent) : boolean; safecall;\r\n  THTMLAnimationEventHandler = reference to function(aEvent : TJSAnimationEvent) : boolean; safecall;\r\n  TJSErrorEventHandler = reference to function(aEvent : TJSErrorEvent) : boolean; safecall;\r\n  TJSFocusEventHandler = reference to function(aEvent : TJSFocusEvent) : boolean; safecall;\r\n  TJSKeyEventhandler = reference to function (aEvent : TJSKeyBoardEvent) : boolean; safecall;\r\n  TJSLoadEventhandler = reference to function (aEvent : TJSLoadEvent) : boolean; safecall;\r\n  TJSPointerEventHandler = reference to function(aEvent : TJSPointerEvent) : boolean; safecall;\r\n  TJSUIEventHandler = reference to function(aEvent : TJSUIEvent) : Boolean; safecall;\r\n  TJSPopStateEventHandler = reference to function(aEvent : TJSPopStateEvent) : Boolean; safecall;\r\n  TJSStorageEventHandler = reference to function(aEvent : TJSStorageEvent) : Boolean; safecall;\r\n  TJSProgressEventhandler =  reference to function(aEvent : TJSProgressEvent) : Boolean; safecall;\r\n  TJSTouchEventHandler = reference to function(aEvent : TJSTouchEvent) : boolean; safecall;\r\n\r\n  TJSDocument = class external name 'Document' (TJSNode)\r\n  Private\r\n    fActiveElement : TJSElement; external name 'activeElement';\r\n    FCharacterSet: String; external name 'characterSet';\r\n    FChildElementCount: NativeInt; external name 'childElementCount';\r\n    FCompatMode: String; external name 'compatMode';\r\n    FCurrentScript: TJSElement; external name 'currentScript';\r\n    FDefaultView: TJSWindow; external name 'defaultView';\r\n    FDocType: TJSDocumentType; external name 'docrype';\r\n    FDocumentElement: TJSElement; external name 'documentElement';\r\n    FDocumentURI: String; external name 'documentURI';\r\n    FEmbeds: TJSHTMLCollection; external name 'embeds';\r\n    FFirstElementChild : TJSElement; external name 'firstElementChild';\r\n    FForms: TJSHTMLCollection; external name 'forms';\r\n    FFullScreenElement: TJSElement; external name 'fullscreenElement';\r\n    FFullscreenEnabled: Boolean; external name 'fullscreenEnabled';\r\n    FHead: TJSElement; external name 'head';\r\n    FHidden: Boolean; external name 'hidden';\r\n    FImages: TJSHTMLCollection; external name 'images';\r\n    FImplementation: TJSDOMImplementation; external name 'implementation';\r\n    FLastElementChild : TJSElement; external name 'lastElementChild';\r\n    FLastModified: String; external name 'lastModified';\r\n    FLastStyleSheetSet: String; external name 'lastStyleSheetSet';\r\n    FLinks: TJSHTMLCollection; external name 'links';\r\n    FLocation: TJSLocation; external name 'location';\r\n    FLocationString: String; external name 'location';\r\n    FPlugins: TJSHTMLCollection; external name 'plugins';\r\n    FPointerLockElement: TJSElement; external name 'pointerLockElement';\r\n    FPreferredStyleSheetSet: String; external name 'preferredStyleSheetSet';\r\n    FReadyState: String; external name 'readyState';\r\n    FReferrer: String; external name 'referrer';\r\n    FScripts: TJSHTMLCollection; external name 'scripts';\r\n    FStyleSheets: TJSStyleSheetList; external name 'styleSheets';\r\n    FStyleSheetSets: TJSValueDynArray; external name 'styleSheetSets';\r\n    FURL: String; external name 'URL';\r\n    FVisibilityState: string; external name 'visibilityState';\r\n  Public\r\n    function adoptNode(aExternalNode : TJSNode) : TJSNode;\r\n    procedure close;\r\n    function createAttribute(aName : string) : TJSAttr;\r\n    function createCDATASection(S : String) : TJSNode;\r\n    function createComment(S : String) : TJSNode;\r\n    function createDocumentFragment : TJSDocumentFragment;\r\n    function createElement(tagName : string) : TJSElement; overload;\r\n    function createElement(tagName : string; const options : TJSElementCreationOptions) : TJSElement; overload;\r\n    function createElementNS(aNameSpace,tagName : string) : TJSElement; overload;\r\n    function createElementNS(aNameSpace,tagName : string; const options : TJSElementCreationOptions) : TJSElement; overload;\r\n    function createEvent(aType : string) : TJSEvent;\r\n    function createExpression(xPathText : String; aNameSpaceMapper: TJSNameSpaceMapperCallback) : TJSXPathExpression;\r\n    function createNSResolver(aNode : TJSNode) : TJSXPathNSResolver;\r\n    function createProcessingInstruction(target, data : String) : TJSProcessingInstruction;\r\n    function createRange : TJSRange;\r\n    function createTextNode(S : String) : TJSNode;\r\n    function createTreeWalker(root : TJSNode; whatToShow : NativeInt; filter : TJSNodeFilter) : TJSTreeWalker;\r\n    function elementFromPoint(x,y : integer) : TJSElement;\r\n    procedure enableStyleSheetsForSet(aSet : String);\r\n    function evaluate(xpathExpression : String; ContextNode : TJSNode; NameSpaceResolver : TJSNamespaceMapperCallBack; resultType : NativeInt; aResult : TJSXPathResult) : TJSXPathResult;\r\n    function execCommand(aCommandName : String; aShowDefaultUI : Boolean; AValueArgument : String) : boolean; overload;\r\n    function execCommand(aCommandName : String; aShowDefaultUI : Boolean) : boolean; overload;\r\n    Procedure exitFullScreen;\r\n    function getElementById(aID : String) : TJSElement;\r\n    function getHTMLElementById(aID : String) : TJSHTMLElement; external name 'getElementById';\r\n    function getElementsByClassName(aNames : string) : TJSHTMLCollection;\r\n    function getElementsByName(aName : String) : TJSNodeList;\r\n    function getElementsByTagName(aName : String) : TJSHTMLCollection;\r\n    function getElementsByTagNameNS(aNameSpace,aName : String) : TJSHTMLCollection;\r\n    function getSelection : TJSSelection;\r\n    function hasFocus : boolean;\r\n    function importNode(aExternalNode : TJSNode; Deep: boolean) : TJSNode;\r\n    function querySelector(aSelectors : String) : TJSElement;\r\n    function querySelectorAll(aSelectors : String) : TJSNodeList;\r\n    procedure open;\r\n    procedure releaseCapture;\r\n    procedure write(aLine : string);\r\n    procedure writeln(aLine : String);\r\n  Public\r\n    body : TJSElement;\r\n    cookie: TJSString;\r\n    designMode : string;\r\n    dir : string;\r\n    domain : string;\r\n    selectedStyleSheetSet : string;\r\n    title : string;\r\n    onabort : TJSEventHandler;\r\n    onblur : TJSEventHandler;\r\n    oncancel : TJSEventHandler;\r\n    oncanplay : TJSEventHandler;\r\n    oncanplaythrough : TJSEventHandler;\r\n    onchange : TJSEventHandler;\r\n    onclick: THTMLClickEventHandler;\r\n    onclose : TJSEventHandler;\r\n    oncontextmenu : TJSEventHandler;\r\n    oncuechange : TJSEventHandler;\r\n    ondblclick : THTMLClickEventHandler;\r\n    ondrag : TJSDragDropEventHandler;\r\n    ondragend : TJSDragDropEventHandler;\r\n    ondragenter : TJSDragDropEventHandler;\r\n    ondragexit : TJSDragDropEventHandler;\r\n    ondragover : TJSDragDropEventHandler;\r\n    ondragleave : TJSDragDropEventHandler;\r\n    ondragstart: TJSDragDropEventHandler;\r\n    ondrop : TJSDragDropEventHandler;\r\n    ondurationchange : TJSEventHandler;\r\n    onemptied : TJSEventHandler;\r\n    onended : TJSEventHandler;\r\n    onerror : TJSErrorEventHandler;\r\n    onfocus : TJSFocusEventhandler;\r\n    ongotpointercapture : TJSPointerEventHandler;\r\n    oninput : TJSEventhandler;\r\n    oninvalid : TJSEventhandler;\r\n    onkeydown : TJSKeyEventhandler;\r\n    onkeypress : TJSKeyEventhandler;\r\n    onkeyup : TJSKeyEventhandler;\r\n    onload : TJSEventhandler;\r\n    onloadeddata : TJSEventhandler;\r\n    onloadedmetadata : TJSEventhandler;\r\n    onloadend : TJSProgressEventhandler;\r\n    onloadstart : TJSProgressEventhandler;\r\n    onlostpointercapture : TJSPointerEventHandler;\r\n    onmessage : TJSEventHandler;\r\n    onmousedown : TJSMouseEventHandler;\r\n    onmouseenter : TJSMouseEventHandler;\r\n    onmouseleave : TJSMouseEventHandler;\r\n    onmousemove : TJSMouseEventHandler;\r\n    onmouseout : TJSMouseEventHandler;\r\n    onmouseover : TJSMouseEventHandler;\r\n    onmouseup : TJSMouseEventHandler;\r\n    onmousewheel : TJSMouseEventHandler;\r\n    onpause : TJSEventHandler;\r\n    onplay : TJSEventHandler;\r\n    onplaying : TJSEventHandler;\r\n    onpointercancel : TJSPointerEventHandler;\r\n    onpointerdown : TJSPointerEventHandler;\r\n    onpointerenter : TJSPointerEventHandler;\r\n    onpointerleave : TJSPointerEventHandler;\r\n    onpointermove : TJSPointerEventHandler;\r\n    onpointerout : TJSPointerEventHandler;\r\n    onpointerover : TJSPointerEventHandler;\r\n    onpointerup : TJSPointerEventHandler;\r\n    onpointerlockchange : TJSPointerEventHandler;\r\n    onprogress : TJSProgressEventhandler;\r\n    onreset : TJSUIEventHandler;\r\n    onratechange : TJSEventHandler;\r\n    onscroll : TJSUIEventHandler;\r\n    onseekend : TJSEventHandler;\r\n    onseeking : TJSEventHandler;\r\n    onselect : TJSEventHandler;\r\n    onselectionchange : TJSEventHandler;\r\n    onsshow : TJSEventHandler;\r\n    onsubmit : TJSEventHandler;\r\n    onunload : TJSUIEventHandler;\r\n    onwaiting : TJSEventHandler;\r\n    touchstart : TJSTouchEventHandler;\r\n    touchend : TJSTouchEventHandler;\r\n    touchmove : TJSTouchEventHandler;\r\n    touchcancel : TJSTouchEventHandler;\r\n    Property activeElement : TJSElement Read FActiveElement;\r\n    Property characterSet : String Read FCharacterSet;\r\n    property childElementCount : NativeInt Read FChildElementCount;\r\n    property compatMode : String Read FCompatMode;\r\n    property currentScript : TJSElement Read FCurrentScript;\r\n    property defaultView : TJSWindow Read FDefaultView;\r\n    property doctype : TJSDocumentType read FDocType;\r\n    property documentElement : TJSElement read FDocumentElement;\r\n    property documentURI : String Read FDocumentURI;\r\n    property embeds : TJSHTMLCollection Read FEmbeds;\r\n    property firstElementChild : TJSElement Read FFirstElementChild;\r\n    property lastElementChild : TJSElement Read FLastElementChild;\r\n    property Forms : TJSHTMLCollection Read FForms;\r\n    property fullscreenElement : TJSElement Read FFullScreenElement;\r\n    property fullscreenEnabled : Boolean Read FFullscreenEnabled;\r\n    property head : TJSElement read FHead;\r\n    Property hidden : Boolean read FHidden;\r\n    property images : TJSHTMLCollection Read FImages;\r\n    property _implementation : TJSDOMImplementation Read FImplementation;\r\n    property lastModified : String Read FLastModified;\r\n    property lastStyleSheetSet : String read FLastStyleSheetSet;\r\n    property links : TJSHTMLCollection Read FLinks;\r\n    property location : TJSLocation read FLocation;\r\n    Property LocationString : String Read FURL Write FLocationString; // On purpose\r\n    property plugins : TJSHTMLCollection Read FPlugins;\r\n    property pointerLockElement : TJSElement Read FPointerLockElement;\r\n    property preferredStyleSheetSet : String Read FPreferredStyleSheetSet;\r\n    Property readyState : String Read FReadyState;\r\n    Property referrer : String Read FReferrer;\r\n    property scripts : TJSHTMLCollection Read FScripts;\r\n    property styleSheets : TJSStyleSheetList Read FStyleSheets;\r\n    property styleSheetSets : TJSValueDynArray Read FStyleSheetSets; // No type documented ?\r\n    Property URL : String Read FURL;\r\n    property visibilityState : string read FVisibilityState;\r\n  end;\r\n\r\n\r\n  { TJSHistory }\r\n\r\n  TJSHistory = class external name 'History'  (TJSObject)\r\n  private\r\n    FLength: NativeInt; external name 'length';\r\n{$IFDEF FIREFOX}\r\n    FState : JSValue; external name 'state';\r\n{$ENDIF}\r\n  Public\r\n    procedure back;\r\n    procedure forward;\r\n    procedure go(aIndex : NativeInt);\r\n    procedure go;\r\n    procedure pushState(aState : jsValue; aTitle : String; AURL : String);\r\n    procedure pushState(aState : jsValue; aTitle : String);\r\n    procedure replaceState(aState : jsValue; aTitle : String; AURL : String);\r\n    procedure replaceState(aState : jsValue; aTitle : String);\r\n    procedure replaceState(aState : jsValue);\r\n{$IFDEF FIREFOX}\r\n    property state : JSValue read FState;\r\n{$ENDIF}\r\n    property length: NativeInt read FLength;\r\n  end;\r\n\r\n\r\n  { TJSStorage }\r\n\r\n  TJSStorage = class external name 'Storage' (TJSEventTarget)\r\n  private\r\n    FLength: NativeInt; external name 'length';\r\n  public\r\n    function key(aIndex : Integer) : String;\r\n    function getItem(aKeyName : string) : string;\r\n    procedure setItem(aKeyName : string; aValue : string);\r\n    procedure removeItem(aKeyName : string);\r\n    procedure clear;\r\n    property Keys[AIndex : Integer] : String read key;\r\n    property Items[aKeyName: String] : String read getItem write setItem; default;\r\n    property length : NativeInt Read FLength;\r\n  end;\r\n\r\n  // Fake object, used for objects whose visible can be checked\r\n  TJSVisibleItem = class external name 'IVisible'  (TJSObject)\r\n  Private\r\n    FVisible : boolean; external name 'visible';\r\n  Public\r\n    Property visible : boolean read FVisible;\r\n  end;\r\n  \r\n  TJSLocationBar = class external name 'LocationBar' (TJSVisibleItem);\r\n  TJSMenuBar = class external name 'MenuBar' (TJSVisibleItem);\r\n  TJSToolBar = class external name 'ToolBar' (TJSVisibleItem);\r\n  TJSPersonalBar = class external name 'PersonalBar' (TJSVisibleItem);\r\n  TJSScrollBars = class external name 'ScrollBars' (TJSVisibleItem);\r\n\r\n  TJSPositionError = record\r\n    code : integer;\r\n    message : string;\r\n  end;\r\n\r\n  TJSPositionOptions = record\r\n    enableHighAccuracy : boolean;\r\n    timeout : integer;\r\n    maximumAge : integer;\r\n  end;\r\n\r\n  TJSCoordinates = record\r\n    latitude : double;\r\n    longitude : double;\r\n    altitude : double;\r\n    accuracy : double;\r\n    altitudeAccuracy : double;\r\n    heading : double;\r\n    speed : double;\r\n  end;\r\n\r\n  TJSPosition = record\r\n    coords : TJSCoordinates;\r\n    timestamp : String;\r\n  end;\r\n\r\n  TJSGeoLocationCallback = procedure (aPosition : TJSPosition);\r\n  TJSGeoLocationEvent = procedure (aPosition : TJSPosition) of object;\r\n  TJSGeoLocationErrorCallback = procedure (aValue : TJSPositionError);\r\n  TJSGeoLocationErrorEvent = procedure (aValue : TJSPositionError) of object;\r\n\r\n  TJSGeoLocation  = class external name 'GeoLocation'  (TJSObject)\r\n  Public\r\n    Procedure getCurrentPosition(ASuccess : TJSGeoLocationCallback); overload;\r\n    Procedure getCurrentPosition(ASuccess : TJSGeoLocationCallback;aError : TJSGeoLocationErrorCallback); overload;\r\n    Procedure getCurrentPosition(ASuccess : TJSGeoLocationCallback;aError : TJSGeoLocationErrorCallback; AOptions : TJSPositionOptions); overload;\r\n    Function watchPosition(ASuccess : TJSGeoLocationCallback) : NativeInt; overload;\r\n    Function watchPosition(ASuccess : TJSGeoLocationCallback;aError : TJSGeoLocationErrorCallback) : NativeInt; overload;\r\n    Function watchPosition(ASuccess : TJSGeoLocationCallback;aError : TJSGeoLocationErrorCallback; AOptions : TJSPositionOptions) : NativeInt; overload;\r\n    procedure clearWatch(AID : NativeInt);\r\n  end;\r\n\r\n  TJSMediaStreamTrack = class external name 'MediaStreamTrack' (TJSEventTarget)\r\n  end;\r\n\r\n  TJSMediaDevices = class external name 'MediaDevices' (TJSEventTarget)\r\n  end;\r\n\r\n\r\n\r\n  { TJSSharedWorker }\r\n\r\n  TJSSharedWorker = class external name 'SharedWorker' (TJSEventTarget)\r\n  private\r\n    FPort: TJSMessagePort; external name 'port';\r\n  Public\r\n    constructor new(aURL : String); overload;\r\n    constructor new(aURL : String; aName : string); overload;\r\n    property port : TJSMessagePort Read FPort;\r\n  end;\r\n\r\n\r\n  TJSServiceWorkerContainerOptions = record\r\n    scope : string;\r\n  end;\r\n\r\n  { TJSServiceWorkerContainer }\r\n\r\n  TJSServiceWorkerContainer = class external name 'ServiceWorkerContainer'  (TJSObject)\r\n  private\r\n    FController: TJSServiceWorker; external name 'controller';\r\n    FReady: TJSPromise; external name 'ready';\r\n  Public\r\n    function register(aURL : String) : TJSPromise; overload;\r\n    function register(aURL : String; aOptions : TJSServiceWorkerContainerOptions) : TJSPromise; overload;\r\n    function getRegistration(aURL : String) : TJSPromise; overload;\r\n    function getRegistration : TJSPromise; overload;\r\n    function getRegistrations : TJSPromise;\r\n    property controller : TJSServiceWorker read FController;\r\n    property ready : TJSPromise read FReady;\r\n  end;\r\n\r\n  TJSClipboardItemOptions = Class external name 'Object' (TJSObject)\r\n    presentationStyle : String;\r\n  end;\r\n\r\n  TJSClipBoardItem = Class external name 'ClipboardItem' (TJSObject)\r\n    constructor new(aData : TJSObject; aOptions : TJSOBject); overload;\r\n    constructor new(aData : TJSObject; aOptions : TJSClipboardItemOptions); overload;\r\n    constructor new(aData : TJSObject); overload;\r\n  end;\r\n\r\n  TJSClipBoard = class external name 'Clipboard' (TJSEventTarget)\r\n    Function read : TJSPromise;\r\n    Function readText : TJSPromise;\r\n    Function write(Data : Array of TJSClipBoardItem) : TJSPromise;\r\n    Function writeText(aText : String) : TJSPromise;\r\n  end;\r\n\r\n  { TJSNavigator }\r\n\r\n  TJSNavigator = class external name 'Navigator'  (TJSObject)\r\n{$IFDEF FIREFOX}\r\n    FbuildID : String ; external name 'buildID';\r\n    FOSCPU : String ; external name 'oscpu';\r\n    FproductSub : string; external name 'productSub';\r\n    FVendor : string; external name 'vendor';\r\n{$ENDIF}\r\n  private\r\n    FCookieEnabled: Boolean; external name 'cookieEnabled';\r\n    FGeoLocation: TJSGeoLocation; external name 'geolocation';\r\n    FLanguage: String; external name 'language';\r\n    FMaxTouchPoints: NativeInt; external name 'maxTouchPoints';\r\n    FMediaDevices: TJSMediaDevices; external name 'mediaDevices';\r\n    FOnline: boolean; external name 'onLine';\r\n    FPlatform: string; external name 'platform';\r\n    FServiceWorker: TJSServiceWorkerContainer; external name 'serviceWorker';\r\n    FStorage: TJSStorageManager; external name 'storage';\r\n    FUserAgent: string; external name 'userAgent';\r\n    fClipBoard : TJSClipBoard; external name 'clipboard';\r\n    FPermissions: TJSPermissions; external name 'permissions';\r\n  public\r\n    function getBattery : TJSPromise;\r\n    function requestMediaKeySystemAccess(aKeySystem : String; supportedConfigurations : TJSValueDynArray) : TJSPromise;\r\n    Procedure registerContentHandler(aMimeType,aURI,aTitle : string);\r\n    Procedure registerProtocolHandler(aProtocol,aURI,aTitle : string);\r\n    Procedure vibrate(aPattern : NativeInt);\r\n    Procedure vibrate(aPattern : Array of NativeInt);\r\n{$IFDEF FIREFOX}\r\n    property buildID : String read FBuildID;\r\n    property oscpu : string read FOSCPU;\r\n    property productSub: string read FproductSub;\r\n    property vendor : string read Fvendor;\r\n{$ENDIF}\r\n    property cookieEnabled : Boolean read FCookieEnabled;\r\n    property geoLocation : TJSGeoLocation Read FGeoLocation;\r\n    property language : String read FLanguage;\r\n    property maxTouchPoints : NativeInt read FMaxTouchPoints;\r\n    property mediaDevices : TJSMediaDevices read FMediaDevices;\r\n    property onLine : boolean read FOnline;\r\n    property platform : string read FPlatform;\r\n    property userAgent : string read FUserAgent;\r\n    property serviceWorker : TJSServiceWorkerContainer read FServiceWorker;\r\n    property ClipBoard : TJSClipBoard Read FCLipboard;\r\n    property permissions: TJSPermissions read FPermissions;\r\n    property storage : TJSStorageManager Read FStorage;\r\n  end;\r\n\r\n  { TJSTouchEvent }\r\n  TTouchCoord = longint;\r\n\r\n  TJSTouch = class external name 'Touch'  (TJSObject)\r\n  private\r\n    FClientX: TTouchCoord; external name 'clientX';\r\n    FClientY: TTouchCoord; external name 'clientY';\r\n    FIDentifier: longint; external name 'identifier';\r\n    FPageX: TTouchCoord; external name 'pageX';\r\n    FPageY: TTouchCoord; external name 'pageY';\r\n    FScreenX: TTouchCoord; external name 'screenX';\r\n    FScreenY: TTouchCoord; external name 'screenY';\r\n    FTarget: TJSElement; external name 'target';\r\n  Public\r\n    Property identifier : longint read FIDentifier;\r\n    Property ScreenX : TTouchCoord Read FScreenX;\r\n    Property ScreenY : TTouchCoord Read FScreenY;\r\n    Property ClientX : TTouchCoord Read FClientX;\r\n    Property ClientY : TTouchCoord Read FClientY;\r\n    Property PageX : TTouchCoord Read FPageX;\r\n    Property PageY : TTouchCoord Read FPageY;\r\n    Property Target : TJSElement Read FTarget;\r\n  end;\r\n\r\n  { TJSTouchList }\r\n\r\n  TJSTouchList = class external name 'TouchList' (TJSObject)\r\n  private\r\n    FLength: NativeInt; external name 'length';\r\n  Public\r\n    function item (aIndex : Integer) : TJSTouch;\r\n    property length : NativeInt Read FLength;\r\n    Property Touches[AIndex : Integer] : TJSTouch Read item; default;\r\n  end;\r\n\r\n\r\n  TJSPerformance = class external name 'Performance' (TJSObject);\r\n\r\n  TJSScreen = class external name 'Screen' (TJSObject)\r\n  private\r\n    FavailHeight: Integer; external name 'availHeight';\r\n    FavailWidth: Integer; external name 'availWidth';\r\n    FcolorDepth: Integer; external name 'colorDepth';\r\n    FPixelDepth: Integer; external name 'pixelDepth';\r\n    Fheight: Integer; external name 'height';\r\n    Fwidth: Integer; external name 'width';\r\n  public\r\n  { Properties declarations }\r\n    property availHeight: Integer read FavailHeight;\r\n    property availWidth: Integer read FavailWidth;\r\n    property colorDepth: Integer read FcolorDepth;\r\n    property pixelDepth: Integer read FPixelDepth;\r\n    property height: Integer read Fheight;\r\n    property width: Integer read Fwidth;\r\n  end;\r\n\r\n\r\n\r\n\r\n\r\n  { TJSMediaQueryList }\r\n\r\n  TJSMediaQueryList = class external name 'MediaQueryList' (TJSObject)\r\n  private\r\n    FMatches: Boolean; external name 'matches';\r\n    FMedia: String; external name 'media';\r\n  Public\r\n    Property matches : Boolean Read FMatches;\r\n    Property media : String Read FMedia;\r\n  end;\r\n\r\n\r\n  TJSDOMHighResTimeStamp = Double;\r\n  TFrameRequestCallback = reference to procedure (aTime: TJSDOMHighResTimeStamp);\r\n\r\n  TJSPostMessageOptions = class external name 'Object' (TJSObject)\r\n    targetOrigin : string;\r\n    transfer : TJSValueDynArray;\r\n  end;\r\n\r\n  TJSIdleCallbackOptions = class\r\n  public\r\n    timeout: Cardinal;\r\n  end;\r\n\r\n  TJSIdleDeadline = class external name 'IdleDeadline'\r\n  private\r\n    FDidTimeout: Boolean; external name 'didTimeout';\r\n  public\r\n    function timeRemaining: TJSDOMHighResTimeStamp;\r\n\r\n    property didTimeout: Boolean read FDidTimeout;\r\n  end;\r\n\r\n\r\n  TJSWindowArray = Array of TJSWindow;\r\n  TIdleCallbackProc = reference to procedure(idleDeadline: TJSIdleDeadline);\r\n\r\n  { TJSWindow }\r\n\r\n  TJSWindow = class external name 'Window' (TJSObject)\r\n  Private\r\n    FClosed: boolean; external name 'closed';\r\n    FConsole : TJSConsole;  external name 'console';\r\n    FCrypto: TJSCrypto; external name 'crypto';\r\n    FDevicePixelRatio: Double; external name 'devicePixelRatio';\r\n    FDocument: TJSDocument; external name 'document';\r\n    FFrameElement: TJSElement; external name 'frameElement';\r\n    FFrames: TJSWindowArray; external name 'frames';\r\n    FHistory: TJSHistory; external name 'history';\r\n    FIndexedDB: TJSIDBFactory; external name 'indexedDB';\r\n    FInnerheight: NativeInt; external name 'innerHeight';\r\n    FInnerWidth: NativeInt; external name 'innerWidth';\r\n    FLength: NativeInt; external name 'length';\r\n    FLocalStorage: TJSStorage; external name 'localStorage';\r\n    FLocation: TJSLocation; external name 'location';\r\n    FLocationBar: TJSLocationBar; external name 'locationbar';\r\n    FLocationString: string; external name 'location';\r\n    FMenuBar: TJSMenuBar; external name 'menubar';\r\n    FNavigator: TJSNavigator; external name 'navigator';\r\n    FOpener: TJSWindow; external name 'opener';\r\n    FOuterheight: NativeInt; external name 'outerHeight';\r\n    FOuterWidth: NativeInt; external name 'outerWidth';\r\n    FParent: TJSWindow; external name 'parent';\r\n    FPerformance: TJSPerformance; external name 'Performance';\r\n    FPersonalBar: TJSPersonalBar; external name 'personalbar';\r\n    FScreen: TJSScreen; external name 'screen';\r\n    FScreenX: NativeInt; external name 'screenX';\r\n    FScreenY: NativeInt; external name 'screenY';\r\n    FScrollbar: TJSScrollBars; external name 'scrollbar';\r\n    FScrollX: NativeInt; external name 'scrollX';\r\n    FScrollY: NativeInt; external name 'scrollY';\r\n    FSelf: TJSWindow; external name 'self';\r\n    FSessionStorage: TJSStorage; external name 'sessionStorage';\r\n    FToolBar: TJSToolBar; external name 'toolbar';\r\n    FTop: TJSWindow; external name 'top';\r\n    FURL: TJSURL; external name 'URL';\r\n  Public\r\n    fullSreen : Boolean;   \r\n    name : string;\r\n    status : string;\r\n    onabort : TJSEventHandler;\r\n    onafterprint : TJSEventHandler;\r\n    onbeforeprint : TJSEventHandler;\r\n    onbeforeinstallprompt : TJSEventHandler;\r\n    onbeforeunloadprompt : TJSEventHandler;\r\n    onblur : TJSEventHandler;\r\n    onchange : TJSEventHandler;\r\n    onclick: THTMLClickEventHandler;\r\n    onclose : TJSEventHandler;\r\n    oncontextmenu : TJSEventHandler;\r\n    ondblclick : THTMLClickEventHandler;\r\n    onerror : TJSErrorEventHandler;\r\n    onfocus : TJSFocusEventhandler;\r\n    onhashchange : TJSHashChangeEventhandler;\r\n    oninput : TJSEventhandler;\r\n    onkeydown : TJSKeyEventhandler;\r\n    onkeypress : TJSKeyEventhandler;\r\n    onkeyup : TJSKeyEventhandler;\r\n    onlanguagechange : TJSEventhandler;\r\n    onload : TJSEventhandler;\r\n    onloadend : TJSLoadEventhandler;\r\n    onloadstart : TJSLoadEventhandler;\r\n    onmessage : TJSEventHandler;\r\n    onmousedown : TJSMouseEventHandler;\r\n    onmouseenter : TJSMouseEventHandler;\r\n    onmouseleave : TJSMouseEventHandler;\r\n    onmousemove : TJSMouseEventHandler;\r\n    onmouseout : TJSMouseEventHandler;\r\n    onmouseover : TJSMouseEventHandler;\r\n    onmouseup : TJSMouseEventHandler;\r\n    onmousewheel : TJSMouseEventHandler;\r\n    onoffline : TJSEventHandler;\r\n    ononline : TJSEventHandler;\r\n    onpagehide : TJSPageTransitionEventHandler;\r\n    onpageshow : TJSPageTransitionEventHandler;\r\n    onpaint : TJSEventHandler;\r\n    onpointercancel : TJSPointerEventHandler;\r\n    onpointerdown : TJSPointerEventHandler;\r\n    onpointerenter : TJSPointerEventHandler;\r\n    onpointerleave : TJSPointerEventHandler;\r\n    onpointermove : TJSPointerEventHandler;\r\n    onpointerout : TJSPointerEventHandler;\r\n    onpointerover : TJSPointerEventHandler;\r\n    onpointerup : TJSPointerEventHandler;\r\n    onpointerlockchange : TJSPointerEventHandler;\r\n    onprogress : TJSProgressEventhandler;\r\n    onpopstate : TJSPopStateEventHandler;\r\n    onreset : TJSUIEventHandler;\r\n    onresize : TJSUIEventHandler;\r\n    onscroll : TJSUIEventHandler;\r\n    onselect : TJSEventHandler;\r\n    onselectionchange : TJSEventHandler;\r\n    onstorage : TJSStorageEventHandler;\r\n    onsubmit : TJSEventHandler;\r\n    onunload : TJSUIEventHandler;\r\n    touchstart : TJSTouchEventHandler;\r\n    touchend : TJSTouchEventHandler;\r\n    touchmove : TJSTouchEventHandler;\r\n    touchcancel : TJSTouchEventHandler;\r\n    procedure addEventListener(aname : string; aListener : TJSEventHandler);\r\n    procedure addEventListener(aname : string; aListener : TJSRawEventHandler);\r\n    procedure addEventListener(aname : string; aListener : JSValue);\r\n    Procedure alert(Const Msg : String);\r\n    Function atob(Const aValue : string) : string;\r\n    procedure blur;\r\n    Procedure clearInterval(aID: NativeInt);\r\n    Procedure clearTimeout(aID: NativeInt);\r\n    Function btoa(Const aValue : string) : string;\r\n    procedure cancelAnimationFrame(aHandle: Integer);\r\n    Procedure close;\r\n    Function confirm(Const aMsg : String) :  boolean;\r\n    function fetch(resource: String; init: TJSObject): TJSPromise; overload; external name 'fetch';\r\n    //function fetch(resource: String): TJSPromise; overload; external name 'fetch';\r\n    function fetch(resource: String): TJSResponse; {$IFNDEF SkipAsync}async;{$ENDIF} overload; external name 'fetch';\r\n    function fetch(resource: TJSObject; init: TJSObject): TJSPromise; overload; external name 'fetch';\r\n    function fetch(resource: TJSObject): TJSPromise; overload; external name 'fetch';\r\n    function asyncfetch(resource: String): TJSResponse; {$IFNDEF SkipAsync}async;{$ENDIF} overload; external name 'fetch';\r\n    function asyncfetch(resource: TJSObject; init: TJSObject): TJSResponse; {$IFNDEF SkipAsync} async;{$ENDIF} overload; external name 'fetch';\r\n    function asyncfetch(resource: TJSObject): TJSResponse;  {$IFNDEF SkipAsync}async;{$ENDIF}  overload;external name 'fetch';\r\n    procedure focus;\r\n    Function getComputedStyle(aElement : TJSElement) : TJSCSSStyleDeclaration; overload;\r\n    Function getComputedStyle(aElement,aPseudoElement : TJSElement) : TJSCSSStyleDeclaration; overload;\r\n    function getSelection : TJSSelection;\r\n    function matchMedia(aQuery : String) : TJSMediaQueryList;\r\n    procedure moveBy(x,y : NativeInt);\r\n    procedure moveTo(x,y : NativeInt);\r\n    function open : TJSWindow;\r\n    function open(Const aURL : String) : TJSWindow; overload;\r\n    function open(Const aURL,aTarget : String) : TJSWindow; overload;\r\n    function open(Const aURL,aTarget : String; AOptions : TJSObject) : TJSWindow; overload;\r\n    procedure postMessage(aMessage : JSValue);\r\n    procedure postMessage(aMessage : JSValue; aOptions : TJSPostMessageOptions);\r\n    procedure postMessage(aMessage : JSValue; aTransfer : TJSValueDynArray);\r\n    procedure postMessage(aMessage : JSValue; aTarget : string);\r\n    procedure postMessage(aMessage : JSValue; aTarget : string; aTransfer : TJSValueDynArray);\r\n    procedure print;\r\n    function prompt(const aMessage : String) : String; overload;\r\n    function prompt(const aMessage,aDefault : String) : String; overload;\r\n    procedure removeEventListener(aname : string; aListener : TJSEventHandler);\r\n    procedure removeEventListener(aname : string; aListener : JSValue);\r\n    function requestAnimationFrame(aCallback: TFrameRequestCallback): Integer;\r\n    procedure resizeBy(aWidth,aHeight : NativeInt);\r\n    procedure resizeTo(aWidth,aHeight : NativeInt);\r\n    procedure scrollBy(x,y : NativeInt);\r\n    procedure scrollTo(x,y : NativeInt);\r\n    Function setInterval(ahandler : TJSTimerCallBack; aInterval : NativeUInt) : NativeInt; varargs;\r\n    Function setTimeout(ahandler : TJSTimerCallBack; aTimeout : NativeUInt) : NativeInt; varargs;\r\n    Function setTimeout(ahandler : TJSTimerCallBack) : NativeInt;\r\n    procedure stop;\r\n    procedure cancelIdleCallback(handle: NativeInt);\r\n    function requestIdleCallback(handler: TIdleCallbackProc): NativeInt; overload;\r\n    function requestIdleCallback(handler: TIdleCallbackProc; options: TJSIdleCallbackOptions): NativeInt; overload;\r\n    function showOpenFilePicker: TJSFileSystemFileHandleArray; async; overload;\r\n    function showOpenFilePicker(options: TJSShowOpenFilePickerOptions): TJSFileSystemFileHandleArray; async; overload;\r\n    function showSaveFilePicker: TJSFileSystemFileHandle; async; overload;\r\n    function showSaveFilePicker(options: TJSShowSaveFilePickerOptions): TJSFileSystemFileHandle; async; overload;\r\n    function FileSystemDirectoryHandle: TJSFileSystemDirectoryHandleArray; async;\r\n    { public properties }\r\n    property console : TJSConsole Read FConsole;\r\n    property closed : boolean read FClosed;\r\n    property crypto : TJSCrypto Read FCrypto;\r\n    property devicePixelRatio : Double read FDevicePixelRatio;\r\n    property document : TJSDocument read FDocument;\r\n    property frameElement : TJSElement Read FFrameElement;\r\n    Property frames  : TJSWindowArray read FFrames;\r\n    Property history : TJSHistory read FHistory;\r\n    Property indexedDB : TJSIDBFactory read FIndexedDB;\r\n    Property innerHeight : NativeInt Read FInnerheight;\r\n    Property innerWidth : NativeInt Read FInnerWidth;\r\n    Property length : NativeInt Read FLength;\r\n    Property localStorage : TJSStorage Read FLocalStorage;\r\n    property location : TJSLocation Read FLocation;\r\n    Property locationString : String read FLocationString write FLocationString;\r\n    property locationbar : TJSLocationBar Read FLocationBar;\r\n    property menubar : TJSMenuBar Read FMenuBar;\r\n    property navigator : TJSNavigator Read FNavigator;\r\n    property opener : TJSWindow read FOpener;\r\n    Property outerHeight : NativeInt Read FOuterheight;\r\n    Property outerWidth : NativeInt Read FOuterWidth;\r\n    Property parent : TJSWindow Read FParent;\r\n    Property Performance : TJSPerformance Read FPerformance;\r\n    property personalbar : TJSPersonalBar Read FPersonalBar;\r\n    property screen : TJSScreen read FScreen;\r\n    property screenX : NativeInt read FScreenX;\r\n    Property screenY : NativeInt read FScreenY;\r\n    Property scrollbar : TJSScrollBars Read FScrollbar;\r\n    property scrollX : NativeInt read FScrollX;\r\n    Property scrollY : NativeInt read FScrollY;\r\n    Property _Self : TJSWindow read FSelf;\r\n    Property sessionStorage : TJSStorage Read FSessionStorage;\r\n    property toolbar : TJSToolBar Read FToolBar;\r\n    property top : TJSWindow Read FTop;\r\n    property URL : TJSURL Read FURL;\r\n  end;\r\n\r\n  { TJSCSSStyleDeclaration }\r\n\r\n  TJSCSSStyleDeclaration = class external name 'CSSStyleDeclaration'  (TJSObject)\r\n  private\r\n    FLength: NativeInt; external name 'length';\r\n    FParentRule: TJSCSSRule; external name 'parentRule';\r\n  public\r\n    cssText : string;\r\n    function item(aIndex : Integer) : string;\r\n    function removeProperty(const aProperty : String) : string;\r\n    function getPropertyPriority(const aProperty : String) : string;\r\n    function getPropertyValue(const aProperty : String) : string;\r\n    procedure setProperty(const aProperty,aValue : String);overload;\r\n    procedure setProperty(const aProperty,aValue,aPriority : string); overload;\r\n    property length : NativeInt read FLength;\r\n    property parentRule : TJSCSSRule read FParentRule;\r\n  end;\r\n\r\n  TJSScrollIntoViewOptions = class external name 'Object'  (TJSObject)\r\n    behaviour : string;\r\n    block : string;\r\n    inline_ : string; external name 'inline';\r\n  end;\r\n\r\n\r\n  { TJSHTMLElement }\r\n\r\n  TJSDatasetMap = class external name 'Object' (TJSObject)\r\n  Private\r\n    function GetProps(Name: String): String; external name '[]';\r\n    procedure SetProps(Name: String; const AValue: String); external name '[]';\r\n  Public\r\n    property Map[Name: String]: string read GetProps write SetProps; default;\r\n  end;\r\n\r\n  TJSHTMLElement = class external name 'HTMLElement' (TJSElement)\r\n  private\r\n    FDataset: TJSDatasetMap ; external name 'dataset';\r\n    FDatasetObj: TJSObject ; external name 'dataset';\r\n    FIsContentEditable: Boolean ; external name 'isContentEditable';\r\n    FOffsetHeight: Double; external name 'offsetHeight';\r\n    FOffsetLeft: Double; external name 'offsetLeft';\r\n    FOffsetParent: TJSElement; external name 'offsetParent';\r\n    FOffsetTop: Double; external name 'offsetTop';\r\n    FOffsetWidth: Double; external name 'offsetWidth';\r\n  Public\r\n    accessKey : string;\r\n    contentEditable : string;\r\n    dir : string;\r\n    draggable : boolean;\r\n    hidden : boolean;\r\n    lang : string;\r\n    spellcheck : boolean;\r\n    style : TJSCSSStyleDeclaration;\r\n    tabIndex : Integer;\r\n    title: string;\r\n    onabort : TJSEventHandler;\r\n    onanimationcancel: THTMLAnimationEventHandler;\r\n    onanimationend: THTMLAnimationEventHandler;\r\n    onblur : TJSEventHandler;\r\n    oncancel : TJSEventHandler;\r\n    oncanplay : TJSEventHandler;\r\n    oncanplaythrough : TJSEventHandler;\r\n    onchange : TJSEventHandler;\r\n    onclick: THTMLClickEventHandler;\r\n    onclose : TJSEventHandler;\r\n    oncontextmenu : TJSEventHandler;\r\n    ondblclick : THTMLClickEventHandler;\r\n    ondrag : TJSDragDropEventHandler;\r\n    ondragend : TJSDragDropEventHandler;\r\n    ondragenter : TJSDragDropEventHandler;\r\n    ondragexit : TJSDragDropEventHandler;\r\n    ondragover : TJSDragDropEventHandler;\r\n    ondragleave : TJSDragDropEventHandler;\r\n    ondragstart: TJSDragDropEventHandler;\r\n    ondrop : TJSDragDropEventHandler;\r\n    onerror : TJSErrorEventHandler;\r\n    onfocus : TJSFocusEventhandler;\r\n    ondurationchange : TJSEventHandler;\r\n    onemptied : TJSEventHandler;\r\n    onended : TJSEventHandler;\r\n    ongotpointercapture : TJSPointerEventHandler;\r\n    oninput : TJSEventhandler;\r\n    oninvalid : TJSEventhandler;\r\n    onkeydown : TJSKeyEventhandler;\r\n    onkeypress : TJSKeyEventhandler;\r\n    onkeyup : TJSKeyEventhandler;\r\n    onload : TJSEventhandler;\r\n    onloadeddata : TJSEventhandler;\r\n    onloadedmetadata : TJSEventhandler;\r\n    onloadend : TJSLoadEventhandler;\r\n    onloadstart : TJSLoadEventhandler;\r\n    onlostpointercapture : TJSPointerEventHandler;\r\n    onmousedown : TJSMouseEventHandler;\r\n    onmouseenter : TJSMouseEventHandler;\r\n    onmouseleave : TJSMouseEventHandler;\r\n    onmousemove : TJSMouseEventHandler;\r\n    onmouseout : TJSMouseEventHandler;\r\n    onmouseover : TJSMouseEventHandler;\r\n    onmouseup : TJSMouseEventHandler;\r\n    onmousewheel : TJSMouseEventHandler;\r\n    onpause : TJSPointerEventHandler;\r\n    onplay : TJSPointerEventHandler;\r\n    onplaying : TJSPointerEventHandler;\r\n    onpointercancel : TJSPointerEventHandler;\r\n    onpointerdown : TJSPointerEventHandler;\r\n    onpointerenter : TJSPointerEventHandler;\r\n    onpointerleave : TJSPointerEventHandler;\r\n    onpointermove : TJSPointerEventHandler;\r\n    onpointerout : TJSPointerEventHandler;\r\n    onpointerover : TJSPointerEventHandler;\r\n    onpointerup : TJSPointerEventHandler;\r\n    onpointerlockchange : TJSPointerEventHandler;\r\n    onprogress : TJSProgressEventhandler;\r\n    onseeked : TJSEventHandler;\r\n    onseeking : TJSEventHandler;\r\n    onreset : TJSUIEventHandler;\r\n    onscroll : TJSUIEventHandler;\r\n    onselect : TJSEventHandler;\r\n    onselectstart : TJSEventHandler;\r\n    onselectionchange : TJSEventHandler;\r\n    onshow : TJSEventHandler;\r\n    onstalled : TJSEventHandler;\r\n    ontimeupdate : TJSEventHandler;\r\n    ontouchstart: TJSTouchEventHandler;\r\n    ontouchmove: TJSTouchEventHandler;\r\n    ontouchcancel: TJSTouchEventHandler;\r\n    ontouchend: TJSTouchEventHandler;\r\n    ontransitioncancel : TJSEventHandler;\r\n    ontransitionend : TJSEventHandler;\r\n    onvolumechange : TJSEventHandler;\r\n    onsubmit : TJSEventHandler;\r\n    onwheel : TJSMouseWheelEventHandler;\r\n    onwaiting : TJSEventHandler;\r\n    touchstart : TJSTouchEventHandler;\r\n    touchend : TJSTouchEventHandler;\r\n    touchmove : TJSTouchEventHandler;\r\n    touchcancel : TJSTouchEventHandler;\r\n    Procedure blur;\r\n    Procedure focus;\r\n    Procedure click;\r\n    procedure scrollIntoView; overload;\r\n    procedure scrollIntoView(alignToTop : Boolean);\r\n    procedure scrollIntoView(aObj : TJSObject);\r\n    procedure scrollIntoView(Opts: TJSScrollIntoViewOptions);\r\n    property dataset : TJSDatasetMap read FDataset;\r\n    property datasetObj : TJSObject read FDatasetObj;\r\n    property isContentEditable : Boolean read FIsContentEditable;\r\n    property offsetHeight : Double Read FOffsetHeight;\r\n    property offsetLeft : Double Read FOffsetLeft;\r\n    property offsetTop : Double Read FOffsetTop;\r\n    property offsetWidth : Double Read FOffsetWidth;\r\n    property offsetParent : TJSElement Read FOffsetParent;\r\n  end;\r\n  TJSHTMLElementArray = Array of TJSHTMLElement;\r\n\r\n  TJSHTMLDivElement = class external name 'HTMLDivElement' (TJSHTMLElement)\r\n  end;\r\n\r\n  TJSHTMLFormControlsCollection = class external name 'HTMLFormControlsCollection' (TJSHTMLCollection)\r\n  Public\r\n    function namedItem(S : String) : TJSElement; reintroduce; external name 'namedItem';\r\n    property Items[S : String] : TJSElement read namedItem; default;\r\n  end;\r\n\r\n  { TJSHTMLFormElement }\r\n\r\n  TJSHTMLFormElement = class external name 'HTMLFormElement' (TJSHTMLElement)\r\n  private\r\n    FElements: TJSHTMLFormControlsCollection; external name 'elements';\r\n    FLength: NativeInt; external name 'length';\r\n  Public\r\n    Procedure reset;\r\n    function reportValidity : Boolean;\r\n    function checkValidity : Boolean;\r\n    procedure requestSubmit;\r\n    procedure requestSubmit(aElement : TJSHTMLElement);\r\n    procedure submit;\r\n    method : string;\r\n    target : string;\r\n    action : string;\r\n    encoding : string;\r\n    enctype : string;\r\n    acceptCharset :  string;\r\n    autocomplete : string;\r\n    noValidate : boolean;\r\n    property elements : TJSHTMLFormControlsCollection read FElements;\r\n    Property length : NativeInt Read FLength;\r\n  end;\r\n\r\n  { TJSValidityState }\r\n\r\n  TJSValidityState = class external name 'ValidityState'  (TJSObject)\r\n  private\r\n    FBadInput: Boolean; external name 'badInput';\r\n    FCustomError: Boolean; external name 'customError';\r\n    FPatternMismatch: Boolean; external name 'patternMisMatch';\r\n    FRangeOverflow: Boolean; external name 'rangeOverflow';\r\n    FRangeUnderflow: Boolean; external name 'rangeUnderflow';\r\n    FStepMismatch: Boolean; external name 'stepMismatch';\r\n    FTooLong: Boolean; external name 'tooLong';\r\n    FTooShort: Boolean; external name 'tooShort';\r\n    FTypeMismatch: Boolean; external name 'typeMisMatch';\r\n    FValid: Boolean; external name 'valid';\r\n    FValueMissing: Boolean; external name 'valueMissing';\r\n  public\r\n    property badInput : Boolean read FBadInput;\r\n    property customError : Boolean read FCustomError;\r\n    property patternMisMatch : Boolean read FPatternMismatch;\r\n    property rangeOverflow : Boolean read FRangeOverflow;\r\n    property rangeUnderflow : Boolean read FRangeUnderflow;\r\n    property stepMismatch : Boolean read FStepMismatch;\r\n    property tooLong : Boolean read FTooLong;\r\n    property tooShort : Boolean read FTooShort;\r\n    property typeMisMatch : Boolean read FTypeMismatch;\r\n    property valid : Boolean Read FValid;\r\n    property valueMissing : Boolean read FValueMissing;\r\n  end;\r\n\r\n\r\n  { TJSHTMLFile }\r\n\r\n  TJSHTMLFile = class external name 'File' (TJSBlob)\r\n  private\r\n    FLastModified: NativeInt; external name 'lastModified';\r\n    FLastModifiedDate: TJSDate; external name 'lastModifiedDate';\r\n    FName: string; external name 'name';\r\n  public\r\n    constructor New(ABits: JSValue; AName: string); overload;\r\n    constructor New(ABits: JSValue; AName: string; AOptions: TJSObject); overload;\r\n    property lastModified: NativeInt read FLastModified;\r\n    property lastModifiedDate : TJSDate read FLastModifiedDate; deprecated;\r\n    property name: String read FName;\r\n  end;\r\n\r\n  { TJSHTMLFileList }\r\n\r\n  TJSHTMLFileList = class external name 'FileList' (TJSEventTarget)\r\n  private\r\n    FLength: NativeInt; external name 'length';\r\n  Public\r\n    function item(aIndex : NativeInt) : TJSHTMLFile;\r\n    property length : NativeInt read FLength;\r\n    property Files[aIndex : NativeInt] : TJSHTMLFile Read item; default;\r\n  end;\r\n\r\n   { TJSHTMLInputElement }\r\n  // https://html.spec.whatwg.org/multipage/forms.html#the-input-element\r\n\r\n  TJSHTMLInputElement = class external name 'HTMLInputElement' (TJSHTMLElement)\r\n  private\r\n    FFiles: TJSHTMLFileList; external name 'files';\r\n    FForm: TJSHTMLFormElement; external name 'form';\r\n    FLabels: TJSNodeList; external name 'labels';\r\n    FList: TJSHTMLElement; external name 'list';\r\n    FValidationmMessage: string; external name 'validationMessage';\r\n    FValidity: TJSValidityState; external name 'validity';\r\n    FWillValidate: boolean; external name 'willValidate';\r\n  Public\r\n    procedure select;\r\n    procedure setCustomValidity(aText : string);\r\n    procedure stepUp; overload;\r\n    procedure stepUp(n : Integer); overload;\r\n    function checkValidity : Boolean;\r\n    function reportValidity : Boolean;\r\n    procedure setSelectionRange(selectionStart, selectionEnd: NativeInt) ; overload;\r\n    procedure setSelectionRange(selectionStart, selectionEnd: NativeInt; Direction : string) ; overload;\r\n    procedure setRangeText(aText : string; selectionStart, selectionEnd: NativeInt) ; overload;\r\n    procedure setRangeText(aText : string; selectionStart, selectionEnd: NativeInt; Direction : string) ; overload;\r\n  Public\r\n    accept : string;\r\n    allowDirs : boolean;\r\n    align : string;\r\n    alt : string;\r\n    autofocus : boolean;\r\n    autocapitalize : string;\r\n    autocomplete : string;\r\n    defaultValue : string;\r\n    defaultChecked : string;\r\n    checked : boolean;\r\n    dirName : string;\r\n    disabled : boolean;\r\n    formAction : string;\r\n    formEncType : string;\r\n    formMethod : string;\r\n    formNoValidate : Boolean;\r\n    formTarget : string;\r\n    height : string;\r\n    indeterminate : boolean;\r\n    inputMode : string;\r\n    max : string;\r\n    maxLength : NativeInt;\r\n    min : string;\r\n    minLength : NativeInt;\r\n    multiple : boolean;\r\n    pattern : string;\r\n    placeholder : string;\r\n    readOnly : boolean;\r\n    required : boolean;\r\n    size : NativeInt;\r\n    src : string;\r\n    step : string;\r\n    _type : string; external name 'type';\r\n    selectionStart : NativeInt;\r\n    selectionEnd : NativeInt;\r\n    selectionDirection : string;\r\n    useMap : string;\r\n    value : string;\r\n    width : string;\r\n    property files : TJSHTMLFileList Read FFiles;\r\n    property form : TJSHTMLFormElement read FForm;\r\n    property labels : TJSNodeList read FLabels;\r\n    property list : TJSHTMLElement Read FList;\r\n    property validationMessage : string read FValidationmMessage;\r\n    property willValidate : boolean read FWillValidate;\r\n    property validity : TJSValidityState read FValidity;\r\n  end;\r\n\r\n  TJSDOMSettableTokenList = class external name 'DOMSettableTokenList' (TJSDOMTokenList)\r\n  private\r\n    fvalue: TJSDOMString; external name 'value';\r\n  public\r\n    property value: TJSDOMString read fvalue; // readonly\r\n  end;\r\n\r\n  TJSHTMLOutputElement = class external name 'HTMLOutputElement' (TJSHTMLElement)\r\n  private\r\n    flabels: TJSNodeList; external name 'labels';\r\n    fform: TJSHTMLFormElement; external name 'form';\r\n    ftype: TJSDOMString; external name 'type';\r\n    fdefaultValue: TJSDOMString; external name 'defaultValue';\r\n    fvalue: TJSDOMString; external name 'value';\r\n    fwillValidate: Boolean; external name 'willValidate';\r\n    fvalidity: TJSValidityState; external name 'validity';\r\n    fvalidationMessage: TJSDOMString; external name 'validationMessage';\r\n  public\r\n    htmlFor: TJSDOMSettableTokenList;\r\n    function checkValidity: Boolean;\r\n    function reportValidity: Boolean;\r\n    procedure setCustomValidity(error: TJSDOMString);\r\n  public\r\n    property labels: TJSNodeList read flabels;\r\n    property form: TJSHTMLFormElement read fform;\r\n    property type_: TJSDOMString read ftype;\r\n    property defaultValue: TJSDOMString read fdefaultValue;\r\n    property value: TJSDOMString read fvalue write fvalue;\r\n    property willValidate: Boolean read fwillValidate;\r\n    property validity: TJSValidityState read fvalidity;\r\n    property validationMessage: TJSDOMString read fvalidationMessage;\r\n  end;\r\n\r\n  { TJSHTMLImageElement }\r\n\r\n  TJSHTMLImageElement = class external name 'Image' (TJSHTMLElement)\r\n  Private\r\n    FComplete: boolean; external name 'complete';\r\n    FCurrentSrc: String; external name 'currentSrc';\r\n    FNaturalHeight: NativeUInt; external name 'naturalHeight';\r\n    FNaturalWidth: NativeUInt; external name 'naturalWidth';\r\n    FX: NativeInt; external name 'x';\r\n    FY: NativeInt; external name 'y';\r\n  Public\r\n    constructor New(x,y : Cardinal); overload;\r\n    alt: String;\r\n    crossOrigin: String;\r\n    decoding: String;\r\n    height: NativeUInt;\r\n    isMap: boolean;\r\n    referrerPolicy: String;\r\n    src: String;\r\n    sizes: String;\r\n    srcset: String;\r\n    useMap: String;\r\n    width: NativeUInt;\r\n    function decode : TJSPromise;\r\n    property complete: boolean read FComplete;\r\n    property currentSrc: String read FCurrentSrc;\r\n    property naturalHeight: NativeUInt read FNaturalHeight;\r\n    property naturalWidth: NativeUInt read FNaturalWidth;\r\n    property x: NativeInt read FX;\r\n    property y: NativeInt read FY;\r\n  end;\r\n\r\n  TJSHTMLLinkElement = class external name 'HTMLLinkElement'(TJSHTMLElement)\r\n  Private\r\n    frelList: TJSDOMTokenList; external name 'relList';\r\n    fsizes: TJSDOMSettableTokenList {TJSDOMTokenList}; external name 'sizes';\r\n  Public\r\n    href: string;\r\n    crossOrigin: string;\r\n    rel: string;\r\n    as_: string; external name 'as';\r\n    media: string;\r\n    integrity: string;\r\n    hreflang: string;\r\n    type_: string external name 'type';\r\n    imageSrcset: string;\r\n    imageSizes: string;\r\n    referrerPolicy: string;\r\n    disabled: string;\r\n    charset: string deprecated; // obsolete\r\n    rev: string deprecated; // obsolete property\r\n    target: string deprecated; // obsolete property\r\n    Property relList: TJSDOMTokenList read frelList;\r\n    Property sizes: TJSDOMSettableTokenList{TJSDOMTokenList} read fsizes;\r\n  end;\r\n\r\n  { TJSHTMLAnchorElement }\r\n\r\n  TJSHTMLAnchorElement = class external name 'HTMLAnchorElement' (TJSHTMLElement)\r\n  Private\r\n    FOrigin: string;external name 'origin';\r\n    frelList: TJSDOMTokenList; external name 'relList';\r\n  Public\r\n    href: string;\r\n    download: string;\r\n    hash: string;\r\n    host: string;\r\n    hostname: string;\r\n    hreflang: string;\r\n    media: string ;\r\n    password: string;\r\n    Protocol: string;\r\n    referrerPolicy : string;\r\n    rel: string ;\r\n    rev: string deprecated; // obsolete property\r\n    target: string ;\r\n    text : string;\r\n    type_ : string external name 'type';\r\n    username : string;\r\n    Property relList: TJSDOMTokenList read frelList;\r\n    Property origin: string Read FOrigin;\r\n  end;\r\n\r\n  { TJSHTMLMenuElement }\r\n\r\n  TJSHTMLMenuElement = class external name 'HTMLMenuElement' (TJSHTMLElement) //  uhm... should it be declared? it is experimental at Mozilla docs...\r\n  end;\r\n\r\n  { TJSHTMLButtonElement }\r\n\r\n  TJSHTMLButtonElement = class external name 'HTMLButtonElement' (TJSHTMLElement)\r\n  private\r\n    FForm: TJSHTMLFormElement; external name 'form';\r\n    FLabels: TJSNodeList; external name 'labels';\r\n    FValidationmMessage: String; external name 'validationMessage';\r\n    FValidity: TJSValidityState; external name 'validity';\r\n    FWillValidate: boolean; external name 'willValidate';\r\n  Public\r\n    autofocus : boolean;\r\n    disabled : boolean;\r\n    formAction : String;\r\n    formEnctype : String;\r\n    formMethod : String;\r\n    formNoValidate : Boolean;\r\n    formTarget : String;\r\n    menu: TJSHTMLMenuElement;\r\n    _type : String; external name 'type';\r\n    value : string;\r\n  Public\r\n    property form : TJSHTMLFormElement Read FForm;\r\n    property labels : TJSNodeList Read FLabels;\r\n    property validationMessage : String Read FValidationmMessage;\r\n    property validity : TJSValidityState Read FValidity;\r\n    property willValidate : boolean read FWillValidate;\r\n  end;\r\n\r\n  TJSHTMLLabelElement = class external name 'HTMLLabelElement' (TJSHTMLElement)\r\n  Private\r\n    FForm: TJSHTMLFormElement; external name 'form';\r\n    FControl : TJSHTMLElement; external name 'control';\r\n  Public\r\n    For_ : String; external name 'htmlFor';\r\n    property Control : TJSHTMLElement Read FControl;\r\n    property Form : TJSHTMLFormElement read FForm;\r\n  end;\r\n\r\n  { TJSHTMLTextAreaElement }\r\n\r\n  TJSHTMLTextAreaElement = class external name 'HTMLTextAreaElement' (TJSHTMLElement)\r\n  private\r\n    FForm: TJSHTMLFormElement; external name 'form';\r\n    FTextLength: NativeInt; external name 'textKength';\r\n    FType: String; external name 'type';\r\n    FValidationMessage: String; external name 'validationMessage';\r\n    FValidity: TJSValidityState;  external name 'validity';\r\n    FWillValidate: boolean; external name 'willValidate';\r\n  Public\r\n    defaultValue : string;\r\n    value : string;\r\n    rows : cardinal;\r\n    cols : cardinal;\r\n    autofocus : boolean;\r\n    disabled : boolean;\r\n    maxLength : nativeInt;\r\n    placeholder: String;\r\n    readOnly : Boolean;\r\n    required : Boolean;\r\n    selectionStart : Cardinal;\r\n    selectionEnd : Cardinal;\r\n    selectionDirection : String;\r\n    wrap : string;\r\n    Property Form : TJSHTMLFormElement Read FForm;\r\n    Property Type_: String Read FType;\r\n    Property textLength : NativeInt Read FTextLength;\r\n    Property validity : TJSValidityState Read FValidity;\r\n    property willValidate : boolean read FWillValidate;\r\n    property validationMessage : String Read FValidationMessage;\r\n  end;\r\n\r\n  { TJSHTMLEmbedElement }\r\n\r\n  TJSHTMLEmbedElement = class external name 'HTMLEmbedElement' (TJSHTMLElement)\r\n  Public\r\n    height: String;\r\n    src: String;\r\n    _type : String; external name 'type';\r\n    width: String;\r\n  end;\r\n\r\n  { TJSHTMLOptionElement }\r\n\r\n  TJSHTMLOptionElement = class external name 'Option' (TJSHTMLElement)\r\n  private\r\n    FForm: TJSHTMLFormElement; external name 'form';\r\n    FIndex: NativeInt; external name 'index';\r\n  Public\r\n    Constructor New; overload;\r\n    Constructor New(aText : String); overload;\r\n    Constructor New(aText,aValue : String); overload;\r\n    Constructor New(aText,aValue : String; aDefaultSelected : Boolean); overload;\r\n    Constructor New(aText,aValue : String; aDefaultSelected,Selected : Boolean); overload;\r\n  Public\r\n    defaultSelected : boolean;\r\n    disabled : boolean;\r\n    _label : string ; external name 'label';\r\n    selected : boolean;\r\n    text : string;\r\n    value : string;\r\n    property index : NativeInt Read FIndex;\r\n    property form : TJSHTMLFormElement Read FForm;\r\n  end;\r\n\r\n  TJSHTMLOptGroupElement = class external name 'HTMLOptGroupElement' (TJSHTMLElement)\r\n  end;\r\n\r\n  TJSHTMLOptionsCollection = class external name 'HTMLOptionsCollection' (TJSHTMLCollection)\r\n  end;\r\n\r\n  { TJSHTMLSelectElement }\r\n\r\n  TJSHTMLSelectElement = Class external name 'HTMLSelectElement' (TJSHTMLElement)\r\n  private\r\n    FForm: TJSHTMLFormElement; external name 'form';\r\n    FLabels: TJSNodeList; external name 'labels';\r\n    FLength: NativeInt; external name 'length';\r\n    FOptions: TJSHTMLOptionsCollection; external name 'options';\r\n    FSelectedOptions: TJSHTMLCollection; external name 'selectedOptions';\r\n    FType: String; external name 'type';\r\n    FValidationMessage: string; external name 'validationMessage';\r\n    FValidity: TJSValidityState; external name 'validity';\r\n    fwillValidate: Boolean; external name 'willValidate';\r\n  Public\r\n    Procedure add(anItem : TJSHTMLOptionElement); overload;\r\n    Procedure add(anItem, before : TJSHTMLOptionElement); overload;\r\n    function item(aIndex : NativeInt): TJSHTMLOptionElement;\r\n    function namedItem(aName : String): TJSHTMLOptionElement;\r\n    procedure remove(aIndex : NativeInt); overload;\r\n    procedure checkValidity;\r\n    procedure setCustomValidity(aMessage : String);\r\n  Public\r\n    autofocus : Boolean;\r\n    disabled : Boolean;\r\n    multiple : boolean;\r\n    required: boolean;\r\n    selectedIndex : NativeInt;\r\n    size : NativeInt;\r\n    value : string;\r\n    property length : NativeInt read FLength;\r\n    Property options : TJSHTMLOptionsCollection read FOptions;\r\n    Property selectedOptions : TJSHTMLCollection read FSelectedOptions;\r\n    Property form : TJSHTMLFormElement read FForm;\r\n    property labels : TJSNodeList Read FLabels;\r\n    property _type : String Read FType;\r\n    property validity : TJSValidityState Read FValidity;\r\n    property validationMessage : string Read FValidationMessage;\r\n    property willValidate : Boolean read fwillValidate;\r\n  end;\r\n\r\n  { TJSHTMLTableElement }\r\n\r\n  TJSHTMLTableSectionElement = class;\r\n  TJSHTMLTableRowElement = class;\r\n\r\n  TJSHTMLTableElement = Class external name 'HTMLTableElement'(TJSHTMLElement)\r\n  private\r\n    FAlign: String; external name 'align';\r\n    FBGColor: String; external name 'bgColor';\r\n    FBorder: String; external name 'border';    FCaption: TJSHTMLElement; external name 'caption';\r\n    FCellPadding: String; external name 'cellPadding';\r\n    FCellSpacing: String; external name 'cellSpacing';\r\n    FFrame: String; external name 'frame';\r\n    FRows: TJSHTMLCollection; external name 'rows';\r\n    FRules: String; external name 'rules';\r\n    FSummary: String; external name 'summary';\r\n    FTBodies: TJSHTMLCollection; external name 'tBodies';\r\n    FTfoot: TJSHTMLTableSectionElement; external name 'tfoot';\r\n    FTHead: TJSHTMLTableSectionElement; external name 'tHead';\r\n    FWidth: String; external name 'width';\r\n  public\r\n  { Methods }\r\n    function createCaption: TJSHTMLElement;\r\n    function createTFoot: TJSHTMLTableSectionElement;\r\n    function createTHead: TJSHTMLTableSectionElement;\r\n    procedure deleteCaption;\r\n    procedure deleteRow(index: Integer);\r\n    procedure deleteTFoot;\r\n    procedure deleteTHead;\r\n    function insertRow(index: Integer): TJSHTMLTableRowElement;\r\n  { Properties }\r\n    property align: String read FAlign write FAlign;\r\n    property bgColor: String read FBGColor write FBGColor;\r\n    property border: String read FBorder write FBorder;\r\n    property caption: TJSHTMLElement read FCaption;\r\n    property cellPadding: String read FCellPadding write FCellPadding;\r\n    property cellSpacing: String read FCellSpacing write FCellSpacing;\r\n    property frame: String read FFrame write FFrame;\r\n    property rows: TJSHTMLCollection read FRows;\r\n    property rules: String read FRules write FRules;\r\n    property summary: String read FSummary write FSummary;\r\n    property tBodies: TJSHTMLCollection read FTBodies;\r\n    property tfoot: TJSHTMLTableSectionElement read FTfoot;\r\n    property tHead: TJSHTMLTableSectionElement read FTHead;\r\n    property width: String read FWidth write FWidth;\r\n  end;\r\n\r\n  { TJSHTMLTableSectionElement }\r\n\r\n  TJSHTMLTableSectionElement = Class external name 'HTMLTableSectionElement' (TJSHTMLElement)\r\n  private\r\n    Falign: String; external name 'align';\r\n    Frows: TJSHTMLCollection external name 'rows';\r\n    Fch: String; external name 'ch';\r\n    FchOff: String; external name 'chOff';\r\n    FvAlign: String; external name 'vAlign';\r\n  public\r\n  { Methods }\r\n    procedure deleteRow(index: Integer);\r\n    function insertRow(index: Integer): TJSHTMLTableRowElement;\r\n  { Properties }\r\n    property align: String read Falign write Falign;\r\n    property rows: TJSHTMLCollection read Frows;\r\n    property ch: String read Fch write Fch;\r\n    property chOff: String read FchOff write FchOff;\r\n    property vAlign: String read FvAlign write FvAlign;\r\n  end;\r\n\r\n  { TJSHTMLTableCellElement }\r\n\r\n  TJSHTMLTableCellElement = Class external name 'HTMLTableCellElement' (TJSHTMLElement)\r\n  private\r\n    Fabbr: String; external name 'abbr';\r\n    Falign: String; external name 'align';\r\n    Faxis: String; external name 'axis';\r\n    FbgColor: String; external name 'bgColor';\r\n    FcellIndex: Integer; external name 'cellIndex';\r\n    Fch: String; external name 'ch';\r\n    FchOff: String; external name 'chOff';\r\n    FcolSpan: Integer; external name 'colSpan';\r\n    Fheaders: String; external name 'headers';\r\n    Fheight: String; external name 'height';\r\n    FnoWrap: Boolean; external name 'noWrap';\r\n    FrowSpan: Integer; external name 'rowSpan';\r\n    Fscope: String; external name 'scope';\r\n    FvAlign: String; external name 'vAlign';\r\n    Fwidth: String; external name 'width';\r\n  public\r\n  { Properties }\r\n    property abbr: String read Fabbr write Fabbr;\r\n    property align: String read Falign write Falign;\r\n    property axis: String read Faxis write Faxis;\r\n    property bgColor: String read FbgColor write FbgColor;\r\n    property cellIndex: Integer read FcellIndex;\r\n    property ch: String read Fch write Fch;\r\n    property chOff: String read FchOff write FchOff;\r\n    property colSpan: Integer read FcolSpan write FcolSpan;\r\n    property headers: String read Fheaders;\r\n    property height: String read Fheight write Fheight;\r\n    property noWrap: Boolean read FnoWrap write FnoWrap;\r\n    property rowSpan: Integer read FrowSpan write FrowSpan;\r\n    property scope: String read Fscope write Fscope;\r\n    property vAlign: String read FvAlign write FvAlign;\r\n    property width: String read Fwidth write Fwidth;\r\n  end;\r\n\r\n  { TJSHTMLTableRowElement }\r\n\r\n  TJSHTMLTableRowElement = Class external name 'HTMLTableRowElement' (TJSHTMLElement)\r\n  private\r\n    Falign: String; external name 'align';\r\n    FbgColor: String; external name 'bgColor';\r\n    Fcells: TJSHTMLCollection; external name 'cells';\r\n    Fch: String; external name 'ch';\r\n    FchOff: String; external name 'chOff';\r\n    FrowIndex: Integer; external name 'rowIndex';\r\n    FsectionRowIndex: Integer; external name 'sectionRowIndex';\r\n    FvAlign: String; external name 'vAlign';\r\n  public\r\n  { Methods }\r\n    procedure deleteCell(index: Integer);\r\n    function insertCell(index: Integer): TJSHTMLTableCellElement;\r\n  { Properties }\r\n    property align: String read Falign write Falign;\r\n    property bgColor: String read FbgColor write FbgColor;\r\n    property cells: TJSHTMLCollection read Fcells;\r\n    property ch: String read Fch write Fch;\r\n    property chOff: String read FchOff write FchOff;\r\n    property rowIndex: Integer read FrowIndex;\r\n    property sectionRowIndex: Integer read FsectionRowIndex;\r\n    property vAlign: String read FvAlign write FvAlign;\r\n  end;\r\n\r\n  { TJSHTMLTableDataCellElement }\r\n\r\n  TJSHTMLTableDataCellElement = Class external name 'HTMLTableDataCellElement' (TJSHTMLElement)\r\n  private\r\n    Fabbr: String; external name 'abbr';\r\n  public\r\n  { Properties }\r\n    property abbr: String read Fabbr write Fabbr;\r\n  end;\r\n\r\n\r\n  TJSCanvasRenderingContext2D = Class;\r\n\r\n  THTMLCanvasToBlobCallback = Reference to function (aBlob : TJSBlob) : boolean; safecall;\r\n\r\n  TJSHTMLCanvasElement = Class external name 'HTMLCanvasElement' (TJSHTMLElement)\r\n  Public\r\n    height : integer;\r\n    width : integer;\r\n    Function getContext(contextType : string) : TJSObject;\r\n    Function getContext(contextType : string; contextAttributes : TJSObject) : TJSObject;\r\n    Function getContextAs2DContext(contextType : string; contextAttributes : TJSObject) : TJSCanvasRenderingContext2D; external name 'getContext';\r\n    Function getContextAs2DContext(contextType : string) : TJSCanvasRenderingContext2D; external name 'getContext';\r\n    Procedure toBlob (aCallBack : THTMLCanvasToBlobCallback; aMimeType : String); overload;\r\n    Procedure toBlob (aCallBack : THTMLCanvasToBlobCallback; aMimeType : String; aQuality : Double); overload;\r\n    Function toDataURL : String; overload;\r\n    Function toDataURL(aMimeType : String) : String; overload;\r\n    Function toDataURL(aMimeType : String; aQuality : Double) : String; overload;\r\n  end;\r\n  \r\n\r\n\r\n  TJSHTMLProgressElement = class external name 'HTMLProgressElement' (TJSHTMLElement)\r\n  private\r\n    Fposition: Double; external name 'position';\r\n    Flabels: TJSNodeList; external name 'labels';\r\n  public\r\n    max: Double;\r\n    value: Double;\r\n    property position: Double read Fposition;\r\n    property labels: TJSNodeList read Flabels;\r\n  end;\r\n  Type\r\n\r\n  { TJSDOMException }\r\n\r\n  TJSDOMException = class external name 'DOMException' (TJSObject)\r\n  private\r\n    FCode: Integer; external name 'code';\r\n    FMessage: String; external name 'message';\r\n    FName: string; external name 'name';\r\n  Public\r\n    Property code : Integer Read FCode;\r\n    Property Message : String Read FMessage;\r\n    Property name : string Read FName;\r\n  end;\r\n\r\n  { TJSFileReader }\r\n\r\n  TJSFileReader = class external name 'FileReader' (TJSEventTarget)\r\n  private\r\n    FError: TJSDOMException; external name 'error';\r\n    fReadyState: Integer; external name 'readyState';\r\n    FResult: JSValue; external name 'result';\r\n  Public\r\n    Const EMPTY : Integer;\r\n    Const LOADING : Integer;\r\n    Const DONE : Integer;\r\n  Public\r\n    onabort : TJSEventHandler;\r\n    onerror : TJSEventHandler;\r\n    onload : TJSEventHandler;\r\n    onloadstart : TJSEventHandler;\r\n    onloadend : TJSEventHandler;\r\n    onprogress : TJSEventHandler;\r\n  Public\r\n    constructor new;\r\n    Procedure abort;\r\n    procedure readAsArrayBuffer(Blob: TJSBlob);\r\n    procedure readAsBinaryString(Blob: TJSBlob);\r\n    procedure readAsDataURL(Blob: TJSBlob);\r\n    procedure readAsText(Blob: TJSBlob; encoding : string);\r\n    procedure readAsText(Blob: TJSBlob);\r\n    property Error : TJSDOMException read FError;\r\n    Property readyState : Integer Read fReadyState;\r\n    property Result : JSValue Read FResult;\r\n  end;\r\n\r\n  TCanvasCoordType = double; // Is in fact a number.\r\n\r\n  // Opaque objects\r\n  TJSCanvasGradient = class external name 'CanvasGradient'  (TJSObject)\r\n  end;\r\n\r\n  TJSCanvasPattern = class external name 'CanvasPattern'  (TJSObject)\r\n  end;\r\n\r\n  TJSPath2D = class external name 'Path2D'  (TJSObject)\r\n  Public\r\n    constructor new; overload;\r\n    constructor new(aPath : TJSPath2D); overload;\r\n    constructor new(SVGPath : String); overload;\r\n    Procedure addPath(aPath : TJSPath2D);\r\n    procedure arc(x,y, radius,startAngle,endAngle : TCanvasCoordType); overload;\r\n    procedure arc(x,y, radius,startAngle,endAngle : TCanvasCoordType; antiClockWise : boolean); overload;\r\n    procedure arcTo(x1,y1,x2,y2,radius : TCanvasCoordType); overload;\r\n    procedure bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y : TCanvasCoordType); overload;\r\n    Procedure closePath;\r\n    procedure ellipse(x, y, radiusX, radiusY : TCanvasCoordType; rotation, startAngle, endAngle : Double); overload;\r\n    procedure ellipse(x, y, radiusX, radiusY : TCanvasCoordType; rotation, startAngle, endAngle : Double; anticlockwise : Boolean); overload;\r\n    Procedure lineTo(X,Y : TCanvasCoordType);\r\n    Procedure moveTo(X,Y : TCanvasCoordType);\r\n    procedure quadraticCurveTo(cpx,cpy,x,y : TCanvasCoordType);\r\n    procedure rect(x,y,awidth,aheight: TCanvasCoordType); overload;\r\n  end;\r\n\r\n  { TJSImageData }\r\n\r\n  TJSImageData = class external name 'ImageData'  (TJSObject)\r\n  private\r\n    FData: TJSUint8ClampedArray; external name 'data';\r\n    FHeight: Integer; external name 'height';\r\n    FWidth: Integer; external name 'width';\r\n  Public\r\n    constructor new(awidth,aheight : integer); overload;\r\n    constructor new(anArray :TJSUint8ClampedArray; awidth,aheight : integer); overload;\r\n    property data : TJSUint8ClampedArray read FData;\r\n    property height : Integer Read FHeight;\r\n    property width : Integer Read FWidth;\r\n  end;\r\n\r\n\r\n  TJSTextMetrics = class external name 'TextMetrics' (TJSObject)\r\n    width : TCanvasCoordType;\r\n    actualBoundingBoxLeft : TCanvasCoordType;\r\n    actualBoundingBoxRight : TCanvasCoordType;\r\n    fontBoundingBoxAscent : TCanvasCoordType;\r\n    fontBoundingBoxDescent : TCanvasCoordType;\r\n    actualBoundingBoxAscent : TCanvasCoordType;\r\n    actualBoundingBoxDescent : TCanvasCoordType;\r\n    emHeightAscent : TCanvasCoordType;\r\n    emHeightDescent : TCanvasCoordType;\r\n    hangingBaseline : TCanvasCoordType;\r\n    alphabeticBaseline : TCanvasCoordType;\r\n    ideographicBaseline : TCanvasCoordType;\r\n  end;\r\n\r\n  { TJSCanvasRenderingContext2D }\r\n  TJSCanvasRenderingContext2D = class external name 'CanvasRenderingContext2D'  (TJSObject)\r\n  private\r\n    FCanvas: TJSHTMLCanvasElement; external name 'canvas';\r\n    FfillStyleColor: String; external name 'fillStyle';\r\n    FfillStyleGradient: TJSCanvasGradient; external name 'fillStyle';\r\n    FfillStylePattern: TJSCanvasPattern; external name 'fillStyle';\r\n    FimageSmoothingEnabled: Boolean; external name 'imageSmoothingEnabled';\r\n    FstrokeStyleColor: String; external name 'strokeStyle';\r\n    FstrokeStyleGradient: TJSCanvasGradient; external name 'strokeStyle';\r\n    FstrokeStylePattern: TJSCanvasPattern; external name 'strokeStyle';\r\n  Public\r\n    fillStyle : JSValue;\r\n    font : string;\r\n    globalAlpha : double;\r\n    globalCompositeOperation : String;\r\n    lineCap : string;\r\n    lineDashOffset : Double;\r\n    lineJoin : String;\r\n    lineWidth : Double;\r\n    miterLimit : Double;\r\n    shadowBlur : Double;\r\n    shadowColor : String;\r\n    shadowOffsetX : Double;\r\n    shadowOffsetY : Double;\r\n    strokeStyle : JSValue;\r\n    textAlign : String;\r\n    textBaseline : String;\r\n    procedure arc(x,y, radius,startAngle,endAngle : TCanvasCoordType); overload;\r\n    procedure arc(x,y, radius,startAngle,endAngle : TCanvasCoordType; antiClockWise : boolean); overload;\r\n    procedure arcTo(x1,y1,x2,y2,radius : TCanvasCoordType); overload;\r\n    procedure beginPath;\r\n    procedure bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y : TCanvasCoordType); overload;\r\n    procedure clearRect(x,y,width,height : TCanvasCoordType);\r\n    procedure clip; overload;\r\n    procedure clip(aFillRule : String); overload;\r\n    procedure clip(aPath : TJSPath2D); overload;\r\n    procedure closePath;\r\n    function createImageData(aWidth,aHeight : Integer) : TJSImageData; overload;\r\n    function createImageData(aImage : TJSImageData) : TJSImageData; overload;\r\n    function createLinearGradient(x0,y0,x1,y1 : TCanvasCoordType) : TJSCanvasGradient;\r\n    function createPattern(aImage : TJSObject; repetition : string) : TJSCanvasPattern;\r\n    function createRadialGradient(x0,y0,r0,x1,y1,r1 : TCanvasCoordType) : TJSCanvasGradient;\r\n    procedure drawFocusIfNeeded(aElement : TJSElement); overload;\r\n    procedure drawFocusIfNeeded(aPath : TJSPath2D; aElement : TJSElement); overload;\r\n    procedure drawImage(image : TJSObject; dx,dy : TCanvasCoordType); overload;\r\n    procedure drawImage(image : TJSObject; dx,dy,dwidth,dheight : TCanvasCoordType); overload;\r\n    procedure drawImage(image : TJSObject; sx,sy,sWidth,sHeight,dx,dy,dwidth,dheight : TCanvasCoordType); overload;\r\n    procedure ellipse(x, y, radiusX, radiusY : TCanvasCoordType; rotation, startAngle, endAngle : Double); overload;\r\n    procedure ellipse(x, y, radiusX, radiusY : TCanvasCoordType; rotation, startAngle, endAngle : Double; anticlockwise : Boolean); overload;\r\n    procedure fill; overload;\r\n    procedure fill(aRule : String); overload;\r\n    procedure fill(aPath : TJSPath2D); overload;\r\n    procedure fill(aPath : TJSPath2D;aRule : String); overload;\r\n    procedure fillRect(x,y,awidth,aheight: TCanvasCoordType); overload;\r\n    procedure fillText(aText : string; x,y : TCanvasCoordType); overload;\r\n    procedure fillText(aText : string; x,y, aMaxWidth : TCanvasCoordType); overload;\r\n    function getImageData(x,y,awidth,aheight: TCanvasCoordType) : TJSImageData; overload;\r\n    function getLineDash : TJSArray;\r\n    function isPointInPath(x,y : TCanvasCoordType) : Boolean; overload;\r\n    function isPointInPath(x,y : TCanvasCoordType; aFillRule : String) : Boolean; overload;\r\n    function isPointInPath(aPath : TJSPath2D; x,y : TCanvasCoordType) : Boolean; overload;\r\n    function isPointInPath(aPath : TJSPath2D; x,y : TCanvasCoordType; aFillRule : String) : Boolean; overload;\r\n    function isPointInStroke(x,y : TCanvasCoordType) : Boolean; overload;\r\n    function isPointInStroke(aPath : TJSPath2D; x,y : TCanvasCoordType) : Boolean; overload;\r\n    procedure lineTo(x,y : TCanvasCoordType);\r\n    function measureText(S : String) : TJSTextMetrics;\r\n    procedure moveTo(x,y : TCanvasCoordType);\r\n    procedure putImageData(aData : TJSImageData; x,y: TCanvasCoordType) ; overload;\r\n    procedure putImageData(aData : TJSImageData; x,y,dityX,dirtyY,dirtyWidth,dirtyHeight: TCanvasCoordType) ; overload;\r\n    procedure quadraticCurveTo(cpx,cpy,x,y : TCanvasCoordType);\r\n    procedure rect(x,y,awidth,aheight: TCanvasCoordType); overload;\r\n    procedure restore;\r\n    procedure rotate(anAngle : double);\r\n    procedure save;\r\n    procedure scale(x,y : double);\r\n    procedure setLineDash(segments : TJSArray); overload;\r\n    procedure setLineDash(segments : array of integer); overload;\r\n    procedure setTransform(a,b,c,d,e,f : double);\r\n    procedure stroke; overload;\r\n    procedure stroke(aPath : TJSPath2D); overload;\r\n    procedure strokeRect(x,y,awidth,aheight: TCanvasCoordType);\r\n    procedure strokeText(aText : string; x,y : TCanvasCoordType); overload;\r\n    procedure strokeText(aText : string; x,y, aMaxWidth : TCanvasCoordType); overload;\r\n    procedure transform(a,b,c,d,e,f : double);\r\n    procedure translate(x,y : TCanvasCoordType);\r\n\r\n    property canvas : TJSHTMLCanvasElement Read FCanvas;\r\n    property fillStyleAsColor : String Read FfillStyleColor Write FfillStyleColor;\r\n    property fillStyleAsGradient : TJSCanvasGradient Read FfillStyleGradient Write FfillStyleGradient;\r\n    property fillStyleAsPattern : TJSCanvasPattern Read FfillStylePattern Write FfillStylePattern;\r\n    property imageSmoothingEnabled : Boolean Read FimageSmoothingEnabled Write FimageSmoothingEnabled;\r\n    property strokeStyleAsColor : String Read FstrokeStyleColor Write FstrokeStyleColor;\r\n    property strokeStyleAsGradient : TJSCanvasGradient Read FstrokeStyleGradient Write FstrokeStyleGradient;\r\n    property strokeStyleAsPattern : TJSCanvasPattern Read FstrokeStylePattern Write FstrokeStylePattern;\r\n  end;\r\n  \r\n  TJSImageBitmap = class external name 'ImageBitmap'  (TJSObject)\r\n  public\r\n    procedure    close();\r\n  end;\r\n\r\n  TJSOffscreenCanvasRenderingContext2D = class external name 'CanvasRenderingContext2D'  (TJSCanvasRenderingContext2D)\r\n  private\r\n  Public\r\n     { subclassing TJSCanvasRenderingContext2D just in case some new methods are required}\r\n  end;\r\n\r\n  TJSHTMLOffscreenCanvasElement = Class external name 'OffscreenCanvas' (TJSHTMLCanvasElement)\r\n  Public\r\n    constructor New(x,y : Cardinal); overload;\r\n    { getContextAs2DContext reintroduced here to return the subclassed context }\r\n    Function getContextAs2DContext(contextType : string; contextAttributes : TJSObject) : TJSOffscreenCanvasRenderingContext2D; external name 'getContext'; reintroduce;\r\n    Function getContextAs2DContext(contextType : string) : TJSOffscreenCanvasRenderingContext2D; external name 'getContext'; reintroduce;\r\n    function transferToImageBitmap: TJSImageBitmap;\r\n  end;\r\n  \r\n\r\n  { TJSHTMLIFrameElement }\r\n\r\n  TJSHTMLIFrameElement = Class external name 'HTMLIFrameElement' (TJSHTMLElement)\r\n  private\r\n    FAllowPaymentRequest: Boolean; external name 'allowPaymentRequest';\r\n    FContentDocument: TJSDocument; external name 'contentDocument';\r\n    FContentWindow: TJSWindow; external name 'contentWindow';\r\n    FSandbox: string; external name 'sandbox';\r\n  Public\r\n    height : string;\r\n    src : string;\r\n    srcdoc : string;\r\n    width : string;\r\n    Property allowPaymentRequest : Boolean Read FAllowPaymentRequest;\r\n    property contentWindow : TJSWindow Read FContentWindow;\r\n    property contentDocument : TJSDocument Read FContentDocument;\r\n    property sandbox : string read FSandbox;\r\n  end;\r\n\r\n  TJSHTMLScriptElement = Class external name 'HTMLScriptElement' (TJSHTMLElement)\r\n  Public\r\n    type_ : String external name 'type';\r\n    src : String;\r\n    charset : string;\r\n    integrity : string;\r\n    async : boolean;\r\n    defer : boolean;\r\n    text : string;\r\n    crossOrigin : string;\r\n    referrerPolicy : string;\r\n    noModule : boolean;\r\n  end;\r\n\r\n\r\n\r\n\r\n  TJSXMLHttpRequestEventTarget = class external name 'XMLHttpRequestEventTarget' (TJSEventTarget)\r\n  end;\r\n\r\n  TJSXMLHttpRequestUpload = class external name 'XMLHttpRequestUpload' (TJSXMLHttpRequestEventTarget)\r\n  end;\r\n\r\n  { TJSXMLHttpRequest }\r\n  TJSOnReadyStateChangeHandler = reference to procedure; safecall;\r\n\r\n  TJSXMLHttpRequest = class external name 'XMLHttpRequest' (TJSXMLHttpRequestEventTarget)\r\n  private\r\n    FReadyState: NativeInt; external name 'readyState';\r\n    FResponse: JSValue; external name 'response';\r\n    FResponseText: string; external name 'responseText';\r\n    FResponseType: string; external name 'responseType';\r\n    FresponseURL: string; external name 'responseURL';\r\n    FresponseXML: TJSDocument; external name 'responseXML';\r\n    FUpload: TJSXMLHttpRequestUpload; external name 'upload';\r\n    FStatus : integer; external name 'status';\r\n    FStatusText : string; external name 'statusText';\r\n  public\r\n    const\r\n      UNSENT           = 0;\r\n      OPENED           = 1;\r\n      HEADERS_RECEIVED = 2;\r\n      LOADING          = 3;\r\n      DONE             = 4;\r\n  public\r\n    timeout : LongWord;\r\n    withCredentials : Boolean;\r\n    onreadystatechange : TJSOnReadyStateChangeHandler;\r\n    constructor new;\r\n    procedure abort;\r\n    function getResponseHeader(aName : string) : String;\r\n    function getAllResponseHeaders : String;\r\n    procedure open(aMethod,aURL : String); overload;\r\n    procedure open(aMethod,aURL : String; Async : Boolean); overload;\r\n    procedure open(aMethod,aURL : String; Async : Boolean; AUserame : String); overload;\r\n    procedure open(aMethod,aURL : String; Async : Boolean; AUserame,APassword : String); overload;\r\n    procedure overrideMimeType(aType : String);\r\n    procedure send(aBody : jsValue);overload;\r\n    procedure send;overload;\r\n    procedure setRequestHeader(aName, AValue : string);\r\n\r\n    property readyState : NativeInt read FReadyState;\r\n    property ResponseHeaders[aName : string] : string Read getResponseHeader;\r\n    property responseXML : TJSDocument read FresponseXML;\r\n    property responseURL : string read FresponseURL;\r\n    property responseType : string read FResponseType Write FResponseType;\r\n    property response : JSValue Read FResponse;\r\n    property responseText : string read FResponseText;\r\n    property Status : integer read FStatus;\r\n    property StatusText : string read FStatusText;\r\n    property upload : TJSXMLHttpRequestUpload read FUpload;\r\n\r\n  end;\r\n\r\n  { TJSUIEvent }\r\n\r\n  TJSUIEvent = class external name 'UIEvent' (TJSEvent)\r\n  private\r\n    FDetail: NativeInt; external name 'detail';\r\n    FView: TJSWindow; external name 'view';\r\n  Public\r\n    property detail : NativeInt read FDetail;\r\n    property view : TJSWindow read FView;\r\n  end;\r\n\r\n  { TJSMouseEvent }\r\n\r\n  TJSMouseEvent = class external name 'MouseEvent' (TJSUIEvent)\r\n  private\r\n    FAltKey: Boolean; external name 'altKey';\r\n    FBUtton: NativeInt; external name 'button';\r\n    FBUttons: NativeInt; external name 'buttons';\r\n    FClientX: Double; external name 'clientX';\r\n    FClientY: Double; external name 'clientY';\r\n    FCtrlKey: Boolean; external name 'ctrlKey';\r\n    FMetaKey: Boolean; external name 'metaKey';\r\n    FmovementX: Double; external name 'movementX';\r\n    FmovementY: Double; external name 'movementY';\r\n    FoffsetX: Double; external name 'offsetX';\r\n    FoffsetY: Double; external name 'offsetY';\r\n    FRegion: String; external name 'region';\r\n    FRelatedTarget: TJSEventTarget; external name 'relatedTarget';\r\n    FscreenX: Double; external name 'screenX';\r\n    FscreenY: Double; external name 'screenY';\r\n    FShiftKey: Boolean; external name 'shiftKey';\r\n  Public\r\n    function getModifierState(keyArg: String): boolean;\r\n    Property altKey : Boolean read FAltKey;\r\n    Property button: NativeInt read FBUtton;\r\n    Property buttons: NativeInt read FBUttons;\r\n    property clientX : Double read FClientX;\r\n    property clientY : Double read FClientY;\r\n    property ctrlKey : Boolean read FCtrlKey;\r\n    property metaKey : Boolean read FMetaKey;\r\n    property movementX : Double read FmovementX;\r\n    property movementY : Double read FmovementY;\r\n    property offsetX : Double read FoffsetX;\r\n    property offsetY : Double read FoffsetY;\r\n{$IFDEF FIREFOX}\r\n    property pageX : Double read FpageX;\r\n    property pageY : Double read FpageY;\r\n{$ENDIF}\r\n    property region : String read FRegion;\r\n    property relatedTarget : TJSEventTarget read FRelatedTarget;\r\n    property screenX : Double read FscreenX;\r\n    property screenY : Double read FscreenY;\r\n    property shiftKey : Boolean read FShiftKey;\r\n    property x : Double read FClientX;\r\n    property y : Double read FClientY;\r\n  end;\r\n\r\n  { TJSWheelEvent }\r\n  TJSWheelEventInit = record\r\n    deltaX : Double;\r\n    deltaY : Double;\r\n    deltaZ : Double;\r\n    deltaMode : NativeInt;\r\n  end;\r\n\r\n  TJSWheelEvent = class external name 'WheelEvent' (TJSMouseEvent)\r\n  private\r\n    FDeltaMode: NativeInt; external name 'deltaMode';\r\n    FDeltaX: Double; external name 'deltaX';\r\n    FDeltaY: Double; external name 'deltaY';\r\n    FDeltaZ: Double; external name 'deltaZ';\r\n  Public\r\n    constructor new(atype : String); overload;\r\n    constructor new(atype : String; aInit : TJSWheelEventInit); overload;\r\n    Property deltaX : Double Read FDeltaX;\r\n    Property deltaY : Double Read FDeltaY;\r\n    Property deltaZ : Double Read FDeltaZ;\r\n    Property deltaMode : NativeInt Read FDeltaMode;\r\n  end;\r\n\r\n  TJSPointerEvent = Class external name 'PointerEvent' (TJSMouseEvent);\r\n\r\n  TJSTouchEvent = Class external name 'TouchEvent'(TJSUIEvent)\r\n  private\r\n    FAltKey: Boolean; external name 'altKey';\r\n    FChangedTouches: TJSTouchList; external name 'changedTouches';\r\n    FCtrlKey: Boolean; external name 'ctrlKey';\r\n    FMetaKey: Boolean; external name 'metaKey';\r\n    FShiftKey: Boolean; external name 'shiftKey';\r\n    FTargetTouches: TJSTouchList; external name 'targetTouches';\r\n    FTouches: TJSTouchList; external name 'touches';\r\n  Public\r\n    Property altKey : Boolean Read FAltKey;\r\n    Property ctrlKey : Boolean Read FCtrlKey;\r\n    Property metaKey : Boolean Read FMetaKey;\r\n    Property shiftKey : Boolean Read FShiftKey;\r\n    property changedTouches : TJSTouchList Read FChangedTouches;\r\n    property touches : TJSTouchList Read FTouches;\r\n    property targetTouches : TJSTouchList Read FTargetTouches;\r\n  end;\r\n\r\n\r\n  // Namespace for standard key names.\r\n  // See list at https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n  TJSKeyNames = Class\r\n  Const\r\n    Alt = 'Alt';\r\n    AltGraph = 'AltGraph';\r\n    CapsLock = 'CapsLock';\r\n    Control = 'Control';\r\n    Fn = 'Fn';\r\n    FnLock = 'FnLock';\r\n    Hyper = 'Hyper';\r\n    Meta = 'Meta';\r\n    NumLock = 'NumLock';\r\n    ScrollLock = 'ScrollLock';\r\n    Shift = 'Shift';\r\n    Super = 'Super';\r\n    Symbol = 'Symbol';\r\n    SymbolLock = 'SymbolLock';\r\n    Enter = 'Enter';\r\n    Tab = 'Tab';\r\n    Space = 'Space';\r\n    ArrowDown = 'ArrowDown';\r\n    ArrowLeft = 'ArrowLeft';\r\n    ArrowRight = 'ArrowRight';\r\n    ArrowUp = 'ArrowUp';\r\n    _End = 'End';\r\n    Home = 'Home';\r\n    PageDown = 'PageDown';\r\n    PageUp = 'PageUp';\r\n    BackSpace = 'Backspace';\r\n    Clear = 'Clear';\r\n    Copy = 'Copy';\r\n    CrSel = 'CrSel';\r\n    Cut = 'Cut';\r\n    Delete = 'Delete';\r\n    EraseEof = 'EraseEof';\r\n    ExSel = 'ExSel';\r\n    Insert = 'Insert';\r\n    Paste = 'Paste';\r\n    Redo = 'Redo';\r\n    Undo = 'Undo';\r\n    Accept = 'Accept';\r\n    Again = 'Again';\r\n    Attn = 'Attn';\r\n    Cancel = 'Cancel';\r\n    ContextMenu = 'Contextmenu';\r\n    Escape = 'Escape';\r\n    Execute = 'Execute';\r\n    Find = 'Find';\r\n    Finish = 'Finish';\r\n    Help = 'Help';\r\n    Pause = 'Pause';\r\n    Play = 'Play';\r\n    Props = 'Props';\r\n    Select = 'Select';\r\n    ZoomIn = 'ZoomIn';\r\n    ZoomOut = 'ZoomOut';\r\n    BrightnessDown = 'BrightnessDown';\r\n    BrightnessUp = 'BrightnessUp';\r\n    Eject = 'Eject';\r\n    LogOff = 'LogOff';\r\n    Power = 'Power';\r\n    PowerOff = 'PowerOff';\r\n    PrintScreen = 'PrintScreen';\r\n    Hibernate = 'Hibernate';\r\n    Standby = 'Standby';\r\n    WakeUp = 'WakeUp';\r\n    AllCandidates = 'AllCandidates';\r\n    Alphanumeric =  'Alphanumeric';\r\n    CodeInput = 'CodeInput';\r\n    Compose = 'Compose';\r\n    Convert = 'Convert';\r\n    Dead = 'Dead';\r\n    FinalMode = 'FinalMode';\r\n    GroupFirst = 'GroupFirst';\r\n    GroupLast = 'GroupLast';\r\n    GroupNext = 'GroupNext';\r\n    GroupPrevious = 'GroupPrevious';\r\n    ModelChange = 'ModelChange';\r\n    NextCandidate = 'NextCandidate';\r\n    NonConvert = 'NonConvert';\r\n    PreviousCandidate = 'PreviousCandidate';\r\n    Process = 'Process';\r\n    SingleCandidate = 'SingleCandidate';\r\n    HangulMode = 'HangulMode';\r\n    HanjaMode = 'HanjaMode';\r\n    JunjaMode = 'JunjaMode';\r\n    Eisu = 'Eisu';\r\n    Hankaku = 'Hankaku';\r\n    Hiranga = 'Hiranga';\r\n    HirangaKatakana = 'HirangaKatakana';\r\n    KanaMode = 'KanaMode';\r\n    Katakana = 'Katakana';\r\n    Romaji = 'Romaji';\r\n    Zenkaku = 'Zenkaku';\r\n    ZenkakuHanaku = 'ZenkakuHanaku';\r\n    F1 = 'F1';\r\n    F2 = 'F2';\r\n    F3 = 'F3';\r\n    F4 = 'F4';\r\n    F5 = 'F5';\r\n    F6 = 'F6';\r\n    F7 = 'F7';\r\n    F8 = 'F8';\r\n    F9 = 'F9';\r\n    F10 = 'F10';\r\n    F11 = 'F11';\r\n    F12 = 'F12';\r\n    F13 = 'F13';\r\n    F14 = 'F14';\r\n    F15 = 'F15';\r\n    F16 = 'F16';\r\n    F17 = 'F17';\r\n    F18 = 'F18';\r\n    F19 = 'F19';\r\n    F20 = 'F20';\r\n    Soft1 = 'Soft1';\r\n    Soft2 = 'Soft2';\r\n    Soft3 = 'Soft3';\r\n    Soft4 = 'Soft4';\r\n    Decimal = 'Decimal';\r\n    Key11 = 'Key11';\r\n    Key12 = 'Key12';\r\n    Multiply = 'Multiply';\r\n    Add = 'Add';\r\n    NumClear = 'Clear';\r\n    Divide = 'Divide';\r\n    Subtract = 'Subtract';\r\n    Separator = 'Separator';\r\n    AppSwitch = 'AppSwitch';\r\n    Call = 'Call';\r\n    Camera = 'Camera';\r\n    CameraFocus = 'CameraFocus';\r\n    EndCall = 'EndCall';\r\n    GoBack = 'GoBack';\r\n    GoHome = 'GoHome';\r\n    HeadsetHook = 'HeadsetHook';\r\n    LastNumberRedial = 'LastNumberRedial';\r\n    Notification = 'Notification';\r\n    MannerMode = 'MannerMode';\r\n    VoiceDial = 'VoiceDial';\r\n    // TODO : Multimedia keys\r\n    // TODO : Audio control keys\r\n    // TODO : TV control keys\r\n    // TODO : Media controller keys\r\n    // TODO : Speech recognition keys\r\n    // TODO : Document keys\r\n    // TODO : Application selector keys\r\n    // TODO : Browser Control keys\r\n  end;\r\n\r\n\r\n  { TJSKeyboardEvent }\r\n\r\n  TJSKeyboardEvent = class external name 'KeyboardEvent' (TJSUIEvent)\r\n  private\r\n    FAltKey: Boolean; external name 'altKey';\r\n    FCode: string; external name 'code';\r\n    FCtrlKey: Boolean; external name 'ctrlKey';\r\n    FIsComposing: Boolean;  external name 'isComposing';\r\n    FKey: String; external name 'key';\r\n    FLocale: string; external name 'locale';\r\n    FLocation: NativeInt; external name 'location';\r\n    FMetaKey: Boolean; external name 'metaKey';\r\n    FRepeat: Boolean; external name 'repeat';\r\n    FShiftKey: Boolean; external name 'shiftKey';\r\n  Public\r\n    function getModifierState(aKey : string) : Boolean;\r\n    property code : string read FCode;\r\n    Property altKey : Boolean read FAltKey;\r\n    property ctrlKey : Boolean read FCtrlKey;\r\n    property isComposing : Boolean read FIsComposing;\r\n    property Key : String read FKey;\r\n    property locale : string read FLocale;\r\n    property location : NativeInt read FLocation;\r\n    property metaKey : Boolean read FMetaKey;\r\n    property _repeat : Boolean read FRepeat;\r\n    property shiftKey : Boolean read FShiftKey;\r\n  end;\r\n\r\n  { MutationObserver }\r\n\r\n  TJSMutationObserver = Class;\r\n\r\n  TJSMutationRecord = record\r\n    type_ : string;\r\n    target : TJSNode;\r\n    addedNodes : TJSNodeList;\r\n    removedNodes : TJSNodeList;\r\n    previousSibling : TJSNode;\r\n    nextSibling : TJSNode;\r\n    attributeName : String;\r\n    attributeNamespace : String;\r\n    oldValue : String;\r\n  end;\r\n\r\n  TJSMutationRecordArray = array of TJSMutationRecord;\r\n  TJSMutationCallback = reference to procedure(mutations: TJSMutationRecordArray; observer: TJSMutationObserver); safecall;\r\n\r\n  TJSMutationObserverInit = record\r\n    attributes: boolean;\r\n    attributeOldValue: boolean;\r\n    characterData: boolean;\r\n    characterDataOldValue: boolean;\r\n    childList: boolean;\r\n    subTree: boolean;\r\n    attributeFilter: TJSArray;\r\n  end;\r\n\r\n  TJSMutationObserver = class external name 'MutationObserver' (TJSObject)\r\n  public\r\n    { constructor }\r\n    constructor new(mutationCallback: TJSMutationCallback); overload;\r\n    { public methods }\r\n    procedure observe(target: TJSNode); overload;\r\n    procedure observe(target: TJSNode; options: TJSMutationObserverInit); overload;\r\n    procedure observe(target: TJSNode; options: TJSObject); overload;\r\n    procedure disconnect;\r\n    function takeRecords: TJSMutationRecordArray;\r\n  end;\r\n\r\n\r\n  { --------------------------------------------------------------------\r\n    TJSWebSocket\r\n    --------------------------------------------------------------------}\r\n\r\n\r\n\r\n  TJSWebSocket = class external name 'WebSocket'  (TJSEventTarget)\r\n  Private\r\n    Furl : String; external name 'url';\r\n    FreadyState : Cardinal; external name 'readyState';\r\n    FbufferedAmount : NativeInt; external name 'bufferedAmount';\r\n    Fextensions : String; external name 'extensions';\r\n    Fprotocol : String; external name 'protocol';\r\n  Public\r\n    Const\r\n      CONNECTING = 0;\r\n      OPEN = 1;\r\n      CLOSING = 2;\r\n      CLOSED = 3;\r\n  Public\r\n    onopen : TJSEventHandler;\r\n    onerror : TJSEventHandler;\r\n    onclose : TJSEventHandler;\r\n    onmessage : TJSEventHandler;\r\n    binaryType : String;\r\n    constructor new(url : String); overload;\r\n    constructor new(url : String; protocol: String); overload;\r\n    constructor new(url : String; protocols: array of String); overload;\r\n    Procedure close; overload;\r\n    Procedure close(code : Cardinal); overload;\r\n    Procedure close(code : Cardinal; reason : String); overload;\r\n    Procedure send(data : String);\r\n    Procedure send(data : TJSBlob);\r\n    Procedure send(data : TJSArrayBuffer);\r\n    Procedure send(data : TJSTypedArray);\r\n    Property url : String Read Furl;\r\n    Property readyState : Cardinal Read FreadyState;\r\n    Property bufferedAmount : NativeInt Read FbufferedAmount;\r\n    Property extensions : String Read Fextensions;\r\n    Property protocol : String Read Fprotocol;\r\n  end;\r\n\r\n  TJSHTMLAudioTrack = class external name 'AudioTrack' (TJSObject)\r\n  end;\r\n\r\n  TJSHTMLAudioTrackList = class external name 'AudioTrackList' (TJSObject)\r\n    FLength : Integer; external name 'length';\r\n    function getitem(aIndex : nativeInt) : TJSHTMLAudioTrack ; external name '[]';\r\n  Public\r\n    onaddtrack : TJSEventHandler;\r\n    onchange : TJSEventHandler;\r\n    onremovetrack : TJSEventHandler;\r\n    Property Length : Integer Read FLength;\r\n    Property tracks [aIndex : NativeInt] : TJSHTMLAudioTrack read Getitem;\r\n  end;\r\n\r\n  TJSHTMLVideoTrack = class external name 'VideoTrack' (TJSObject)\r\n  end;\r\n\r\n  TJSHTMLVideoTrackList = class external name 'VideoTrackList' (TJSObject)\r\n    FLength : Integer; external name 'length';\r\n    function getitem(aIndex : nativeInt) : TJSHTMLVideoTrack ; external name '[]';\r\n  Public\r\n    onaddtrack : TJSEventHandler;\r\n    onchange : TJSEventHandler;\r\n    onremovetrack : TJSEventHandler;\r\n    Property Length : Integer Read FLength;\r\n    Property tracks [aIndex : NativeInt] : TJSHTMLVideoTrack read Getitem;\r\n  end;\r\n\r\n  TJSHTMLTextTrack = class external name 'TextTrack' (TJSObject)\r\n  end;\r\n\r\n  TJSHTMLTextTrackList = class external name 'TextTrackList' (TJSObject)\r\n    FLength : Integer; external name 'length';\r\n    function getitem(aIndex : nativeInt) : TJSHTMLTextTrack ; external name '[]';\r\n  Public\r\n    onaddtrack : TJSEventHandler;\r\n    onchange : TJSEventHandler;\r\n    onremovetrack : TJSEventHandler;\r\n    Property Length : Integer Read FLength;\r\n    Property tracks [aIndex : NativeInt] : TJSHTMLTextTrack read Getitem;\r\n  end;\r\n\r\n\r\n  { TJSHTMLMediaElement }\r\n  TJSMEdiaError = class external name 'MediaError' (TJSObject)\r\n    code : NativeInt;\r\n    message : string;\r\n  end;\r\n\r\n  TJSHTMLMediaStream = class external name 'MediaStream' (TJSObject);\r\n\r\n  TJSHTMLMediaController = class external name 'MediaController' (TJSObject);\r\n\r\n  TJSHTMLMediaElement = Class external name 'HTMLMediaElement' (TJSHTMLElement)\r\n  private\r\n    FAudioTracks: TJSHTMLAudioTrackList; external name 'audioTracks';\r\n    FVideoTracks: TJSHTMLVideoTrackList; external name 'videoTracks';\r\n    FTextTracks: TJSHTMLTextTrackList; external name 'textTracks';\r\n    FControlsList: TJSDOMTokenList; external name 'controlslist';\r\n    FCurrentSrc: String; external name 'currentSrc';\r\n    FDuration: Double; external name 'duration';\r\n    FEnded: Boolean;external name 'ended';\r\n    FError: TJSMEdiaError; external name 'error';\r\n    FNetworkState: NativeInt; external name 'networkState';\r\n    FPaused: boolean; external name 'paused';\r\n    FReadyState: NativeInt; external name 'readyState';\r\n    FSeeking: boolean; external name 'seeking';\r\n    FSinkID: string; external name 'sinkId';\r\n  Public\r\n    autoplay : Boolean;\r\n    buffered : Boolean;\r\n    controls : Boolean;\r\n    controller : TJSHTMLMediaController;\r\n    crossOrigin : String;\r\n    currentTime : Double;\r\n    defaultMuted : boolean;\r\n    defaultPlaybackRate : Double;\r\n    disableRemotePlayback : Boolean;\r\n    loop : boolean;\r\n    mediaGroup : string;\r\n    muted : boolean;\r\n    preload : string;\r\n    preservesPitch : boolean;\r\n    src : string;\r\n    srcObject : TJSHTMLMediaStream;\r\n    volume : double;\r\n    onencrypted : TJSEventHandler;\r\n    onwaitingforkey : TJSEventHandler;\r\n    function canPlayType(aType : String) : String;\r\n    Function captureStream : TJSHTMLMediaStream;\r\n    Procedure play;\r\n    Procedure load;\r\n    Procedure pause;\r\n\r\n    Property AudioTracks : TJSHTMLAudioTrackList Read FAudioTracks;\r\n    Property Controlslist : TJSDOMTokenList Read FControlsList;\r\n    Property CurrentSrc : String Read FCurrentSrc;\r\n    Property Duration : Double read FDuration;\r\n    Property Ended : Boolean read FEnded;\r\n    Property Error : TJSMEdiaError read FError;\r\n    property networkState : NativeInt read FNetworkState;\r\n    property paused : boolean read FPaused;\r\n    property readyState : NativeInt read FReadyState;\r\n    property seeking : boolean read FSeeking;\r\n    property sinkID : string read FSinkID;\r\n    Property TextTracks : TJSHTMLTextTrackList Read FTextTracks;\r\n    Property VideoTracks : TJSHTMLVideoTrackList Read FVideoTracks;\r\n  end;\r\n\r\n  TJSHTMLAudioElement = Class external name 'HTMLAudioElement' (TJSHTMLMediaElement)\r\n\r\n  end;\r\n\r\n  TJSHTMLVideoElement = Class external name 'HTMLVideoElement' (TJSHTMLMediaElement)\r\n  end;\r\n\r\n  { TJSHTMLStyleElement }\r\n\r\n  TJSHTMLStyleElement = class external name 'HTMLStyleElement' (TJSHTMLElement)\r\n  private\r\n    FSheet: TJSStyleSheet; external name 'sheet';\r\n  public\r\n    media : string;\r\n    type_ : string; external name 'style';\r\n    disabled : boolean;\r\n    property sheet : TJSStyleSheet read FSheet;\r\n  end;\r\n\r\n\r\n  TJSFormDataEntryValue = String;\r\n  TJSFormDataEntryValueArray = Array of TJSFormDataEntryValue;\r\n\r\n  TJSFormData = Class external name 'FormData' (TJSObject)\r\n    constructor new;\r\n    constructor new(aForm : TJSHTMLElement);\r\n    Procedure append(const aName,aValue : String);\r\n    Procedure append(const aName : String; aBlob : TJSBlob);\r\n    Procedure delete(const aName : String);\r\n    Function entries : TJSFormDataEntryValueArray;\r\n    Function get(const aName : String): TJSFormDataEntryValue;\r\n    function has(const aName : String): Boolean;\r\n    Function keys : TStringDynArray; reintroduce;\r\n    Procedure set_(const aName,aValue : String); external name 'set';\r\n    Procedure set_(const aName : String; aBlob : TJSBlob); external name 'set';\r\n    Function getAll(const aName : String) : TJSFormDataEntryValueArray;\r\n    Function values : TJSValueDynArray; reintroduce;\r\n    Property Entry[const aIndex : String] : TJSFormDataEntryValue read Get;\r\n  end;\r\n\r\n  TJSHTMLTemplateElement = class external name 'HTMLTemplateElement' (TJSHTMLElement)\r\n    content : TJSHTMLElement;\r\n  end;\r\n\r\n    TJSHTMLOrXMLDocument = Class external name 'Document' (TJSDocument)\r\n  end;\r\n\r\n  TJSHTMLDocument = Class external name 'HTMLDocument' (TJSHTMLOrXMLDocument)\r\n  end;\r\n\r\n  TJSXMLDocument = Class external name 'HTMLDocument' (TJSHTMLOrXMLDocument)\r\n  end;\r\n\r\n  TDOMParser = Class external name 'DOMParser' (TJSObject)\r\n  Public\r\n    Function parseFromString (aString,aMimetype : String): TJSHTMLOrXMLDocument;\r\n  end;\r\n\r\n\r\n\r\n  TJSShowOpenFilePickerTypeOptions = class external name 'Object' (TJSObject)\r\n  public\r\n    description: String;\r\n    accept: TJSObject;\r\n  end;\r\n\r\n  TJSShowOpenFilePickerOptions = class external name 'Object' (TJSObject)\r\n  public\r\n    multiple: Boolean;\r\n    excludeAcceptAllOption: Boolean;\r\n    types: array of TJSShowOpenFilePickerTypeOptions;\r\n  end;\r\n\r\n  TJSShowSaveFilePickerOptionsAccept = class external name 'Object' (TJSObject)\r\n  public\r\n    description: String;\r\n    accept: TStringDynArray;\r\n  end;\r\n\r\n  TJSShowSaveFilePickerOptions = class external name 'Object' (TJSObject)\r\n  public\r\n    excludeAcceptAllOption: Boolean;\r\n    accept: array of TJSShowSaveFilePickerOptionsAccept;\r\n  end;\r\n\r\n  TJSXSLTProcessor = class external name 'XSLTProcessor' (TJSObject)\r\n  Public\r\n    procedure importStylesheet(aStyle: TJSNode);\r\n    function transformToFragment(aSource: TJSNode; aOutput: TJSDocument): TJSDocumentFragment;\r\n    function transformToDocument(aSource: TJSNode): TJSDocument;\r\n    procedure setParameter(aNamespaceURI: String; aLocalName: String; aValue: String);\r\n    function getParameter(aNamespaceURI: String; aLocalName: String): String;\r\n    procedure removeParameter(aNamespaceURI: String; aLocalName: String);\r\n    procedure clearParameters;\r\n    procedure reset;\r\n  end;\r\n\r\n  TJSXMLSerializer = class external name 'XMLSerializer' (TJSObject)\r\n  public\r\n    function serializeToString(aRoot: TJSNode): string;\r\n  end;\r\n\r\n\r\nvar\r\n  document : TJSDocument; external name 'document';\r\n  window : TJSWindow; external name 'window';\r\n  console : TJSConsole; external name 'window.console';\r\n  caches : TJSCacheStorage; external name 'caches';\r\n  serviceWorker : TJSServiceWorker; external name 'window.navigator.serviceWorker';\r\n\r\nFunction HasServiceWorker : Boolean;\r\n\r\nimplementation\r\n\r\nFunction HasServiceWorker : Boolean;\r\nbegin\r\n  if jsvalue(window.navigator.serviceWorker) then\r\n    exit(true)\r\n  else\r\n    exit(false);\r\nend;\r\n\r\n{ TJSEventHelper }\r\n\r\nfunction TJSEventHelper.GetCurrentTargetElement: TJSElement;\r\nbegin\r\n  Result:=TJSElement(CurrentTarget);\r\nend;\r\n\r\nfunction TJSEventHelper.GetCurrentTargetHTMLElement: TJSHTMLElement;\r\nbegin\r\n  Result:=TJSHTMLElement(CurrentTarget);\r\nend;\r\n\r\nfunction TJSEventHelper.GetTargetElement: TJSElement;\r\nbegin\r\n  Result:=TJSElement(Target);\r\nend;\r\n\r\nfunction TJSEventHelper.GetTargetHTMLElement: TJSHTMLElement;\r\nbegin\r\n  Result:=TJSHTMLElement(Target);\r\nend;\r\n\r\nend.","{\r\n    This file is part of the Free Pascal run time library.\r\n    Copyright (c) 2003 by the Free Pascal development team\r\n\r\n    CustomApplication class.\r\n\r\n    Port to pas2js by Mattias Gaertner mattias@freepascal.org\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n{$IFNDEF FPC_DOTTEDUNITS} \r\nunit CustApp;\r\n{$ENDIF}\r\n\r\n{$mode objfpc}\r\n\r\ninterface\r\n\r\nuses\r\n{$IFDEF FPC_DOTTEDUNITS} \r\n  System.Classes, System.SysUtils, System.Types, JSApi.JS;\r\n{$ELSE}\r\n  Classes, SysUtils, Types, JS;\r\n{$ENDIF}\r\n\r\nConst\r\n  SErrInvalidOption: String = 'Invalid option at position %s: \"%s\"';\r\n  SErrNoOptionAllowed: String = 'Option at position %s does not allow an argument: %s';\r\n  SErrOptionNeeded: String = 'Option at position %s needs an argument : %s';\r\n\r\nType\r\n  TExceptionEvent = procedure (Sender : TObject; E : Exception) of object;\r\n  TEventLogTypes = set of TEventType;\r\n\r\n  { TCustomApplication }\r\n\r\n  TCustomApplication = Class(TComponent)\r\n  Private\r\n    FEventLogFilter: TEventLogTypes;\r\n    FExceptObjectJS: JSValue;\r\n    FOnException: TExceptionEvent;\r\n    FTerminated: Boolean;\r\n    FTitle: String;\r\n    FOptionChar: Char;\r\n    FCaseSensitiveOptions: Boolean;\r\n    FStopOnException: Boolean;\r\n    FExceptionExitCode: Integer;\r\n    FExceptObject: Exception;\r\n  Protected\r\n    function GetEnvironmentVar(VarName: String): String; virtual;\r\n    function GetExeName: string; virtual;\r\n    function GetLocation: String; virtual; abstract;\r\n    function GetOptionAtIndex(AIndex: Integer; IsLong: Boolean): String;\r\n    procedure SetTitle(const AValue: string); virtual;\r\n    function GetConsoleApplication: boolean; virtual; abstract;\r\n    procedure DoRun; virtual; abstract;\r\n    function GetParams(Index: Integer): String; virtual;\r\n    function GetParamCount: Integer; virtual;\r\n    procedure DoLog(EventType: TEventType; const Msg: String); virtual;\r\n  Public\r\n    constructor Create(AOwner: TComponent); override;\r\n    // Some Delphi methods.\r\n    procedure HandleException(Sender: TObject); virtual;\r\n    procedure Initialize; virtual;\r\n    procedure Run;\r\n    procedure ShowException(E: Exception); virtual; abstract;\r\n    procedure Terminate; virtual;\r\n    procedure Terminate(AExitCode: Integer); virtual;\r\n    // Extra methods.\r\n    function FindOptionIndex(Const S: String; var Longopt: Boolean; StartAt: Integer = -1): Integer;\r\n    function GetOptionValue(Const S: String): String;\r\n    function GetOptionValue(Const C: Char; Const S: String): String;\r\n    function GetOptionValues(Const C: Char; Const S: String): TStringDynArray;\r\n    function HasOption(Const S: String) : Boolean;\r\n    function HasOption(Const C: Char; Const S: String): Boolean;\r\n    function CheckOptions(Const ShortOptions: String; Const Longopts: TStrings;\r\n      Opts,NonOpts: TStrings; AllErrors: Boolean = False): String;\r\n    function CheckOptions(Const ShortOptions: String; Const Longopts: Array of string;\r\n      Opts,NonOpts: TStrings; AllErrors: Boolean = False): String;\r\n    function CheckOptions(Const ShortOptions: String; Const Longopts: TStrings;\r\n      AllErrors: Boolean = False): String;\r\n    function CheckOptions(Const ShortOptions: String; Const LongOpts: Array of string;\r\n      AllErrors: Boolean = False): String;\r\n    function CheckOptions(Const ShortOptions: String; Const LongOpts: String;\r\n      AllErrors: Boolean = False): String;\r\n    function GetNonOptions(Const ShortOptions: String; Const Longopts: Array of string): TStringDynArray;\r\n    procedure GetNonOptions(Const ShortOptions: String; Const Longopts: Array of string;\r\n      NonOptions: TStrings);\r\n    procedure GetEnvironmentList(List: TStrings; NamesOnly: Boolean); virtual; abstract;\r\n    procedure GetEnvironmentList(List: TStrings); virtual;\r\n    procedure Log(EventType: TEventType; const Msg: String);\r\n    procedure Log(EventType: TEventType; const Fmt: String; const Args: Array of const);\r\n    // Delphi properties\r\n    property ExeName: string read GetExeName;\r\n    property Terminated: Boolean read FTerminated;\r\n    property Title: string read FTitle write SetTitle;\r\n    property OnException: TExceptionEvent read FOnException write FOnException;\r\n    // Extra properties\r\n    property ConsoleApplication: Boolean Read GetConsoleApplication;\r\n    property Location: String Read GetLocation;\r\n    property Params[Index: integer]: String Read GetParams;\r\n    property ParamCount: Integer Read GetParamCount;\r\n    property EnvironmentVariable[EnvName: String]: String Read GetEnvironmentVar;\r\n    property OptionChar: Char Read FoptionChar Write FOptionChar;\r\n    property CaseSensitiveOptions: Boolean Read FCaseSensitiveOptions Write FCaseSensitiveOptions;\r\n    property StopOnException: Boolean Read FStopOnException Write FStopOnException;\r\n    property ExceptionExitCode: Longint Read FExceptionExitCode Write FExceptionExitCode;\r\n    property ExceptObject: Exception read FExceptObject write FExceptObject;\r\n    property ExceptObjectJS: JSValue read FExceptObjectJS write FExceptObjectJS;\r\n    property EventLogFilter: TEventLogTypes Read FEventLogFilter Write FEventLogFilter;\r\n  end;\r\n\r\nvar CustomApplication: TCustomApplication = nil;\r\n\r\nimplementation\r\n\r\n{ TCustomApplication }\r\n\r\nfunction TCustomApplication.GetEnvironmentVar(VarName: String): String;\r\nbegin\r\n  Result:=GetEnvironmentVariable(VarName);\r\nend;\r\n\r\nfunction TCustomApplication.GetExeName: string;\r\nbegin\r\n  Result:=ParamStr(0);\r\nend;\r\n\r\nfunction TCustomApplication.GetOptionAtIndex(AIndex: Integer; IsLong: Boolean\r\n  ): String;\r\n\r\nVar\r\n  P : Integer;\r\n  O : String;\r\n\r\nbegin\r\n  Result:='';\r\n  If AIndex=-1 then\r\n    Exit;\r\n  If IsLong then\r\n    begin // Long options have form --option=value\r\n    O:=Params[AIndex];\r\n    P:=Pos('=',O);\r\n    If P=0 then\r\n      P:=Length(O);\r\n    Delete(O,1,P);\r\n    Result:=O;\r\n    end\r\n  else\r\n    begin // short options have form '-o value'\r\n    If AIndex<ParamCount then\r\n      if Copy(Params[AIndex+1],1,1)<>'-' then\r\n        Result:=Params[AIndex+1];\r\n    end;\r\nend;\r\n\r\nprocedure TCustomApplication.SetTitle(const AValue: string);\r\nbegin\r\n  FTitle:=AValue;\r\nend;\r\n\r\nfunction TCustomApplication.GetParams(Index: Integer): String;\r\nbegin\r\n  Result:=ParamStr(Index);\r\nend;\r\n\r\nfunction TCustomApplication.GetParamCount: Integer;\r\nbegin\r\n  Result:=System.ParamCount;\r\nend;\r\n\r\nprocedure TCustomApplication.DoLog(EventType: TEventType; const Msg: String);\r\nbegin\r\n  // Do nothing, override in descendants\r\n  if EventType=etCustom then ;\r\n  if Msg='' then ;\r\nend;\r\n\r\nconstructor TCustomApplication.Create(AOwner: TComponent);\r\nbegin\r\n  inherited Create(AOwner);\r\n  FOptionChar:='-';\r\n  FCaseSensitiveOptions:=True;\r\n  FStopOnException:=False;\r\nend;\r\n\r\nprocedure TCustomApplication.HandleException(Sender: TObject);\r\n\r\nVar\r\n  E : Exception;\r\n  Tmp : Exception;\r\n\r\nbegin\r\n  Tmp:=Nil;\r\n  E:=ExceptObject;\r\n  if (E=Nil) and Assigned(ExceptObjectJS) then\r\n    begin\r\n    if (ExceptObjectJS is TJSError) then\r\n      Tmp:=EExternalException.Create(TJSError(ExceptObjectJS).Message)\r\n    else if (ExceptObjectJS is TJSObject) and TJSObject(ExceptObjectJS).hasOwnProperty('message') then\r\n      Tmp:=EExternalException.Create(String(TJSObject(ExceptObjectJS)['message']))\r\n    else\r\n      Tmp:=EExternalException.Create(TJSJSON.stringify(ExceptObjectJS));\r\n    E:=Tmp;\r\n    end;\r\n  try\r\n    ShowException(E);\r\n    if FStopOnException then\r\n      Terminate(ExceptionExitCode);\r\n  finally\r\n    Tmp.Free;\r\n  end;\r\n  if Sender=nil then ;\r\nend;\r\n\r\nprocedure TCustomApplication.Initialize;\r\nbegin\r\n  FTerminated:=False;\r\nend;\r\n\r\nprocedure TCustomApplication.Run;\r\nbegin\r\n  Repeat\r\n    ExceptObject:=nil;\r\n    ExceptObjectJS:=nil;\r\n    Try\r\n      DoRun;\r\n    except\r\n      on E: Exception do\r\n      begin\r\n        ExceptObject:=E;\r\n        ExceptObjectJS:=E;\r\n        HandleException(Self);\r\n      end\r\n      else begin\r\n        ExceptObject:=nil;\r\n        ExceptObjectJS := {$IFDEF FPC_DOTTEDUNITS}JSApi.{$ENDIF}JS.JSExceptValue;\r\n        HandleException(Self);\r\n      end;\r\n    end;\r\n    break;\r\n  Until FTerminated;\r\nend;\r\n\r\nprocedure TCustomApplication.Terminate;\r\nbegin\r\n  Terminate(ExitCode);\r\nend;\r\n\r\nprocedure TCustomApplication.Terminate(AExitCode: Integer);\r\nbegin\r\n  FTerminated:=True;\r\n  ExitCode:=AExitCode;\r\nend;\r\n\r\nfunction TCustomApplication.FindOptionIndex(const S: String;\r\n  var Longopt: Boolean; StartAt: Integer): Integer;\r\n\r\nVar\r\n  SO,O : String;\r\n  I,P : Integer;\r\n\r\nbegin\r\n  If Not CaseSensitiveOptions then\r\n    SO:=UpperCase(S)\r\n  else\r\n    SO:=S;\r\n  Result:=-1;\r\n  I:=StartAt;\r\n  if I=-1 then\r\n    I:=ParamCount;\r\n  While (Result=-1) and (I>0) do\r\n    begin\r\n    O:=Params[i];\r\n    // - must be seen as an option value\r\n    If (Length(O)>1) and (O[1]=FOptionChar) then\r\n      begin\r\n      Delete(O,1,1);\r\n      LongOpt:=(Length(O)>0) and (O[1]=FOptionChar);\r\n      If LongOpt then\r\n        begin\r\n        Delete(O,1,1);\r\n        P:=Pos('=',O);\r\n        If (P<>0) then\r\n          O:=Copy(O,1,P-1);\r\n        end;\r\n      If Not CaseSensitiveOptions then\r\n        O:=UpperCase(O);\r\n      If (O=SO) then\r\n        Result:=i;\r\n      end;\r\n    Dec(i);\r\n    end;\r\nend;\r\n\r\nfunction TCustomApplication.GetOptionValue(const S: String): String;\r\nbegin\r\n  Result:=GetOptionValue(' ',S);\r\nend;\r\n\r\nfunction TCustomApplication.GetOptionValue(const C: Char; const S: String\r\n  ): String;\r\n\r\nVar\r\n  B : Boolean;\r\n  I : integer;\r\n\r\nbegin\r\n  Result:='';\r\n  I:=FindOptionIndex(C,B);\r\n  If I=-1 then\r\n    I:=FindOptionIndex(S,B);\r\n  If I<>-1 then\r\n    Result:=GetOptionAtIndex(I,B);\r\nend;\r\n\r\nfunction TCustomApplication.GetOptionValues(const C: Char; const S: String\r\n  ): TStringDynArray;\r\n\r\nVar\r\n  I,Cnt : Integer;\r\n  B : Boolean;\r\n\r\nbegin\r\n  SetLength(Result,ParamCount);\r\n  Cnt:=0;\r\n  Repeat\r\n    I:=FindOptionIndex(C,B,I);\r\n    If I<>-1 then\r\n      begin\r\n      Inc(Cnt);\r\n      Dec(I);\r\n      end;\r\n  Until I=-1;\r\n  Repeat\r\n    I:=FindOptionIndex(S,B,I);\r\n    If I<>-1 then\r\n      begin\r\n      Inc(Cnt);\r\n      Dec(I);\r\n      end;\r\n  Until I=-1;\r\n  SetLength(Result,Cnt);\r\n  Cnt:=0;\r\n  I:=-1;\r\n  Repeat\r\n    I:=FindOptionIndex(C,B,I);\r\n    If (I<>-1) then\r\n      begin\r\n      Result[Cnt]:=GetOptionAtIndex(I,False);\r\n      Inc(Cnt);\r\n      Dec(i);\r\n      end;\r\n  Until (I=-1);\r\n  I:=-1;\r\n  Repeat\r\n    I:=FindOptionIndex(S,B,I);\r\n    If I<>-1 then\r\n      begin\r\n      Result[Cnt]:=GetOptionAtIndex(I,True);\r\n      Inc(Cnt);\r\n      Dec(i);\r\n      end;\r\n  Until (I=-1);\r\nend;\r\n\r\nfunction TCustomApplication.HasOption(const S: String): Boolean;\r\n\r\nVar\r\n  B : Boolean;\r\n\r\nbegin\r\n  Result:=FindOptionIndex(S,B)<>-1;\r\nend;\r\n\r\nfunction TCustomApplication.HasOption(const C: Char; const S: String): Boolean;\r\n\r\nVar\r\n  B : Boolean;\r\n\r\nbegin\r\n  Result:=(FindOptionIndex(C,B)<>-1) or (FindOptionIndex(S,B)<>-1);\r\nend;\r\n\r\nfunction TCustomApplication.CheckOptions(const ShortOptions: String;\r\n  const Longopts: TStrings; Opts, NonOpts: TStrings; AllErrors: Boolean\r\n  ): String;\r\n\r\nVar\r\n  I,J,L,P : Integer;\r\n  O,OV,SO : String;\r\n  UsedArg,HaveArg : Boolean;\r\n\r\n  Function FindLongOpt(S : String) : boolean;\r\n\r\n  Var\r\n    I : integer;\r\n\r\n  begin\r\n    Result:=Assigned(LongOpts);\r\n    if Not Result then\r\n      exit;\r\n    If CaseSensitiveOptions then\r\n      begin\r\n      I:=LongOpts.Count-1;\r\n      While (I>=0) and (LongOpts[i]<>S) do\r\n        Dec(i);\r\n      end\r\n    else\r\n      begin\r\n      S:=UpperCase(S);\r\n      I:=LongOpts.Count-1;\r\n      While (I>=0) and (UpperCase(LongOpts[i])<>S) do\r\n        Dec(i);\r\n      end;\r\n    Result:=(I<>-1);\r\n  end;\r\n\r\n  Procedure AddToResult(Const Msg : string);\r\n\r\n  begin\r\n    If (Result<>'') then\r\n      Result:=Result+sLineBreak;\r\n    Result:=Result+Msg;\r\n  end;\r\n\r\nbegin\r\n  If CaseSensitiveOptions then\r\n    SO:=Shortoptions\r\n  else\r\n    SO:=LowerCase(Shortoptions);\r\n  Result:='';\r\n  I:=1;\r\n  While (I<=ParamCount) and ((Result='') or AllErrors) do\r\n    begin\r\n    O:=Paramstr(I);\r\n    If (Length(O)=0) or (O[1]<>FOptionChar) then\r\n      begin\r\n      If Assigned(NonOpts) then\r\n        NonOpts.Add(O);\r\n      end\r\n    else\r\n      begin\r\n      If (Length(O)<2) then\r\n        AddToResult(Format(SErrInvalidOption,[IntToStr(I),O]))\r\n      else\r\n        begin\r\n        HaveArg:=False;\r\n        OV:='';\r\n        // Long option ?\r\n        If (O[2]=FOptionChar) then\r\n          begin\r\n          Delete(O,1,2);\r\n          J:=Pos('=',O);\r\n          If J<>0 then\r\n            begin\r\n            HaveArg:=true;\r\n            OV:=O;\r\n            Delete(OV,1,J);\r\n            O:=Copy(O,1,J-1);\r\n            end;\r\n          // Switch Option\r\n          If FindLongopt(O) then\r\n            begin\r\n            If HaveArg then\r\n              AddToResult(Format(SErrNoOptionAllowed,[IntToStr(I),O]));\r\n            end\r\n          else\r\n            begin // Required argument\r\n            If FindLongOpt(O+':') then\r\n              begin\r\n              If Not HaveArg then\r\n                AddToResult(Format(SErrOptionNeeded,[IntToStr(I),O]));\r\n              end\r\n            else\r\n              begin // Optional Argument.\r\n              If not FindLongOpt(O+'::') then\r\n                AddToResult(Format(SErrInvalidOption,[IntToStr(I),O]));\r\n              end;\r\n            end;\r\n          end\r\n        else // Short Option.\r\n          begin\r\n          HaveArg:=(I<ParamCount) and (Length(ParamStr(I+1))>0) and (ParamStr(I+1)[1]<>FOptionChar);\r\n          UsedArg:=False;\r\n          If Not CaseSensitiveOptions then\r\n            O:=LowerCase(O);\r\n          L:=Length(O);\r\n          J:=2;\r\n          While ((Result='') or AllErrors) and (J<=L) do\r\n            begin\r\n            P:=Pos(O[J],SO);\r\n            If (P=0) or (O[j]=':') then\r\n              AddToResult(Format(SErrInvalidOption,[IntToStr(I),O[J]]))\r\n            else\r\n              begin\r\n              If (P<Length(SO)) and (SO[P+1]=':') then\r\n                begin\r\n                // Required argument\r\n                If ((P+1)=Length(SO)) or (SO[P+2]<>':') Then\r\n                  If (J<L) or not haveArg then // Must be last in multi-opt !!\r\n                    begin\r\n                    AddToResult(Format(SErrOptionNeeded,[IntToStr(I),O[J]]));\r\n                    end;\r\n                O:=O[j]; // O is added to arguments.\r\n                UsedArg:=True;\r\n                end;\r\n              end;\r\n            Inc(J);\r\n            end;\r\n          HaveArg:=HaveArg and UsedArg;\r\n          If HaveArg then\r\n            begin\r\n            Inc(I); // Skip argument.\r\n            OV:=Paramstr(I);\r\n            end;\r\n          end;\r\n        If HaveArg and ((Result='') or AllErrors) then\r\n          If Assigned(Opts) then\r\n            Opts.Add(O+'='+OV);\r\n        end;\r\n      end;\r\n    Inc(I);\r\n    end;\r\nend;\r\n\r\nfunction TCustomApplication.CheckOptions(const ShortOptions: String;\r\n  const Longopts: array of string; Opts, NonOpts: TStrings; AllErrors: Boolean\r\n  ): String;\r\nVar\r\n  L : TStringList;\r\n  I : Integer;\r\nbegin\r\n  L:=TStringList.Create;\r\n  try\r\n    For I:=0 to High(LongOpts) do\r\n      L.Add(LongOpts[i]);\r\n    Result:=CheckOptions(ShortOptions,L,Opts,NonOpts,AllErrors);\r\n  finally\r\n    L.Destroy;\r\n  end;\r\nend;\r\n\r\nfunction TCustomApplication.CheckOptions(const ShortOptions: String;\r\n  const Longopts: TStrings; AllErrors: Boolean): String;\r\nbegin\r\n  Result:=CheckOptions(ShortOptions,LongOpts,Nil,Nil,AllErrors);\r\nend;\r\n\r\nfunction TCustomApplication.CheckOptions(const ShortOptions: String;\r\n  const LongOpts: array of string; AllErrors: Boolean): String;\r\n\r\nVar\r\n  L : TStringList;\r\n  I : Integer;\r\n\r\nbegin\r\n  L:=TStringList.Create;\r\n  Try\r\n    For I:=0 to High(LongOpts) do\r\n      L.Add(LongOpts[i]);\r\n    Result:=CheckOptions(ShortOptions,L,AllErrors);\r\n  Finally\r\n    L.Destroy;\r\n  end;\r\nend;\r\n\r\nfunction TCustomApplication.CheckOptions(const ShortOptions: String;\r\n  const LongOpts: String; AllErrors: Boolean): String;\r\n\r\nConst\r\n  SepChars = ' '#10#13#9;\r\n\r\nVar\r\n  L : TStringList;\r\n  Len,I,J : Integer;\r\n\r\nbegin\r\n  L:=TStringList.Create;\r\n  Try\r\n    I:=1;\r\n    Len:=Length(LongOpts);\r\n    While I<=Len do\r\n      begin\r\n      While Isdelimiter(SepChars,LongOpts,I) do\r\n        Inc(I);\r\n      J:=I;\r\n      While (J<=Len) and Not IsDelimiter(SepChars,LongOpts,J) do\r\n        Inc(J);\r\n      If (I<=J) then\r\n        L.Add(Copy(LongOpts,I,(J-I)));\r\n      I:=J+1;\r\n      end;\r\n    Result:=CheckOptions(Shortoptions,L,AllErrors);\r\n  Finally\r\n    L.Destroy;\r\n  end;\r\nend;\r\n\r\nfunction TCustomApplication.GetNonOptions(const ShortOptions: String;\r\n  const Longopts: array of string): TStringDynArray;\r\n\r\nVar\r\n  NO : TStrings;\r\n  I : Integer;\r\n\r\nbegin\r\n  No:=TStringList.Create;\r\n  try\r\n    GetNonOptions(ShortOptions,LongOpts,No);\r\n    SetLength(Result,NO.Count);\r\n    For I:=0 to NO.Count-1 do\r\n      Result[I]:=NO[i];\r\n  finally\r\n    NO.Destroy;\r\n  end;\r\nend;\r\n\r\nprocedure TCustomApplication.GetNonOptions(const ShortOptions: String;\r\n  const Longopts: array of string; NonOptions: TStrings);\r\n\r\nVar\r\n  S : String;\r\n\r\nbegin\r\n  S:=CheckOptions(ShortOptions,LongOpts,Nil,NonOptions,true);\r\n  if (S<>'') then\r\n    Raise EListError.Create(S);\r\nend;\r\n\r\nprocedure TCustomApplication.GetEnvironmentList(List: TStrings);\r\nbegin\r\n  GetEnvironmentList(List,False);\r\nend;\r\n\r\nprocedure TCustomApplication.Log(EventType: TEventType; const Msg: String);\r\nbegin\r\n  If (FEventLogFilter=[]) or (EventType in FEventLogFilter) then\r\n    DoLog(EventType,Msg);\r\nend;\r\n\r\nprocedure TCustomApplication.Log(EventType: TEventType; const Fmt: String;\r\n  const Args: array of const);\r\nbegin\r\n  try\r\n    Log(EventType, Format(Fmt, Args));\r\n  except\r\n    On E: Exception do\r\n      Log(etError,Format('Error formatting message \"%s\" with %d arguments: %s',\r\n        [Fmt,IntToStr(Length(Args)),E.Message]));\r\n  end\r\nend;\r\n\r\nend.\r\n\r\n","{\r\n    This file is part of the Free Pascal run time library.\r\n    Copyright (c) 2003 by the Free Pascal development team\r\n\r\n    Pascal code generator class.\r\n\r\n    Port to pas2js by Mattias Gaertner mattias@freepascal.org\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n{$IFNDEF FPC_DOTTEDUNITS} \r\nunit BrowserApp;\r\n{$ENDIF}\r\n\r\n{$mode objfpc}\r\n\r\ninterface\r\n\r\nuses\r\n{$IFDEF FPC_DOTTEDUNITS} \r\n  System.Classes, System.SysUtils, System.Types, JSApi.JS, BrowserApi.Web, Fcl.CustApp;\r\n{$ELSE}\r\n  Classes, SysUtils, Types, JS, web, CustApp;\r\n{$ENDIF}\r\n\r\ntype\r\n  TServiceWorkerRegisteredEvent = reference to procedure(Registration: TJSServiceWorkerRegistration);\r\n\r\n  { TBrowserApplication }\r\n\r\n  TBrowserApplication = class(TCustomApplication)\r\n  private\r\n    FShowExceptions: Boolean;\r\n  protected\r\n    function GetHTMLElement(aID : String) : TJSHTMLElement;\r\n    function CreateHTMLElement(aTag : String; aID : String = '') : TJSHTMLElement;\r\n    procedure DoRun; override;\r\n    function GetConsoleApplication: boolean; override;\r\n    Function LogGetElementErrors : Boolean; virtual;\r\n    function GetLocation: String; override;\r\n  public\r\n    Constructor Create(aOwner: TComponent); override;\r\n    Destructor destroy; override;\r\n    procedure GetEnvironmentList(List: TStrings; NamesOnly: Boolean); override;\r\n    procedure ShowException(E: Exception); override;\r\n    procedure HandleException(Sender: TObject); override;\r\n    function RegisterServiceWorker(aFile: String;\r\n      const aOnRegistered: TServiceWorkerRegisteredEvent = Nil; DoLogging: Boolean = false) : Boolean;\r\n    Property ShowExceptions : Boolean Read FShowExceptions Write FShowExceptions;\r\n  end;\r\n\r\nprocedure ReloadEnvironmentStrings;\r\n\r\nimplementation\r\n\r\nvar\r\n  EnvNames: TJSObject;\r\n  Params : TStringDynArray;\r\n  AppInstance : TBrowserApplication;\r\n\r\nprocedure ReloadEnvironmentStrings;\r\n\r\nvar\r\n  I : Integer;\r\n  S,N : String;\r\n  A,P : TStringDynArray;\r\nbegin\r\n  if Assigned(EnvNames) then\r\n    FreeAndNil(EnvNames);\r\n  EnvNames:=TJSObject.new;\r\n  S:=Window.Location.search;\r\n  S:=Copy(S,2,Length(S)-1);\r\n  A:=TJSString(S).split('&');\r\n  for I:=0 to Length(A)-1 do\r\n    begin\r\n    P:=TJSString(A[i]).split('=');\r\n    N:=LowerCase(decodeURIComponent(P[0]));\r\n    if Length(P)=2 then\r\n      EnvNames[N]:=decodeURIComponent(P[1])\r\n    else if Length(P)=1 then\r\n      EnvNames[N]:=''\r\n    end;\r\nend;\r\n\r\nprocedure ReloadParamStrings;\r\n\r\nVar\r\n  ParsLine : String;\r\n  Pars : Array of String;\r\n  I : integer;\r\n\r\nbegin\r\n  ParsLine:=Copy(window.location.hash,2);\r\n  If ParsLine<>'' then\r\n    Pars:=ParsLine.Split(['/'])\r\n  else\r\n    SetLength(Pars,0);\r\n  SetLength(Params,1+Length(Pars));\r\n  Params[0]:=Window.location.pathname;\r\n  For I:=0 to Length(Pars)-1 do\r\n    Params[1+I]:=Pars[I];\r\nend;\r\n\r\n\r\nfunction GetParamCount: longint;\r\nbegin\r\n  Result:=Length(Params)-1;\r\nend;\r\n\r\nfunction GetParamStr(Index: longint): String;\r\nbegin\r\n  if (Index>=0) and (Index<Length(Params)) then\r\n    Result:=Params[Index];\r\nend;\r\n\r\nfunction MyGetEnvironmentVariable(Const EnvVar: String): String;\r\n\r\nVar\r\n  aName : String;\r\n\r\nbegin\r\n  aName:=Lowercase(EnvVar);\r\n  if EnvNames.hasOwnProperty(aName) then\r\n    Result:=String(EnvNames[aName])\r\n  else\r\n    Result:='';\r\nend;\r\n\r\nfunction MyGetEnvironmentVariableCount: Integer;\r\nbegin\r\n  Result:=length(TJSOBject.getOwnPropertyNames(envNames));\r\nend;\r\n\r\nfunction MyGetEnvironmentString(Index: Integer): String;\r\nbegin\r\n  Result:=String(EnvNames[TJSOBject.getOwnPropertyNames(envNames)[Index]]);\r\nend;\r\n\r\n{ TBrowserApplication }\r\n\r\nfunction DoFindGlobalComponent(const aName: string): TComponent;\r\nbegin\r\n  if Assigned(AppInstance) then\r\n    Result:=AppInstance.FindComponent(aName)\r\n  else\r\n    Result:=Nil;\r\nend;\r\n\r\nfunction TBrowserApplication.GetHTMLElement(aID: String): TJSHTMLElement;\r\nbegin\r\n  Result:=TJSHTMLElement(Document.getElementById(aID));\r\n  if (Result=Nil) and LogGetElementErrors then\r\n    Writeln('Could not find element with ID ',aID);\r\nend;\r\n\r\nfunction TBrowserApplication.CreateHTMLElement(aTag: String; aID: String): TJSHTMLElement;\r\nbegin\r\n  Result:=TJSHTMLElement(Document.createElement(aTag));\r\n  if aID<>'' then\r\n    Result.ID:=aID;\r\nend;\r\n\r\nprocedure TBrowserApplication.DoRun;\r\nbegin\r\n  // Override in descendent classes.\r\nend;\r\n\r\nfunction TBrowserApplication.GetConsoleApplication: boolean;\r\nbegin\r\n  Result:=true;\r\nend;\r\n\r\nfunction TBrowserApplication.LogGetElementErrors: Boolean;\r\nbegin\r\n  Result:=True;\r\nend;\r\n\r\nfunction TBrowserApplication.GetLocation: String;\r\nbegin\r\n  Result:=''; // ToDo ExtractFilePath(GetExeName);\r\nend;\r\n\r\nconstructor TBrowserApplication.Create(aOwner: TComponent);\r\nbegin\r\n  inherited Create(aOwner);\r\n  ShowExceptions:=True;\r\n  if AppInstance=Nil then\r\n     begin\r\n     AppInstance:=Self;\r\n     RegisterFindGlobalComponentProc(@DoFindGlobalComponent);\r\n     end;\r\n\r\nend;\r\n\r\ndestructor TBrowserApplication.destroy;\r\nbegin\r\n  if AppInstance=Self then\r\n    AppInstance:=Nil;\r\n  inherited destroy;\r\nend;\r\n\r\nprocedure TBrowserApplication.GetEnvironmentList(List: TStrings;\r\n  NamesOnly: Boolean);\r\nvar\r\n  Names: TStringDynArray;\r\n  i: Integer;\r\nbegin\r\n  Names:=TJSObject.getOwnPropertyNames(EnvNames);\r\n  for i:=0 to length(Names)-1 do\r\n  begin\r\n    if NamesOnly then\r\n      List.Add(Names[i])\r\n    else\r\n      List.Add(Names[i]+'='+String(EnvNames[Names[i]]));\r\n  end;\r\nend;\r\n\r\nprocedure TBrowserApplication.ShowException(E: Exception);\r\n\r\nVar\r\n  S : String;\r\n\r\nbegin\r\n  if (E<>nil) then\r\n    S:=E.ClassName+': '+E.Message\r\n  else if ExceptObjectJS then\r\n    s:=TJSObject(ExceptObjectJS).toString;\r\n  S:='Unhandled exception caught: '+S;\r\n  if ShowExceptions then\r\n    window.alert(S);\r\n  Writeln(S);\r\nend;\r\n\r\nprocedure TBrowserApplication.HandleException(Sender: TObject);\r\nbegin\r\n  if ExceptObject is Exception then\r\n    ShowException(ExceptObject);\r\n  inherited HandleException(Sender);\r\nend;\r\n\r\nfunction TBrowserApplication.RegisterServiceWorker(aFile: String;\r\n  const aOnRegistered: TServiceWorkerRegisteredEvent; DoLogging: Boolean\r\n  ): Boolean;\r\nbegin\r\n  // register service worker if supported\r\n  Result:=HasServiceWorker;\r\n  if Result then\r\n    Window.addEventListener('load',\r\n      procedure()\r\n      begin\r\n        Window.navigator.serviceWorker\r\n          .register(aFile)\r\n          ._then(TJSPromiseResolver(procedure(Registration: TJSServiceWorkerRegistration)\r\n            begin\r\n              if DoLogging then\r\n                console.log('service worker registered');\r\n              if Assigned(aOnRegistered) then\r\n                aOnRegistered(Registration);\r\n            end))\r\n          .catch(TJSPromiseResolver(procedure(err: JSValue)\r\n            begin\r\n              if DoLogging then\r\n                console.log('service worker not registered: '+String(err));\r\n            end));\r\n      end);\r\nend;\r\n\r\ninitialization\r\n  IsConsole:=true;\r\n  OnParamCount:=@GetParamCount;\r\n  OnParamStr:=@GetParamStr;\r\n  ReloadEnvironmentStrings;\r\n  ReloadParamStrings;\r\n  OnGetEnvironmentVariable:=@MyGetEnvironmentVariable;\r\n  OnGetEnvironmentVariableCount:=@MyGetEnvironmentVariableCount;\r\n  OnGetEnvironmentString:=@MyGetEnvironmentString;\r\n\r\nend.\r\n\r\n","{\r\n    Delphi/Kylix compatibility unit: String handling routines.\r\n\r\n    This file is part of the Free Pascal run time library.\r\n    Copyright (c) 2018 by the Free Pascal development team\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n{$mode objfpc}\r\n\r\n{$inline on}\r\n{$IFNDEF FPC_DOTTEDUNITS}\r\nunit strutils;\r\n{$ENDIF}\r\n\r\ninterface\r\n\r\nuses\r\n{$IFNDEF FPC_DOTTEDUNITS}\r\n  SysUtils, Types;\r\n{$ELSE}  \r\n  System.SysUtils, System.Types;\r\n{$ENDIF}  \r\n\r\n{ ---------------------------------------------------------------------\r\n    Case insensitive search/replace\r\n  ---------------------------------------------------------------------}\r\n\r\nFunction AnsiResemblesText(const AText, AOther: string): Boolean;\r\nFunction AnsiContainsText(const AText, ASubText: string): Boolean;\r\nFunction AnsiStartsText(const ASubText, AText: string): Boolean;\r\nFunction AnsiEndsText(const ASubText, AText: string): Boolean;\r\nFunction AnsiReplaceText(const AText, AFromText, AToText: string): string;\r\nFunction AnsiMatchText(const AText: string; const AValues: array of string): Boolean;\r\nFunction AnsiIndexText(const AText: string; const AValues: array of string): Integer;\r\n\r\nFunction StartsText(const ASubText, AText: string): Boolean;\r\nFunction EndsText(const ASubText, AText: string): Boolean;\r\n\r\nfunction ResemblesText(const AText, AOther: string): Boolean;\r\nfunction ContainsText(const AText, ASubText: string): Boolean;\r\nfunction MatchText(const AText: string; const AValues: array of string): Boolean;\r\nfunction IndexText(const AText: string; const AValues: array of string): Integer;\r\n\r\n{ ---------------------------------------------------------------------\r\n    Case sensitive search/replace\r\n  ---------------------------------------------------------------------}\r\n\r\nFunction AnsiContainsStr(const AText, ASubText: string): Boolean;\r\nFunction AnsiStartsStr(const ASubText, AText: string): Boolean;\r\nFunction AnsiEndsStr(const ASubText, AText: string): Boolean;\r\nFunction AnsiReplaceStr(const AText, AFromText, AToText: string): string;\r\nFunction AnsiMatchStr(const AText: string; const AValues: array of string): Boolean;\r\nFunction AnsiIndexStr(const AText: string; const AValues: array of string): Integer;\r\nFunction MatchStr(const AText: String; const AValues: array of String): Boolean;\r\nFunction IndexStr(const AText: String; const AValues: array of String): Integer;\r\nfunction ContainsStr(const AText, ASubText: string): Boolean;\r\nFunction StartsStr(const ASubText, AText: string): Boolean;\r\nFunction EndsStr(const ASubText, AText: string): Boolean;\r\n\r\n{ ---------------------------------------------------------------------\r\n    Miscellaneous\r\n  ---------------------------------------------------------------------}\r\n\r\nFunction DupeString(const AText: string; ACount: Integer): string;\r\nFunction ReverseString(const AText: string): string;\r\nFunction AnsiReverseString(const AText: String): String;\r\nFunction StuffString(const AText: string; AStart, ALength: Cardinal;  const ASubText: string): string;\r\nFunction RandomFrom(const AValues: array of string): string; overload;\r\nFunction IfThen(AValue: Boolean; const ATrue: string; const AFalse: string = ''): string; overload;\r\nfunction NaturalCompareText (const S1 , S2 : string ): Integer ;\r\nfunction NaturalCompareText(const Str1, Str2: string; const ADecSeparator, AThousandSeparator: String): Integer;\r\n\r\n\r\n{ ---------------------------------------------------------------------\r\n    VB emulations.\r\n  ---------------------------------------------------------------------}\r\n\r\nFunction LeftStr(const AText: String; const ACount: SizeInt): String;\r\nFunction RightStr(const AText: String; const ACount: SizeInt): String;\r\nFunction MidStr(const AText: String; const AStart, ACount: SizeInt): String;\r\nFunction RightBStr(const AText: String; const AByteCount: SizeInt): String;\r\nFunction MidBStr(const AText: String; const AByteStart, AByteCount: SizeInt): String;\r\nFunction AnsiLeftStr(const AText: String; const ACount: SizeInt): String;\r\nFunction AnsiRightStr(const AText: String; const ACount: SizeInt): String;\r\nFunction AnsiMidStr(const AText: String; const AStart, ACount: SizeInt): String;\r\nFunction LeftBStr(const AText: String; const AByteCount: SizeInt): String;\r\n\r\n{ ---------------------------------------------------------------------\r\n    Extended search and replace\r\n  ---------------------------------------------------------------------}\r\n\r\nVar\r\n  { Default word delimiters are any character except the core alphanumerics. }\r\n  WordDelimiters: Array of Char;// = [#0..#255] - ['a'..'z','A'..'Z','1'..'9','0'];\r\n  \r\nConst\r\n  SErrAmountStrings    = 'Amount of search and replace strings don''t match';\r\n  SInvalidRomanNumeral = '%s is not a valid Roman numeral';\r\n\r\ntype\r\n  TStringSearchOption = (soDown, soMatchCase, soWholeWord);\r\n  TStringSearchOptions = set of TStringSearchOption;\r\n  TStringSeachOption = TStringSearchOption;\r\n\r\nFunction PosEx(const SubStr, S: string; Offset: SizeUint): SizeInt;\r\nFunction PosEx(const SubStr, S: string): SizeInt; // Offset: Cardinal = 1\r\nFunction PosEx(c:char; const S: string; Offset: SizeUint): SizeInt;\r\nfunction StringsReplace(const S: string; OldPattern, NewPattern: array of string;  Flags: TReplaceFlags): string;\r\n\r\n{ ---------------------------------------------------------------------\r\n    Delphi compat\r\n  ---------------------------------------------------------------------}\r\n\r\nFunction ReplaceStr(const AText, AFromText, AToText: string): string;\r\nFunction ReplaceText(const AText, AFromText, AToText: string): string;\r\n\r\n{ ---------------------------------------------------------------------\r\n    Soundex Functions.\r\n  ---------------------------------------------------------------------}\r\n\r\ntype\r\n  TSoundexLength = 1..MaxInt;\r\n\r\nFunction Soundex(const AText: string; ALength: TSoundexLength): string;\r\nFunction Soundex(const AText: string): string; // ; ALength: TSoundexLength = 4\r\n\r\ntype\r\n  TSoundexIntLength = 1..8;\r\n\r\nFunction SoundexInt(const AText: string; ALength: TSoundexIntLength): Integer;\r\nFunction SoundexInt(const AText: string): Integer; //; ALength: TSoundexIntLength = 4\r\nFunction DecodeSoundexInt(AValue: Integer): string;\r\nFunction SoundexWord(const AText: string): Word;\r\nFunction DecodeSoundexWord(AValue: Word): string;\r\nFunction SoundexSimilar(const AText, AOther: string; ALength: TSoundexLength): Boolean;\r\nFunction SoundexSimilar(const AText, AOther: string): Boolean; //; ALength: TSoundexLength = 4\r\nFunction SoundexCompare(const AText, AOther: string; ALength: TSoundexLength): Integer;\r\nFunction SoundexCompare(const AText, AOther: string): Integer; //; ALength: TSoundexLength = 4\r\nFunction SoundexProc(const AText, AOther: string): Boolean;\r\n\r\ntype\r\n  TCompareTextProc = Function(const AText, AOther: string): Boolean;\r\n\r\nVar\r\n  AnsiResemblesProc: TCompareTextProc;\r\n  ResemblesProc: TCompareTextProc;\r\n\r\n{ ---------------------------------------------------------------------\r\n    Other functions, based on RxStrUtils.\r\n  ---------------------------------------------------------------------}\r\ntype\r\n TRomanConversionStrictness = (rcsStrict, rcsRelaxed, rcsDontCare);\r\n\r\n\r\nfunction IsEmptyStr(const S: string; const EmptyChars: Array of char): Boolean;\r\nfunction DelSpace(const S: string): string;\r\nfunction DelChars(const S: string; Chr: Char): string;\r\nfunction DelSpace1(const S: string): string;\r\nfunction Tab2Space(const S: string; Numb: Byte): string;\r\nfunction NPos(const C: string; S: string; N: Integer): SizeInt;\r\nFunction RPosEX(C:char;const S : String;offs:cardinal):SizeInt; overload;\r\nFunction RPosex (Const Substr : String; Const Source : String;offs:cardinal) : SizeInt; overload;\r\nFunction RPos(c:char;const S : String):SizeInt; overload;\r\nFunction RPos (Const Substr : String; Const Source : String) : SizeInt; overload;\r\nfunction AddChar(C: Char; const S: string; N: Integer): string;\r\nfunction AddCharR(C: Char; const S: string; N: Integer): string;\r\nfunction PadLeft(const S: string; N: Integer): string;\r\nfunction PadRight(const S: string; N: Integer): string;\r\nfunction PadCenter(const S: string; Len: SizeInt): string;\r\nfunction Copy2Symb(const S: string; Symb: Char): string;\r\nfunction Copy2SymbDel(var S: string; Symb: Char): string;\r\nfunction Copy2Space(const S: string): string;\r\nfunction Copy2SpaceDel(var S: string): string;\r\nfunction AnsiProperCase(const S: string; const WordDelims: Array of char): string;\r\nfunction WordCount(const S: string; const WordDelims: Array of char): SizeInt;\r\nfunction WordPosition(const N: Integer; const S: string; const WordDelims: Array of char): SizeInt;\r\nfunction ExtractWord(N: Integer; const S: string;  const WordDelims: Array of char): string;\r\nfunction ExtractWordPos(N: Integer; const S: string; const WordDelims: Array of char; out Pos: Integer): string;\r\nfunction ExtractDelimited(N: Integer; const S: string;  const Delims: Array of char): string;\r\nfunction ExtractSubstr(const S: string; var Pos: Integer;  const Delims: Array of char): string;\r\nfunction IsWordPresent(const W, S: string; const WordDelims: Array of char): Boolean;\r\nfunction FindPart(const HelpWilds, InputStr: string): SizeInt;\r\nfunction IsWild(InputStr, Wilds: string; IgnoreCase: Boolean): Boolean;\r\nfunction XorString(const Key, Src: String): String;\r\nfunction XorEncode(const Key, Source: string): string;\r\nfunction XorDecode(const Key, Source: string): string;\r\nfunction GetCmdLineArg(const Switch: string; SwitchChars: Array of char): string;\r\nfunction Numb2USA(const S: string): string;\r\nfunction Hex2Dec(const S: string): Longint;\r\nfunction Dec2Numb(N: Longint; Len, Base: Byte): string;\r\nfunction Numb2Dec(S: string; Base: Byte): Longint;\r\nfunction IntToBin(Value: Longint; Digits, Spaces: Integer): string;\r\nfunction IntToBin(Value: Longint; Digits: Integer): string;\r\nfunction IntToBin(Value: NativeInt; Digits:integer): string;\r\nfunction IntToRoman(Value: Longint): string;\r\nfunction TryRomanToInt(S: String; out N: LongInt; Strictness: TRomanConversionStrictness = rcsRelaxed): Boolean;\r\nfunction RomanToInt(const S: string; Strictness: TRomanConversionStrictness = rcsRelaxed): Longint;\r\nfunction RomanToIntDef(Const S : String; const ADefault: Longint = 0; Strictness: TRomanConversionStrictness = rcsRelaxed): Longint;\r\n\r\nconst\r\n  DigitChars = ['0'..'9'];\r\n  Brackets = ['(',')','[',']','{','}'];\r\n  StdWordDelims = [#0..' ',',','.',';','/','\\',':','''','\"','`'] + Brackets;\r\n  StdSwitchChars = ['-','/'];\r\n\r\nfunction PosSet (const c:Array of char;const s : String ):SizeInt;\r\nfunction PosSet (const c:string;const s : String ):SizeInt;\r\nfunction PosSetEx (const c:Array of char;const s : String;count:Integer ):SizeInt;\r\nfunction PosSetEx (const c:string;const s : String;count:Integer ):SizeInt;\r\n\r\nProcedure Removeleadingchars(VAR S : String; Const CSet:Array of char);\r\nProcedure RemoveTrailingChars(VAR S : String;Const CSet:Array of char);\r\nProcedure RemovePadChars(VAR S : String;Const CSet:Array of char);\r\n\r\nfunction TrimLeftSet(const S: String;const CSet:Array of char): String;\r\nFunction TrimRightSet(const S: String;const CSet:Array of char): String;\r\nfunction TrimSet(const S: String;const CSet:Array of char): String;\r\n\r\nFunction SplitString(const S, Delimiters: string): TStringDynArray;\r\n\r\ntype\r\n  SizeIntArray = array of SizeInt;\r\n\r\n\r\nimplementation\r\n\r\nuses\r\n{$IFDEF FPC_DOTTEDUNITS}\r\n  JSApi.JS;\r\n{$ELSE}\r\n  js;\r\n{$ENDIF}\r\n\r\n{ ---------------------------------------------------------------------\r\n   Possibly Exception raising functions\r\n  ---------------------------------------------------------------------}\r\n\r\n\r\nfunction Hex2Dec(const S: string): Longint;\r\nvar\r\n  HexStr: string;\r\nbegin\r\n  if Pos('$',S)=0 then\r\n    HexStr:='$'+ S\r\n  else\r\n    HexStr:=S;\r\n  Result:=StrToInt(HexStr);\r\nend;\r\n\r\n{\r\n  We turn off implicit exceptions, since these routines are tested, and it \r\n  saves 20% codesize (and some speed) and don't throw exceptions, except maybe \r\n  heap related. If they don't, that is consider a bug.\r\n\r\n  In the future, be wary with routines that use strtoint, floating point \r\n  and/or format() derivatives. And check every divisor for 0.\r\n}\r\n\r\n{$IMPLICITEXCEPTIONS OFF}\r\n\r\n{ ---------------------------------------------------------------------\r\n    Case insensitive search/replace\r\n  ---------------------------------------------------------------------}\r\nFunction AnsiResemblesText(const AText, AOther: string): Boolean;\r\n\r\nbegin\r\n  if Assigned(AnsiResemblesProc) then\r\n    Result:=AnsiResemblesProc(AText,AOther)\r\n  else\r\n    Result:=False;\r\nend;\r\n\r\nFunction AnsiContainsText(const AText, ASubText: string): Boolean;\r\nbegin\r\n  Result:=Pos(Uppercase(ASubText),Uppercase(AText))>0;\r\nend;\r\n\r\n\r\nFunction AnsiStartsText(const ASubText, AText: string): Boolean;\r\nbegin\r\n  if (Length(AText) >= Length(ASubText)) and (ASubText <> '') then\r\n    Result := SameText(ASubText,Copy(AText,1,Length(ASubText)))\r\n  else\r\n    Result := False;\r\nend;\r\n\r\n\r\nFunction AnsiEndsText(const ASubText, AText: string): Boolean;\r\nbegin\r\n  if Length(AText) >= Length(ASubText) then\r\n    Result := SameText(aSubText,RightStr(aText,Length(ASubText)))\r\n  else\r\n    Result := False;\r\nend;\r\n\r\n\r\nFunction AnsiReplaceText(const AText, AFromText, AToText: string): string;\r\nbegin\r\n  Result := StringReplace(AText,AFromText,AToText,[rfReplaceAll,rfIgnoreCase]);\r\nend;\r\n\r\n\r\nFunction AnsiMatchText(const AText: string; const AValues: array of string): Boolean;\r\nbegin\r\n  Result:=(AnsiIndexText(AText,AValues)<>-1)\r\nend;\r\n\r\n\r\nFunction AnsiIndexText(const AText: string; const AValues: array of string): Integer;\r\n\r\nvar\r\n  i : Integer;\r\n\r\nbegin\r\n  Result:=-1;\r\n  if (high(AValues)=-1) or (High(AValues)>MaxInt) Then\r\n    Exit;\r\n  for i:=low(AValues) to High(Avalues) do\r\n     if CompareText(avalues[i],atext)=0 Then\r\n       exit(i);  // make sure it is the first val.\r\nend;\r\n\r\n\r\n{ ---------------------------------------------------------------------\r\n    Case sensitive search/replace\r\n  ---------------------------------------------------------------------}\r\n\r\nFunction AnsiContainsStr(const AText, ASubText: string): Boolean;\r\nbegin\r\n  Result := Pos(ASubText,AText)>0;\r\nend;\r\n\r\n\r\nFunction AnsiStartsStr(const ASubText, AText: string): Boolean;\r\nbegin\r\n  if (Length(AText) >= Length(ASubText)) and (ASubText <> '') then\r\n    Result := (ASubText=Copy(aText,1,Length(ASubtext)))\r\n  else\r\n    Result := False;\r\nend;\r\n\r\n\r\nFunction AnsiEndsStr(const ASubText, AText: string): Boolean;\r\nbegin\r\n  if Length(AText) >= Length(ASubText) then\r\n    Result := (ASubText=RightStr(aText,Length(ASubText)))\r\n  else\r\n    Result := False;\r\nend;\r\n\r\n\r\nFunction AnsiReplaceStr(const AText, AFromText, AToText: string): string;\r\nbegin\r\n  Result := StringReplace(AText,AFromText,AToText,[rfReplaceAll]);\r\nend;\r\n\r\n\r\nFunction AnsiMatchStr(const AText: string; const AValues: array of string): Boolean;\r\nbegin\r\n  Result:=AnsiIndexStr(AText,Avalues)<>-1;\r\nend;\r\n\r\n\r\nFunction AnsiIndexStr(const AText: string; const AValues: array of string): Integer;\r\nvar\r\n  i : longint;\r\nbegin\r\n  result:=-1;\r\n  if (high(AValues)=-1) or (High(AValues)>MaxInt) Then\r\n    Exit;\r\n  for i:=low(AValues) to High(Avalues) do\r\n     if (avalues[i]=AText) Then\r\n       exit(i);                                 // make sure it is the first val.\r\nend;\r\n\r\n\r\nFunction MatchStr(const AText: String; const AValues: array of String): Boolean;\r\nbegin\r\n  Result := IndexStr(AText,AValues) <> -1;\r\nend;\r\n\r\n\r\nFunction IndexStr(const AText: String; const AValues: array of String): Integer;\r\nvar\r\n  i: longint;\r\nbegin\r\n  Result := -1;\r\n  if (high(AValues) = -1) or (High(AValues) > MaxInt) Then\r\n    Exit;\r\n  for i := low(AValues) to High(Avalues) do\r\n     if (avalues[i] = AText) Then\r\n       exit(i);                                 // make sure it is the first val.\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n    Playthingies\r\n  ---------------------------------------------------------------------}\r\n\r\nFunction DupeString(const AText: string; ACount: Integer): string;\r\n\r\nvar i : SizeInt;\r\n\r\nbegin\r\n result:='';\r\n for i:=1 to ACount do\r\n   Result:=Result+aText;\r\nend;\r\n\r\nFunction ReverseString(const AText: string): string;\r\n\r\nvar\r\n  i,j : SizeInt;\r\n\r\nbegin\r\n  setlength(result,length(atext));\r\n  i:=1; j:=length(atext);\r\n  while (i<=j) do\r\n    begin\r\n    result[i]:=atext[j-i+1];\r\n    inc(i);\r\n    end;\r\nend;\r\n\r\n\r\nFunction AnsiReverseString(const AText: String): String;\r\n\r\nbegin\r\n  Result:=ReverseString(AText);\r\nend;\r\n\r\n\r\nFunction StuffString(const AText: string; AStart, ALength: Cardinal;  const ASubText: string): string;\r\n\r\nvar i,j,k : SizeUInt;\r\n\r\nbegin\r\n  j:=length(ASubText);\r\n  i:=length(AText);\r\n  if AStart>i then \r\n    aStart:=i+1;\r\n  k:=i+1-AStart;\r\n  if ALength> k then\r\n    ALength:=k;\r\n  SetLength(Result,i+j-ALength);\r\n  Result:=Copy(AText,1,AStart-1)+Copy(ASubText,1,J)+Copy(AText,AStart+ALength,I+1-AStart-ALength);\r\nend;\r\n\r\nFunction RandomFrom(const AValues: array of string): string; overload;\r\n\r\nbegin\r\n  if high(AValues)=-1 then exit('');\r\n  result:=Avalues[random(High(AValues)+1)];\r\nend;\r\n\r\nFunction IfThen(AValue: Boolean; const ATrue: string; const AFalse: string = ''): string; overload;\r\n\r\nbegin\r\n  if avalue then\r\n    result:=atrue\r\n  else\r\n    result:=afalse;\r\nend;\r\n\r\nfunction NaturalCompareText(const Str1, Str2: string; const ADecSeparator, AThousandSeparator: String): Integer;\r\n{\r\n NaturalCompareBase compares strings in a collated order and\r\n so numbers are sorted too. It sorts like this:\r\n\r\n 01\r\n 001\r\n 0001\r\n\r\n and\r\n\r\n 0\r\n 00\r\n 000\r\n 000_A\r\n 000_B\r\n\r\n in a intuitive order.\r\n }\r\nvar\r\n  Num1, Num2: double;\r\n  pStr1, pStr2: integer;\r\n  Len1, Len2: SizeInt;\r\n  TextLen1, TextLen2: SizeInt;\r\n  TextStr1: string = '';\r\n  TextStr2: string = '';\r\n  i: SizeInt;\r\n  j: SizeInt;\r\n  \r\n  function Sign(const AValue: sizeint): integer;\r\n\r\n  begin\r\n    If Avalue<0 then\r\n      Result:=-1\r\n    else If Avalue>0 then\r\n      Result:=1\r\n    else\r\n      Result:=0;\r\n  end;\r\n\r\n  function IsNumber(ch: char): boolean; overload;\r\n  begin\r\n    Result := ch in ['0'..'9'];\r\n  end;\r\n\r\n  function GetInteger(aString : String; var pch: integer; var Len: sizeint): double;\r\n\r\n  begin\r\n    Result := 0;\r\n    while (pch<=length(astring)) and IsNumber(AString[pch]) do\r\n      begin\r\n      Result := (Result * 10) + Ord(Astring[pch]) - Ord('0');\r\n      Inc(Len);\r\n      Inc(pch);\r\n      end;\r\n  end;\r\n\r\n  procedure GetChars;\r\n\r\n  begin\r\n    TextLen1 := 0;\r\n    while not (Str1[pStr1 + TextLen1] in ['0'..'9']) and ((pStr1 + TextLen1)<=Length(Str1)) do\r\n      Inc(TextLen1);\r\n    TextStr1:='';\r\n    i := 1;\r\n    j := 0;\r\n    while i <= TextLen1 do\r\n      begin\r\n      TextStr1 := TextStr1+Str1[pStr1 + j];\r\n      Inc(i);\r\n      Inc(j);\r\n      end;\r\n\r\n    TextLen2 := 0;\r\n    while not (Str2[pStr2 + TextLen2] in ['0'..'9']) and ((pStr2 + TextLen2)<=Length(Str2)) do\r\n      Inc(TextLen2);\r\n    i := 1;\r\n    j := 0;\r\n    while i <= TextLen2 do\r\n      begin\r\n      TextStr2 := TextStr2+Str2[pStr2 + j];\r\n      Inc(i);\r\n      Inc(j);\r\n    end;\r\n  end;\r\n\r\nbegin\r\n  if (Str1 <> '') and (Str2 <> '') then\r\n    begin\r\n    pStr1 := 1;\r\n    pStr2 := 1;\r\n    Result := 0;\r\n    while (pStr1<=Length(Str1)) and (pStr2 <=Length(Str2)) do\r\n      begin\r\n      TextLen1 := 1;\r\n      TextLen2 := 1;\r\n      Len1 := 0;\r\n      Len2 := 0;\r\n      while (Str1[pStr1] = ' ') do\r\n      begin\r\n        Inc(pStr1);\r\n        Inc(Len1);\r\n      end;\r\n      while (Str2[pstr2] = ' ') do\r\n        begin\r\n        Inc(pStr2);\r\n        Inc(Len2);\r\n        end;\r\n      if IsNumber(Str1[pStr1]) and IsNumber(Str2[pStr2]) then\r\n        begin\r\n         Num1 := GetInteger(Str1,pStr1, Len1);\r\n         Num2 := GetInteger(Str2, pStr2, Len2);\r\n        if Num1 < Num2 then\r\n          Result := -1\r\n        else if Num1 > Num2 then\r\n          Result := 1\r\n        else\r\n        begin\r\n          Result := Sign(Len1 - Len2);\r\n        end;\r\n        Dec(pStr1);\r\n        Dec(pStr2);\r\n        end\r\n      else\r\n        begin\r\n        GetChars;\r\n        if TextStr1 <> TextStr2 then\r\n          Result := CompareText(TextStr1, TextStr2)\r\n        else\r\n          Result := 0;\r\n        end;\r\n      if Result <> 0 then\r\n        Break;\r\n      Inc(pStr1, TextLen1);\r\n      Inc(pStr2, TextLen2);\r\n      end;\r\n    end;\r\n  Num1:=Length(Str1);\r\n  Num2:=Length(Str2);\r\n  if (Result = 0) and (Num1 <> Num2) then\r\n    begin\r\n    if Num1 < Num2 then\r\n      Result := -1\r\n    else\r\n      Result := 1;\r\n    end;\r\n  if ADecSeparator='' then ;\r\n  if aThousandSeparator='' then ;\r\nend;\r\n\r\nfunction NaturalCompareText (const S1 , S2 : string ): Integer ;\r\nbegin\r\n  Result := NaturalCompareText(S1, S2, FormatSettings.DecimalSeparator,FormatSettings.ThousandSeparator);\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n    VB emulations.\r\n  ---------------------------------------------------------------------}\r\n\r\nFunction LeftStr(const AText: String; const ACount: SizeInt): String;\r\n\r\nbegin\r\n  Result:=Copy(AText,1,ACount);\r\nend;\r\n\r\nFunction RightStr(const AText: String; const ACount: SizeInt): String;\r\n\r\nvar j,l:SizeInt;\r\n\r\nbegin\r\n  l:=length(atext);\r\n  j:=ACount;\r\n  if j>l then j:=l;\r\n  Result:=Copy(AText,l-j+1,j);\r\nend;\r\n\r\nFunction MidStr(const AText: String; const AStart, ACount: SizeInt): String;\r\n\r\nbegin\r\n  if (ACount=0) or (AStart>length(atext)) then\r\n    exit('');\r\n  Result:=Copy(AText,AStart,ACount);\r\nend;\r\n\r\n\r\n\r\nFunction LeftBStr(const AText: String; const AByteCount: SizeInt): String;\r\n\r\nbegin\r\n  Result:=LeftStr(AText,AByteCount);\r\nend;\r\n\r\n\r\nFunction RightBStr(const AText: String; const AByteCount: SizeInt): String;\r\nbegin\r\n  Result:=RightStr(Atext,AByteCount);\r\nend;\r\n\r\n\r\nFunction MidBStr(const AText: String; const AByteStart, AByteCount: SizeInt): String;\r\nbegin\r\n  Result:=MidStr(AText,AByteStart,AByteCount);\r\nend;\r\n\r\n\r\nFunction AnsiLeftStr(const AText: String; const ACount: SizeInt): String;\r\nbegin\r\n  Result := copy(AText,1,ACount);\r\nend;\r\n\r\n\r\nFunction AnsiRightStr(const AText: String; const ACount: SizeInt): String;\r\nbegin\r\n  Result := copy(AText,length(AText)-ACount+1,ACount);\r\nend;\r\n\r\n\r\nFunction AnsiMidStr(const AText: String; const AStart, ACount: SizeInt): String;\r\nbegin\r\n  Result:=Copy(AText,AStart,ACount);\r\nend;\r\n\r\n\r\nFunction PosEx(const SubStr, S: string; Offset: SizeUint): SizeInt;\r\n\r\n\r\nbegin\r\n  result:=TJSString.New(S).IndexOf(SubStr,offset-1)+1;\r\nend;\r\n\r\nFunction PosEx(c:char; const S: string; Offset: SizeUint): SizeInt;\r\nbegin\r\n  result:=TJSString.New(S).IndexOf(c,offset-1)+1;\r\nend;\r\n\r\nFunction PosEx(const SubStr, S: string): SizeInt; // Offset: Cardinal = 1\r\n\r\nbegin\r\n  Result:=posex(substr,s,1);\r\nend;\r\n\r\n\r\nfunction StringsReplace(const S: string; OldPattern, NewPattern: array of string;  Flags: TReplaceFlags): string;\r\n\r\nvar pc,pcc,lastpc : integer;\r\n    strcount      : integer;\r\n    ResStr,\r\n    CompStr       : string;\r\n    Found         : Boolean;\r\n    sc            : sizeint;\r\n\r\nbegin\r\n  sc := length(OldPattern);\r\n  if sc <> length(NewPattern) then\r\n    raise exception.Create(SErrAmountStrings);\r\n\r\n  dec(sc);\r\n\r\n  if rfIgnoreCase in Flags then\r\n    begin\r\n    CompStr:=UpperCase(S);\r\n    for strcount := 0 to sc do\r\n      OldPattern[strcount] := UpperCase(OldPattern[strcount]);\r\n    end\r\n  else\r\n    CompStr := s;\r\n\r\n  ResStr := '';\r\n  pc := 1;\r\n  pcc := 1;\r\n  lastpc := pc+Length(S);\r\n\r\n  while pc < lastpc do\r\n    begin\r\n    Found := False;\r\n    for strcount := 0 to sc do\r\n      begin\r\n      if (Copy(compStr,pc,Length(OldPattern[strcount]))=OldPattern[strcount]) then\r\n        begin\r\n        ResStr := ResStr + NewPattern[strcount];\r\n        pc := pc+Length(OldPattern[strcount]);\r\n        pcc := pcc+Length(OldPattern[strcount]);\r\n        Found := true;\r\n        end\r\n      end;\r\n    if not found then\r\n      begin\r\n      ResStr := ResStr + S[pcc];\r\n      inc(pc);\r\n      inc(pcc);\r\n      end\r\n    else if not (rfReplaceAll in Flags) then\r\n      begin\r\n      ResStr := ResStr + copy(S,pcc,Length(S)-pcc+1);\r\n      break;\r\n      end;\r\n    end;\r\n  Result := ResStr;\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n    Delphi compat\r\n  ---------------------------------------------------------------------}\r\n\r\nFunction ReplaceStr(const AText, AFromText, AToText: string): string;\r\nbegin\r\n  result:=AnsiReplaceStr(AText, AFromText, AToText);\r\nend;\r\n\r\nFunction ReplaceText(const AText, AFromText, AToText: string): string;\r\nbegin\r\n  result:=AnsiReplaceText(AText, AFromText, AToText);\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n    Soundex Functions.\r\n  ---------------------------------------------------------------------}\r\nVar\r\n  SScore : String =\r\n      '00000000000000000000000000000000'+ // 1..32\r\n      '00000000000000000000000000000000'+ // 33..64\r\n      '0123012i02245501262301i2i2'+ // 65..90\r\n      '000000'+ // 91..96\r\n      '0123012i02245501262301i2i2'+ // 97..122\r\n      '00000000000000000000000000000000'+ // 123..154\r\n      '00000000000000000000000000000000'+ // 155..186\r\n      '00000000000000000000000000000000'+ // 187..218\r\n      '00000000000000000000000000000000'+ // 219..250\r\n      '00000'; // 251..255\r\n\r\nFunction Soundex(const AText: string; ALength: TSoundexLength): string;\r\n\r\nVar\r\n  S,PS : Char;\r\n  I,L : SizeInt;\r\n\r\nbegin\r\n  Result:='';\r\n  PS:=#0;\r\n  If Length(AText)>0 then\r\n    begin\r\n    Result:=Upcase(AText[1]);\r\n    I:=2;\r\n    L:=Length(AText);\r\n    While (I<=L) and (Length(Result)<ALength) do\r\n      begin\r\n      S:=SScore[Ord(AText[i])];\r\n      If Not (S in ['0','i',PS]) then\r\n        Result:=Result+S;\r\n      If (S<>'i') then\r\n        PS:=S;\r\n      Inc(I);\r\n      end;\r\n    end;\r\n  L:=Length(Result);\r\n  If (L<ALength) then\r\n    Result:=Result+StringOfChar('0',Alength-L);\r\nend;\r\n\r\n\r\n\r\nFunction Soundex(const AText: string): string; // ; ALength: TSoundexLength = 4\r\n\r\nbegin\r\n  Result:=Soundex(AText,4);\r\nend;\r\n\r\nConst\r\n  Ord0 = Ord('0');\r\n  OrdA = Ord('A');\r\n\r\nFunction SoundexInt(const AText: string; ALength: TSoundexIntLength): Integer;\r\n\r\nvar\r\n  SE: string;\r\n  I: SizeInt;\r\n\r\nbegin\r\n  Result:=-1;\r\n  SE:=Soundex(AText,ALength);\r\n  If Length(SE)>0 then\r\n    begin\r\n    Result:=Ord(SE[1])-OrdA;\r\n    if ALength > 1 then\r\n      begin\r\n      Result:=Result*26+(Ord(SE[2])-Ord0);\r\n      for I:=3 to ALength do\r\n        Result:=(Ord(SE[I])-Ord0)+Result*7;\r\n      end;\r\n    Result:=ALength+Result*9;\r\n    end;\r\nend;\r\n\r\n\r\nFunction SoundexInt(const AText: string): Integer; //; ALength: TSoundexIntLength = 4\r\nbegin\r\n  Result:=SoundexInt(AText,4);\r\nend;\r\n\r\n\r\nFunction DecodeSoundexInt(AValue: Integer): string;\r\n\r\nvar\r\n  I, Len: Integer;\r\n\r\nbegin\r\n  Result := '';\r\n  Len := AValue mod 9;\r\n  AValue := AValue div 9;\r\n  for I:=Len downto 3 do\r\n    begin\r\n    Result:=Chr(Ord0+(AValue mod 7))+Result;\r\n    AValue:=AValue div 7;\r\n    end;\r\n  if Len>1 then\r\n    begin\r\n    Result:=Chr(Ord0+(AValue mod 26))+Result;\r\n    AValue:=AValue div 26;\r\n    end;\r\n  Result:=Chr(OrdA+AValue)+Result;\r\nend;\r\n\r\n\r\nFunction SoundexWord(const AText: string): Word;\r\n\r\nVar\r\n  S : String;\r\n\r\nbegin\r\n  S:=SoundEx(Atext,4);\r\n  Result:=Ord(S[1])-OrdA;\r\n  Result:=Result*26+ord(S[2])-48;\r\n  Result:=Result*7+ord(S[3])-48;\r\n  Result:=Result*7+ord(S[4])-48;\r\nend;\r\n\r\n\r\nFunction DecodeSoundexWord(AValue: Word): string;\r\nbegin\r\n  Result := Chr(Ord0+ (AValue mod 7));\r\n  AValue := AValue div 7;\r\n  Result := Chr(Ord0+ (AValue mod 7)) + Result;\r\n  AValue := AValue div 7;\r\n  Result := IntToStr(AValue mod 26) + Result;\r\n  AValue := AValue div 26;\r\n  Result := Chr(OrdA+AValue) + Result;\r\nend;\r\n\r\n\r\nFunction SoundexSimilar(const AText, AOther: string; ALength: TSoundexLength): Boolean;\r\nbegin\r\n  Result:=Soundex(AText,ALength)=Soundex(AOther,ALength);\r\nend;\r\n\r\n\r\nFunction SoundexSimilar(const AText, AOther: string): Boolean; //; ALength: TSoundexLength = 4\r\nbegin\r\n  Result:=SoundexSimilar(AText,AOther,4);\r\nend;\r\n\r\n\r\nFunction SoundexCompare(const AText, AOther: string; ALength: TSoundexLength): Integer;\r\nbegin\r\n  Result:=AnsiCompareStr(Soundex(AText,ALength),Soundex(AOther,ALength));\r\nend;\r\n\r\n\r\nFunction SoundexCompare(const AText, AOther: string): Integer; //; ALength: TSoundexLength = 4\r\nbegin\r\n  Result:=SoundexCompare(AText,AOther,4);\r\nend;\r\n\r\n\r\nFunction SoundexProc(const AText, AOther: string): Boolean;\r\nbegin\r\n  Result:=SoundexSimilar(AText,AOther);\r\nend;\r\n\r\n{ ---------------------------------------------------------------------\r\n    RxStrUtils-like functions.\r\n  ---------------------------------------------------------------------}\r\n\r\n\r\n\r\nfunction IsEmptyStr(const S: string; const EmptyChars: Array of char): Boolean;\r\n\r\nvar\r\n  i,l: SizeInt;\r\n\r\nbegin\r\n  l:=Length(S);\r\n  i:=1;\r\n  Result:=True;\r\n  while Result and (i<=l) do\r\n    begin\r\n    Result:=CharInSet(S[i],EmptyChars);\r\n    Inc(i);\r\n    end;\r\nend;\r\n\r\nfunction DelSpace(const S: String): string;\r\n\r\nbegin\r\n  Result:=DelChars(S,' ');\r\nend;\r\n\r\nfunction DelChars(const S: string; Chr: Char): string;\r\n\r\nvar\r\n  I,J: SizeInt;\r\n\r\nbegin\r\n  Result:=S;\r\n  I:=Length(Result);\r\n  While I>0 do\r\n    begin\r\n    if Result[I]=Chr then\r\n      begin\r\n      J:=I-1;\r\n      While (J>0) and (Result[J]=Chr) do\r\n        Dec(j);\r\n      Delete(Result,J+1,I-J);\r\n      I:=J+1;\r\n      end;\r\n    dec(I);\r\n    end;\r\nend;\r\n\r\nfunction DelSpace1(const S: string): string;\r\n\r\nvar\r\n  I : SizeInt;\r\n\r\nbegin\r\n  Result:=S;\r\n  for i:=Length(Result) downto 2 do\r\n    if (Result[i]=' ') and (Result[I-1]=' ') then\r\n      Delete(Result,I,1);\r\nend;\r\n\r\nfunction Tab2Space(const S: string; Numb: Byte): string;\r\n\r\nvar\r\n  I: SizeInt;\r\n\r\nbegin\r\n  I:=1;\r\n  Result:=S;\r\n  while I <= Length(Result) do\r\n    if Result[I]<>Chr(9) then\r\n      inc(I)\r\n    else\r\n      begin\r\n      Result[I]:=' ';\r\n      If (Numb>1) then\r\n        Insert(StringOfChar(' ',Numb-1),Result,I);\r\n      Inc(I,Numb);\r\n      end;\r\nend;\r\n\r\nfunction NPos(const C: string; S: string; N: Integer): SizeInt;\r\n\r\nvar\r\n  i,p,k: SizeInt;\r\n\r\nbegin\r\n  Result:=0;\r\n  if N<1 then\r\n    Exit;\r\n  k:=0;\r\n  i:=1;\r\n  Repeat\r\n    p:=pos(C,S);\r\n    Inc(k,p);\r\n    if p>0 then\r\n      delete(S,1,p);\r\n    Inc(i);\r\n  Until (i>n) or (p=0);\r\n  If (P>0) then\r\n    Result:=K;\r\nend;\r\n\r\nfunction AddChar(C: Char; const S: string; N: Integer): string;\r\n\r\nVar\r\n  l : SizeInt;\r\n\r\nbegin\r\n  Result:=S;\r\n  l:=Length(Result);\r\n  if l<N then\r\n    Result:=StringOfChar(C,N-l)+Result;\r\nend;\r\n\r\nfunction AddCharR(C: Char; const S: string; N: Integer): string;\r\n\r\nVar\r\n  l : SizeInt;\r\n\r\nbegin\r\n  Result:=S;\r\n  l:=Length(Result);\r\n  if l<N then\r\n    Result:=Result+StringOfChar(C,N-l);\r\nend;\r\n\r\n\r\nfunction PadRight(const S: string; N: Integer): string;\r\nbegin\r\n  Result:=AddCharR(' ',S,N);\r\nend;\r\n\r\n\r\nfunction PadLeft(const S: string; N: Integer): string;\r\nbegin\r\n  Result:=AddChar(' ',S,N);\r\nend;\r\n\r\n\r\nfunction Copy2Symb(const S: string; Symb: Char): string;\r\n\r\nvar\r\n  p: SizeInt;\r\n\r\nbegin\r\n  p:=Pos(Symb,S);\r\n  if p=0 then\r\n    p:=Length(S)+1;\r\n  Result:=Copy(S,1,p-1);\r\nend;\r\n\r\nfunction Copy2SymbDel(var S: string; Symb: Char): string;\r\n\r\nvar\r\n  p: SizeInt;\r\n\r\nbegin\r\n  p:=Pos(Symb,S);\r\n  if p=0 then\r\n    begin\r\n      result:=s;\r\n      s:='';\r\n    end\r\n  else\r\n    begin\t\r\n      Result:=Copy(S,1,p-1);\r\n      delete(s,1,p);\t\t\r\n    end;\r\nend;\r\n\r\nfunction Copy2Space(const S: string): string;\r\nbegin\r\n  Result:=Copy2Symb(S,' ');\r\nend;\r\n\r\nfunction Copy2SpaceDel(var S: string): string;\r\nbegin\r\n  Result:=Copy2SymbDel(S,' ');\r\nend;\r\n\r\nfunction AnsiProperCase(const S: string; const WordDelims: Array of char): string;\r\n\r\nvar\r\n  P,L : Integer;\r\n\r\nbegin\r\n  Result:=LowerCase(S);\r\n  P:=1;\r\n  L:=Length(Result);\r\n  while (P<=L) do\r\n    begin\r\n    while (P<=L) and (CharInSet(Result[P],WordDelims)) do\r\n      inc(P);\r\n    if (P<=L) then\r\n      Result[P]:=UpCase(Result[P]);\r\n    while (P<=L) and not CharInSet(Result[P],WordDelims) do\r\n      inc(P);\r\n    end;\r\nend;\r\n\r\nfunction WordCount(const S: string; const WordDelims: Array of char): SizeInt;\r\n\r\nvar\r\n  P,L : Integer;\r\n\r\nbegin\r\n  Result:=0;\r\n  P:=1;\r\n  L:=Length(S);\r\n  while (P<=L) do\r\n    begin\r\n    while (P<=L) and (CharInSet(S[P],WordDelims)) do\r\n      Inc(P);\r\n    if (P<=L) then\r\n      inc(Result);\r\n    while (P<=L) and not (CharInSet(S[P],WordDelims)) do\r\n      inc(P);\r\n    end;\r\nend;\r\n\r\nfunction WordPosition(const N: Integer; const S: string; const WordDelims: Array of char): SizeInt;\r\n\r\nvar\r\n  PS,P,PE,Count : Integer;\r\n\r\nbegin\r\n  Result:=0;\r\n  Count:=0;\r\n  PS:=1;\r\n  PE:=Length(S);\r\n  P:=PS;\r\n  while (P<=PE) and (Count<>N) do\r\n    begin\r\n    while (P<=PE) and CharInSet(S[P],WordDelims) do\r\n      inc(P);\r\n    if (P<=PE) then\r\n      inc(Count);\r\n    if (Count<>N) then\r\n      while (P<=PE) and not CharInSet(S[P],WordDelims) do\r\n        inc(P)\r\n    else\r\n      Result:=(P-PS)+1;\r\n    end;\r\nend;\r\n\r\n\r\nfunction ExtractWord(N: Integer; const S: string; const WordDelims: Array of char): string;\r\nvar\r\n  i: LongInt;\r\nbegin\r\n  Result:=ExtractWordPos(N,S,WordDelims,i);\r\nend;\r\n\r\n\r\nfunction ExtractWordPos(N: Integer; const S: string; const WordDelims: Array of char; out Pos: Integer): string;\r\n\r\nvar\r\n  i,j,l: SizeInt;\r\n\r\nbegin\r\n  j:=0;\r\n  i:=WordPosition(N, S, WordDelims);\r\n  if (I>MaxInt) then\r\n    begin\r\n    Result:='';\r\n    Pos:=-1;\r\n    Exit;\r\n    end;\r\n  Pos:=i;\r\n  if (i<>0) then\r\n    begin\r\n    j:=i;\r\n    l:=Length(S);\r\n    while (j<=L) and not CharInSet(S[j],WordDelims) do\r\n      inc(j);\r\n    end;\r\n  Result:=Copy(S,I,j-I);\r\nend;\r\n\r\n\r\nfunction ExtractDelimited(N: Integer; const S: string; const Delims: Array of char): string;\r\nvar\r\n  w,i,l,len: SizeInt;\r\nbegin\r\n  w:=0;\r\n  i:=1;\r\n  l:=0;\r\n  len:=Length(S);\r\n  SetLength(Result, 0);\r\n  while (i<=len) and (w<>N) do\r\n    begin\r\n    if CharInSet(S[i],Delims) then\r\n      inc(w)\r\n    else\r\n      begin\r\n      if (N-1)=w then\r\n        begin\r\n        inc(l);\r\n        Result:=Result+S[i];\r\n        end;\r\n      end;\r\n    inc(i);\r\n    end;\r\nend;\r\n\r\n\r\nfunction ExtractSubstr(const S: string; var Pos: Integer; const Delims: Array of char): string;\r\n\r\nvar\r\n  i,l: SizeInt;\r\n\r\nbegin\r\n  i:=Pos;\r\n  l:=Length(S);\r\n  while (i<=l) and not CharInSet(S[i],Delims) do\r\n    inc(i);\r\n  Result:=Copy(S,Pos,i-Pos);\r\n  while (i<=l) and CharInSet(S[i],Delims) do\r\n    inc(i);\r\n  if I>MaxInt then\r\n    Pos:=MaxInt\r\n  else\r\n    Pos:=i;\r\nend;\r\n\r\nfunction isWordPresent(const W, S: string; const WordDelims: Array of char): Boolean;\r\n\r\nvar\r\n  i,Count : SizeInt;\r\n\r\nbegin\r\n  Result:=False;\r\n  Count:=WordCount(S, WordDelims);\r\n  I:=1;\r\n  While (Not Result) and (I<=Count) do\r\n    begin\r\n    Result:=ExtractWord(i,S,WordDelims)=W;\r\n    Inc(i);\r\n    end;\r\nend;\r\n\r\n\r\nfunction Numb2USA(const S: string): string;\r\nvar\r\n  i, NA: Integer;\r\nbegin\r\n  i:=Length(S);\r\n  Result:=S;\r\n  NA:=0;\r\n  while (i > 0) do begin\r\n    if ((Length(Result) - i + 1 - NA) mod 3 = 0) and (i <> 1) then\r\n    begin\r\n      insert(',', Result, i);\r\n      inc(NA);\r\n    end;\r\n    Dec(i);\r\n  end;\r\nend;\r\n\r\nfunction PadCenter(const S: string; Len: SizeInt): string;\r\nbegin\r\n  if Length(S)<Len then\r\n    begin\r\n    Result:=StringOfChar(' ',(Len div 2) -(Length(S) div 2))+S;\r\n    Result:=Result+StringOfChar(' ',Len-Length(Result));\r\n    end\r\n  else\r\n    Result:=S;\r\nend;\r\n\r\n\r\nfunction Dec2Numb(N: Longint; Len, Base: Byte): string;\r\n\r\nvar\r\n  C: Integer;\r\n  Number: Longint;\r\n\r\nbegin\r\n  if N=0 then\r\n    Result:='0'\r\n  else\r\n    begin\r\n    Number:=N;\r\n    Result:='';\r\n    while Number>0 do\r\n      begin\r\n      C:=Number mod Base;\r\n      if C>9 then\r\n        C:=C+55\r\n      else\r\n        C:=C+48;\r\n      Result:=Chr(C)+Result;\r\n      Number:=Number div Base;\r\n      end;\r\n    end;\r\n  if (Result<>'') then\r\n    Result:=AddChar('0',Result,Len);\r\nend;\r\n\r\nfunction Numb2Dec(S: string; Base: Byte): Longint;\r\n\r\nvar\r\n  i, P: sizeint;\r\n\r\nbegin\r\n  i:=Length(S);\r\n  Result:=0;\r\n  S:=UpperCase(S);\r\n  P:=1;\r\n  while (i>=1) do\r\n    begin\r\n    if (S[i]>'@') then\r\n      Result:=Result+(Ord(S[i])-55)*P\r\n    else\r\n      Result:=Result+(Ord(S[i])-48)*P;\r\n    Dec(i);\r\n    P:=P*Base;\r\n    end;\r\nend;\r\n\r\nFunction RomanValues(C : Char) : Word;\r\n\r\nbegin\r\n  Case c of\r\n    'C' : Result:=100;\r\n    'D' : Result:=500;\r\n    'I' : Result:=1;\r\n    'L' : Result:=50;\r\n    'M' : Result:=1000;\r\n    'V' : Result:=5;\r\n    'X' : Result:=10;\r\n  else\r\n    Result:=0;\r\n  end;\r\nend;\r\n\r\nfunction RomanToIntDontCare(const S: String): Longint;\r\n{This was the original implementation of RomanToInt,\r\n it is internally used in TryRomanToInt when Strictness = rcsDontCare}\r\nconst\r\n  RomanChars  = ['C','D','I','L','M','V','X'];\r\n\r\nvar\r\n  index, Next: Char;\r\n  i,l: SizeInt;\r\n  Negative: Boolean;\r\n\r\nbegin\r\n  Result:=0;\r\n  i:=0;\r\n  Negative:=(Length(S)>0) and (S[1]='-');\r\n  if Negative then\r\n    inc(i);\r\n  l:=Length(S);\r\n  while (i<l) do\r\n    begin\r\n    inc(i);\r\n    index:=UpCase(S[i]);\r\n    if index in RomanChars then\r\n      begin\r\n      if (i+1)<=l then\r\n        Next:=UpCase(S[i+1])\r\n      else\r\n        Next:=#0;\r\n      if (Next in RomanChars) and (RomanValues(index)<RomanValues(Next)) then\r\n        begin\r\n        inc(Result, RomanValues(Next));\r\n        Dec(Result, RomanValues(index));\r\n        inc(i);\r\n        end\r\n      else\r\n        inc(Result, RomanValues(index));\r\n      end\r\n    else\r\n      begin\r\n      Result:=0;\r\n      Exit;\r\n      end;\r\n    end;\r\n  if Negative then\r\n    Result:=-Result;\r\nend;\r\n\r\n\r\n{ TryRomanToInt: try to convert a roman numeral to an integer\r\n  Parameters:\r\n  S: Roman numeral (like: 'MCMXXII')\r\n  N: Integer value of S (only meaningfull if the function succeeds)\r\n  Stricness: controls how strict the parsing of S is\r\n    - rcsStrict:\r\n      * Follow common subtraction rules\r\n         - only 1 preceding subtraction character allowed: IX = 9, but IIX <> 8\r\n         - from M you can only subtract C\r\n         - from D you can only subtract C\r\n         - from C you can only subtract X\r\n         - from L you can only subtract X\r\n         - from X you can only subtract I\r\n         - from V you can only subtract I\r\n      *  The numeral is parsed in \"groups\" (first M's, then D's etc.), the next group to be parsed\r\n         must always be of a lower denomination than the previous one.\r\n         Example: 'MMDCCXX' is allowed but 'MMCCXXDD' is not\r\n      * There can only ever be 3 consecutive M's, C's, X's or I's\r\n      * There can only ever be 1 D, 1 L and 1 V\r\n      * After IX or IV there can be no more characters\r\n      * Negative numbers are not supported\r\n      // As a consequence the maximum allowed Roman numeral is MMMCMXCIX = 3999, also N can never become 0 (zero)\r\n\r\n    - rcsRelaxed: Like rcsStrict but with the following exceptions:\r\n      * An infinite number of (leading) M's is allowed\r\n      * Up to 4 consecutive M's, C's, X's and I's are allowed\r\n      // So this is allowed: 'MMMMMMCXIIII'  = 6124\r\n\r\n    - rcsDontCare:\r\n      * no checking on the order of \"groups\" is done\r\n      * there are no restrictions on the number of consecutive chars\r\n      * negative numbers are supported\r\n      * an empty string as input will return True and N will be 0\r\n      * invalid input will return false\r\n      // for backwards comatibility: it supports rather ludicrous input like '-IIIMIII' -> -(2+(1000-1)+3)=-1004\r\n}\r\n\r\nfunction TryRomanToInt(S: String; out N: LongInt; Strictness: TRomanConversionStrictness = rcsRelaxed): Boolean;\r\n\r\nvar\r\n  i, Len: SizeInt;\r\n  Terminated: Boolean;\r\n\r\nbegin\r\n  Result := (False);\r\n  S := UpperCase(S);  //don't use AnsiUpperCase please\r\n  Len := Length(S);\r\n  if (Strictness = rcsDontCare) then\r\n  begin\r\n    N := RomanToIntDontCare(S);\r\n    if (N = 0) then\r\n    begin\r\n      Result := (Len = 0);\r\n    end\r\n    else\r\n      Result := True;\r\n    Exit;\r\n  end;\r\n  if (Len = 0) then Exit;\r\n  i := 1;\r\n  N := 0;\r\n  Terminated := False;\r\n  //leading M's\r\n  while (i <= Len) and ((Strictness <> rcsStrict) or (i < 4)) and (S[i] = 'M') do\r\n  begin\r\n    //writeln('TryRomanToInt: Found 1000');\r\n    Inc(i);\r\n    N := N + 1000;\r\n  end;\r\n  //then CM or or CD or D or (C, CC, CCC, CCCC)\r\n  if (i <= Len) and (S[i] = 'D') then\r\n  begin\r\n    //writeln('TryRomanToInt: Found 500');\r\n    Inc(i);\r\n    N := N + 500;\r\n  end\r\n  else if (i + 1 <= Len) and (S[i] = 'C') then\r\n  begin\r\n    if (S[i+1] = 'M') then\r\n    begin\r\n      //writeln('TryRomanToInt: Found 900');\r\n      Inc(i,2);\r\n      N := N + 900;\r\n    end\r\n    else if (S[i+1] = 'D') then\r\n    begin\r\n      //writeln('TryRomanToInt: Found 400');\r\n      Inc(i,2);\r\n      N := N + 400;\r\n    end;\r\n  end ;\r\n  //next max 4 or 3 C's, depending on Strictness\r\n  if (i <= Len) and (S[i] = 'C') then\r\n  begin\r\n    //find max 4 C's\r\n    //writeln('TryRomanToInt: Found 100');\r\n    Inc(i);\r\n    N := N + 100;\r\n    if (i <= Len) and (S[i] = 'C') then\r\n    begin\r\n      //writeln('TryRomanToInt: Found 100');\r\n      Inc(i);\r\n      N := N + 100;\r\n    end;\r\n    if (i <= Len) and (S[i] = 'C') then\r\n    begin\r\n      //writeln('TryRomanToInt: Found 100');\r\n      Inc(i);\r\n      N := N + 100;\r\n    end;\r\n    if (Strictness <> rcsStrict) and (i <= Len) and (S[i] = 'C') then\r\n    begin\r\n      //writeln('TryRomanToInt: Found 100');\r\n      Inc(i);\r\n      N := N + 100;\r\n    end;\r\n  end;\r\n\r\n  //then XC or XL\r\n  if (i + 1 <= Len) and (S[i] = 'X') then\r\n  begin\r\n    if (S[i+1] = 'C') then\r\n    begin\r\n      //writeln('TryRomanToInt: Found 90');\r\n      Inc(i,2);\r\n      N := N + 90;\r\n    end\r\n    else if  (S[i+1] = 'L') then\r\n    begin\r\n      //writeln('TryRomanToInt: Found 40');\r\n      Inc(i,2);\r\n      N := N + 40;\r\n    end;\r\n  end;\r\n\r\n  //then L\r\n  if (i <= Len) and (S[i] = 'L') then\r\n  begin\r\n    //writeln('TryRomanToInt: Found 50');\r\n    Inc(i);\r\n    N := N + 50;\r\n  end;\r\n\r\n  //then (X, xx, xxx, xxxx)\r\n  if (i <= Len) and (S[i] = 'X') then\r\n  begin\r\n    //find max 3 or 4 X's, depending on Strictness\r\n    //writeln('TryRomanToInt: Found 10');\r\n    Inc(i);\r\n    N := N + 10;\r\n    if (i <= Len) and (S[i] = 'X') then\r\n    begin\r\n      //writeln('TryRomanToInt: Found 10');\r\n      Inc(i);\r\n      N := N + 10;\r\n    end;\r\n    if (i <= Len) and (S[i] = 'X') then\r\n    begin\r\n      //writeln('TryRomanToInt: Found 10');\r\n      Inc(i);\r\n      N := N + 10;\r\n    end;\r\n    if (Strictness <> rcsStrict) and (i <= Len) and (S[i] = 'X') then\r\n    begin\r\n      //writeln('TryRomanToInt: Found 10');\r\n      Inc(i);\r\n      N := N + 10;\r\n    end;\r\n  end;\r\n\r\n  //then IX or IV\r\n  if (i + 1 <= Len) and (S[i] = 'I') then\r\n  begin\r\n    if (S[i+1] = 'X') then\r\n    begin\r\n      Terminated := (True);\r\n      //writeln('TryRomanToInt: Found 9');\r\n      Inc(i,2);\r\n      N := N + 9;\r\n    end\r\n    else if (S[i+1] = 'V') then\r\n    begin\r\n      Terminated := (True);\r\n      //writeln('TryRomanToInt: Found 4');\r\n      Inc(i,2);\r\n      N := N + 4;\r\n    end;\r\n  end;\r\n\r\n  //then V\r\n  if (not Terminated) and (i <= Len) and (S[i] = 'V') then\r\n  begin\r\n    //writeln('TryRomanToInt: Found 5');\r\n    Inc(i);\r\n    N := N + 5;\r\n  end;\r\n\r\n\r\n  //then I\r\n  if (not Terminated) and (i <= Len) and (S[i] = 'I') then\r\n  begin\r\n    Terminated := (True);\r\n    //writeln('TryRomanToInt: Found 1');\r\n    Inc(i);\r\n    N := N + 1;\r\n    //Find max 2 or 3 closing I's, depending on strictness\r\n    if (i <= Len) and (S[i] = 'I') then\r\n    begin\r\n      //writeln('TryRomanToInt: Found 1');\r\n      Inc(i);\r\n      N := N + 1;\r\n    end;\r\n    if (i <= Len) and (S[i] = 'I') then\r\n    begin\r\n      //writeln('TryRomanToInt: Found 1');\r\n      Inc(i);\r\n      N := N + 1;\r\n    end;\r\n    if (Strictness <> rcsStrict) and (i <= Len) and (S[i] = 'I') then\r\n    begin\r\n      //writeln('TryRomanToInt: Found 1');\r\n      Inc(i);\r\n      N := N + 1;\r\n    end;\r\n  end;\r\n\r\n  //writeln('TryRomanToInt: Len = ',Len,' i = ',i);\r\n  Result := (i > Len);\r\n  //if Result then writeln('TryRomanToInt: N = ',N);\r\n\r\nend;\r\n\r\nfunction RomanToInt(const S: string; Strictness: TRomanConversionStrictness = rcsRelaxed): Longint;\r\nbegin\r\n  if not TryRomanToInt(S, Result, Strictness) then\r\n    raise EConvertError.CreateFmt(SInvalidRomanNumeral,[S]);\r\nend;\r\n\r\nfunction RomanToIntDef(const S: String; const ADefault: Longint;\r\n  Strictness: TRomanConversionStrictness): Longint;\r\nbegin\r\n  if not TryRomanToInt(S, Result, Strictness) then\r\n    Result := ADefault;\r\nend;\r\n\r\n\r\n\r\n\r\nfunction intToRoman(Value: Longint): string;\r\n\r\nconst\r\n  Arabics : Array[1..13] of Integer\r\n          = (1,4,5,9,10,40,50,90,100,400,500,900,1000);\r\n  Romans  :  Array[1..13] of String\r\n          = ('I','IV','V','IX','X','XL','L','XC','C','CD','D','CM','M');\r\n\r\nvar\r\n  i: Integer;\r\n\r\nbegin\r\n  Result:='';\r\n  for i:=13 downto 1 do\r\n    while (Value >= Arabics[i]) do\r\n      begin\r\n        Value:=Value-Arabics[i];\r\n        Result:=Result+Romans[i];\r\n      end;\r\nend;\r\n\r\nfunction intToBin(Value: Longint; Digits, Spaces: Integer): string;\r\n\r\nvar endpos : integer;\r\n    p,p2: integer;\r\n    k: integer;\r\n\r\nbegin\r\n  Result:='';\r\n  if (Digits>32) then\r\n    Digits:=32;\r\n  if (spaces=0) then\r\n   begin\r\n     result:=inttobin(value,digits);\r\n     exit;\r\n   end;\r\n  endpos:=digits+ (digits-1) div spaces;\r\n  setlength(result,endpos);\r\n  p:=endpos;\r\n  p2:=1;\r\n  k:=spaces;\r\n  while (p>=p2) do\r\n    begin\r\n      if k=0 then\r\n       begin\r\n         Result[p]:=' ';\r\n         dec(p);\r\n         k:=spaces;\r\n       end;\r\n      Result[P]:=chr(48+(cardinal(value) and 1));\r\n      value:=cardinal(value) shr 1;\r\n      dec(p); \r\n      dec(k);\r\n   end;\r\nend;\r\n\r\nfunction intToBin(Value: Longint; Digits:integer): string;\r\n\r\nvar\r\n    p,p2 : integer;\r\n\r\nbegin\r\n  result:='';\r\n  if digits<=0 then exit;\r\n  setlength(result,digits);\r\n  p:=digits;\r\n  p2:=1;\r\n  // typecasts because we want to keep intto* delphi compat and take an integer\r\n  while (p>=p2) and (cardinal(value)>0) do     \r\n    begin\r\n       Result[p]:=chr(48+(cardinal(value) and 1));\r\n       value:=cardinal(value) shr 1;\r\n       dec(p); \r\n    end;\r\n  digits:=p-p2+1;\r\n  While digits>0 do\r\n    begin\r\n    Result[Digits]:=Chr(48);\r\n    Dec(Digits);\r\n    end;\r\nend;\r\n\r\nfunction IntToBin(Value: NativeInt; Digits:integer): string;\r\nvar\r\n      p,p2 : integer;\r\nbegin\r\n  result:='';\r\n  if digits<=0 then exit;\r\n  setlength(result,digits);\r\n  p:=digits;\r\n  p2:=1;\r\n  // typecasts because we want to keep intto* delphi compat and take a signed val\r\n  // and avoid warnings\r\n  while (p>=p2) and (value>0) do\r\n    begin\r\n       Result[p]:=chr(48+(cardinal(value) and 1));\r\n       value:=value div 2;\r\n       dec(p); \r\n    end;\r\n  digits:=p-p2+1;\r\n  While digits>0 do\r\n    result[digits]:=#48;\r\nend;\r\n\r\n\r\nfunction FindPart(const HelpWilds, inputStr: string): SizeInt;\r\nvar\r\n  Diff, i, J: SizeInt;\r\n\r\nbegin\r\n  Result:=0;\r\n  i:=Pos('?',HelpWilds);\r\n  if (i=0) then\r\n    Result:=Pos(HelpWilds, inputStr)\r\n  else\r\n    begin\r\n    Diff:=Length(inputStr) - Length(HelpWilds);\r\n    for i:=0 to Diff do\r\n      begin\r\n      for J:=1 to Length(HelpWilds) do\r\n        if (inputStr[i + J] = HelpWilds[J]) or (HelpWilds[J] = '?') then\r\n          begin\r\n          if (J=Length(HelpWilds)) then\r\n            begin\r\n            Result:=i+1;\r\n            Exit;\r\n            end;\r\n          end\r\n        else\r\n          Break;\r\n      end;\r\n    end;\r\nend;\r\n\r\nFunction isMatch(level : integer;inputstr,wilds : string; CWild, CinputWord: SizeInt;MaxInputword,maxwilds : SizeInt; Out EOS : Boolean) : Boolean;\r\n\r\nbegin\r\n  EOS:=False;\r\n  Result:=True;\r\n  repeat\r\n    if Wilds[CWild] = '*' then { handling of '*' }\r\n      begin\r\n      inc(CWild);\r\n      while Wilds[CWild] = '?' do { equal to '?' }\r\n        begin\r\n        { goto next letter }\r\n        inc(CWild);\r\n        inc(CinputWord);\r\n        end;\r\n      { increase until a match }\r\n      Repeat\r\n        while (inputStr[CinputWord]<>Wilds[CWild]) and (CinputWord <= MaxinputWord) do\r\n          inc(CinputWord);\r\n        Result:=isMatch(Level+1,inputstr,wilds,CWild, CinputWord,MaxInputword,maxwilds,EOS);\r\n        if not Result then\r\n          Inc(cInputWord);\r\n      Until Result or (CinputWord>=MaxinputWord);\r\n      if Result and EOS then\r\n        Exit;\r\n      Continue;\r\n      end;\r\n    if Wilds[CWild] = '?' then { equal to '?' }\r\n      begin\r\n      { goto next letter }\r\n      inc(CWild);\r\n      inc(CinputWord);\r\n      Continue;\r\n      end;\r\n    if inputStr[CinputWord] = Wilds[CWild] then { equal letters }\r\n      begin\r\n      { goto next letter }\r\n      inc(CWild);\r\n      inc(CinputWord);\r\n      Continue;\r\n      end;\r\n    Result:=false;\r\n    Exit;\r\n  until (CinputWord > MaxinputWord) or (CWild > MaxWilds);\r\n  { no completed evaluation, we need to check what happened }\r\n  if (CinputWord <= MaxinputWord) or (CWild < MaxWilds) then\r\n    Result:=false\r\n  else if (CWild>Maxwilds) then\r\n    EOS:=False\r\n  else\r\n    begin\r\n    EOS:=Wilds[CWild]='*';\r\n    if not EOS then\r\n      Result:=False;\r\n    end\r\nend;\r\n\r\nfunction isWild(inputStr, Wilds: string; ignoreCase: boolean): boolean;\r\n\r\nvar\r\n  i: SizeInt;\r\n  MaxinputWord, MaxWilds: SizeInt; { Length of inputStr and Wilds }\r\n  eos : Boolean;\r\n\r\nbegin\r\n  Result:=true;\r\n  if Wilds = inputStr then\r\n    Exit;\r\n  { delete '**', because '**' = '*' }\r\n  i:=Pos('**', Wilds);\r\n  while i > 0 do\r\n    begin\r\n    Delete(Wilds, i, 1);\r\n    i:=Pos('**', Wilds);\r\n    end;\r\n  if Wilds = '*' then { for fast end, if Wilds only '*' }\r\n    Exit;\r\n  MaxinputWord:=Length(inputStr);\r\n  MaxWilds:=Length(Wilds);\r\n  if (MaxWilds = 0) or (MaxinputWord = 0) then\r\n    begin\r\n    Result:=false;\r\n    Exit;\r\n    end;\r\n  if ignoreCase then { upcase all letters }\r\n    begin\r\n    inputStr:=UpperCase(inputStr);\r\n    Wilds:=UpperCase(Wilds);\r\n    end;\r\n  Result:=isMatch(1,inputStr,wilds,1,1,MaxinputWord, MaxWilds,EOS);\r\nend;\r\n\r\n\r\nfunction XorString(const Key, Src: String): String;\r\nvar\r\n  i: SizeInt;\r\nbegin\r\n  Result:=Src;\r\n  if Length(Key) > 0 then\r\n    for i:=1 to Length(Src) do\r\n      Result[i]:=Chr(Ord(Key[1 + ((i - 1) mod Length(Key))]) xor Ord(Src[i]));\r\nend;\r\n\r\nfunction XorEncode(const Key, Source: string): string;\r\n\r\nvar\r\n  i: Integer;\r\n  C: Byte;\r\n\r\nbegin\r\n  Result:='';\r\n  for i:=1 to Length(Source) do\r\n    begin\r\n    if Length(Key) > 0 then\r\n      C:=Ord(Key[1 + ((i - 1) mod Length(Key))]) xor Ord(Source[i])\r\n    else\r\n      C:=Ord(Source[i]);\r\n    Result:=Result+LowerCase(intToHex(C, 2));\r\n    end;\r\nend;\r\n\r\nfunction XorDecode(const Key, Source: string): string;\r\nvar\r\n  i: Integer;\r\n  C: Char;\r\nbegin\r\n  Result:='';\r\n  for i:=0 to Length(Source) div 2 - 1 do\r\n    begin\r\n    C:=Chr(StrTointDef('$' + Copy(Source, (i * 2) + 1, 2), Ord(' ')));\r\n    if Length(Key) > 0 then\r\n      C:=Chr(Ord(Key[1 + (i mod Length(Key))]) xor Ord(C));\r\n    Result:=Result + C;\r\n    end;\r\nend;\r\n\r\nfunction GetCmdLineArg(const Switch: string; SwitchChars: Array of char): string;\r\nvar\r\n  i: Integer;\r\n  S: string;\r\nbegin\r\n  i:=1;\r\n  Result:='';\r\n  while (Result='') and (i<=ParamCount) do\r\n    begin\r\n    S:=ParamStr(i);\r\n    if (Length(SwitchChars)=0) or (CharInSet(S[1],SwitchChars) and (Length(S) > 1)) and\r\n       (CompareText(Copy(S,2,Length(S)-1),Switch)=0) then\r\n      begin\r\n      inc(i);\r\n      if i<=ParamCount then\r\n        Result:=ParamStr(i);\r\n      end;\r\n    inc(i);\r\n    end;\r\nend;\r\n\r\nFunction RPosEX(C:char;const S : String;offs:cardinal):SizeInt; overload;\r\n\r\nBegin\r\n Result:=TJSString.New(S).lastIndexOf(c,offs-1)+1;\r\nEnd;\r\n\r\nFunction RPos(c:char;const S : String):SizeInt;\r\n\r\nbegin\r\n  Result:=RPosEx(string(C),S,Length(S));\r\nend;\r\n\r\nFunction RPos (Const Substr : String; Const Source : String) : SizeInt; overload;\r\nbegin\r\n  Result:=RPosEx(SubStr,Source,Length(Source));\r\nend;\r\n\r\nFunction RPosex (Const Substr : String; Const Source : String;offs:cardinal) : SizeInt; overload;\r\n\r\nbegin\r\n  Result:=TJSString.New(Source).lastIndexOf(SubStr,offs-1)+1;\r\nend;\r\n\r\nfunction possetex (const c:Array of char;const s : String;count:Integer ):SizeInt;\r\n\r\nvar i,j:SizeInt;\r\n\r\nbegin\r\n  if s='' then\r\n    j:=0\r\n  else\r\n    begin\r\n    i:=length(s);\r\n    j:=count;\r\n    if j>i then\r\n      begin\r\n      result:=0;\r\n      exit;\r\n      end;\r\n    while (j<=i) and (not CharInSet(s[j],c)) do inc(j);\r\n    if (j>i) then\r\n      j:=0;                                         // not found.\r\n    end;\r\n result:=j;\r\nend;\r\n\r\nfunction PosSetEx (const c:string;const s : String;count:Integer ):SizeInt;\r\n\r\nvar\r\n  cset : Array of char;\r\n  i,l    : SizeInt;\r\nbegin\r\n  L:=Length(C);\r\n  SetLength(Cset,L);\r\n  if L>0 then\r\n    for i:=1 to l do\r\n      cset[i-1]:=c[i];\r\n  Result:=PosSetEx(cset,s,count);\r\nend;\r\n\r\nfunction posset (const c:Array of char;const s : String ):SizeInt;\r\n\r\nbegin\r\n  result:=possetex(c,s,1);\r\nend;\r\n\r\nfunction PosSet (const c:string;const s : String ):SizeInt;\r\n\r\nbegin\r\n  Result:=PosSetEx(c,S,1);\r\nend;\r\n\r\n\r\nProcedure Removeleadingchars(Var S : String; Const CSet:Array of char);\r\n\r\nvar\r\n  I,J : Longint;\r\n\r\nbegin\r\n  I:=Length(S);\r\n  if (I>0) then\r\n    begin\r\n    J:=1;\r\n    while (J<=I) and CharInSet(S[J],CSet) DO\r\n      inc(J);\r\n    if J>1 then\r\n      Delete(S,1,J-1);\r\n    end;\r\nend;\r\n\r\n\r\nfunction TrimLeftSet(const S: String;const CSet:Array of char): String;\r\n\r\nbegin\r\n  result:=s;\r\n  removeleadingchars(result,cset); \r\nend;\r\n\r\nProcedure RemoveTrailingChars(VAR S : String;Const CSet:Array of char);\r\n\r\nvar\r\n  i,j : longint;\r\n\r\nbegin\r\n  I:=Length(S);\r\n  if (I>0) then\r\n    begin\r\n    J:=I;\r\n    while (j>0) and CharInSet(S[J],CSet) do\r\n      dec(J);\r\n    if J<>I then\r\n      setLength(S,J);\r\n    End;\r\nEnd;\r\n\r\nFunction TrimRightSet(const S: String;const CSet:Array of char): String;\r\n\r\nbegin\r\n  result:=s;\r\n  RemoveTrailingchars(result,cset); \r\nend;\r\n\r\nProcedure RemovePadChars(VAR S : String;Const CSet:Array of char);\r\n\r\nvar\r\n  I,J,K: longint;\r\n\r\nbegin\r\n  I:=Length(S);\r\n  if I=0 then exit;\r\n  J:=I;\r\n  while (j>0) and CharInset(S[J],CSet) do\r\n    dec(J);\r\n  if j=0 Then\r\n    begin\r\n    s:='';\r\n    exit;\r\n    end;\r\n  SetLength(S,J);\r\n  I:=J;\r\n  k:=1;\r\n  while (k<=I) and CharInSet(S[k],CSet) do\r\n    inc(k);\r\n  if k>1 Then\r\n    Delete(S,1,K-1);\r\nend;\r\n\r\nfunction TrimSet(const S: String;const CSet:Array of char): String;\r\n\r\nbegin\r\n  Result:=s;\r\n  RemovePadChars(Result,cset);\r\nend;\r\n\r\nfunction SplitString(const S, Delimiters: string): TStringDynArray;\r\nbegin\r\n  Result:=S.Split(Delimiters);\r\nend;\r\n\r\nfunction StartsText(const ASubText, AText: string): Boolean;\r\nbegin\r\n  Result := AnsiStartsText(ASubText, AText);\r\nend;\r\n\r\n\r\nfunction EndsText(const ASubText, AText: string): Boolean;\r\nbegin\r\n  Result := AnsiEndsText(ASubText, AText);\r\nend;\r\n\r\nfunction ResemblesText(const AText, AOther: string): Boolean;\r\nbegin\r\n  if Assigned(ResemblesProc) then\r\n    Result := ResemblesProc(AText, AOther)\r\n  else\r\n    Result := False;\r\nend;\r\n\r\nfunction ContainsText(const AText, ASubText: string): Boolean;\r\nbegin\r\n  Result := AnsiContainsText(AText, ASubText);\r\nend;\r\n\r\nfunction MatchText(const AText: string; const AValues: array of string): Boolean;\r\nbegin\r\n  Result := AnsiMatchText(AText, AValues);\r\nend;\r\n\r\nfunction IndexText(const AText: string; const AValues: array of string): Integer;\r\nbegin\r\n  Result := AnsiIndexText(AText, AValues);\r\nend;\r\n\r\nfunction ContainsStr(const AText, ASubText: string): Boolean;\r\nbegin\r\n  Result := AnsiContainsStr(AText, ASubText);\r\nend;\r\n\r\nFunction StartsStr(const ASubText, AText: string): Boolean;\r\n\r\nbegin\r\n  Result := AnsiStartsStr(ASubText, AText);\r\nend;\r\n\r\nFunction EndsStr(const ASubText, AText: string): Boolean;\r\n\r\nbegin\r\n  Result := AnsiEndsStr(ASubText, AText);\r\nend;\r\n\r\n\r\ninitialization\r\n  AnsiResemblesProc:= @SoundexProc;\r\n  ResemblesProc:=@SoundexProc;\r\n\r\nend.\r\n","{\r\n    This file is part of the Free Pascal run time library.\r\n    Copyright (c) 2019-Now by Michael Van Canneyt, member of the\r\n    Free Pascal development team\r\n\r\n    WEB Widget Set\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n{$IFNDEF FPC_DOTTEDUNITS}\r\nunit webwidget;\r\n{$ENDIF}\r\n\r\n{$mode objfpc}{$H+}\r\n{$WARN 4501 off : }\r\n\r\ninterface\r\n\r\nuses\r\n{$IFDEF FPC_DOTTEDUNITS}\r\n  System.Types, System.Classes, System.SysUtils, JSApi.JS, BrowserApi.Web, BrowserApi.WebOrWorker;\r\n{$ELSE}\r\n  Types, Classes, SysUtils, JS, Web, weborworker;\r\n{$ENDIF}\r\n\r\nConst\r\n\r\n  SElementData = 'wwElement';\r\n  STopElementData = SElementData+'Top';\r\n  SContentElementData = SElementData+'Content';\r\n  SElementClass = 'wwClass';\r\n\r\n  sEventAbort = 'abort';\r\n  SEventAnimationCancel = 'animationcancel';\r\n  SEventAnimationEnd = 'animationend';\r\n  SEventAnimationIteration = 'animationiteration';\r\n  SEventAnimationStart = 'animationstart';\r\n  sEventAuxClick = 'auxclick';\r\n  sEventBlur = 'blur';\r\n  SEventCancel = 'cancel';\r\n  SEventCanPlay = 'canplay';\r\n  SEventCanPlayThrough = 'canplaythrough';\r\n  SEventChange = 'change';\r\n  sEventClick = 'click';\r\n  sEventCompositionEnd = 'compositionend';\r\n  sEventCompositionStart = 'compositionstart';\r\n  sEventCompositionUpdate = 'compositionupdate';\r\n  sEventContextMenu = 'contextmenu';\r\n  sEventCopy = 'copy';\r\n  sEventCut = 'cut';\r\n  sEventCueChange = 'cuechange';\r\n  sEventDblClick = 'dblclick';\r\n  sEventDurationChange = 'durationchange';\r\n  sEventEnded  = 'ended';\r\n  sEventError  = 'error';\r\n  sEventFocus = 'focus';\r\n  sEventFocusIn  = 'focusin';\r\n  sEventFocusOut  = 'focusout';\r\n  SEventGotPointerCapture = 'gotpointercapture';\r\n  SEventInput = 'input';\r\n  SEventInvalid = 'invalid';\r\n  sEventKeyDown = 'keydown';\r\n  sEventKeyPress = 'keypress';\r\n  sEventKeyUp = 'keyup';\r\n  sEventLoad = 'load';\r\n  sEventLoadedData = 'loadeddata';\r\n  sEventLoadedMetaData = 'loadedmetadata';\r\n  sEventLoadend = 'loadend';\r\n  sEventLoadStart = 'loadstart';\r\n  SEventLostPointerCapture = 'lostpointercapture';\r\n  sEventMouseDown = 'mousedown';\r\n  sEventMouseEnter = 'mouseenter';\r\n  sEventMouseLeave = 'mouseleave';\r\n  sEventMouseMove = 'mousemove';\r\n  sEventMouseOut = 'mouseout';\r\n  sEventMouseUp = 'mouseup';\r\n  sEventOverFlow = 'overflow';\r\n  sEventPaste = 'paste';\r\n  sEventPause = 'pause';\r\n  sEventPlay = 'play';\r\n  SEventPointerCancel = 'pointercancel';\r\n  SEventPointerDown = 'pointerdown';\r\n  SEventPointerEnter = 'pointerenter';\r\n  SEventPointerLeave = 'pointerleave';\r\n  SEventPointerMove = 'pointermove';\r\n  SEventPointerOut = 'pointerout';\r\n  SEventPointerOver = 'pointerover';\r\n  SEventPointerUp = 'pointerup';\r\n  sEventReset = 'reset';\r\n  sEventResize = 'resize';\r\n  sEventScroll = 'scroll';\r\n  sEventSelect = 'select';\r\n  sEventSubmit = 'submit';\r\n  sEventTouchStart = 'touchstart';\r\n  SEventTransitionCancel = 'transitioncancel';\r\n  SEventTransitionEnd = 'transitionend';\r\n  SEventTransitionRun = 'transitionrun';\r\n  SEventTransitionStart = 'transitionstart';\r\n  SEventWheel = 'wheel';\r\n\r\n\r\nType\r\n  EWidgets = Class(Exception);\r\n  TCustomWebWidget = Class;\r\n\r\n  THTMLNotifyEvent = Procedure (Sender : TObject; Event : TJSEvent) of object;\r\n\r\n\r\n  TEventDispatch = Record\r\n    MsgStr : String;\r\n    HTMLEvent : TJSEvent;\r\n    EventHandler : THTMLNotifyEvent;\r\n  end;\r\n\r\n  { TStyleItem }\r\n  TStylePriority = (spNone,spImportant);\r\n\r\n  TStyleItem = Class(TCollectionItem)\r\n  private\r\n    FPriority: TStylePriority;\r\n    FName: String;\r\n    FValue: String;\r\n    FImported : Boolean;\r\n    procedure SetPriority(AValue: TStylePriority);\r\n    procedure SetValue(AValue: String);\r\n    procedure SetName(AValue: String);\r\n  Protected\r\n    procedure MarkDirty;\r\n  Public\r\n    Property Imported : Boolean read FImported;\r\n    Procedure Assign(Source : TPersistent) ; override;\r\n  Published\r\n    Property Name : String Read FName Write SetName;\r\n    Property Value : String Read FValue Write SetValue;\r\n    Property Priority : TStylePriority Read FPriority Write SetPriority;\r\n  end;\r\n\r\n  { TWebWidgetStyles }\r\n\r\n  TWebWidgetStyles = Class(TOwnedCollection)\r\n  private\r\n    Function GetStyleItem(aIndex : Integer): TStyleItem;\r\n    procedure SetStyleItem(aIndex : Integer; AValue: TStyleItem);\r\n  Protected\r\n    Procedure MarkDirty(aItem : TStyleItem);\r\n    Procedure ApplyToDOM(aElement : TJSHTMlElement;aItem : TStyleItem); virtual; overload;\r\n  Public\r\n    Function Widget : TCustomWebWidget;\r\n    // Manipulate\r\n    Function Add(Const aName : String; const aValue : String= '') : TStyleItem; overload;\r\n    Function EnsureStyle(Const aName : String; const aValue : String= '') : TStyleItem;\r\n    Function IndexOfStyle(Const aName : String) : integer;\r\n    Function FindStyle(Const aName : String) : TStyleItem;\r\n    Function GetStyle(Const aName : String) : TStyleItem;\r\n    Function RemoveStyle(Const aName : String) : String;\r\n    Procedure RefreshFromDOM(aElement : TJSHTMlElement = Nil;DoClear : Boolean = True);virtual;\r\n    Procedure ClearImported;\r\n    Procedure ApplyToDOM(aElement : TJSHTMlElement = Nil); virtual; overload;\r\n    Property Styles[aIndex : Integer] : TStyleItem Read GetStyleItem Write SetStyleItem; default;\r\n  end;\r\n\r\n\r\n  TStyleRefresh = (srOnElementID, // Only refresh styles if ElementID was set and we bind to existing element.\r\n                   srAlways,      // Always refresh styles\r\n                   srNever);      // Never refresh\r\n  TStyleRefreshes = Set of TStyleRefresh;\r\n\r\n  { TReferenceItem }\r\n  TJSHTMLElementArray = Array of TJSHTMLElement;\r\n\r\n  TReferenceItem = Class(TCollectionItem)\r\n  private\r\n    FName: String;\r\n    FSelector: String;\r\n    procedure SetInputValidity(AValue: String);\r\n    procedure SetName(AValue: String);\r\n    procedure SetSelector(AValue: String);\r\n    function GetElement: TJSHTMLElement;\r\n    function GetElements: TJSHTMLElementArray;\r\n  Protected\r\n    procedure SetInputValue(AValue: String); virtual;\r\n    Function GetInputValue : String; virtual;\r\n    Procedure MarkDirty; virtual;\r\n  Public\r\n    Procedure Refresh;\r\n    Function Exists : Boolean;\r\n    Function IsArray : Boolean;\r\n    Function IsInput : Boolean;\r\n    Property Element : TJSHTMLElement Read GetElement;\r\n    Property Elements : TJSHTMLElementArray Read GetElements;\r\n    Property InputValue : String Read GetInputValue Write SetInputValue;\r\n    Property InputValidity : String Write SetInputValidity;\r\n  Published\r\n    Property Selector : String Read FSelector Write SetSelector;\r\n    Property Name : String Read FName Write SetName;\r\n  end;\r\n\r\n  { TWebWidgetReferences }\r\n\r\n  TWebWidgetReferences = Class(TOwnedCollection)\r\n  Private\r\n    FRefs : TJSObject; // Arrays of elements, even for single element\r\n    function GetReferenceItem(aIndex : Integer): TReferenceItem;\r\n    procedure SetReferenceItem(aIndex : Integer; AValue: TReferenceItem);\r\n  Protected\r\n    Procedure MarkDirty(aItem : TReferenceItem);\r\n    Procedure RefreshFromDOM(aItem : TReferenceItem;aElement : TJSHTMlElement);\r\n    Property Refs : TJSObject Read FRefs;\r\n  Public\r\n    Function Widget : TCustomWebWidget;\r\n    // Manipulate\r\n    Function Add(Const aName : String; aSelector : String = '') : TReferenceItem; overload;\r\n    Function EnsureReference(Const aName : String; Const aSelector : String = '') : TReferenceItem;\r\n    Function IndexOfReference(Const aName : String) : Integer;\r\n    Function FindReference(Const aName : String) : TReferenceItem;\r\n    Function GetReference(Const aName : String) : TReferenceItem;\r\n    Procedure RemoveReference(Const aName : String);\r\n    Function ElementExists(Const aName : String) : Boolean;\r\n    Function ElementIsArray(Const aName : String) : Boolean;\r\n    Function FindElementByName(Const aName : String) : TJSHTMLElement;\r\n    Function GetElementByName(Const aName : String) : TJSHTMLElement;\r\n    Function GetElementsByName(Const aName : String) : TJSHTMLElementArray;\r\n    Procedure RefreshFromDOM(aElement : TJSHTMlElement = Nil);virtual;\r\n    Property Items[aIndex : Integer] : TReferenceItem Read GetReferenceItem Write SetReferenceItem;\r\n    Property References[aName : String] : TReferenceItem Read GetReference; default;\r\n  end;\r\n\r\n{$DispatchStrField name}\r\n  { TCustomWebWidget }\r\n\r\n  TCustomWebWidget = Class(TComponent)\r\n  Private\r\n    const MaxEvents = 66;\r\n    Class Var WidgetID : NativeInt;\r\n    Const FEventNames : Array[0..MaxEvents] of String = (\r\n    // When adding, only add at the end !!\r\n    sEventAbort,               //0\r\n    SEventAnimationCancel,\r\n    SEventAnimationEnd,\r\n    SEventAnimationIteration,\r\n    SEventAnimationStart,\r\n    sEventAuxClick ,\r\n    sEventBlur ,\r\n    SEventCancel ,\r\n    SEventCanPlay ,\r\n    SEventCanPlayThrough ,\r\n    SEventChange ,             // 10\r\n    sEventClick ,\r\n    sEventCompositionEnd ,\r\n    sEventCompositionStart ,\r\n    sEventCompositionUpdate ,\r\n    sEventContextMenu ,\r\n    sEventCopy ,\r\n    sEventCut ,\r\n    sEventCueChange ,\r\n    sEventDblClick ,\r\n    sEventDurationChange ,         // 20\r\n    sEventEnded  ,\r\n    sEventError  ,\r\n    sEventFocus ,\r\n    sEventFocusIn  ,\r\n    sEventFocusOut  ,\r\n    SEventGotPointerCapture ,\r\n    SEventInput ,\r\n    SEventInvalid ,\r\n    sEventKeyDown ,\r\n    sEventKeyPress ,                //  30\r\n    sEventKeyUp ,\r\n    sEventLoad ,\r\n    sEventLoadedData ,\r\n    sEventLoadedMetaData ,\r\n    sEventLoadend ,\r\n    sEventLoadStart ,\r\n    SEventLostPointerCapture ,\r\n    sEventMouseDown ,\r\n    sEventMouseEnter ,\r\n    sEventMouseLeave ,                  // 40\r\n    sEventMouseMove ,\r\n    sEventMouseOut ,\r\n    sEventMouseUp ,\r\n    sEventOverFlow ,\r\n    sEventPaste ,\r\n    sEventPause ,\r\n    sEventPlay ,\r\n    SEventPointerCancel ,\r\n    SEventPointerDown ,\r\n    SEventPointerEnter ,\r\n    SEventPointerLeave ,\r\n    SEventPointerMove ,\r\n    SEventPointerOut ,\r\n    SEventPointerOver ,\r\n    SEventPointerUp ,\r\n    sEventReset ,\r\n    sEventResize ,\r\n    sEventScroll ,\r\n    sEventSelect ,\r\n    sEventSubmit ,\r\n    sEventTouchStart ,\r\n    SEventTransitionCancel ,\r\n    SEventTransitionEnd ,\r\n    SEventTransitionRun ,\r\n    SEventTransitionStart ,\r\n    SEventWheel\r\n  );\r\n  private\r\n    FAfterRenderHTML: TNotifyEvent;\r\n    FAfterUnRenderHTML: TNotifyEvent;\r\n    FBeforeRenderHTML: TNotifyEvent;\r\n    FBeforeUnRenderHTML: TNotifyEvent;\r\n    FOnElementBound: TNotifyEvent;\r\n    FParent : TCustomWebWidget;\r\n    FMyHook : TJSRawEventHandler;\r\n    // Set by setting ParentID or Parent\r\n    FParentElement : TJSHTMLElement;\r\n    FElement : TJSHTMLElement;\r\n    FOwnsElement : Boolean;\r\n    FParentID : String;\r\n    FElementID : String;\r\n    FChildren : TJSArray;\r\n    FClasses : String;\r\n    FMyEvents : TJSObject;\r\n    FStyleRefresh: TStyleRefresh;\r\n    FStyles: TWebWidgetStyles;\r\n    FVisible : Boolean;\r\n    FDisplay : String;\r\n    FReferences : TWebWidgetReferences;\r\n    FAttrs : TJSObject;\r\n    function GetChildCount: Integer;\r\n    function GetChild(aIndex : Integer): TCustomWebWidget;\r\n    function GetClasses: String;\r\n    function GetDataset(aName : String): String;\r\n    function GetElement: TJSHTMLELement;\r\n    function GetExternalElement: Boolean;\r\n    function GetFixedElementID: Boolean;\r\n    function GetHaveReferences: Boolean;\r\n    function GetHTMLEvent(AIndex: Integer): THTMLNotifyEvent;\r\n    function GetIsElementDirty: Boolean;\r\n    function GetParent: TCustomWebWidget;\r\n    function GetParentElement: TJSHTMLELement;\r\n    function GetParentID: String;\r\n    function GetElementID: String;\r\n    function GetReference(const aName : string): TJSHTMLElement;\r\n    function GetReferenceItem(aName : String): TReferenceItem;\r\n    function GetReferenceList(const aName : string): TJSHTMLElementArray;\r\n    function GetReferences: TWebWidgetReferences;\r\n    function GetRendered: Boolean;\r\n    function GetVisible: Boolean;\r\n    procedure SetClasses(AValue: String);\r\n    procedure SetDataset(aName : String; AValue: String);\r\n    procedure SetElementID(AValue: String);\r\n    procedure SetHTMLEvent(AIndex: Integer; AValue: THTMLNotifyEvent);\r\n    procedure SetParent(AValue: TCustomWebWidget);\r\n    procedure SetParentID(AValue: String);\r\n    Procedure AddChild(aValue : TCustomWebWidget);\r\n    Procedure RemoveChild(aValue : TCustomWebWidget);\r\n    procedure SetReferences(AValue: TWebWidgetReferences);\r\n    procedure SetStyles(AValue: TWebWidgetStyles);\r\n    procedure SetVisible(AValue: Boolean);\r\n    procedure SetAttr(const aName : string; AValue: String);\r\n    Function GetAttr(const aName : String) : String;\r\n    // This protected section is not meant to be made public\r\n  Protected\r\n    // Events mechanism\r\n    procedure EventEntry(aEvent: TJSEvent); virtual;\r\n    // Low level\r\n    procedure RemoveEvent(aElement: TJSHTMLElement; const aEvent: String);\r\n    procedure HookupEvent(aElement: TJSHTMLElement; const aEvent: String);\r\n    Procedure HookupEvents(aElement : TJSHTMLElement); virtual;\r\n    // Add to internal list, if rendered, calls hookup\r\n    Procedure AddEvent(aName : String; AHandler : THTMLNotifyEvent);\r\n    // Remove from internal list, if rendered, calls RemoveEvent\r\n    Procedure DeleteEvent(aName : String);\r\n    // Override these if you want somehow to grab a fixed element on a page.\r\n    Class Function FixedParent : TJSHTMLElement; virtual;\r\n    Class Function DefaultParentElement : TJSHTMLElement; virtual;\r\n    Class Function DefaultParent : TCustomWebWidget; virtual;\r\n    Class Function FixedElement : TJSHTMLElement; virtual;\r\n    // Generate an ID\r\n    Class function GenerateID: String;\r\n    // Find element in DOM tree.\r\n    Class Function FindElement(aID : String) : TJSHTMLElement;\r\n    // Create element in DOM tree, set ID if it is nonzero\r\n    Class function CreateElement (aTag : String; aID : String) : TJSHTMLElement;\r\n    Class function CreateElement (aParent:TJSElement; aTag : String; aID : String) : TJSHTMLElement;\r\n    // references are relative to this element. By default, this is the element of the widget.\r\n    // override if you want for instance to indicate the parent element.\r\n    function GetReferenceElement: TJSHTMLELement; virtual;\r\n    // override if you want content to go in this sub-element instead of directly below the toplevel element.\r\n    function GetContentElement: TJSHTMLELement; virtual;\r\n    // Override this if Element is not the top element of this widget.\r\n    function GetTopElement: TJSHTMLELement; virtual;\r\n    // Auxiliary function to create a displayable name of this widget\r\n    Function DisplayElementName : String;\r\n    // Called after ElementID was set\r\n    procedure DoOnSetElementID; virtual;\r\n    // Make sure there is an element.\r\n    function EnsureElement: TJSHTMLElement;\r\n    // Set parent element to nil. No rendering is done. Can be called when there are no DOM elements\r\n    Procedure InvalidateParentElement;\r\n    // Set element to nil, clears styles and references. Can be called when there are no DOM elements\r\n    Procedure InvalidateElement; virtual;\r\n    // Name of the tag to create. Set to '' if you don't want RenderHTML to create one.\r\n    Function HTMLTag : String; virtual; abstract;\r\n    // Class names that must always be applied for this widget to work.\r\n    // They are only added during render, and do not show up in classes property.\r\n    // e.g. for a bootstrap button widget, this would return \"btn\"\r\n    Function WidgetClasses : String; virtual;\r\n    // Override this if you want to create custom styles collection\r\n    Function CreateStyles : TWebWidgetStyles; virtual;\r\n    // Override this if you want to create custom references\r\n    Function CreateReferences : TWebWidgetReferences; virtual;\r\n    // Forces apply of visible, sets Visible property\r\n    procedure ApplyVisible(aElement : TJSHTMLElement; AValue: Boolean); virtual;\r\n    // Here all properties from the widget are applied to the element.\r\n    // This is called during RenderHTML, but also when binding ElementID to an Element.\r\n    Procedure ApplyWidgetSettings(aElement : TJSHTMLElement); virtual;\r\n    {\r\n      Actually create & render element.\r\n      This gets the element as created by RenderHTML and the parent as received by RenderHTML.\r\n      If aElement is nil, the DoRenderHTML is responsible for creating & attaching it to the parent element.\r\n      Must return the value for Element.\r\n    }\r\n    Function DoRenderHTML(aParent,aElement : TJSHTMLElement) :TJSHTMLElement; virtual;\r\n    // Apply data to Element, Top and Content. Can only be called when the 3 are set, i.e. after RenderHTML or when Element is set from ElementID.\r\n    Procedure ApplyData; virtual;\r\n    Procedure RemoveData; virtual;\r\n    // Update references\r\n    Procedure RefreshReferences; virtual;\r\n    // Create html. Creates element below parent, and renders HTML using doRenderHTML\r\n    Function RenderHTML(aParent : TJSHTMLELement) : TJSHTMLElement;\r\n    // Override this if you need to do additional actions besides removing top element from parent. Parent is always assigned\r\n    Procedure DoUnRender(aParent : TJSHTMLElement) ; virtual;\r\n    // Remove HTML, if any. aParent can be nil.\r\n    Procedure UnRender(aParent : TJSHTMLElement); overload;\r\n    // Dispatch an event\r\n    Function DispatchEvent(aName : String; aEvent : TJSEvent = Nil) : Boolean;\r\n    // the rendered or attached element if ElementID was set. Can be Nil;\r\n    // This is the \"main\" widget of the rendered HTML. There can be HTML below or HTML before.\r\n    Property Element : TJSHTMLELement Read GetElement;\r\n    // The attached parent element. Obtained through Parent or ParentID. Can be Nil;\r\n    // Not necessarily the parent element of Element, but definitely the parent of TopElement;\r\n    Property ParentElement : TJSHTMLELement Read GetParentElement;\r\n    // Content Element. By default equals Element.\r\n    Property ContentElement : TJSHTMLELement Read GetContentElement;\r\n    // Top Element. The parent element is the direct parent of this element.\r\n    Property TopElement : TJSHTMLELement Read GetTopElement;\r\n    // Is true if this class created the element (i.e. it was not obtained with ElementID)\r\n    Property OwnsElement : Boolean Read FOwnsElement;\r\n    // My Events\r\n    Property MyEvents : TJSObject Read FMyEvents;\r\n    // Return true if the ElementID is referring to an existing element.\r\n    Property ExternalElement : Boolean Read GetExternalElement;\r\n    // since reading references creates the collection, we want a way to see if there are any without creating them.\r\n    Property HaveReferences : Boolean Read GetHaveReferences;\r\n    // Property attrs\r\n    Property StoredAttrs : TJSObject Read FAttrs;\r\n  Public\r\n    Class var CreateDataTags : Boolean;\r\n  Public\r\n    Constructor Create(aOwner : TComponent); override;\r\n    Destructor Destroy; override;\r\n    // Clear content\r\n    Procedure ClearContent; virtual;\r\n    // Does this element allow childern ?\r\n    Class Function AllowChildren : Boolean; virtual;\r\n    // Manipulate Classes\r\n    Class Function AddRemoveClasses(const Source, aAddClasses, aRemoveClasses : String; Normalize : Boolean = false) : String;\r\n    // Number of classes in search and replace must match.\r\n    Class Function ReplaceClasses(const Source, aSearchClasses, aReplaceClasses : String; Normalize : Boolean = false) : String;\r\n    Class Function RemoveClasses(const Source, aClasses : String; Normalize : Boolean = false) : String;\r\n    Class Function RemoveClasses(el : TJSHTMLElement; const aClasses : String; Normalize : Boolean = false) : String;\r\n    Class Function AddClasses(const Source, aClasses : String; Normalize : Boolean = false) : String;\r\n    Class Function AddClasses(el : TJSHTMLElement; const aClasses : String; Normalize : Boolean = false) : String;\r\n    Class Function AddRemoveClasses(el : TJSHTMLElement; const aAddClasses, aRemoveClasses : String; Normalize : Boolean = false) : String;\r\n    // Number of classes in search and replace must match.\r\n    Class Function ReplaceClasses(el : TJSHTMLElement; const aSearchClasses, aReplaceClasses : String; Normalize : Boolean = false) : String;\r\n    // Manipulate styles\r\n    function EnsureStyle(const aName: String): TStyleItem;\r\n    function AddStyle(const aName,aValue: String): TStyleItem;\r\n    function GetStyleValue(const aName : String) : String;\r\n    function RemoveStyle(const aName: String): String;\r\n    // Remove data from dataset\r\n    Procedure RemoveData(const aName : String);\r\n    // Set attributes\r\n    // Re-render\r\n    Procedure Refresh;\r\n    // Unrender\r\n    Procedure Unrender; overload;\r\n    // Focus widget. Will render if it was not yet rendered.\r\n    Procedure Focus;\r\n    // These work on the classes property, and on the current element if rendered. Returns the new value of classes.\r\n    Function AddRemoveClasses(const aAddClasses, aRemoveClasses : String; Normalize : Boolean = false) : String;\r\n    Function ReplaceClasses(const aSearchClasses, aReplaceClasses : String; Normalize : Boolean = false) : String;\r\n    Function RemoveClasses(const aClasses : String; Normalize : Boolean = false) : String;\r\n    Function AddClasses(const aClasses : String; Normalize : Boolean = false) : String;\r\n    // Finding widgets\r\n    Function FindWidgetByID(aElementID : String; Recurse : Boolean = True) : TCustomWebWidget;\r\n    Function GetWidgetByID(aElementID : String; Recurse : Boolean = True) : TCustomWebWidget;\r\n\r\n    // For complex HTML, this is the toplevel element\r\n    Property Parent : TCustomWebWidget Read GetParent Write SetParent;\r\n    // Are we rendered, i.e. is Element valid ?\r\n    Property IsRendered : Boolean Read GetRendered;\r\n    // Do we need to refresh our internal properties from the element? Currently true if rendered.\r\n    // Use this when reading properties and you want/need to refresh a property from the element.\r\n    Property IsElementDirty : Boolean Read GetIsElementDirty;\r\n    // Child widgets. Note that this can differ significantly from\r\n    Property ChildCount : Integer Read GetChildCount;\r\n    Property Children [aIndex : Integer] : TCustomWebWidget Read GetChild;\r\n    Property Data[aName : String] : String Read GetDataset Write SetDataset;\r\n    // This works with style Display: none.\r\n    Property Visible : Boolean Read GetVisible Write SetVisible;\r\n    // Is the ElementID Set\r\n    Property FixedElementID : Boolean Read GetFixedElementID;\r\n    // When the element is bound\r\n    Property OnElementBound : TNotifyEvent Read FOnElementBound Write FOnElementBound;\r\n  // This protected section can be published in descendents\r\n  Protected\r\n    // Parent or Element ID: Will be used when determining the HTML element when rendering.\r\n    // Only one of the Parent or Element ID can be set.\r\n    Property ParentID : String Read GetParentID Write SetParentID;\r\n    Property ElementID : String Read GetElementID Write SetElementID;\r\n    // When reading, returns the actual classes if rendered.\r\n    // When rendering, these classes are added to any existing ones if the element exists.\r\n    Property Classes : String Read GetClasses Write SetClasses;\r\n    // Apply these styles when rendering. Depending on StyleRefresh, styles are imported from actual element.\r\n    Property Styles: TWebWidgetStyles Read FStyles Write SetStyles;\r\n    // When rendering, should we refresh styles ?\r\n    Property StyleRefresh : TStyleRefresh Read FStyleRefresh Write FStyleRefresh;\r\n    // Possible references to sub widgets, based on CSS selectors\r\n    Property References : TWebWidgetReferences Read GetReferences write SetReferences;\r\n    // Direct named acces\r\n    Property Reference[aName : String] : TReferenceItem Read GetReferenceItem;\r\n    // Easy access to an element\r\n    Property Elements[const aName : string] : TJSHTMLElement Read GetReference;\r\n    // Easy access to an element list\r\n    Property ElementList[const aName : string] : TJSHTMLElementArray Read GetReferenceList;\r\n    // Easy access to attributed\r\n    Property Attrs[const aName : string] : String Read GetAttr Write SetAttr;\r\n    // Events of TWebWidget\r\n    Property BeforeRenderHTML : TNotifyEvent Read FBeforeRenderHTML Write FBeforeRenderHTML;\r\n    Property AfterRenderHTML : TNotifyEvent Read FAfterRenderHTML Write FAfterRenderHTML;\r\n    Property BeforeUnRenderHTML : TNotifyEvent Read FBeforeUnRenderHTML Write FBeforeUnRenderHTML;\r\n    Property AfterUnRenderHTML : TNotifyEvent Read FAfterUnRenderHTML Write FAfterUnRenderHTML;\r\n    // HTML DOM events\r\n    Property OnAbort: THTMLNotifyEvent Index 0 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnAnimationCancel: THTMLNotifyEvent Index 1 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnAnimationEnd: THTMLNotifyEvent Index 2 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnAnimationIteration: THTMLNotifyEvent Index 3 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnAnimationStart: THTMLNotifyEvent Index 4 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnAuxClick : THTMLNotifyEvent Index 5 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnBlur : THTMLNotifyEvent Index 6 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnCancel : THTMLNotifyEvent Index 7 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnCanPlay : THTMLNotifyEvent Index 8 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnCanPlayThrough : THTMLNotifyEvent Index 9 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnChange : THTMLNotifyEvent Index 10 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnClick : THTMLNotifyEvent Index 11 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnCompositionEnd : THTMLNotifyEvent Index 12 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnCompositionStart : THTMLNotifyEvent Index 13 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnCompositionUpdate : THTMLNotifyEvent Index 14 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnContextMenu : THTMLNotifyEvent Index 15 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnCopy : THTMLNotifyEvent Index 16 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnCut : THTMLNotifyEvent Index 17 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnCueChange : THTMLNotifyEvent Index 18 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnDblClick : THTMLNotifyEvent Index 19 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnDurationChange : THTMLNotifyEvent Index 20 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnEnded  : THTMLNotifyEvent Index 21 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnError  : THTMLNotifyEvent Index 22 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnFocus : THTMLNotifyEvent Index 23 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnFocusIn  : THTMLNotifyEvent Index 24 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnFocusOut  : THTMLNotifyEvent Index 25 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnGotPointerCapture : THTMLNotifyEvent Index 26 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnInput : THTMLNotifyEvent Index 27 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnInvalid : THTMLNotifyEvent Index 28 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnKeyDown : THTMLNotifyEvent Index 29 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnKeyPress : THTMLNotifyEvent Index 30 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnKeyUp : THTMLNotifyEvent Index 31 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnLoad : THTMLNotifyEvent Index 32 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnLoadedData : THTMLNotifyEvent Index 33 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnLoadedMetaData : THTMLNotifyEvent Index 34 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnLoadend : THTMLNotifyEvent Index 35 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnLoadStart : THTMLNotifyEvent Index 36 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnLostPointerCapture : THTMLNotifyEvent Index 37 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnMouseDown : THTMLNotifyEvent Index 38 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnMouseEnter : THTMLNotifyEvent Index 39 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnMouseLeave : THTMLNotifyEvent Index 40 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnMouseMove : THTMLNotifyEvent Index 41 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnMouseOut : THTMLNotifyEvent Index 42 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnMouseUp : THTMLNotifyEvent Index 43 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnOverFlow : THTMLNotifyEvent Index 44 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnPaste : THTMLNotifyEvent Index 45 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnPause : THTMLNotifyEvent Index 46 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnPlay : THTMLNotifyEvent Index 47 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnPointerCancel : THTMLNotifyEvent Index 48 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnPointerDown : THTMLNotifyEvent Index 49 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnPointerEnter : THTMLNotifyEvent Index 50 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnPointerLeave : THTMLNotifyEvent Index 51 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnPointerMove : THTMLNotifyEvent Index 52 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnPointerOut : THTMLNotifyEvent Index 53 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnPointerOver : THTMLNotifyEvent Index 54 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnPointerUp : THTMLNotifyEvent Index 55 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnReset : THTMLNotifyEvent Index 56 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnResize : THTMLNotifyEvent Index 57 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnScroll : THTMLNotifyEvent Index 58 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnSelect : THTMLNotifyEvent Index 59 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnSubmit : THTMLNotifyEvent Index 60 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnTouchStart : THTMLNotifyEvent Index 61 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnTransitionCancel : THTMLNotifyEvent Index 62 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnTransitionEnd : THTMLNotifyEvent Index 63 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnTransitionRun : THTMLNotifyEvent Index 64 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnTransitionStart : THTMLNotifyEvent Index 65 Read GetHTMLEvent Write SetHTMLEvent;\r\n    Property OnWheel : THTMLNotifyEvent Index 66 Read GetHTMLEvent Write SetHTMLEvent;\r\n  end;\r\n  TCustomWebWidgetClass = Class of TCustomWebWidget;\r\n\r\n  { TWebWidget }\r\n\r\n  TWebWidget = Class(TCustomWebWidget)\r\n  Published\r\n    // Properties\r\n    Property ParentID;\r\n    Property ElementID;\r\n    Property Classes;\r\n    Property Styles;\r\n    Property StyleRefresh;\r\n    Property Visible;\r\n    // Events\r\n    Property BeforeRenderHTML;\r\n    Property AfterRenderHTML;\r\n    Property OnAbort;\r\n    Property OnAnimationCancel;\r\n    Property OnAnimationEnd;\r\n    Property OnAnimationIteration;\r\n    Property OnAnimationStart;\r\n    Property OnAuxClick;\r\n    Property OnBlur;\r\n    Property OnCancel;\r\n    Property OnCanPlay;\r\n    Property OnCanPlayThrough;\r\n    Property OnChange;\r\n    Property OnClick;\r\n    Property OnCompositionEnd;\r\n    Property OnCompositionStart;\r\n    Property OnCompositionUpdate;\r\n    Property OnContextMenu;\r\n    Property OnCopy;\r\n    Property OnCut;\r\n    Property OnCueChange;\r\n    Property OnDblClick;\r\n    Property OnDurationChange;\r\n    Property OnEnded ;\r\n    Property OnError ;\r\n    Property OnFocus;\r\n    Property OnFocusIn ;\r\n    Property OnFocusOut ;\r\n    Property OnGotPointerCapture;\r\n    Property OnInput;\r\n    Property OnInvalid;\r\n    Property OnKeyDown;\r\n    Property OnKeyPress;\r\n    Property OnKeyUp;\r\n    Property OnLoad;\r\n    Property OnLoadedData;\r\n    Property OnLoadedMetaData;\r\n    Property OnLoadend;\r\n    Property OnLoadStart;\r\n    Property OnLostPointerCapture;\r\n    Property OnMouseDown;\r\n    Property OnMouseEnter;\r\n    Property OnMouseLeave;\r\n    Property OnMouseMove;\r\n    Property OnMouseOut;\r\n    Property OnMouseUp;\r\n    Property OnOverFlow;\r\n    Property OnPaste;\r\n    Property OnPause;\r\n    Property OnPlay;\r\n    Property OnPointerCancel;\r\n    Property OnPointerDown;\r\n    Property OnPointerEnter;\r\n    Property OnPointerLeave;\r\n    Property OnPointerMove;\r\n    Property OnPointerOut;\r\n    Property OnPointerOver;\r\n    Property OnPointerUp;\r\n    Property OnReset;\r\n    Property OnResize;\r\n    Property OnScroll;\r\n    Property OnSelect;\r\n    Property OnSubmit;\r\n    Property OnTouchStart;\r\n    Property OnTransitionCancel;\r\n    Property OnTransitionEnd;\r\n    Property OnTransitionRun;\r\n    Property OnTransitionStart;\r\n    Property OnWheel;\r\n  end;\r\n  TWebWidgetClass = Class of TWebWidget;\r\n\r\n  { TContainerWidget }\r\n\r\n  TContainerWidget = Class(TWebWidget)\r\n  private\r\n    const KnownStyleCount = 6;\r\n    Const KnownStyles : Array[0..KnownStyleCount] of string = ('min-width','max-width','min-height','max-height','display','width','height');\r\n    function GetKnownStyle(AIndex: Integer): String;\r\n    procedure SetKnownStyle(AIndex: Integer; AValue: String);\r\n  Public\r\n    Function HTMLTag : String; override;\r\n    Constructor Create(aOwner : TComponent); override;\r\n    Property MinWidth : String Index 0 Read GetKnownStyle Write SetKnownStyle;\r\n    Property MaxWidth : String Index 1 Read GetKnownStyle Write SetKnownStyle;\r\n    Property MinHeight : String Index 2 Read GetKnownStyle Write SetKnownStyle;\r\n    Property MaxHeight : String Index 3 Read GetKnownStyle Write SetKnownStyle;\r\n    Property Display : String Index 4 Read GetKnownStyle Write SetKnownStyle;\r\n    Property Width : String Index 5 Read GetKnownStyle Write SetKnownStyle;\r\n    Property Height : String Index 6 Read GetKnownStyle Write SetKnownStyle;\r\n  end;\r\n\r\n  { TCustomTemplateWidget }\r\n\r\n  TCustomTemplateWidget = Class(TWebWidget)\r\n  private\r\n    FContainerTag: String;\r\n    procedure SetContainerTag(AValue: String);\r\n  Protected\r\n    function GetReferenceElement: TJSHTMLELement; override;\r\n    function GetTemplateHTML: String; virtual; abstract;\r\n    Procedure ApplyTemplate(aElement : TJSHTMLElement); virtual;\r\n    Function DoRenderHTML(aParent, aElement: TJSHTMLElement) : TJSHTMLElement; override;\r\n    // When set, a tag will be created and the template will be rendered below this tag.\r\n    Property ContainerTag : String Read FContainerTag Write SetContainerTag;\r\n  Public\r\n    Function HTMLTag : String; override;\r\n  end;\r\n\r\n  { TSimpleTemplateWidget }\r\n\r\n  TSimpleTemplateWidget = Class(TCustomTemplateWidget)\r\n  Private\r\n    FTemplate: String;\r\n    procedure SetTemplate(AValue: String);\r\n  Protected\r\n    function GetTemplateHTML: String; override;\r\n  Public\r\n    Property Reference;\r\n    Property References;\r\n    Property Elements;\r\n    Property ElementList;\r\n  Published\r\n    // The template.\r\n    Property Template : String Read FTemplate Write SetTemplate;\r\n    Property ContainerTag;\r\n  end;\r\n\r\n\r\n  TTemplateWidget = Class(TCustomTemplateWidget)\r\n  Private\r\n    FTemplate: TStrings;\r\n    procedure DoTemplateChanged(Sender: TObject);\r\n    procedure SetTemplate(AValue: TStrings);\r\n  Protected\r\n    function GetTemplateHTML: String; override;\r\n  Public\r\n    Constructor Create(aOwner : TComponent); override;\r\n    Destructor Destroy; override;\r\n    Property Reference;\r\n    Property References;\r\n    Property Elements;\r\n    Property ElementList;\r\n  Published\r\n    // The template.\r\n    Property Template : TStrings Read FTemplate Write SetTemplate;\r\n    Property ContainerTag;\r\n  end;\r\n\r\n  { TCustomLoopTemplateWidget }\r\n\r\n  { TLoopTemplateValue }\r\n\r\n  TLoopTemplateValue = Class\r\n  Public\r\n    Index : Integer;\r\n    Name : String;\r\n    Value : String;\r\n  end;\r\n  TGetLoopTemplateValueEvent = Procedure (Sender : TObject; aValue : TLoopTemplateValue) of object;\r\n\r\n  { TLoopTemplateGroup }\r\n\r\n  TLoopTemplateGroup = class(TCollectionItem)\r\n  private\r\n    FGroupValue : string;\r\n    FFooterTemplate: String;\r\n    FHeaderTemplate: String;\r\n    FName: string;\r\n    procedure SetFooterTemplate(AValue: String);\r\n    procedure SetHeaderTemplate(AValue: String);\r\n    procedure SetName(AValue: string);\r\n  Public\r\n    function GetDisplayName: string; override;\r\n    Procedure Assign(Source: TPersistent); override;\r\n  Published\r\n    Property Name : string Read FName Write SetName;\r\n    Property HeaderTemplate : String Read FHeaderTemplate Write SetHeaderTemplate;\r\n    Property FooterTemplate : String Read FFooterTemplate Write SetFooterTemplate;\r\n  end;\r\n\r\n  { TLoopTemplateGroupList }\r\n\r\n  TLoopTemplateGroupList = class(TOwnedCollection)\r\n  private\r\n    function GetG(aIndex : Integer): TLoopTemplateGroup;\r\n    procedure SetG(aIndex : Integer; AValue: TLoopTemplateGroup);\r\n  Protected\r\n    procedure Update(Item: TCollectionItem); override;\r\n  Public\r\n    Function IndexOfGroup(const aName : string) : Integer;\r\n    Function FindGroup(const aName : string) : TLoopTemplateGroup;\r\n    Function GetGroup(const aName : string) : TLoopTemplateGroup;\r\n    Function AddGroup(Const aName,aHeader,aFooter : String) : TLoopTemplateGroup;\r\n    Property Groups [aIndex : Integer] : TLoopTemplateGroup Read GetG Write SetG; default;\r\n  end;\r\n\r\n  TCustomLoopTemplateWidget = Class(TCustomTemplateWidget)\r\n  Private\r\n    FFooter: String;\r\n    FGroups: TLoopTemplateGroupList;\r\n    FHeader: String;\r\n    FOnGetValue: TGetLoopTemplateValueEvent;\r\n    FTemplate: String;\r\n    procedure SetFooter(AValue: String);\r\n    procedure SetGroups(AValue: TLoopTemplateGroupList);\r\n    procedure SetHeader(AValue: String);\r\n    procedure SetTemplate(AValue: String);\r\n  Protected\r\n    Type\r\n      { TLoopEnumerator }\r\n      TLoopEnumerator = Class\r\n      private\r\n        FGroup : TLoopTemplateGroup;\r\n        FWidget: TCustomLoopTemplateWidget;\r\n        FIndex : Integer;\r\n        FCurrValues : TLoopTemplateValue;\r\n      public\r\n        constructor Create(AWidget : TCustomLoopTemplateWidget; aValues: TLoopTemplateValue); reintroduce; virtual;\r\n        destructor destroy; override;\r\n        Function GetValue(Const aName : String): String; virtual;\r\n        function MoveNext: Boolean; virtual;\r\n        Property Widget: TCustomLoopTemplateWidget Read FWidget;\r\n        Property Index : Integer Read FIndex;\r\n        Property CurrValues : TLoopTemplateValue Read FCurrValues;\r\n      end;\r\n  Protected\r\n    // Template support\r\n    function GetTemplateHTML: String; override;\r\n    Function RenderTemplate(aEnum : TLoopEnumerator; aTemplate : String) : String; virtual;\r\n    // Grouping support\r\n    function RenderGroupFooters(aStartIndex: Integer; aEnum: TLoopEnumerator): String; virtual;\r\n    function RenderGroupHeaders(aEnum: TLoopEnumerator): String; virtual;\r\n    function GetGroupValue(enum: TLoopEnumerator; aGroupIndex: Integer; aGroup: TLoopTemplateGroup): String; virtual;\r\n    // Create all kinds of helper classes\r\n    Class Function CreateGroups(aOwner : TComponent) : TLoopTemplateGroupList; virtual;\r\n    Class Function CreateCurrValues : TLoopTemplateValue; virtual;\r\n    Function CreateLoopEnumerator (aCurrValues : TLoopTemplateValue) : TLoopEnumerator; virtual; abstract;\r\n  Public\r\n    Constructor Create(aOwner : TComponent); override;\r\n    Destructor Destroy; override;\r\n    Property Elements;\r\n    Property ElementList;\r\n  Protected\r\n    // The templates.\r\n    Property Groups : TLoopTemplateGroupList Read FGroups Write SetGroups;\r\n    Property HeaderTemplate : String Read FHeader Write SetHeader;\r\n    Property ItemTemplate : String Read FTemplate Write SetTemplate;\r\n    Property FooterTemplate : String Read FFooter Write SetFooter;\r\n    Property OnGetValue : TGetLoopTemplateValueEvent Read FOnGetValue Write FOnGetValue;\r\n  end;\r\n\r\n  { TSimpleLoopTemplateWidget }\r\n\r\n  { TSimpleLoopTemplateGroup }\r\n\r\n  TSimpleLoopTemplateGroup = Class(TLoopTemplateGroup)\r\n  private\r\n    FGroupValueTemplate: String;\r\n    procedure SetGroupValueTemplate(AValue: String);\r\n  Published\r\n    Property GroupValueTemplate : String Read FGroupValueTemplate Write SetGroupValueTemplate;\r\n  end;\r\n\r\n  TSimpleLoopTemplateWidget = Class(TCustomLoopTemplateWidget)\r\n  private\r\n    FItemCount: Integer;\r\n    FOnGetGroupValue: TGetLoopTemplateValueEvent;\r\n    procedure SetItemCount(AValue: Integer);\r\n  Protected\r\n    Type\r\n      { TSimpleLoopEnumerator }\r\n      TSimpleLoopEnumerator = Class(TLoopEnumerator)\r\n      private\r\n        FMaxCount: Integer;\r\n      public\r\n        function MoveNext: Boolean; override;\r\n        Property MaxCount : Integer Read FMaxCount;\r\n      end;\r\n  Protected\r\n    Function CreateLoopEnumerator(aCurrValues : TLoopTemplateValue)  : TLoopEnumerator; override;\r\n    function GetGroupValue(aEnum: TLoopEnumerator; aGroupIndex: Integer; aGroup: TLoopTemplateGroup): String; override;\r\n    Class Function CreateGroups(aOwner : TComponent) : TLoopTemplateGroupList; override;\r\n  Published\r\n    Property ItemCount : Integer Read FItemCount Write SetItemCount;\r\n    Property Groups;\r\n    Property HeaderTemplate;\r\n    Property ItemTemplate;\r\n    Property FooterTemplate;\r\n    Property OnGetValue;\r\n    Property OnGetGroupValue : TGetLoopTemplateValueEvent Read FOnGetGroupValue Write FOnGetGroupValue;\r\n    Property References;\r\n    Property ContainerTag;\r\n  end;\r\n\r\n\r\n  { TListLoopTemplateWidget }\r\n\r\n  TListLoopTemplateWidget = Class(TCustomLoopTemplateWidget)\r\n  Public\r\n    Type\r\n      TListKind = (lkCollection,lkFPList,lkList,lkObjectArray,lkJSArray);\r\n      TValueMode = (vmRTTI,vmProperty);\r\n    Const\r\n      ListKindNames : Array[TlistKind] of string = ('Collection','FPList','List','ObjectArray','JSArray');\r\n  private\r\n    FListKind: TListKind;\r\n    FList : JSValue;\r\n    procedure CheckList(aKind: TListKind);\r\n    function GetCollection: TCollection;\r\n    function GetFPList: TFPList;\r\n    function GetJSArray: TJSArray;\r\n    function GetList: TList;\r\n    function GetObjectArray: TObjectDynArray;\r\n    function GetValueMode: TValueMode;\r\n    procedure SetCollection(AValue: TCollection);\r\n    procedure SetFPList(AValue: TFPList);\r\n    procedure SetJSArray(AValue: TJSArray);\r\n    procedure SetList(AValue: TList);\r\n    procedure SetObjectArray(AValue: TObjectDynArray);\r\n  Protected\r\n    Type\r\n      { TListLoopEnumerator }\r\n      TListLoopEnumerator = Class(TLoopEnumerator)\r\n      private\r\n        FArray : TJSArray;\r\n        FCurrent : JSValue;\r\n      public\r\n        function MoveNext: Boolean; override;\r\n        Property Current : JSValue Read FCurrent;\r\n      end;\r\n      { TRTTIListLoopEnumerator }\r\n      TRTTIListLoopEnumerator = Class(TListLoopEnumerator)\r\n      public\r\n        function GetValue(const aName: String): String; override;\r\n      end;\r\n      { TPropListLoopEnumerator }\r\n      TPropListLoopEnumerator = Class(TListLoopEnumerator)\r\n      public\r\n        function GetValue(const aName: String): String; override;\r\n      end;\r\n  Protected\r\n    // Return JS array from list\r\n    Function GetArray : TJSArray;virtual;\r\n    Function CreateLoopEnumerator(aCurrValues : TLoopTemplateValue) : TLoopEnumerator; override;\r\n  Public\r\n    Property Collection : TCollection Read GetCollection Write SetCollection;\r\n    Property FPList : TFPList Read GetFPList Write SetFPList;\r\n    Property List : TList Read GetList Write SetList;\r\n    Property ObjectArray : TObjectDynArray Read GetObjectArray Write SetObjectArray;\r\n    Property JSArray : TJSArray Read GetJSArray Write SetJSArray;\r\n    // What kind of list do we have\r\n    Property ListKind : TListKind Read FListKind;\r\n    // How do we get values from the objects.\r\n    Property ValueMode : TValueMode Read GetValueMode;\r\n  Published\r\n    Property HeaderTemplate;\r\n    Property ItemTemplate;\r\n    Property FooterTemplate;\r\n    Property OnGetValue;\r\n  end;\r\n\r\nimplementation\r\n\r\nuses \r\n{$IFDEF FPC_DOTTEDUNITS}\r\n  System.Strutils, System.TypInfo;\r\n{$ELSE}\r\n  Strutils, TypInfo;\r\n{$ENDIF}\r\n\r\nResourceString\r\n   SErrCannotSetParentAndElementID = 'ElementID and ParentID cannot be set at the same time.';\r\n   SErrCannotRenderWithoutParent = '%s: Cannot render without parent';\r\n   SErrInvalidChildIndex = 'Invalid child index: value %d is not in valid range [0..%d]';\r\n   SErrUnknownStyle = 'Unknown style: %s';\r\n   SErrElementIDNotAllowed = '%s: Setting element ID is not allowed';\r\n   SErrParentIDNotAllowed = '%s: Setting parent ID is not allowed';\r\n   SErrParentNotAllowed = '%s: Setting parent is not allowed';\r\n   SErrChildrenNotAllowed = '%s: Parent does not allow children';\r\n   SErrWidgetNotFound = 'Widget with ID \"%s\" not found.';\r\n   SErrUnknownReference = 'Unknown reference: %s';\r\n   SErrNoElement = '%s: Element reference is empty: \"%s\"';\r\n   SErrNotRendered = 'Cannot perform this operation: Widget not rendered';\r\n   SErrCannotRefreshNoWidget = 'Cannot refresh references without widget';\r\n   SErrNotInput = 'Reference %s is not an input element';\r\n   SErrListNotA = '%s: List is not a %';\r\n   SErrUnknownTemplateGroup = 'Unknown template group item: \"%s\"';\r\n   SErrDuplicateTemplateGroup = 'Duplicate template group item: \"%s\"';\r\n   SErrNoGroupInNonGroupTemplate = 'Group name can only be used group value template';\r\n\r\n{ TSimpleLoopTemplateGroup }\r\n\r\nprocedure TSimpleLoopTemplateGroup.SetGroupValueTemplate(AValue: String);\r\nbegin\r\n  if FGroupValueTemplate=AValue then Exit;\r\n  FGroupValueTemplate:=AValue;\r\n  Changed(False);\r\nend;\r\n\r\n{ TLoopTemplateGroupList }\r\n\r\nfunction TLoopTemplateGroupList.GetG(aIndex : Integer): TLoopTemplateGroup;\r\nbegin\r\n  Result:=TLoopTemplateGroup(Items[aIndex])\r\nend;\r\n\r\nprocedure TLoopTemplateGroupList.SetG(aIndex : Integer; AValue: TLoopTemplateGroup);\r\nbegin\r\n  Items[aIndex]:=aValue;\r\nend;\r\n\r\nprocedure TLoopTemplateGroupList.Update(Item: TCollectionItem);\r\nbegin\r\n  inherited Update(Item);\r\n  if Owner is TCustomLoopTemplateWidget then\r\n    With TCustomLoopTemplateWidget(Owner) do\r\n      if IsRendered then\r\n        Refresh;\r\nend;\r\n\r\nfunction TLoopTemplateGroupList.IndexOfGroup(const aName: string): Integer;\r\nbegin\r\n  Result:=Count-1;\r\n  While (Result>=0) and Not SameText(GetG(Result).Name,aName) do\r\n    Dec(Result);\r\nend;\r\n\r\nfunction TLoopTemplateGroupList.FindGroup(const aName: string): TLoopTemplateGroup;\r\n\r\nVar\r\n  Idx: Integer;\r\n\r\nbegin\r\n  Idx:=IndexOfGroup(aName);\r\n  if (Idx=-1) then\r\n    Result:=Nil\r\n  else\r\n    Result:=GetG(Idx);\r\nend;\r\n\r\nfunction TLoopTemplateGroupList.GetGroup(const aName: string): TLoopTemplateGroup;\r\nbegin\r\n  Result:=FindGroup(aName);\r\n  if (Result=Nil) then\r\n    raise EWidgets.CreateFmt(SErrUnknownTemplateGroup, [aName]);\r\nend;\r\n\r\nfunction TLoopTemplateGroupList.AddGroup(const aName, aHeader, aFooter: String): TLoopTemplateGroup;\r\nbegin\r\n  if IndexOfGroup(aName)<>-1 then\r\n    raise EWidgets.CreateFmt(SErrDuplicateTemplateGroup, [aName]);\r\n  Result:=add as TLoopTemplateGroup;\r\n  Result.Name:=aName;\r\n  Result.FFooterTemplate:=aFooter;\r\n  Result.HeaderTemplate:=aHeader;\r\nend;\r\n\r\n{ TLoopTemplateGroup }\r\n\r\nprocedure TLoopTemplateGroup.SetFooterTemplate(AValue: String);\r\nbegin\r\n  if FFooterTemplate=AValue then Exit;\r\n  FFooterTemplate:=AValue;\r\n  Changed(False);\r\nend;\r\n\r\nprocedure TLoopTemplateGroup.SetHeaderTemplate(AValue: String);\r\nbegin\r\n  if FHeaderTemplate=AValue then Exit;\r\n  FHeaderTemplate:=AValue;\r\n  Changed(False);\r\nend;\r\n\r\nprocedure TLoopTemplateGroup.SetName(AValue: string);\r\nbegin\r\n  if FName=AValue then Exit;\r\n  if Assigned(Collection) then\r\n    if TLoopTemplateGroupList(Collection).IndexOfGroup(aValue)<>-1 then\r\n      raise EWidgets.CreateFmt(SErrDuplicateTemplateGroup, [aValue]);\r\n  FName:=AValue;\r\nend;\r\n\r\nfunction TLoopTemplateGroup.GetDisplayName: string;\r\nbegin\r\n  Result:=Name;\r\n  if Result='' then\r\n    Result:=Inherited GetDisplayName;\r\nend;\r\n\r\nprocedure TLoopTemplateGroup.Assign(Source: TPersistent);\r\n\r\nVar\r\n  G : TLoopTemplateGroup;\r\n\r\nbegin\r\n  if Source is TLoopTemplateGroup then\r\n    begin\r\n    G:=Source as TLoopTemplateGroup;\r\n    FName:=G.Name;\r\n    FHeaderTemplate:=G.HeaderTemplate;\r\n    FFooterTemplate:=G.FooterTemplate;\r\n    end\r\n  else\r\n    inherited Assign(Source);\r\nend;\r\n\r\n{ TListLoopTemplateWidget.TPropListLoopEnumerator }\r\n\r\nfunction TListLoopTemplateWidget.TPropListLoopEnumerator.GetValue(const aName: String): String;\r\n\r\nVar\r\n  V : JSValue;\r\n\r\nbegin\r\n  V:=TJSObject(Current)[aName];\r\n  if IsDefined(V) then\r\n    Result:=String(V);\r\nend;\r\n\r\n{ TListLoopTemplateWidget.TRTTIListLoopEnumerator }\r\n\r\nfunction TListLoopTemplateWidget.TRTTIListLoopEnumerator.GetValue(const aName: String): String;\r\n\r\nConst\r\n  AllowedTypes = [tkInteger,tkChar, tkString, tkEnumeration, tkSet,tkDouble, tkBool, tkJSValue];\r\n\r\nVar\r\n  O : TObject;\r\n  MP : TTypeMemberProperty;\r\n\r\nbegin\r\n  O:=TObject(Current);\r\n  MP:=GetPropInfo(O,aName,AllowedTypes);\r\n  if Assigned(Mp) then\r\n    case MP.TypeInfo.Kind of\r\n     tkInteger : Result:=IntToStr(GetOrdProp(O,MP));\r\n     tkChar,\r\n     tkString : Result:=GetStrProp(O,MP);\r\n     tkEnumeration : Result:=GetEnumName(TTypeInfoEnum(MP.TypeInfo),GetOrdProp(O,MP));\r\n     tkSet : Result:=GetSetProp(O,MP);\r\n     tkDouble : Result:=FloatToStr(GetFloatProp(O,MP));\r\n     tkBool : Result:=BoolToStr(GetBoolProp(O,MP));\r\n     tkJSValue : Result:=String(GetJSValueProp(O,MP));\r\n    end;\r\nend;\r\n\r\n{ TListLoopTemplateWidget.TListLoopEnumerator }\r\n\r\nfunction TListLoopTemplateWidget.TListLoopEnumerator.MoveNext: Boolean;\r\nbegin\r\n  Result:=Index<FArray.Length-1;\r\n  Result:=inherited MoveNext;\r\n  if Result then\r\n    FCurrent:=FArray[Index];\r\nend;\r\n\r\n{ TListLoopTemplateWidget }\r\n\r\n\r\nprocedure TListLoopTemplateWidget.CheckList(aKind: TListKind);\r\n\r\nbegin\r\n  If FListKind<>aKind then\r\n    Raise EWidgets.CreateFmt(SErrListNotA,[DisplayElementName,ListKindNames[aKind]]);\r\nend;\r\n\r\nfunction TListLoopTemplateWidget.GetCollection: TCollection;\r\nbegin\r\n  CheckList(lkCollection);\r\n  Result:=TCollection(FList)\r\nend;\r\n\r\nfunction TListLoopTemplateWidget.GetFPList: TFPList;\r\nbegin\r\n  CheckList(lkFPList);\r\n  Result:=TFPList(FList)\r\nend;\r\n\r\nfunction TListLoopTemplateWidget.GetJSArray: TJSArray;\r\nbegin\r\n  CheckList(lkJSArray);\r\n  Result:=TJSArray(FList)\r\nend;\r\n\r\nfunction TListLoopTemplateWidget.GetList: TList;\r\nbegin\r\n  CheckList(lkList);\r\n  Result:=TList(FList)\r\nend;\r\n\r\nfunction TListLoopTemplateWidget.GetObjectArray: TObjectDynArray;\r\nbegin\r\n  CheckList(lkObjectArray);\r\n  Result:=TObjectDynArray(FList);\r\nend;\r\n\r\n\r\nfunction TListLoopTemplateWidget.GetValueMode: TValueMode;\r\nbegin\r\n  if ListKind in [lkCollection,lkFPList,lkList,lkObjectArray] then\r\n    Result:=vmRTTI\r\n  else\r\n    Result:=vmProperty;\r\nend;\r\n\r\nprocedure TListLoopTemplateWidget.SetCollection(AValue: TCollection);\r\nbegin\r\n  Flist:=aValue;\r\n  FListKind:=lkCollection;\r\nend;\r\n\r\nprocedure TListLoopTemplateWidget.SetFPList(AValue: TFPList);\r\nbegin\r\n  Flist:=aValue;\r\n  FListKind:=lkFPList;\r\nend;\r\n\r\nprocedure TListLoopTemplateWidget.SetJSArray(AValue: TJSArray);\r\nbegin\r\n  FList:=AValue;\r\n  FListKind:=lkJSArray;\r\nend;\r\n\r\nprocedure TListLoopTemplateWidget.SetList(AValue: TList);\r\nbegin\r\n  Flist:=aValue;\r\n  FListKind:=lkList;\r\nend;\r\n\r\nprocedure TListLoopTemplateWidget.SetObjectArray(AValue: TObjectDynArray);\r\nbegin\r\n  FListKind:=lkObjectArray;\r\n  FList:=aValue;\r\nend;\r\n\r\n\r\nfunction TListLoopTemplateWidget.GetArray: TJSArray;\r\n\r\nVar\r\n  I : integer;\r\n  C : TCollection;\r\nbegin\r\n  Case FListKind of\r\n    lkCollection :\r\n      begin\r\n      C:=TCollection(Flist);\r\n      Result:=TJSArray.New(C.Count);\r\n      for I:=0 To C.Count-1 do\r\n        Result[i]:=C.Items[i];\r\n      end;\r\n    lkFPList:\r\n      Result:=TJSArray(TFPList(FList).List);\r\n    lkList:\r\n      Result:=TJSArray(TList(FList).List);\r\n    lkJSArray,\r\n    lkObjectArray :\r\n      Result:=TJSArray(FList);\r\n    end;\r\nend;\r\n\r\nfunction TListLoopTemplateWidget.CreateLoopEnumerator(aCurrValues : TLoopTemplateValue) : TLoopEnumerator;\r\n\r\nbegin\r\n  Case ValueMode of\r\n    vmRTTI     : Result:=TRTTIListLoopEnumerator.Create(Self,aCurrValues);\r\n    vmProperty : Result:=TPropListLoopEnumerator.Create(Self,aCurrValues);\r\n  end;\r\n  TListLoopEnumerator(Result).FArray:=GetArray;\r\nend;\r\n\r\n{ TSimpleLoopTemplateWidget.TSimpleLoopEnumerator }\r\n\r\nfunction TSimpleLoopTemplateWidget.TSimpleLoopEnumerator.MoveNext: Boolean;\r\nbegin\r\n  Result:=(Index<MaxCount-1);\r\n  if Result then\r\n    Inherited MoveNext;\r\nend;\r\n\r\n{ TSimpleLoopTemplateWidget }\r\n\r\nprocedure TSimpleLoopTemplateWidget.SetItemCount(AValue: Integer);\r\nbegin\r\n  if FItemCount=AValue then Exit;\r\n  FItemCount:=AValue;\r\n  if IsRendered then\r\n    Refresh;\r\nend;\r\n\r\nfunction TSimpleLoopTemplateWidget.CreateLoopEnumerator(aCurrValues : TLoopTemplateValue) : TLoopEnumerator;\r\n\r\nVar\r\n  L : TSimpleLoopEnumerator;\r\n\r\nbegin\r\n  L:=TSimpleLoopEnumerator.Create(Self,aCurrValues);\r\n  L.FMaxCount:=Self.ItemCount;\r\n  Result:=L;\r\nend;\r\n\r\nfunction TSimpleLoopTemplateWidget.GetGroupValue(aEnum: TLoopEnumerator; aGroupIndex: Integer; aGroup: TLoopTemplateGroup): String;\r\nbegin\r\n  aEnum.CurrValues.Name:=aGroup.Name;\r\n  if TSimpleLoopTemplateGroup(aGroup).GroupValueTemplate<>'' then\r\n    aEnum.FCurrValues.Value:=RenderTemplate(aEnum,TSimpleLoopTemplateGroup(aGroup).GroupValueTemplate);\r\n  if Assigned(OnGetGroupValue) then\r\n    OnGetGroupValue(Self,aEnum.CurrValues);\r\n  Result:=aEnum.CurrValues.Value;\r\n  // Writeln('Group Value: ',aEnum.CurrValues.Value,' for ',aGroup.Name);\r\nend;\r\n\r\nclass function TSimpleLoopTemplateWidget.CreateGroups(aOwner: TComponent): TLoopTemplateGroupList;\r\nbegin\r\n  Result:=TLoopTemplateGroupList.Create(aOwner,TSimpleLoopTemplateGroup)\r\nend;\r\n\r\n{ TCustomLoopTemplateWidget }\r\n\r\nprocedure TCustomLoopTemplateWidget.SetTemplate(AValue: String);\r\nbegin\r\n  if FTemplate=aValue then exit;\r\n  FTemplate:=aValue;\r\n  if IsRendered then\r\n    Refresh;\r\nend;\r\n\r\nClass function TCustomLoopTemplateWidget.CreateGroups(aOwner : TComponent): TLoopTemplateGroupList;\r\nbegin\r\n  Result:=TLoopTemplateGroupList.Create(AOwner,TLoopTemplateGroup);\r\nend;\r\n\r\nClass function TCustomLoopTemplateWidget.CreateCurrValues: TLoopTemplateValue;\r\nbegin\r\n  Result:=TLoopTemplateValue.Create;\r\nend;\r\n\r\nfunction TCustomLoopTemplateWidget.RenderTemplate(aEnum: TLoopEnumerator; aTemplate: String): String;\r\n\r\nVar\r\n  E : TJSRegexp;\r\n\r\nbegin\r\n  E:=TJSRegexp.New('{{([_\\w]*)}}','g');\r\n  Result:=TJSString(aTemplate).Replace(E,Function (Const match,p1 : string; offset : Integer; AString : String) : string\r\n  begin\r\n    aEnum.CurrValues.Value:=aEnum.GetValue(p1);\r\n    // Writeln(p1,' -> ',aEnum.CurrValues.Value);\r\n    if Assigned(OnGetValue) then\r\n      begin\r\n      aEnum.CurrValues.Index:=aEnum.Index;\r\n      aEnum.CurrValues.Name:=P1;\r\n      OnGetValue(Self,aEnum.CurrValues);\r\n      end;\r\n    Result:=AEnum.CurrValues.Value;\r\n  end);\r\nend;\r\n\r\nprocedure TCustomLoopTemplateWidget.SetFooter(AValue: String);\r\nbegin\r\n  if FFooter=AValue then Exit;\r\n  FFooter:=AValue;\r\n  if IsRendered then\r\n    Refresh;\r\nend;\r\n\r\nprocedure TCustomLoopTemplateWidget.SetGroups(AValue: TLoopTemplateGroupList);\r\nbegin\r\n  if FGroups=AValue then Exit;\r\n  FGroups.Assign(AValue);\r\n  if IsRendered then\r\n    Refresh;\r\nend;\r\n\r\nprocedure TCustomLoopTemplateWidget.SetHeader(AValue: String);\r\nbegin\r\n  if FHeader=AValue then Exit;\r\n  FHeader:=AValue;\r\n  if IsRendered then\r\n    Refresh;\r\nend;\r\n\r\nfunction TCustomLoopTemplateWidget.GetGroupValue(enum : TLoopEnumerator; aGroupIndex : Integer; aGroup : TLoopTemplateGroup) : String;\r\n\r\nbegin\r\n  Result:=aGroup.Name;\r\nend;\r\n\r\nfunction TCustomLoopTemplateWidget.RenderGroupHeaders(aEnum : TLoopEnumerator) : String;\r\n\r\nVar\r\n  ChangeIdx,GrpIdx: Integer;\r\n  grp : TLoopTemplateGroup;\r\n  S,V : String;\r\n\r\nbegin\r\n  // Writeln('Rendering group headers for row ',aEnum.Index);\r\n  Result:='';\r\n  // Determine level at which there is a change.\r\n  if aEnum.Index=0 then\r\n    ChangeIdx:=0\r\n  else\r\n    begin\r\n    ChangeIdx:=-1;\r\n    GrpIdx:=0;\r\n    While (ChangeIdx=-1) and (GrpIdx<Groups.Count) do\r\n      begin\r\n      Grp:=Groups[GrpIdx];\r\n      V:=GetGroupValue(aEnum,GrpIdx,Grp);\r\n      if (V<>Grp.FGroupValue)  then\r\n        ChangeIdx:=GrpIdx;\r\n      Inc(GrpIdx);\r\n      end;\r\n    end;\r\n  if ChangeIdx>=0 then\r\n    begin\r\n    Grp:=Groups[ChangeIdx];\r\n    // Writeln('Change at group ', ChangeIdx, ' : ',V,'<>',Grp.FGroupValue);\r\n    if aEnum.Index>0 then\r\n      begin\r\n      // Writeln('Closing footers up to ',GrpIdx);\r\n      aEnum.FGroup:=Grp;\r\n      Result:=Result+RenderGroupFooters(ChangeIdx,aEnum);\r\n      end;\r\n    for GrpIdx:=ChangeIdx to Groups.Count-1 do\r\n      begin\r\n      Grp:=Groups[GrpIdx];\r\n      V:=GetGroupValue(aEnum,GrpIdx,Grp);\r\n      Grp.FGroupValue:=V;\r\n      // Writeln('Group ',Grp.Name, ' header for value ',V);\r\n      aEnum.FGroup:=Grp;\r\n      S:=RenderTemplate(aEnum,Grp.HeaderTemplate);\r\n      // Writeln('Rendering group ',Grp.Name,' (',V,') header template: ',Grp.HeaderTemplate,' : ',S);\r\n      Result:=Result+S;\r\n      end;\r\n    aEnum.FGroup:=Nil;\r\n    end;\r\nend;\r\n\r\nfunction TCustomLoopTemplateWidget.RenderGroupFooters(aStartIndex : Integer; aEnum : TLoopEnumerator) : String;\r\n\r\n\r\nVar\r\n  GrpIdx : Integer;\r\n  grp : TLoopTemplateGroup;\r\n\r\nbegin\r\n  Result:='';\r\n  For GrpIdx:=Groups.Count-1 downto aStartIndex do\r\n    begin\r\n    Grp:=Groups[GrpIdx];\r\n    Result:=Result+RenderTemplate(aEnum,Grp.FooterTemplate);\r\n    end;\r\nend;\r\n\r\nfunction TCustomLoopTemplateWidget.GetTemplateHTML: String;\r\n\r\nVar\r\n  Enum : TLoopEnumerator;\r\n\r\nbegin\r\n  Enum:=CreateLoopEnumerator(CreateCurrValues);\r\n  try\r\n    Result:=RenderTemplate(Enum,HeaderTemplate);\r\n    While enum.MoveNext do\r\n      begin\r\n      if Groups.Count>0 then\r\n        Result:=Result+RenderGroupHeaders(Enum);\r\n      Result:=Result+RenderTemplate(Enum,ItemTemplate);\r\n      end;\r\n    if Groups.Count>0 then\r\n      Result:=Result+RenderGroupFooters(0,Enum);\r\n    Result:=Result+RenderTemplate(Enum,FooterTemplate);\r\n  finally\r\n    Enum.Free;\r\n  end;\r\nend;\r\n\r\nconstructor TCustomLoopTemplateWidget.Create(aOwner: TComponent);\r\nbegin\r\n  inherited Create(aOwner);\r\n  FGroups:=CreateGroups(Self);\r\nend;\r\n\r\ndestructor TCustomLoopTemplateWidget.Destroy;\r\nbegin\r\n  FreeAndNil(FGroups);\r\n  inherited Destroy;\r\nend;\r\n\r\n\r\n{ TCustomLoopTemplateWidget.TLoopEnumerator }\r\n\r\nconstructor TCustomLoopTemplateWidget.TLoopEnumerator.Create(AWidget: TCustomLoopTemplateWidget; aValues: TLoopTemplateValue);\r\nbegin\r\n  FWidget:=AWidget;\r\n  FCurrValues:=aValues;\r\n  FIndex:=-1;\r\nend;\r\n\r\ndestructor TCustomLoopTemplateWidget.TLoopEnumerator.destroy;\r\nbegin\r\n  FreeAndNil(FCurrValues);\r\n  inherited destroy;\r\nend;\r\n\r\nfunction TCustomLoopTemplateWidget.TLoopEnumerator.GetValue(const aName: String): String;\r\nbegin\r\n  Case AName of\r\n   '_index_' : Result:=IntToStr(Index);\r\n   '_row_' : Result:=IntToStr(Index+1);\r\n   '_group_' : if Assigned(FGroup) then\r\n                 Result:=FGroup.FGroupValue\r\n               else\r\n                 Raise EWidgets.Create(SErrNoGroupInNonGroupTemplate);\r\n  else\r\n    Result:='';\r\n  end;\r\nend;\r\n\r\nfunction TCustomLoopTemplateWidget.TLoopEnumerator.MoveNext: Boolean;\r\nbegin\r\n  Result:=True;\r\n  Inc(FIndex);\r\n  FCurrValues.Index:=FIndex;\r\nend;\r\n\r\n{ TSimpleTemplateWidget }\r\n\r\nprocedure TSimpleTemplateWidget.SetTemplate(AValue: String);\r\n\r\nbegin\r\n  FTemplate:=AValue;\r\n  if isRendered then\r\n    Refresh;\r\nend;\r\n\r\nfunction TSimpleTemplateWidget.GetTemplateHTML: String;\r\nbegin\r\n  Result:=FTemplate;\r\nend;\r\n\r\n\r\n{ TWebWidgetReferences }\r\n\r\nfunction TWebWidgetReferences.GetReferenceItem(aIndex : Integer): TReferenceItem;\r\nbegin\r\n  Result:=TReferenceItem(Inherited Items[aIndex])\r\nend;\r\n\r\nprocedure TWebWidgetReferences.SetReferenceItem(aIndex : Integer; AValue: TReferenceItem);\r\nbegin\r\n  Items[aIndex]:=aValue;\r\nend;\r\n\r\nprocedure TWebWidgetReferences.MarkDirty(aItem: TReferenceItem);\r\nbegin\r\n  if Assigned(Widget) and Assigned(Widget.Element) then\r\n    RefreshFromDOM(aItem,Widget.GetReferenceElement)\r\nend;\r\n\r\nprocedure TWebWidgetReferences.RefreshFromDOM(aItem: TReferenceItem; aElement: TJSHTMlElement);\r\n\r\nVar\r\n  a : TJSHTMlElementArray;\r\n  Nodes : TJSNodeList;\r\n  I : integer;\r\n\r\nbegin\r\n  if aElement=Nil then\r\n    begin\r\n    if (Widget=Nil) then\r\n      Raise EWidgets.Create(SErrCannotRefreshNoWidget);\r\n    if (Widget.Element=Nil) then\r\n      Raise EWidgets.Create(SErrNotRendered);\r\n    aElement:=Widget.GetReferenceElement;\r\n    end;\r\n  if FRefs=Nil then\r\n    FRefs:=New([]);\r\n  try\r\n    Nodes:=aElement.querySelectorAll(aItem.Selector);\r\n    SetLength(a,Nodes.length);\r\n    For I:=0 to Nodes.length-1 do\r\n      A[i]:=TJSHTMLElement(Nodes[i]);\r\n  except\r\n    SetLength(a,0);\r\n  end;\r\n  FRefs[LowerCase(aItem.Name)]:=A;\r\nend;\r\n\r\nfunction TWebWidgetReferences.Widget: TCustomWebWidget;\r\nbegin\r\n  Result:=TCustomWebWidget(owner);\r\nend;\r\n\r\nfunction TWebWidgetReferences.Add(const aName: String; aSelector: String): TReferenceItem;\r\nbegin\r\n  Result:=Add as TReferenceItem;\r\n  Result.FName:=aName;\r\n  Result.Selector:=aSelector;\r\n  if (aSelector<>'') then\r\n    MarkDirty(Result)\r\nend;\r\n\r\nfunction TWebWidgetReferences.EnsureReference(const aName: String; const aSelector: String): TReferenceItem;\r\nbegin\r\n  Result:=FindReference(aName);\r\n  if Result=Nil then\r\n    Result:=Add(aName,aSelector);\r\nend;\r\n\r\nfunction TWebWidgetReferences.IndexOfReference(const aName: String): Integer;\r\nbegin\r\n  Result:=Count-1;\r\n  While (Result>=0) and not SameText(GetReferenceItem(Result).Name,aName) do\r\n    Dec(Result);\r\nend;\r\n\r\nfunction TWebWidgetReferences.FindReference(const aName: String): TReferenceItem;\r\n\r\nVar\r\n  Idx:Integer;\r\n\r\nbegin\r\n  Idx:=IndexOfReference(aName);\r\n  if Idx=-1 then\r\n    Result:=Nil\r\n  else\r\n    Result:=GetReferenceItem(Idx)\r\nend;\r\n\r\nfunction TWebWidgetReferences.GetReference(const aName: String): TReferenceItem;\r\nbegin\r\n  Result:=FindReference(aName);\r\n  if (Result=Nil) then\r\n    Raise EWidgets.CreateFmt(SErrUnknownReference,[aName]);\r\nend;\r\n\r\nprocedure TWebWidgetReferences.RemoveReference(const aName: String);\r\nVar\r\n  Idx:Integer;\r\n\r\nbegin\r\n  Idx:=IndexOfReference(aName);\r\n  if Idx<>-1 then\r\n    Delete(Idx);\r\nend;\r\n\r\nfunction TWebWidgetReferences.ElementExists(const aName: String): Boolean;\r\n\r\nVar\r\n  V : JSValue;\r\nbegin\r\n  Result:=Assigned(FRefs);\r\n  if Result then\r\n    begin\r\n    V:=FRefs[LowerCase(aName)];\r\n    Result:=Assigned(V);\r\n    end;\r\nend;\r\n\r\nfunction TWebWidgetReferences.ElementIsArray(const aName: String): Boolean;\r\nVar\r\n  V : JSValue;\r\nbegin\r\n  Result:=Assigned(FRefs);\r\n  if Result then\r\n    begin\r\n    V:=FRefs[LowerCase(aName)];\r\n    Result:=isArray(V) and (TJSArray(V).Length>1);\r\n    end;\r\nend;\r\n\r\nfunction TWebWidgetReferences.FindElementByName(const aName: String): TJSHTMLElement;\r\nVar\r\n  J : JSValue;\r\n  Arr : TJSArray absolute J;\r\n\r\nbegin\r\n  Result:=Nil;\r\n  if FRefs=Nil then\r\n    exit;\r\n  J:=FRefs[LowerCase(aName)];\r\n  if isArray(J) and (Arr.Length>0) then\r\n    Result:=TJSHTMLElement(Arr[0])\r\nend;\r\n\r\nfunction TWebWidgetReferences.GetElementByName(const aName: String): TJSHTMLElement;\r\n\r\nbegin\r\n  Result:=FindElementByName(aName);\r\n  if Result=Nil then\r\n    Raise EWidgets.CreateFmt(SErrNoElement,[Widget.DisplayElementName,aName]);\r\nend;\r\n\r\nfunction TWebWidgetReferences.GetElementsByName(const aName: String): TJSHTMLElementArray;\r\nVar\r\n  J : JSValue;\r\n  Arr : TJSArray absolute J;\r\n\r\nbegin\r\n  Result:=Nil;\r\n  if FRefs=Nil then\r\n    exit;\r\n  J:=FRefs[LowerCase(aName)];\r\n  if isArray(J) and (Arr.Length>0) then\r\n    Result:=TJSHTMLElementArray(Arr)\r\nend;\r\n\r\nprocedure TWebWidgetReferences.RefreshFromDOM(aElement: TJSHTMlElement);\r\n\r\nVar\r\n  I : Integer;\r\n\r\nbegin\r\n  For I:=0 to Count-1 do\r\n    RefreshFromDOM(GetReferenceItem(I),aElement);\r\nend;\r\n\r\n{ TReferenceItem }\r\n\r\nprocedure TReferenceItem.SetName(AValue: String);\r\nbegin\r\n  if FName=AValue then Exit;\r\n  FName:=AValue;\r\n  MarkDirty;\r\nend;\r\n\r\nprocedure TReferenceItem.SetInputValidity(AValue: String);\r\nbegin\r\n  if IsInput then\r\n    // this is not quite correct, but will work\r\n    TJSHTMLInputElement(Element).setCustomValidity(aValue)\r\n  else\r\n    Raise EWidgets.CreateFmt(SErrNotInput,[Name]);\r\nend;\r\n\r\nfunction TReferenceItem.GetElement: TJSHTMLElement;\r\nbegin\r\n  if Assigned(Collection) then\r\n    Result:=(Collection as TWebWidgetReferences).GetElementByName(Name)\r\n  else\r\n    Result:=Nil;\r\nend;\r\n\r\nfunction TReferenceItem.GetElements: TJSHTMLElementArray;\r\nbegin\r\n  if Assigned(Collection) then\r\n    Result:=(Collection as TWebWidgetReferences).GetElementsByName(Name)\r\n  else\r\n    Result:=Nil;\r\nend;\r\n\r\nprocedure TReferenceItem.SetInputValue(AValue: String);\r\nbegin\r\n  if IsInput then\r\n    TJSObject(Element)['value']:=aValue\r\n  else\r\n    Raise EWidgets.CreateFmt(SErrNotInput,[Name])\r\nend;\r\n\r\nprocedure TReferenceItem.MarkDirty;\r\nbegin\r\n  if Assigned(Collection)  then\r\n    (Collection as TWebWidgetReferences).MarkDirty(Self);\r\nend;\r\n\r\nprocedure TReferenceItem.Refresh;\r\nbegin\r\n  MarkDirty;\r\nend;\r\n\r\nfunction TReferenceItem.Exists: Boolean;\r\nbegin\r\n  if Assigned(Collection) then\r\n    Result:=(Collection as TWebWidgetReferences).ElementExists(Name)\r\n  else\r\n    Result:=False;\r\nend;\r\n\r\nfunction TReferenceItem.IsArray: Boolean;\r\nbegin\r\n  if Assigned(Collection) then\r\n    Result:=(Collection as TWebWidgetReferences).ElementIsArray(Name)\r\n  else\r\n    Result:=False;\r\nend;\r\n\r\nfunction TReferenceItem.IsInput: Boolean;\r\n\r\nVar\r\n  el : TJSHTMLELement;\r\n\r\nbegin\r\n  Result:=Exists and not IsArray;\r\n  if Result then\r\n    begin\r\n    el:=Element;\r\n    Result:= ((el is TJSHTMLInputElement)\r\n               or (el is TJSHTMLTextAreaElement)\r\n               or (el is TJSHTMLSelectElement));\r\n    end;\r\nend;\r\n\r\nfunction TReferenceItem.GetInputValue: String;\r\nbegin\r\n  if IsInput then\r\n    Result:=String(TJSObject(Element)['value'])\r\n  else\r\n    Raise EWidgets.CreateFmt(SErrNotInput,[Name])\r\nend;\r\n\r\nprocedure TReferenceItem.SetSelector(AValue: String);\r\nbegin\r\n  if FSelector=AValue then Exit;\r\n  FSelector:=AValue;\r\n  MarkDirty;\r\nend;\r\n\r\n{ TCustomTemplateWidget }\r\n\r\nprocedure TCustomTemplateWidget.ApplyTemplate(aElement: TJSHTMLElement);\r\nbegin\r\n  aElement.InnerHTML:=GetTemplateHTML;\r\nend;\r\n\r\nfunction TCustomTemplateWidget.DoRenderHTML(aParent, aElement: TJSHTMLElement): TJSHTMLElement;\r\nbegin\r\n  if (ContainerTag='') then\r\n    begin\r\n    ApplyTemplate(AParent);\r\n    Result:= TJSHTMLElement(aParent.firstElementChild);\r\n    end\r\n  else\r\n    begin\r\n    ApplyTemplate(aElement);\r\n    Result:=aElement;\r\n    end;\r\nend;\r\n\r\nprocedure TCustomTemplateWidget.SetContainerTag(AValue: String);\r\nbegin\r\n  if FContainerTag=AValue then Exit;\r\n  FContainerTag:=AValue;\r\n  if IsRendered then\r\n    Refresh;\r\nend;\r\n\r\nfunction TCustomTemplateWidget.GetReferenceElement: TJSHTMLELement;\r\nbegin\r\n  If (ContainerTag='') then\r\n    Result:=ParentElement\r\n  else\r\n    Result:=Element;\r\nend;\r\n\r\nfunction TCustomTemplateWidget.HTMLTag: String;\r\nbegin\r\n  Result:=ContainerTag;\r\nend;\r\n\r\n{ TTemplateWidget }\r\n\r\nprocedure TTemplateWidget.SetTemplate(AValue: TStrings);\r\nbegin\r\n  if FTemplate=AValue then Exit;\r\n  FTemplate.Assign(AValue);\r\nend;\r\n\r\nfunction TTemplateWidget.GetTemplateHTML: String;\r\nbegin\r\n  Result:=FTemplate.Text;\r\nend;\r\n\r\n\r\nprocedure TTemplateWidget.DoTemplateChanged(Sender: TObject);\r\nbegin\r\n  if isRendered then\r\n    Refresh;\r\nend;\r\n\r\nconstructor TTemplateWidget.Create(aOwner: TComponent);\r\n\r\nbegin\r\n  inherited Create(aOwner);\r\n  FTemplate:=TStringList.Create;\r\n  TStringList(FTemplate).OnChange:=@DoTemplateChanged;\r\n  FContainerTag:='';\r\nend;\r\n\r\ndestructor TTemplateWidget.Destroy;\r\n\r\nbegin\r\n  FreeAndNil(FTemplate);\r\n  inherited Destroy;\r\nend;\r\n\r\n{ TContainerWidget }\r\n\r\nfunction TContainerWidget.GetKnownStyle(AIndex: Integer): String;\r\n\r\nvar\r\n  S : TStyleItem;\r\nbegin\r\n  S:=Styles.FindStyle(KnownStyles[aIndex]);\r\n  if Assigned(S) then\r\n    Result:=S.Value;\r\nend;\r\n\r\nprocedure TContainerWidget.SetKnownStyle(AIndex: Integer; AValue: String);\r\n\r\nbegin\r\n  Styles.EnsureStyle(KnownStyles[aIndex]).Value:=aValue;\r\nend;\r\n\r\nfunction TContainerWidget.HTMLTag: String;\r\nbegin\r\n  Result:='div';\r\nend;\r\n\r\nconstructor TContainerWidget.Create(aOwner: TComponent);\r\nbegin\r\n  inherited Create(aOwner);\r\n  MinWidth:='32px';\r\n  MinHeight:='12px';\r\n  Width:='50%';\r\n  Height:='50%';\r\nend;\r\n\r\n\r\n\r\n{ TWebWidgetStyles }\r\n\r\nfunction TWebWidgetStyles.GetStyleItem(aIndex: Integer): TStyleItem;\r\nbegin\r\n  Result:=TStyleItem(Items[Aindex]);\r\nend;\r\n\r\nprocedure TWebWidgetStyles.SetStyleItem(aIndex: Integer; AValue: TStyleItem);\r\nbegin\r\n  Items[aIndex]:=aValue;\r\nend;\r\n\r\nprocedure TWebWidgetStyles.MarkDirty(aItem: TStyleItem);\r\n\r\nVar\r\n  El : TJSHTMLElement;\r\n\r\nbegin\r\n  If Assigned(Widget) then\r\n    begin\r\n    if Not (csLoading in Widget.ComponentState) then\r\n      begin\r\n      el:=Widget.Element;\r\n      if Assigned(El) then\r\n        ApplyToDom(El,aItem);\r\n      end;\r\n    end;\r\nend;\r\n\r\nprocedure TWebWidgetStyles.ApplyToDOM(aElement: TJSHTMlElement; aItem: TStyleItem);\r\n\r\nConst\r\n  Prios : Array[TStylePriority] of string = ('','important');\r\n\r\nbegin\r\n  With AItem do\r\n    if (Name<>'') then\r\n      if (Value<>'') then\r\n        aElement.Style.setProperty(Name,Value,Prios[Priority])\r\n      else\r\n        aElement.Style.removeProperty(name);\r\nend;\r\n\r\nfunction TWebWidgetStyles.Add(const aName: String; const aValue: String): TStyleItem;\r\nbegin\r\n  Result:=Add as TStyleItem;\r\n  // Don't use Name\r\n  Result.FName:=aName;\r\n  if aValue<>'' then\r\n    Result.Value:=aValue; // will trigger markdirty\r\nend;\r\n\r\nfunction TWebWidgetStyles.EnsureStyle(const aName: String; const aValue: String): TStyleItem;\r\nbegin\r\n  Result:=FindStyle(aName);\r\n  if Result=Nil then\r\n    Result:=Add(aName,aValue)\r\n  else if AValue<>'' then\r\n    Result.Value:=aValue\r\nend;\r\n\r\nfunction TWebWidgetStyles.Widget: TCustomWebWidget;\r\nbegin\r\n  Result:=TCustomWebWidget(Owner);\r\nend;\r\n\r\nfunction TWebWidgetStyles.IndexOfStyle(const aName: String): integer;\r\n\r\nbegin\r\n  Result:=Count-1;\r\n  While (Result>=0) and not SameText(aName,GetStyleItem(Result).Name) do\r\n    Dec(Result);\r\nend;\r\n\r\nfunction TWebWidgetStyles.FindStyle(const aName: String): TStyleItem;\r\n\r\nVar\r\n  Idx : integer;\r\n\r\nbegin\r\n  Idx:=IndexOfStyle(aName);\r\n  If Idx=-1 then\r\n    Result:=Nil\r\n  else\r\n    Result:=GetStyleItem(Idx)\r\nend;\r\n\r\nfunction TWebWidgetStyles.GetStyle(const aName: String): TStyleItem;\r\nbegin\r\n  Result:=FindStyle(aName);\r\n  if Result=Nil then\r\n    Raise EWidgets.CreateFmt(SErrUnknownStyle,[aName]);\r\nend;\r\n\r\nfunction TWebWidgetStyles.RemoveStyle(const aName: String): String;\r\n\r\nVar\r\n  I : Integer;\r\n  el : TJSHTMLElement;\r\n\r\nbegin\r\n  I:=IndexOfStyle(aName);\r\n  if I<>-1 then\r\n    begin\r\n    Result:=Styles[i].Value;\r\n    Delete(I);\r\n    end;\r\n  if Assigned(Widget)  then\r\n    begin\r\n    el:=Widget.Element;\r\n    if Assigned(el) then\r\n      begin\r\n      if (Result='') then\r\n        Result:=el.style.getPropertyValue(aName);\r\n      el.style.removeProperty(aName);\r\n      end;\r\n    end;\r\nend;\r\n\r\nprocedure TWebWidgetStyles.RefreshFromDOM(aElement : TJSHTMlElement = Nil;DoClear: Boolean = False);\r\n\r\nVar\r\n  S : TJSCSSStyleDeclaration;\r\n  I : integer;\r\n  K : String;\r\n  W : TCustomWebWidget;\r\n  itm : TStyleItem;\r\n\r\nbegin\r\n  if aElement= Nil then\r\n    begin\r\n    W:=Widget;\r\n    if assigned(W) then\r\n      aElement:=W.Element;\r\n    if AElement=Nil then exit;\r\n    end;\r\n  if DoClear then\r\n    Clear;\r\n  S:=aElement.style;\r\n  For I:=0 to S.length-1 do\r\n    begin\r\n    K:=S.Item(I);\r\n    itm:=FindStyle(K);\r\n    if Itm=Nil then\r\n      begin\r\n      Itm:=Add(K);\r\n      Itm.FImported:=True;\r\n      end;\r\n    Itm.FValue:=S.getPropertyValue(K);\r\n    Case LowerCase(S.getPropertyPriority(K)) of\r\n     'important' : Itm.FPriority:=spImportant;\r\n    end;\r\n    end;\r\nend;\r\n\r\nprocedure TWebWidgetStyles.ClearImported;\r\n\r\nVar\r\n  I : integer;\r\n\r\nbegin\r\n  I:=Count-1;\r\n  While I>=0 do\r\n    begin\r\n    If GetStyleItem(I).Fimported then\r\n      Delete(I);\r\n    Dec(I);\r\n    end;\r\nend;\r\n\r\nprocedure TWebWidgetStyles.ApplyToDOM(aElement : TJSHTMlElement = Nil);\r\n\r\nVar\r\n  I : Integer;\r\n\r\nbegin\r\n  if (AElement=Nil) and (Widget<>Nil) then\r\n    aElement:=Widget.Element;\r\n  if AElement<>Nil then\r\n    For I:=0 to Count-1 do\r\n      ApplyToDOM(aElement,GetStyleItem(i));\r\nend;\r\n\r\n{ TStyleItem }\r\n\r\nprocedure TStyleItem.MarkDirty;\r\n\r\nbegin\r\n  If Assigned(Collection) then\r\n   TWebWidgetStyles(Collection).MarkDirty(Self);\r\nend;\r\n\r\nprocedure TStyleItem.SetValue(AValue: String);\r\nbegin\r\n  if FValue=AValue then Exit;\r\n  FValue:=aValue;\r\n  MarkDirty;\r\nend;\r\n\r\nprocedure TStyleItem.SetPriority(AValue: TStylePriority);\r\nbegin\r\n  if FPriority=AValue then Exit;\r\n  FPriority:=AValue;\r\n  MarkDirty;\r\nend;\r\n\r\n\r\nprocedure TStyleItem.SetName(AValue: String);\r\nbegin\r\n  if aValue=FName then Exit;\r\n  FName:=AValue;\r\n  MarkDirty;\r\nend;\r\n\r\nprocedure TStyleItem.Assign(Source: TPersistent);\r\n\r\nVar\r\n  SI : TStyleItem;\r\n\r\nbegin\r\n  if Source is TStyleItem then\r\n    begin\r\n    SI:=Source as TStyleItem;\r\n    FName:=SI.FName;\r\n    FValue:=SI.FValue;\r\n    FImported:=SI.FImported;\r\n    MarkDirty;\r\n    end\r\n  else\r\n    inherited Assign(Source);\r\nend;\r\n\r\n\r\n{ TCustomWebWidget }\r\n\r\nfunction TCustomWebWidget.DisplayElementName: String;\r\n\r\nbegin\r\n  Result:=Name;\r\n  If Result='' then\r\n    Result:=' <'+HTMLTag+'>';\r\n  if Assigned(FElement) then\r\n    Result:=Result+'#'+FElement.ID;\r\n  Result:=Result+' (Type: '+ClassName+')';\r\nend;\r\n\r\nfunction TCustomWebWidget.EnsureElement : TJSHTMLElement;\r\n\r\nvar\r\n  P : TJSHTMLElement;\r\n\r\nbegin\r\n  Result:=GetElement;\r\n  if Result=Nil then\r\n    begin\r\n    // If we have a parent, make sure it has it's element\r\n    if Assigned(Parent) then\r\n       Parent.EnsureElement;\r\n    P:=ParentElement;\r\n    if (P=Nil) and (FixedElement=Nil) then\r\n      Raise EWidgets.CreateFmt(SErrCannotRenderWithoutParent,[DisplayElementName])\r\n    else\r\n      begin\r\n      Result:=RenderHTML(P);\r\n      FOwnsElement:=True;\r\n      FElement:=Result;\r\n      end;\r\n    ApplyData;\r\n    RefreshReferences; // After data, so data can be used in selectors\r\n    end;\r\n  if Assigned(FOnElementBound) then\r\n    FOnElementBound(Self);\r\nend;\r\n\r\nprocedure TCustomWebWidget.InvalidateParentElement;\r\n\r\nVar\r\n  I : Integer;\r\n  C : TCustomWebWidget;\r\n\r\nbegin\r\n  FParentElement:=nil;\r\n  For I:=0 to ChildCount-1 do\r\n    begin\r\n    C:=Children[i];\r\n    if Assigned(C) then // Can be Nil\r\n      C.InvalidateParentElement;\r\n    end;\r\nend;\r\n\r\nprocedure TCustomWebWidget.InvalidateElement;\r\n\r\nVar\r\n  I : Integer;\r\n  C : TCustomWebWidget;\r\n\r\nbegin\r\n  If FStyles.Count>0 then\r\n    FStyles.ClearImported;\r\n  if Assigned(Freferences) then\r\n    FReferences.FRefs:=Nil;\r\n  FElement:=nil;\r\n  For I:=0 to ChildCount-1 do\r\n    begin\r\n    C:=Children[i];\r\n    if Assigned(C) then // Can be Nil\r\n      C.InvalidateElement;\r\n    end;\r\nend;\r\n\r\nfunction TCustomWebWidget.WidgetClasses: String;\r\nbegin\r\n  Result:='';\r\nend;\r\n\r\n\r\nfunction TCustomWebWidget.GetElement: TJSHTMLELement;\r\n\r\nVar\r\n  El : TJSHTMLElement;\r\n\r\n\r\nbegin\r\n  if (FElement=Nil) and not (csLoading in ComponentState) then\r\n    begin\r\n    if (FElementID<>'') then\r\n      begin\r\n      El:=FindElement(FElementID);\r\n      FElement:=El;\r\n      if Assigned(El) then\r\n        begin\r\n        if Assigned(FBeforeRenderHTML) then\r\n          FBeforeRenderHTML(Self);\r\n        ApplyWidgetSettings(el);\r\n        HookupEvents(el);\r\n        if Assigned(FAfterRenderHTML) then\r\n          FAfterRenderHTML(Self);\r\n        end;\r\n      if Assigned(El) then\r\n        ApplyData;\r\n      RefreshReferences;// After data, so data can be used in selectors\r\n      end;\r\n    end;\r\n  Result:=FElement;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetExternalElement: Boolean;\r\nbegin\r\n  Result:=(FElementID<>'')\r\nend;\r\n\r\nfunction TCustomWebWidget.GetFixedElementID: Boolean;\r\nbegin\r\n  Result:=(FElementID<>'');\r\nend;\r\n\r\nfunction TCustomWebWidget.GetHaveReferences: Boolean;\r\nbegin\r\n  Result:=Assigned(FReferences);\r\nend;\r\n\r\nfunction TCustomWebWidget.GetHTMLEvent(AIndex: Integer): THTMLNotifyEvent;\r\n\r\nVar\r\n  Fun : JSValue;\r\nbegin\r\n  Result:=nil;\r\n  if Assigned(FMyEvents) and (aIndex>=0) and (aIndex<=MaxEvents) then\r\n    begin\r\n    Fun:=FMyEvents[FEventNames[aindex]];\r\n    if Not isUndefined(Fun) then\r\n      Result:=THTMLNotifyEvent(Fun);\r\n    end;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetIsElementDirty: Boolean;\r\nbegin\r\n  Result:=IsRendered;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetClasses: String;\r\nbegin\r\n  if IsRendered Then\r\n    FClasses:=FElement.ClassName;\r\n  Result:=FClasses;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetDataset(aName : String): String;\r\n\r\nVar\r\n  el : TJSHTMLElement;\r\n\r\nbegin\r\n  el:=Element;\r\n  if Assigned(El) then\r\n    Result:=El.Dataset[aName]\r\n  else\r\n    Result:='';\r\nend;\r\n\r\nfunction TCustomWebWidget.GetChildCount: Integer;\r\nbegin\r\n  Result:=FChildren.Length;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetChild(aIndex : Integer): TCustomWebWidget;\r\nbegin\r\n  if (aIndex<0) or (aIndex>=FChildren.Length) then\r\n    Raise EListError.CreateFmt(SErrInvalidChildIndex,[aIndex,FChildren.Length-1]);\r\n  Result:=TCustomWebWidget(FChildren[aIndex]);\r\nend;\r\n\r\nfunction TCustomWebWidget.GetContentElement: TJSHTMLELement;\r\nbegin\r\n  Result:=Element;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetParent: TCustomWebWidget;\r\nbegin\r\n  Result:=FParent;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetParentElement: TJSHTMLELement;\r\n\r\nVar\r\n  El : TJSHTMLElement;\r\n\r\nbegin\r\n  if (FParentElement=Nil) then\r\n    begin\r\n    El:=TopElement;\r\n    if Assigned(el) then\r\n      FParentElement:=TJSHTMLElement(el.parentElement)\r\n    else if (FParentID<>'') then\r\n      FParentElement:=FindElement(FParentID)\r\n    else if Assigned(FParent) then\r\n      FParentElement:=FParent.ContentElement\r\n    else\r\n      FParentElement:=DefaultParentElement;\r\n    end;\r\n  Result:=FParentElement;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetParentID: String;\r\n\r\nVar\r\n  E : TJSHTMLElement;\r\n\r\nbegin\r\n  Result:='';\r\n  E:=ParentElement;\r\n  if Assigned(E) then\r\n    Result:=E.ID\r\n  else\r\n    Result:=FParentID;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetElementID: String;\r\n\r\nVar\r\n  El : TJSHTMLElement;\r\n\r\nbegin\r\n  El:=Element;\r\n  If Assigned(El) then\r\n    Result:=el.ID\r\n  else\r\n    Result:=FElementID;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetReference(const aName : string): TJSHTMLElement;\r\nbegin\r\n  if Assigned(FReferences) then\r\n    Result:=FReferences.GetElementByName(aName)\r\n  else\r\n    Result:=Nil;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetReferenceItem(aName : String): TReferenceItem;\r\nbegin\r\n  if Assigned(FReferences) then\r\n    Result:=FReferences.GetReference(aName)\r\n  else\r\n    Result:=Nil;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetReferenceList(const aName : string): TJSHTMLElementArray;\r\nbegin\r\n  if Assigned(FReferences) then\r\n    Result:=FReferences.GetElementsByName(aName)\r\n  else\r\n    Result:=Nil;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetReferences: TWebWidgetReferences;\r\nbegin\r\n  if (FReferences=Nil) then\r\n    FReferences:=CreateReferences;\r\n  Result:=FReferences;\r\n\r\nend;\r\n\r\nfunction TCustomWebWidget.GetRendered: Boolean;\r\nbegin\r\n  Result:=(FElement<>Nil)\r\nend;\r\n\r\nfunction TCustomWebWidget.GetTopElement: TJSHTMLELement;\r\nbegin\r\n  Result:=Element;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetVisible: Boolean;\r\nbegin\r\n  Result:=FVisible;\r\nend;\r\n\r\nprocedure TCustomWebWidget.SetAttr(const aName : string; AValue: String);\r\nbegin\r\n  if IsRendered then\r\n    Element[aName]:=aValue;\r\n  if Not Assigned(FAttrs) then\r\n    FAttrs:=TJSObject.New;\r\n  FAttrs[aName]:=aValue;\r\nend;\r\n\r\nprocedure TCustomWebWidget.SetClasses(AValue: String);\r\nbegin\r\n  FClasses:=AddClasses(AValue,WidgetClasses);\r\n  If IsRendered then\r\n    FElement.ClassName:=FClasses;\r\nend;\r\n\r\nprocedure TCustomWebWidget.SetDataset(aName : String; AValue: String);\r\n\r\nVar\r\n  El : TJSHTMLElement;\r\n\r\nbegin\r\n  el:=Element;\r\n  If (El=Nil) then\r\n    Raise EWidgets.Create(SErrNotRendered);\r\n  el.Dataset[aName]:=aValue;\r\nend;\r\n\r\nprocedure TCustomWebWidget.SetElementID(AValue: String);\r\nbegin\r\n  if (FElementID=AValue) then Exit;\r\n  if (aValue<>'') then\r\n    begin\r\n    if (FParentID<>'') then\r\n      Raise EWidgets.CreateFmt(SErrCannotSetParentAndElementID,[DisplayElementName]);\r\n    if FixedElement<>Nil then\r\n      Raise EWidgets.CreateFmt(SErrElementIDNotAllowed,[DisplayElementName]);\r\n    FElementID:=AValue;\r\n    end\r\n  else\r\n    begin\r\n    FElementID:=AValue;\r\n    if IsRendered then\r\n      Unrender(ParentElement);\r\n    end;\r\n  DoOnSetElementID;\r\nend;\r\n\r\nprocedure TCustomWebWidget.DoOnSetElementID;\r\n\r\nbegin\r\n  // Override in descendents\r\nend;\r\n\r\nprocedure TCustomWebWidget.SetHTMLEvent(AIndex: Integer; AValue: THTMLNotifyEvent);\r\n\r\nVar\r\n  EventName : String;\r\n\r\nbegin\r\n  if (aIndex<0) or (aIndex>MaxEvents) then\r\n    exit;\r\n  EventName:=FEventNames[aIndex];\r\n  if Assigned(aValue) then\r\n    AddEvent(EventName,AValue)\r\n  else\r\n    DeleteEvent(EventName);\r\nend;\r\n\r\nprocedure TCustomWebWidget.SetParent(AValue: TCustomWebWidget);\r\n\r\nVar\r\n  ReRender : Boolean;\r\nbegin\r\n  if (AValue=FParent) then exit;\r\n  if (FixedParent<>Nil) then\r\n    Raise EWidgets.CreateFmt(SErrParentNotAllowed,[DisplayElementName]);\r\n  if Assigned(aValue) then\r\n    if Not aValue.AllowChildren then\r\n      Raise EWidgets.CreateFmt(SErrChildrenNotAllowed,[DisplayElementName]);\r\n  If Assigned(FParent) then\r\n    FParent.RemoveChild(Self);\r\n  // Unrender\r\n  ReRender:=IsRendered;\r\n  if ReRender then\r\n    UnRender(ParentElement);\r\n  If (aValue=Nil) and (csDestroying in ComponentState) then\r\n    exit;\r\n  // here we re-render if needed\r\n  InvalidateParentElement;\r\n  If Assigned(aValue) then\r\n    begin\r\n    FParentID:='';\r\n    aValue.AddChild(Self); // Sets FParent\r\n    end;\r\n  if ReRender and Assigned(ParentElement) then\r\n    begin\r\n    FElement:=RenderHTML(ParentElement);\r\n    if Assigned(FElement) then\r\n      begin\r\n      ApplyData;\r\n      RefreshReferences;\r\n      end;\r\n    end;\r\nend;\r\n\r\nprocedure TCustomWebWidget.SetParentID(AValue: String);\r\n\r\nVar\r\n  ReRender : Boolean;\r\n\r\nbegin\r\n  if (FParentID=AValue) then exit;\r\n  if (aValue<>'') then\r\n    begin\r\n    if (FElementID<>'') then\r\n      Raise EWidgets.CreateFmt(SErrCannotSetParentAndElementID,[DisplayElementName]);\r\n    if (FixedParent<>Nil) then\r\n      Raise EWidgets.CreateFmt(SErrParentIDNotAllowed,[DisplayElementName]);\r\n    end;\r\n  ReRender:=IsRendered;\r\n  if ReRender then\r\n    UnRender(ParentElement);\r\n  if (aValue<>'') and Assigned(FParent) then\r\n    FParent.RemoveChild(Self);\r\n  FParentID:=aValue;\r\n  InvalidateParentElement;\r\n  if ReRender and Assigned(ParentElement) then\r\n    EnsureElement;\r\nend;\r\n\r\nprocedure TCustomWebWidget.AddChild(aValue: TCustomWebWidget);\r\nbegin\r\n  if AValue=Nil then exit;\r\n  aValue.FParent:=Self;\r\n  if FChildren.IndexOf(aValue)=-1 then\r\n    FChildren.Push(aValue);\r\nend;\r\n\r\nprocedure TCustomWebWidget.RemoveChild(aValue: TCustomWebWidget);\r\n\r\nVar\r\n  I : NativeInt;\r\n\r\nbegin\r\n  if AValue=Nil then exit;\r\n  I:=FChildren.indexOf(aValue);\r\n  if I>=0 then\r\n    begin\r\n    FChildren.splice(I,1);\r\n    aValue.FParent:=Nil;\r\n    end;\r\nend;\r\n\r\nprocedure TCustomWebWidget.SetReferences(AValue: TWebWidgetReferences);\r\nbegin\r\n  if (aValue=FReferences) then exit;\r\n  References.Assign(aValue);\r\n  if IsRendered then\r\n    References.RefreshFromDOM(GetReferenceElement);\r\nend;\r\n\r\nprocedure TCustomWebWidget.SetStyles(AValue: TWebWidgetStyles);\r\nbegin\r\n  if FStyles=AValue then Exit;\r\n  FStyles.Assign(AValue);\r\nend;\r\n\r\nprocedure TCustomWebWidget.SetVisible(AValue: Boolean);\r\n\r\nVar\r\n  el : TJSHTMLElement;\r\n\r\nbegin\r\n  if aValue=FVisible then\r\n    Exit;\r\n  el:=Element;\r\n  if Assigned(el) then\r\n    ApplyVisible(el,aValue)\r\n  else\r\n    FVisible:=aValue;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetAttr(const aName: String): String;\r\nVar\r\n  el : TJSObject;\r\nbegin\r\n  Result:='';\r\n  if IsRendered then\r\n    el:=Element\r\n  else\r\n    el:=FAttrs;\r\n  if Assigned(el) and isDefined(el[aName]) then\r\n    Result:=String(el[aName]);\r\nend;\r\n\r\nprocedure TCustomWebWidget.ApplyVisible(aElement: TJSHTMLElement;AValue: Boolean);\r\n\r\nbegin\r\n  if aValue then\r\n    begin\r\n    if (FDisplay<>'') then\r\n      aElement.Style.setProperty('display',FDisplay)\r\n    else\r\n      aElement.Style.removeProperty('display');\r\n    end\r\n  else\r\n    begin\r\n    FDisplay:=aElement.Style.getPropertyValue('display');\r\n    aElement.Style.setProperty('display','none');\r\n    end;\r\n  FVisible:=aValue;\r\nend;\r\n\r\nprocedure TCustomWebWidget.EventEntry(aEvent: TJSEvent);\r\n\r\nVar\r\n  R : TEventDispatch;\r\n  Fun : JSValue;\r\n\r\nbegin\r\n  R.MsgStr:=aEvent._type;\r\n  R.HTMLEvent:=aEvent;\r\n  if Assigned(FMyEvents) then\r\n    Fun:=FMyEvents[R.MsgStr]\r\n  else\r\n    Fun:=nil;\r\n  if Not (isUndefined(Fun) or isNull(Fun)) then\r\n    R.EventHandler:=THTMLNotifyEvent(Fun);\r\n  DispatchStr(R);\r\n  if (R.EventHandler<>Nil) then\r\n    R.EventHandler(Self,R.HTMLEvent);\r\nend;\r\n\r\nfunction TCustomWebWidget.CreateStyles: TWebWidgetStyles;\r\nbegin\r\n  Result:=TWebWidgetStyles.Create(Self,TStyleItem);\r\nend;\r\n\r\nfunction TCustomWebWidget.CreateReferences: TWebWidgetReferences;\r\nbegin\r\n  Result:=TWebWidgetReferences.Create(Self,TReferenceItem);\r\nend;\r\n\r\nprocedure TCustomWebWidget.RemoveEvent(aElement: TJSHTMLElement; const aEvent: String);\r\nbegin\r\n  aElement.RemoveEventListener(aEvent,FMyHook);\r\nend;\r\n\r\nprocedure TCustomWebWidget.HookupEvent(aElement: TJSHTMLElement; const aEvent : String);\r\n\r\nbegin\r\n  aElement.addEventListener(aEvent,FMyHook);\r\nend;\r\n\r\nprocedure TCustomWebWidget.HookupEvents(aElement: TJSHTMLElement);\r\n\r\nVar\r\n  Event : String;\r\n\r\nbegin\r\n  if Assigned(FMyEvents) then\r\n    for Event in TJSObject.keys(FMyEvents) do\r\n      HookupEvent(aElement,Event);\r\nend;\r\n\r\nprocedure TCustomWebWidget.AddEvent(aName: String; AHandler: THTMLNotifyEvent);\r\n\r\nVar\r\n  el : TJSHTMLElement;\r\n\r\nbegin\r\n  if FMyEvents=nil then\r\n    FMyEvents:=TJSObject.New;\r\n  FMyEvents[aName]:=aHandler;\r\n  El:=FElement;\r\n  if Assigned(El) then\r\n    HookupEvent(el,aName);\r\nend;\r\n\r\nprocedure TCustomWebWidget.DeleteEvent(aName: String);\r\n\r\nVar\r\n  el : TJSHTMLElement;\r\n\r\nbegin\r\n  if (FMyEvents<>nil) and FMyEvents.hasOwnProperty(aName) then\r\n      JSDelete(FMyEvents,aName);\r\n  El:=Element;\r\n  if Assigned(El) then\r\n    RemoveEvent(el,aName);\r\nend;\r\n\r\nclass function TCustomWebWidget.FixedParent: TJSHTMLElement;\r\nbegin\r\n  Result:=Nil;\r\nend;\r\n\r\nclass function TCustomWebWidget.DefaultParentElement: TJSHTMLElement;\r\nbegin\r\n  Result:=Nil;\r\nend;\r\n\r\nclass function TCustomWebWidget.DefaultParent: TCustomWebWidget;\r\nbegin\r\n  Result:=nil;\r\nend;\r\n\r\nclass function TCustomWebWidget.FixedElement: TJSHTMLElement;\r\nbegin\r\n  Result:=Nil;\r\nend;\r\n\r\n\r\n\r\nclass function TCustomWebWidget.FindElement(aID: String): TJSHTMLElement;\r\nbegin\r\n  Result:=TJSHTMLElement(Document.getElementbyID(aID));\r\nend;\r\n\r\nclass function TCustomWebWidget.CreateElement(aTag: String; aID: String\r\n  ): TJSHTMLElement;\r\nbegin\r\n  Result:=TJSHTMLElement(Document.createElement(aTag));\r\n  if aID<>'' then\r\n    Result.id:=aID;\r\nend;\r\n\r\nclass function TCustomWebWidget.CreateElement(aParent: TJSElement; \r\n  aTag: String; aID: String): TJSHTMLElement;\r\nbegin\r\n  Result := CreateElement(aTag, aID);\r\n  if aParent <> nil then\r\n    aParent.appendChild(Result);\r\nend;\r\n\r\nfunction TCustomWebWidget.GetReferenceElement: TJSHTMLELement;\r\nbegin\r\n  Result:=Element;\r\nend;\r\n\r\nprocedure TCustomWebWidget.Refresh;\r\n\r\nVar\r\n  I : integer;\r\n\r\nbegin\r\n  if IsRendered then\r\n    UnRender(ParentElement);\r\n  InvalidateParentElement;\r\n  EnsureElement;\r\n  For I:=0 to ChildCount-1 do\r\n    Children[i].Refresh;\r\nend;\r\n\r\nprocedure TCustomWebWidget.Unrender;\r\n\r\nVar\r\n  P : TJSHTMLElement;\r\n\r\nbegin\r\n  P:=ParentElement;\r\n  If Assigned(P) then\r\n    UnRender(P);\r\nend;\r\n\r\nprocedure TCustomWebWidget.Focus;\r\nbegin\r\n  if not IsRendered then\r\n    ReFresh;\r\n  Element.Focus;\r\nend;\r\n\r\n\r\nprocedure TCustomWebWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\n\r\n// Normally, this should be called BEFORE FElement is set.\r\n// But we'll be extra careful, and not rely on getters using FElement.\r\n\r\nVar\r\n  S : String;\r\n\r\nbegin\r\n  if aElement.id='' then\r\n    aElement.id:=GenerateID;\r\n  // Don't use Classes, it will return FElement.Classname when set\r\n  S:=AddClasses(FClasses,WidgetClasses);\r\n  if (S<>'') then\r\n    AddClasses(aElement,S);\r\n  if FStyles.Count>0 then\r\n    FStyles.ApplyToDOM(aElement);\r\n  if Not FVisible then\r\n    ApplyVisible(aElement,FVisible);\r\n  // Maybe we should put this under control of a property or so ?\r\n  // TStyleRefresh = (srAlways,srOnElementID,srNever)\r\n  if (StyleRefresh = srAlways)\r\n     or ((FelementID<>'') and (FElementID<>'')) then\r\n    FStyles.RefreshFromDom(aElement,False);\r\n  if Assigned(FAttrs) then\r\n    for S in TJSObject.getOwnPropertyNames(FAttrs) do\r\n      if IndexText(S,['id','class'])=-1 then\r\n        aElement[S]:=String(FAttrs[S]);\r\nend;\r\n\r\nfunction TCustomWebWidget.DoRenderHTML(aParent, aElement: TJSHTMLElement): TJSHTMLElement;\r\nbegin\r\n  If AParent=Nil then\r\n    Console.Log(DisplayElementName+': render without parent!');\r\n  Result:=aElement;\r\nend;\r\n\r\n\r\nprocedure TCustomWebWidget.ApplyData;\r\n\r\nVar\r\n  AID : String;\r\n\r\n  Procedure MaybeSet(El : TJSHTMLElement; AName : String);\r\n\r\n  begin\r\n    if Assigned(el) and CreateDataTags then\r\n      el.Dataset[aName]:=AID;\r\n  end;\r\n\r\nbegin\r\n  AID:=ElementID;\r\n  if assigned(Element) and Not CreateDataTags then\r\n    Element.dataset[SElementClass]:=ClassName;\r\n  MaybeSet(Element,SElementData);\r\n  MaybeSet(TopElement,STopElementData);\r\n  if AllowChildren then\r\n    MaybeSet(ContentElement,SContentElementData);\r\nend;\r\n\r\nprocedure TCustomWebWidget.RemoveData;\r\n\r\n  Procedure MaybeUnSet(El : TJSHTMLElement; AName : String);\r\n\r\n  begin\r\n    if Assigned(el) then\r\n      jsDelete(el.Dataset,aName);\r\n  end;\r\n\r\nbegin\r\n  MaybeUnSet(Element,SElementData);\r\n  MaybeUnSet(TopElement,STopElementData);\r\n  MaybeUnSet(ContentElement,SContentElementData);\r\nend;\r\n\r\nprocedure TCustomWebWidget.RefreshReferences;\r\nbegin\r\n  if Assigned(FReferences) then\r\n    begin\r\n    if Assigned(Element) then\r\n      References.RefreshFromDom(GetReferenceElement)\r\n    else\r\n      References.FRefs:=Nil\r\n    end;\r\nend;\r\n\r\nclass function TCustomWebWidget.GenerateID: String;\r\n\r\nbegin\r\n  Inc(WidgetID);\r\n  Result:='ww-'+intToStr(WidgetID);\r\nend;\r\n\r\nfunction TCustomWebWidget.RenderHTML(aParent: TJSHTMLELement): TJSHTMLElement;\r\n\r\nVar\r\n  aTag : String;\r\n\r\nbegin\r\n  aTag:=HTMLTag;\r\n  if aTag='' then\r\n    Result:=Nil\r\n  else\r\n    begin\r\n    Result:=FixedElement;\r\n    if Result=Nil then\r\n      Result:=CreateElement(HTMLTag,GenerateID);\r\n    end;\r\n  if Assigned(Result) and Assigned(aParent) then\r\n    aParent.AppendChild(Result);\r\n  if Assigned(FBeforeRenderHTML) then\r\n    FBeforeRenderHTML(Self);\r\n  Result:=DoRenderHTML(aParent,Result);\r\n  if Assigned(Result) then\r\n    begin\r\n    ApplyWidgetSettings(Result);\r\n    HookupEvents(Result);\r\n    end;\r\n  if Assigned(FAfterRenderHTML) then\r\n    FAfterRenderHTML(Self);\r\nend;\r\n\r\nprocedure TCustomWebWidget.DoUnRender(aParent: TJSHTMLElement);\r\n\r\nVar\r\n  el : TJSHTMLElement;\r\n\r\nbegin\r\n  if Assigned(aParent) and Assigned(FElement) then\r\n    begin\r\n    if FOwnsElement then\r\n      begin\r\n      el:=TopElement;\r\n      if (El.ParentElement=aParent) then\r\n        aParent.removeChild(el);\r\n      end;\r\n    InvalidateElement;\r\n    end;\r\nend;\r\n\r\nprocedure TCustomWebWidget.UnRender(aParent: TJSHTMLElement);\r\nbegin\r\n  if Assigned(FBeforeUnRenderHTML) then\r\n    FBeforeUnRenderHTML(Self);\r\n  RemoveData;\r\n  if assigned(AParent) then\r\n    DoUnRender(aParent);\r\n  if Assigned(FAfterUnRenderHTML) then\r\n    FAfterUnRenderHTML(Self);\r\nend;\r\n\r\nfunction TCustomWebWidget.DispatchEvent(aName: String; aEvent: TJSEvent): Boolean;\r\n\r\nbegin\r\n  if not IsRendered then\r\n    exit;\r\n  if (aEvent=Nil) then\r\n    aEvent:=TJSEvent.New(aName);\r\n  Result:=Element.dispatchEvent(aEvent);\r\nend;\r\n\r\nconstructor TCustomWebWidget.Create(aOwner: TComponent);\r\nbegin\r\n  inherited Create(aOwner);\r\n  FChildren:=TJSArray.New;\r\n  FStyles:=CreateStyles;\r\n  FMyHook:=@EventEntry;\r\n  FParent:=DefaultParent;\r\n  FVisible:=True;\r\nend;\r\n\r\ndestructor TCustomWebWidget.Destroy;\r\n\r\nVar\r\n  I : integer;\r\n  C : TCustomWebWidget;\r\n\r\nbegin\r\n  For I:=0 to FChildren.Length-1 do\r\n    begin\r\n    C:=TCustomWebWidget(FChildren[i]);\r\n    FChildren[i]:=Nil;\r\n    C.Free;\r\n    end;\r\n  FChildren.Length:=0;\r\n  Parent:=Nil;\r\n  ParentID:='';\r\n  FChildren:=Nil;\r\n  FreeAndNil(FStyles);\r\n  inherited Destroy;\r\nend;\r\n\r\nprocedure TCustomWebWidget.ClearContent;\r\nbegin\r\n  if Assigned(FElement) then\r\n    FElement.InnerHTML:='';\r\nend;\r\n\r\nclass function TCustomWebWidget.AllowChildren: Boolean;\r\nbegin\r\n  Result:=True;\r\nend;\r\n\r\nclass function TCustomWebWidget.AddRemoveClasses(const Source, aAddClasses,\r\n  aRemoveClasses: String; Normalize: Boolean): String;\r\nvar\r\n  T : TJSStringDynArray;\r\n  i : integer;\r\n  S : String;\r\nbegin\r\n  Result:=Source;\r\n  if Normalize then\r\n    Result:=TJSString(Result).replace(TJSRegexp.New('\\s\\s+','g'),' ');\r\n  T:=TJSString(Result).split(' ');\r\n  For S in TJSString(aRemoveClasses).split(' ') do\r\n    if (S<>'') then\r\n      begin\r\n      I:=TJSArray(T).indexOf(S);\r\n      if (I<>-1) then\r\n        TJSArray(T).splice(i,1);\r\n      end;\r\n  For S in TJSString(aAddClasses).split(' ') do\r\n    if (S<>'') then\r\n      begin\r\n      I:=TJSArray(T).indexOf(S);\r\n      if (I=-1) then\r\n        TJSArray(T).Push(S);\r\n      end;\r\n  Result:=TJSArray(T).join(' ');\r\nend;\r\n\r\nclass function TCustomWebWidget.ReplaceClasses(const Source, aSearchClasses, aReplaceClasses : String; Normalize: Boolean): String;\r\nvar\r\n  Dest,Srch,Repl : TJSStringDynArray;\r\n  sIdx,I : integer;\r\n  S : String;\r\n\r\nbegin\r\n  Srch:=TJSString(aSearchClasses).split(' ');\r\n  Repl:=TJSString(aReplaceClasses).split(' ');\r\n  Result:=Source;\r\n  if Normalize then\r\n    Result:=TJSString(Result).replace(TJSRegexp.New('\\s\\s+','g'),' ');\r\n  Dest:=TJSString(Result).split(' ');\r\n  For sIdx:=0 to length(Srch)-1 do\r\n    begin\r\n    S:=Srch[sIdx];\r\n    if (S<>'') then\r\n      begin\r\n      I:=TJSArray(Dest).indexOf(S);\r\n      if (I<>-1) then\r\n        begin\r\n        TJSArray(Dest).splice(i,1);\r\n        if sIdx<Length(Repl) then\r\n          begin\r\n          I:=TJSArray(Dest).indexOf(Repl[sIdx]);\r\n          if I=-1 then\r\n            TJSArray(Dest).Push(Repl[sIdx]);\r\n          end;\r\n        end;\r\n      end;\r\n    end;\r\n  Result:=TJSArray(Dest).join(' ');\r\nend;\r\n\r\nclass function TCustomWebWidget.RemoveClasses(const Source, aClasses: String; Normalize : Boolean = false): String;\r\n\r\nbegin\r\n  Result:=AddRemoveClasses(Source,'',aClasses,Normalize);\r\nend;\r\n\r\nclass function TCustomWebWidget.RemoveClasses(el: TJSHTMLElement; const aClasses: String; Normalize : Boolean = false): String;\r\n\r\nbegin\r\n  Result:=RemoveClasses(el.ClassName,aClasses,Normalize);\r\n  el.ClassName:=Result;\r\nend;\r\n\r\nclass function TCustomWebWidget.AddClasses(const Source, aClasses: String; Normalize : Boolean = false): String;\r\n\r\nbegin\r\n  Result:=AddRemoveClasses(Source,aClasses,'',Normalize);\r\nend;\r\n\r\nclass function TCustomWebWidget.AddClasses(el: TJSHTMLElement; const aClasses: String; Normalize : Boolean = false): String;\r\n\r\nbegin\r\n  Result:=AddClasses(el.ClassName,aClasses,Normalize);\r\n  el.ClassName:=Trim(Result);\r\nend;\r\n\r\nclass function TCustomWebWidget.AddRemoveClasses(el: TJSHTMLElement;\r\n  const aAddClasses, aRemoveClasses: String; Normalize: Boolean): String;\r\nbegin\r\n  Result:=AddRemoveClasses(el.ClassName,aAddClasses,aRemoveClasses,Normalize);\r\n  el.ClassName:=Trim(Result);\r\nend;\r\n\r\nclass function TCustomWebWidget.ReplaceClasses(el: TJSHTMLElement;\r\n  const aSearchClasses, aReplaceClasses: String; Normalize: Boolean): String;\r\nbegin\r\n  Result:=ReplaceClasses(el.ClassName,aSearchClasses, aReplaceClasses,Normalize);\r\n  el.ClassName:=Trim(Result);\r\nend;\r\n\r\nfunction TCustomWebWidget.AddRemoveClasses(const aAddClasses,\r\n  aRemoveClasses: String; Normalize: Boolean): String;\r\nbegin\r\n  FClasses:=AddRemoveClasses(FClasses,aAddClasses,aRemoveClasses,Normalize);\r\n  Result:=FClasses;\r\n  if IsRendered then\r\n    Result:=AddRemoveClasses(FElement,aAddClasses,aRemoveClasses,Normalize)\r\nend;\r\n\r\nfunction TCustomWebWidget.ReplaceClasses(const aSearchClasses,\r\n  aReplaceClasses: String; Normalize: Boolean): String;\r\nbegin\r\n  FClasses:=ReplaceClasses(FClasses,aSearchClasses,aReplaceClasses,Normalize);\r\n  Result:=FClasses;\r\n  if IsRendered then\r\n    Result:=ReplaceClasses(FElement,aSearchClasses,aReplaceClasses,Normalize)\r\nend;\r\n\r\nfunction TCustomWebWidget.RemoveClasses(const aClasses: String; Normalize : Boolean = false): String;\r\nbegin\r\n  FClasses:=RemoveClasses(FClasses,aClasses,Normalize);\r\n  Result:=FClasses;\r\n  if IsRendered then\r\n    Result:=RemoveClasses(FElement,aClasses,Normalize)\r\nend;\r\n\r\nfunction TCustomWebWidget.AddClasses(const aClasses: String; Normalize: Boolean): String;\r\nbegin\r\n  FClasses:=AddClasses(FClasses,aClasses,Normalize);\r\n  Result:=FClasses;\r\n  if IsRendered then\r\n    Result:=AddClasses(FElement,aClasses,Normalize)\r\nend;\r\n\r\nfunction TCustomWebWidget.FindWidgetByID(aElementID: String; Recurse: Boolean): TCustomWebWidget;\r\n\r\nVar\r\n  I : Integer;\r\n\r\nbegin\r\n  Result:=Nil;\r\n  if aElementID='' then\r\n    exit;\r\n  if (aElementID=elementID) then\r\n    Exit(Self);\r\n  I:=ChildCount-1;\r\n  // First this level. Typical layout is not so nested.\r\n  While (i>=0) and (Result=Nil) do\r\n    begin\r\n    Result:=Children[i];\r\n    if (Result.ElementID<>aElementID) then\r\n      Result:=nil;\r\n    Dec(I);\r\n    end;\r\n  If (Result=Nil) and (Recurse) then\r\n     begin\r\n     I:=ChildCount-1;\r\n     While (i>=0) and (Result=Nil) do\r\n       begin\r\n       Result:=Children[i].FindWidgetByID(aElementID,True);\r\n       Dec(I);\r\n       end;\r\n     end;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetWidgetByID(aElementID: String; Recurse: Boolean): TCustomWebWidget;\r\nbegin\r\n  Result:=FindWidgetByID(aElementID,Recurse);\r\n  if Result=Nil then\r\n    Raise EWidgets.CreateFmt(SErrWidgetNotFound,[aElementID]);\r\nend;\r\n\r\nfunction TCustomWebWidget.EnsureStyle(const aName: String): TStyleItem;\r\nbegin\r\n  Result:=Styles.EnsureStyle(aName);\r\nend;\r\n\r\nfunction TCustomWebWidget.AddStyle(const aName, aValue: String): TStyleItem;\r\nbegin\r\n  Result:=EnsureStyle(aName);\r\n  Result.Value:=aValue;\r\nend;\r\n\r\nfunction TCustomWebWidget.GetStyleValue(const aName : String): String;\r\n\r\nVar\r\n  S : TStyleItem;\r\n\r\nbegin\r\n  S:=Styles.FindStyle(aName);\r\n  if Assigned(S) then\r\n    Result:=S.Value\r\n  else\r\n    Result:='';\r\nend;\r\n\r\nfunction TCustomWebWidget.RemoveStyle(const aName: String): String;\r\n\r\nbegin\r\n  Result:=Styles.RemoveStyle(aName);\r\nend;\r\n\r\nprocedure TCustomWebWidget.RemoveData(const aName: String);\r\nbegin\r\n  if IsRendered then\r\n    jsDelete(Element.Dataset,aName)\r\nend;\r\n\r\nend.\r\n\r\n","{\r\n    This file is part of the Free Pascal run time library.\r\n    Copyright (c) 2019-Now by Michael Van Canneyt, member of the\r\n    Free Pascal development team\r\n\r\n    WEB Widget Set : Basic bare HTML Widgets\r\n\r\n    See the file COPYING.FPC, included in this distribution,\r\n    for details about the copyright.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n **********************************************************************}\r\n{$IFNDEF FPC_DOTTEDUNITS}\r\nunit htmlwidgets;\r\n{$ENDIF}\r\n\r\n{$mode objfpc}\r\n{$h+}\r\n\r\ninterface\r\n\r\nuses\r\n{$IFDEF FPC_DOTTEDUNITS}\r\n  System.Classes, System.SysUtils, Widget.Web, JSApi.JS, BrowserApi.Web;\r\n{$ELSE}\r\n  Classes, SysUtils, webwidget, js, web;\r\n{$ENDIF}\r\n\r\nType\r\n  TTextMode = (tmText,tmHTML);\r\n\r\n  { TButtonWidget }\r\n\r\n  TButtonWidget = Class(TWebWidget)\r\n  private\r\n    FText: String;\r\n    FTextMode: TTextMode;\r\n    FDisabled: boolean;\r\n    procedure SetText(AValue: String);\r\n    procedure SetTextMode(AValue: TTextMode);\r\n    procedure SetDisabled(AValue: boolean);\r\n  Protected\r\n    procedure ApplyText(aElement: TJSHTMLElement);\r\n    procedure ApplyDisabled(aElement: TJSHTMLElement);\r\n    Procedure SetName(const NewName: TComponentName); override;\r\n    Procedure ApplyWidgetSettings(aElement: TJSHTMLElement); override;\r\n  Public\r\n    Procedure Click;\r\n    Function HTMLTag : String; override;\r\n  Published\r\n    Property Text : String Read FText Write SetText;\r\n    Property TextMode : TTextMode Read FTextMode Write SetTextMode;\r\n    Property Disabled : boolean Read FDisabled Write SetDisabled;\r\n  end;\r\n\r\n  { TViewPort }\r\n\r\n  TViewPort = Class(TCustomWebWidget)\r\n  Private\r\n    Class var FInstance : TViewPort;\r\n  Protected\r\n    Class Function FixedParent : TJSHTMLElement; override;\r\n    Class Function FixedElement : TJSHTMLElement; override;\r\n    Function DoRenderHTML(aParent,aElement : TJSHTMLElement) :TJSHTMLElement; override;\r\n  Public\r\n    Constructor Create (aOwner: TComponent); override;\r\n    Function HTMLTag : String; override;\r\n    Class Function Instance : TViewPort;\r\n    Property Element;\r\n  end;\r\n\r\n  { TWebPage }\r\n\r\n  TWebPage = Class(TCustomWebWidget)\r\n  private\r\n  Protected\r\n    Class Function DefaultParentElement: TJSHTMLElement; override;\r\n    Class Function DefaultParent : TCustomWebWidget; override;\r\n    Procedure DoUnRender(aParent : TJSHTMLElement) ; override;\r\n  Public\r\n    Constructor Create(AOwner : TComponent); override;\r\n    Function HTMLTag : String; override;\r\n    // Later on, allow IFrame;\r\n  Published\r\n    Property ParentID;\r\n    Property ElementID;\r\n    Property Classes;\r\n    Property Styles;\r\n    Property StyleRefresh;\r\n    Property Visible;\r\n    // Events\r\n    Property BeforeRenderHTML;\r\n    Property AfterRenderHTML;\r\n    Property OnAbort;\r\n    Property OnAnimationCancel;\r\n    Property OnAnimationEnd;\r\n    Property OnAnimationIteration;\r\n    Property OnAnimationStart;\r\n    Property OnAuxClick;\r\n    Property OnBlur;\r\n    Property OnCancel;\r\n    Property OnCanPlay;\r\n    Property OnCanPlayThrough;\r\n    Property OnChange;\r\n    Property OnClick;\r\n    Property OnCompositionEnd;\r\n    Property OnCompositionStart;\r\n    Property OnCompositionUpdate;\r\n    Property OnContextMenu;\r\n    Property OnCopy;\r\n    Property OnCut;\r\n    Property OnCueChange;\r\n    Property OnDblClick;\r\n    Property OnDurationChange;\r\n    Property OnEnded ;\r\n    Property OnError ;\r\n    Property OnFocus;\r\n    Property OnFocusIn ;\r\n    Property OnFocusOut ;\r\n    Property OnGotPointerCapture;\r\n    Property OnInput;\r\n    Property OnInvalid;\r\n    Property OnKeyDown;\r\n    Property OnKeyPress;\r\n    Property OnKeyUp;\r\n    Property OnLoad;\r\n    Property OnLoadedData;\r\n    Property OnLoadedMetaData;\r\n    Property OnLoadend;\r\n    Property OnLoadStart;\r\n    Property OnLostPointerCapture;\r\n    Property OnMouseDown;\r\n    Property OnMouseEnter;\r\n    Property OnMouseLeave;\r\n    Property OnMouseMove;\r\n    Property OnMouseOut;\r\n    Property OnMouseUp;\r\n    Property OnOverFlow;\r\n    Property OnPaste;\r\n    Property OnPause;\r\n    Property OnPlay;\r\n    Property OnPointerCancel;\r\n    Property OnPointerDown;\r\n    Property OnPointerEnter;\r\n    Property OnPointerLeave;\r\n    Property OnPointerMove;\r\n    Property OnPointerOut;\r\n    Property OnPointerOver;\r\n    Property OnPointerUp;\r\n    Property OnReset;\r\n    Property OnResize;\r\n    Property OnScroll;\r\n    Property OnSelect;\r\n    Property OnSubmit;\r\n    Property OnTouchStart;\r\n    Property OnTransitionCancel;\r\n    Property OnTransitionEnd;\r\n    Property OnTransitionRun;\r\n    Property OnTransitionStart;\r\n    Property OnWheel;\r\n  end;\r\n\r\n  { TCustomInputWidget }\r\n\r\n  TCustomInputWidget = Class(TWebWidget)\r\n  private\r\n    FValue : String;\r\n    FValueName : String;\r\n    FText : String;\r\n    FReadOnly : Boolean;\r\n    FRequired : Boolean;\r\n    function GetReadOnly: Boolean;\r\n    function GetRequired: Boolean;\r\n    function GetText: String;\r\n    function GetValue: String;\r\n    function GetValueName: String;\r\n    procedure SetReadonly(AValue: Boolean);\r\n    procedure SetRequired(AValue: Boolean);\r\n    procedure SetText(AValue: String);\r\n    procedure SetValue(AValue: String);\r\n    function GetInputElement: TJSHTMLInputElement;\r\n    procedure SetValueName(AValue: String);\r\n  Protected\r\n    Procedure SetName(const NewName: TComponentName); override;\r\n    Procedure ApplyWidgetSettings(aElement: TJSHTMLElement); override;\r\n    Property InputElement : TJSHTMLInputElement Read GetInputElement;\r\n    // Text to show (checkbox etc). Enable in descendents as needed\r\n    Property Text : String Read GetText Write SetText;\r\n  Public\r\n    function InputType : String; virtual; abstract;\r\n    Function HTMLTag : String; override;\r\n    // Value as string\r\n    Property Value : String Read GetValue Write SetValue;\r\n    // Value Name to use when submitting using form.\r\n    Property ValueName : String Read GetValueName Write SetValueName;\r\n    Property ReadOnly : Boolean Read GetReadOnly Write SetReadonly;\r\n    Property Required : Boolean Read GetRequired Write SetRequired;\r\n  end;\r\n\r\n  { TTextInputWidget }\r\n\r\n  TInputTextType = (ittText,ittPassword,ittNumber,ittEmail,ittSearch,ittTelephone,ittURL,ittColor);\r\n  TTextInputWidget = class(TCustomInputWidget)\r\n  private\r\n    FMaxLength : Integer;\r\n    FMinLength : Integer;\r\n    FTextType : TInputTextType;\r\n    function GetAsNumber: NativeInt;\r\n    function GetMaxLength: NativeInt;\r\n    function GetMinLength: NativeInt;\r\n    function GetTextType: TInputTextType;\r\n    procedure SetAsNumber(AValue: NativeInt);\r\n    procedure SetMaxLength(AValue: NativeInt);\r\n    procedure SetMinLength(AValue: NativeInt);\r\n    procedure SetTextType(AValue: TInputTextType);\r\n  Protected\r\n    Procedure ApplyWidgetSettings(aElement: TJSHTMLElement); override;\r\n  Public\r\n    Class Function AllowChildren : Boolean; override;\r\n    function InputType : String; override;\r\n  Published\r\n    Property Value;\r\n    Property ValueName;\r\n    Property Required;\r\n    Property TextType : TInputTextType Read GetTextType Write SetTextType;\r\n    property AsNumber : NativeInt Read GetAsNumber Write SetAsNumber;\r\n    Property MaxLength : NativeInt Read GetMaxLength Write SetMaxLength;\r\n    Property MinLength : NativeInt Read GetMinLength Write SetMinLength;\r\n    // Todo: List support\r\n  end;\r\n\r\n\r\n  { TButtonInputWidget }\r\n  TInputButtonType = (ibtSubmit,ibtReset,ibtImage);\r\n  TInputButtonTypes = set of TInputButtonType;\r\n\r\n  TButtonInputWidget = class(TCustomInputWidget)\r\n  private\r\n    FButtonType: TInputButtonType;\r\n    FSrc: String;\r\n    procedure SetButtonType(AValue: TInputButtonType);\r\n    procedure SetSrc(AValue: String);\r\n  Public\r\n    Procedure ApplyWidgetSettings(aElement: TJSHTMLElement); override;\r\n    function InputType : String; override;\r\n    Class Function AllowChildren : Boolean; override;\r\n  Published\r\n    Property ButtonType : TInputButtonType Read FButtonType Write SetButtonType;\r\n    Property Value;\r\n    Property ValueName;\r\n    Property Src : String Read FSrc Write SetSrc;\r\n  end;\r\n\r\n  { TCheckableInputWidget }\r\n\r\n  TCheckableInputWidget = class(TCustomInputWidget)\r\n  private\r\n    FChecked: Boolean;\r\n    function GetChecked: Boolean;\r\n    procedure SetChecked(AValue: Boolean);\r\n  Protected\r\n    Procedure ApplyWidgetSettings(aElement: TJSHTMLElement); override;\r\n  Public\r\n    Property Value;\r\n    Property ValueName;\r\n    Property Checked : Boolean Read GetChecked Write SetChecked;\r\n    Property Text;\r\n  end;\r\n\r\n  { TRadioInputWidget }\r\n\r\n  TRadioInputWidget = class(TCheckableInputWidget)\r\n  private\r\n  Public\r\n    function InputType : String; override;\r\n  Published\r\n    Property Value;\r\n    Property ValueName;\r\n    Property Checked;\r\n    Property Text;\r\n  end;\r\n\r\n  { TCheckboxInputWidget }\r\n\r\n  TCheckboxInputWidget = class(TCheckableInputWidget)\r\n  private\r\n  Public\r\n    function InputType : String; override;\r\n  Published\r\n    Property Value;\r\n    Property ValueName;\r\n    Property Checked;\r\n    Property Text;\r\n  end;\r\n\r\n\r\n  { TDateInputWidget }\r\n\r\n  TDateInputWidget = class(TCustomInputWidget)\r\n  private\r\n    FDate: TDateTime;\r\n    function GetDate: TDateTime;\r\n    procedure SetDate(AValue: TDateTime);\r\n  Public\r\n    function InputType : String; override;\r\n    Class Function AllowChildren : Boolean; override;\r\n  Published\r\n    Property Required;\r\n    Property ValueName;\r\n    Property Date : TDateTime Read GetDate Write SetDate;\r\n  end;\r\n\r\n  { TFileInputWidget }\r\n  TFileInfo = record\r\n    Name : String;\r\n    TimeStamp : TDateTime;\r\n    FileType : String;\r\n    Size : NativeInt;\r\n  end;\r\n\r\n  TFileInputWidget = class(TCustomInputWidget)\r\n  private\r\n    FMultiple: Boolean;\r\n    function GetFileCount: Integer;\r\n    function GetFileDate(aIndex : Integer): TDateTime;\r\n    function GetFileInfo(aIndex : Integer): TFileInfo;\r\n    function GetFileName(aIndex : Integer): String;\r\n    function GetFileSize(aIndex : Integer): NativeInt;\r\n    function GetFileType(aIndex : Integer): String;\r\n    function GetMultiple: Boolean;\r\n    procedure SetMultiple(AValue: Boolean);\r\n  Protected\r\n    Procedure ApplyWidgetSettings(aElement: TJSHTMLElement); override;\r\n  Public\r\n    Class Function AllowChildren : Boolean; override;\r\n    function InputType : String; override;\r\n    Property FileCount : Integer read GetFileCount;\r\n    Property Files[aIndex : Integer] : String Read GetFileName;\r\n    Property FileSizes[aIndex : Integer] : NativeInt Read GetFileSize;\r\n    Property FileTypes[aIndex : Integer] : String Read GetFileType;\r\n    Property FileDates[aIndex : Integer] : TDateTime Read GetFileDate;\r\n    Property FileInfos[aIndex : Integer] : TFileInfo Read GetFileInfo;\r\n  Published\r\n    Property ValueName;\r\n    Property Required;\r\n    Property Multiple : Boolean Read GetMultiple Write SetMultiple;\r\n  end;\r\n\r\n  { THiddenInputWidget }\r\n\r\n  THiddenInputWidget = class(TCustomInputWidget)\r\n  Public\r\n    Class Function AllowChildren : Boolean; override;\r\n    function InputType : String; override;\r\n  Published\r\n    Property ValueName;\r\n    Property Value;\r\n    Property Required;\r\n  end;\r\n\r\n  { TTextAreaWidget }\r\n\r\n  TTextAreaWrap = (tawSoft,tawHard,tawOff);\r\n  TTextAreaWidget = Class(TWebWidget)\r\n  private\r\n    FLines: TStrings;\r\n    FIgnoreChanges : Boolean;\r\n    FMaxLength: Cardinal;\r\n    FValueName : String;\r\n    FRows,\r\n    FColumns : Cardinal;\r\n    FWrap: TTextAreaWrap;\r\n    FRequired,\r\n    FReadOnly : Boolean;\r\n    procedure ApplyWrap(aElement: TJSHTMLTextAreaElement);\r\n    procedure DoLineChanges(Sender: TObject);\r\n    function GetColumns: Cardinal;\r\n    function GetLines: TStrings;\r\n    function GetReadOnly: Boolean;\r\n    function GetRequired: Boolean;\r\n    function GetRows: Cardinal;\r\n    function GetText: String;\r\n    function GetValueName: string;\r\n    procedure SetColumns(AValue: Cardinal);\r\n    procedure SetLines(AValue: TStrings);\r\n    procedure SetMaxLength(AValue: Cardinal);\r\n    procedure SetReadonly(AValue: Boolean);\r\n    procedure SetRequired(AValue: Boolean);\r\n    procedure SetRows(AValue: Cardinal);\r\n    procedure SetText(AValue: String);\r\n    procedure SetValueName(AValue: string);\r\n    Function GetTextArea : TJSHTMLTextAreaElement;\r\n    procedure SetWrap(AValue: TTextAreaWrap);\r\n  Protected\r\n    procedure ApplyLines(aElement: TJSHTMLTextAreaElement);\r\n    procedure LinesFromHTML(aHTML : String);\r\n    Procedure SetName(const NewName: TComponentName); override;\r\n    Procedure ApplyWidgetSettings(aElement: TJSHTMLElement); override;\r\n    Property TextArea :TJSHTMLTextAreaElement Read GetTextArea;\r\n  Public\r\n    Constructor Create(aOwner : TComponent); override;\r\n    Destructor Destroy; override;\r\n    Class Function AllowChildren : Boolean; override;\r\n    Function HTMLTag : String; override;\r\n    Property InnerHTML : String Read GetText Write SetText;\r\n  Published\r\n    Property ValueName : string Read GetValueName Write SetValueName;\r\n    Property Rows : Cardinal Read GetRows Write SetRows;\r\n    Property Columns : Cardinal Read GetColumns Write SetColumns;\r\n    Property Lines : TStrings Read GetLines Write SetLines;\r\n    Property MaxLength : Cardinal Read FMaxLength Write SetMaxLength;\r\n    Property Wrap : TTextAreaWrap Read FWrap Write SetWrap;\r\n    Property ReadOnly : Boolean Read GetReadOnly Write SetReadonly;\r\n    Property Required : Boolean Read GetRequired Write SetRequired;\r\n  end;\r\n\r\n  { TImageWidget }\r\n\r\n  TImageWidget = class(TWebWidget)\r\n  private\r\n    FHeight: Integer;\r\n    FWidth: Integer;\r\n    FSrc : String;\r\n    function GetHeight: Integer;\r\n    function GetImg: TJSHTMLImageElement;\r\n    function GetSrc: String;\r\n    function GetWidth: Integer;\r\n    procedure SetHeight(AValue: Integer);\r\n    procedure SetSrc(AValue: String);\r\n    procedure SetWidth(AValue: Integer);\r\n  Protected\r\n    Procedure ApplyWidgetSettings(aElement: TJSHTMLElement); override;\r\n    Property ImgElement : TJSHTMLImageElement Read GetImg;\r\n  Public\r\n    Function HTMLTag : String; override;\r\n  Published\r\n    Property Src : String Read GetSrc Write SetSrc;\r\n    Property Width : Integer Read GetWidth Write SetWidth;\r\n    Property Height : Integer Read GetHeight Write SetHeight;\r\n  end;\r\n\r\n  { TSelectWidget }\r\n\r\n  TJSHTMLOptionElementArray = Array of TJSHTMLOptionElement;\r\n  TCustomSelectWidget = Class;\r\n\r\n\r\n  { TCustomSelectWidget }\r\n\r\n  TCustomSelectWidget = class(TWebWidget)\r\n  Private\r\n    FSize,\r\n    FSelectedIndex : Integer;\r\n    FOptions : TJSHTMLOptionElementArray;\r\n    FMultiple : Boolean;\r\n    function GetMultiple: Boolean;\r\n    function GetSelected(Index : Integer): Boolean;\r\n    function GetSelectedIndex: Integer;\r\n    function GetSelect: TJSHTMLSelectElement;\r\n    function GetSelectionCount: Integer;\r\n    function GetSelectionItem(aIndex : Integer): String;\r\n    function GetSelectionValue(aIndex : Integer): String;\r\n    function GetSize: Integer;\r\n    procedure SetMultiple(AValue: Boolean);\r\n    procedure SetSelected(Index : Integer; AValue: Boolean);\r\n    procedure SetSelectedIndex(AValue: Integer);\r\n    procedure SetSize(AValue: Integer);\r\n  Protected\r\n    Type\r\n      { TSelectOptionEnumerator }\r\n      TSelectOptionEnumerator = Class\r\n      private\r\n        FSelect: TCustomSelectWidget;\r\n      public\r\n        constructor Create(ASelect : TCustomSelectWidget); reintroduce; virtual;\r\n        Function OptionText : String; virtual; abstract;\r\n        Function HasValue : boolean; virtual;\r\n        Function Value : string; virtual;\r\n        function MoveNext: Boolean; virtual; abstract;\r\n        Property Select: TCustomSelectWidget Read FSelect;\r\n      end;\r\n  Protected\r\n    function CreateFixedElements(aSelect: TJSHTMLSelectElement): Integer; virtual;\r\n    function GetItemCount: Integer; virtual;\r\n    Function CreateOptionEnumerator : TSelectOptionEnumerator; virtual; abstract;\r\n    Procedure ApplyWidgetSettings(aElement: TJSHTMLElement); override;\r\n    Procedure BuildOptions(aSelect : TJSHTMLSelectElement); virtual;\r\n    Property Options : TJSHTMLOptionElementArray Read Foptions;\r\n    Property SelectElement : TJSHTMLSelectElement Read GetSelect;\r\n  Protected\r\n    // Can be made public/published\r\n    // Items that are selected\r\n    Property ItemCount : Integer Read GetItemCount;\r\n    Property Selected[Index : Integer] : Boolean Read GetSelected Write SetSelected;\r\n    Property SelectionCount : Integer Read GetSelectionCount;\r\n    Property SelectionValue[aIndex : Integer] : String Read GetSelectionValue;\r\n    Property SelectionItem[aIndex : Integer] : String Read GetSelectionItem;\r\n    property SelectedIndex : Integer Read GetSelectedIndex Write SetSelectedindex;\r\n    Property Multiple : Boolean Read GetMultiple Write SetMultiple;\r\n    Property Size : Integer Read GetSize Write SetSize;\r\n  Public\r\n    Constructor Create(aOWner : TComponent); override;\r\n    Function HTMLTag : String; override;\r\n  end;\r\n\r\n  TSelectWidget = class(TCustomSelectWidget)\r\n  private\r\n    FItems : TStrings;\r\n    FValues : TStrings;\r\n    function GetItems: TStrings;\r\n    function GetValues: TStrings;\r\n    procedure OptionsChanged(Sender: TObject);\r\n    procedure setItems(AValue: TStrings);\r\n    procedure setValues(AValue: TStrings);\r\n  Protected\r\n    Type\r\n      { TStringsSelectOptionEnumerator }\r\n      TStringsSelectOptionEnumerator = Class(TSelectOptionEnumerator)\r\n        FCurrent : Integer;\r\n        constructor Create(ASelect : TCustomSelectWidget); override;\r\n        Function OptionText : String; override;\r\n        Function HasValue : boolean; override;\r\n        Function Value : string; override;\r\n        function MoveNext: Boolean; override;\r\n      end;\r\n    Function CreateOptionEnumerator: TSelectOptionEnumerator; override;\r\n  Public\r\n    Constructor Create(aOWner : TComponent); override;\r\n    Destructor Destroy; override;\r\n    Property SelectionCount;\r\n    Property SelectionValue;\r\n    Property SelectionItem;\r\n    Property Selected;\r\n    Property Options;\r\n    Property SelectElement;\r\n    Property ItemCount;\r\n  Published\r\n    Property Items : TStrings Read GetItems Write setItems;\r\n    Property Values : TStrings Read GetValues Write setValues;\r\n    property SelectedIndex;\r\n    Property Multiple;\r\n    property size;\r\n    property Classes;\r\n  end;\r\n\r\n  { TLabelWidget }\r\n\r\n  TLabelWidget = Class(TWebWidget)\r\n  private\r\n    FLabelFor: TWebWidget;\r\n    FText: String;\r\n    function GetLabelEl: TJSHTMLLabelElement;\r\n    function GetText: String;\r\n    procedure SetLabelFor(AValue: TWebWidget);\r\n    procedure SetText(AValue: String);\r\n  Protected\r\n    procedure ApplyLabelFor(aLabelElement: TJSHTMLLabelElement);\r\n    Procedure Notification(AComponent: TComponent; Operation: TOperation); override;\r\n    Procedure SetName(const NewName: TComponentName); override;\r\n    Procedure ApplyWidgetSettings(aElement: TJSHTMLElement); override;\r\n    Property LabelElement : TJSHTMLLabelElement Read GetLabelEl;\r\n  Public\r\n    Function HTMLTag : String; override;\r\n    Property Text : String Read GetText Write SetText;\r\n    Property LabelFor : TWebWidget Read FLabelFor Write SetLabelFor;\r\n  end;\r\n\r\n  TTextTag = (ttParagraph,ttBold,ttItalic,ttUnderline,ttStrikeThrough,ttSpan,ttQuote,ttBlockQuote,ttH1,ttH2,ttH3,ttH4,ttH5,ttH6,ttPre,ttRuby,ttArticle,ttAddress,ttAbbr,ttCustom);\r\n\r\n  { TTextWidget }\r\n\r\n  { TCustomTextWidget }\r\n\r\n  TCustomTextWidget = Class(TCustomWebWidget)\r\n  private\r\n    FCustomTag: String;\r\n    FEnvelopeTag: TTextTag;\r\n    FTextMode: TTextMode;\r\n    procedure SetCustomTag(AValue: String);\r\n    procedure SetEnvelopeTag(AValue: TTextTag);\r\n    procedure SetTextMode(AValue: TTextMode);\r\n  Protected\r\n    procedure ApplyWidgetSettings(aElement: TJSHTMLElement); override;\r\n    procedure ApplyText(aElement : TJSHTMLElement); virtual;\r\n    Function GetText : String; virtual; abstract;\r\n  Public\r\n    Function HTMLTag : String; override;\r\n  Published\r\n    Property CustomTag : String Read FCustomTag Write SetCustomTag;\r\n    Property EnvelopeTag : TTextTag Read FEnvelopeTag Write SetEnvelopeTag;\r\n    Property TextMode : TTextMode Read FTextMode Write SetTextMode;\r\n  end;\r\n\r\n  TTextWidget = Class(TCustomTextWidget)\r\n  private\r\n    FText : String;\r\n    procedure SetText(AValue: String);\r\n  Protected\r\n    Function GetText : String; override;\r\n  published\r\n    Property Text : String Read FText Write SetText;\r\n  end;\r\n\r\n  { TTextLinesWidget }\r\n\r\n  TTextLinesWidget = Class(TCustomTextWidget)\r\n  private\r\n    FLines : TStrings;\r\n    FForceLineBreaks: Boolean;\r\n    procedure DoLinesChanged(Sender: TObject);\r\n    procedure SetLines(AValue: TStrings);\r\n    procedure SetForceLineBreaks(AValue: Boolean);\r\n  Protected\r\n    Function GetText : String; override;\r\n    procedure ApplyText(aElement : TJSHTMLElement); override;\r\n  Public\r\n    Constructor Create(aOwner : TComponent); override;\r\n    Destructor Destroy; override;\r\n  published\r\n    Property Lines : TStrings Read FLines Write SetLines;\r\n    // When forcelinebreaks is true a <br> will be appended to every line.\r\n    // Note that for TextMode=tmText this means the lines will be rendered as-is, but there will still be a <br> between the lines\r\n    Property ForceLineBreaks : Boolean Read FForceLineBreaks Write SetForceLineBreaks;\r\n  end;\r\n\r\n  { TCustomTableColumn }\r\n  TColumnOption = (coHeader,coCaptionHeader);\r\n  TColumnOptions = set of TColumnOption;\r\n\r\n  TCustomTableColumn = Class(TCollectionItem)\r\n  private\r\n    FAlignment: TAlignment;\r\n    FCaption: String;\r\n    FClassNames: String;\r\n    procedure SetAlignment(AValue: TAlignment);\r\n    procedure SetCaption(AValue: String);\r\n    procedure SetClassNames(AValue: String);\r\n  Protected\r\n    Function RenderColumn : Boolean; virtual;\r\n    Function GetDisplayName: string; override;\r\n    function GetCaption: String; virtual;\r\n  Public\r\n    Procedure Assign(Source : TPersistent); override;\r\n    Property Alignment : TAlignment Read FAlignment Write SetAlignment;\r\n    Property Caption : String Read GetCaption Write SetCaption;\r\n    Property ClassNames : String Read FClassNames Write SetClassNames;\r\n  end;\r\n\r\n  { TCustomTableColumns }\r\n\r\n  TCustomTableColumns = Class(TCollection)\r\n  private\r\n    function GetCustomColumn(Index : Integer): TCustomTableColumn;\r\n    procedure SetCustomColumn(Index : Integer; AValue: TCustomTableColumn);\r\n  Protected\r\n    Property CustomColumns [Index : Integer] : TCustomTableColumn Read GetCustomColumn Write SetCustomColumn; default;\r\n  Public\r\n    Function Add(aCaption : String): TCustomTableColumn; overload;\r\n  end;\r\n\r\n  { TCustomTableWidget }\r\n  TTableOption = (toHeader,    // use THead tag\r\n                  toHeaderRow, // Create header row\r\n                  toBody,      // use TBody tag\r\n                  toFooter,    // use TFoot tag\r\n                  toFooterRow,  // create footer row\r\n                  toRowID,      // add ID to tr: -kind-row\r\n                  toCellID,     // add ID to cell td: -kind-row-col\r\n                  toHeaderRowData,     // Add rowno to <tr data-row> for header.\r\n                  toHeaderCellDataRow, // Add rowno to <th data-row> for header. Automatic if onheadercellclick is set.\r\n                  toHeaderCellDataCol, // Add colno to <th data-col> for header. Automatic if onheadercellclick is set.\r\n                  toBodyRowData,       // Add rowno to <tr data-row> for body.\r\n                  toBodyCellDataRow,   // Add rowno to <th data-row> for body. Automatic if oncellclick is set.\r\n                  toBodyCellDataCol,   // Add colno to <th data-col> for body. Automatic if oncellclick is set.\r\n                  tofooterRowData,     // Add rowno to <tr data-row> for footer\r\n                  tofooterCellDataRow, // Add rowno to <th data-row> for footer. Automatic if onfootercellclick is set.\r\n                  tofooterCellDataCol  // Add colno to <th data-col> for footer. Automatic if onfootercellclick is set.\r\n                  );\r\n  TTableOptions = Set of TTableOption;\r\n\r\n  TRowKind = (rkHeader,rkBody,rkFooter);\r\n\r\nType\r\n  TCustomTableWidget = Class;\r\n\r\n  // Constructed only once when rendering !\r\n  { TTableWidgetCelldata }\r\n  TTableWidgetCellData = Class\r\n  private\r\n    FAsHTML: Boolean;\r\n    FClassNames: String;\r\n    FCol: Integer;\r\n    FColumn: TCustomTableColumn;\r\n    FContent: TJSHTMLElement;\r\n    FKind: TRowKind;\r\n    FRow: Integer;\r\n    FTable: TCustomTableWidget;\r\n    FTableID: String;\r\n    FTag: String;\r\n    FText: String;\r\n    FWidget: TWebWidget;\r\n  Protected\r\n    Procedure SetRowColKind(aRow,aCol : Integer; aKind : TRowKind); virtual;\r\n    Procedure Reset; // do not reset row,col, column\r\n  Public\r\n    Constructor Create(aTable : TCustomTableWidget;aTableID : String); virtual;\r\n    Property Table : TCustomTableWidget Read FTable;\r\n    Property Column : TCustomTableColumn Read FColumn Write FColumn;\r\n    Property Row : Integer Read FRow;\r\n    Property Col : Integer Read FCol;\r\n    Property Kind : TRowKind Read FKind;\r\n    Property Tag : String Read FTag Write FTag;\r\n    Property ClassNames : String Read FClassNames Write FClassNames;\r\n    Property Text : String Read FText Write FText;\r\n    Property AsHTML : Boolean Read FAsHTML Write FAsHTML;\r\n    Property Content : TJSHTMLElement Read FContent Write FContent;\r\n    Property Widget : TWebWidget Read FWidget Write FWidget;\r\n    Property TableID : String Read FTableID;\r\n  end;\r\n\r\n\r\n  TTableRowEnumerator = Class\r\n  private\r\n    FTable: TCustomTableWidget;\r\n    FCurrent : Integer;\r\n  public\r\n    constructor Create(ATable : TCustomTableWidget); reintroduce; virtual;\r\n    Procedure GetCellData(aCell : TTableWidgetCellData); virtual;\r\n    function MoveNext: Boolean; virtual;\r\n    property CurrentRow : Integer Read FCurrent;\r\n    Property Table : TCustomTableWidget Read FTable;\r\n  end;\r\n\r\n  TTableRowCountEnumerator = Class (TTableRowEnumerator)\r\n  private\r\n    FRowCount: Integer;\r\n  public\r\n    constructor Create(ATable : TCustomTableWidget;aCount : Integer); reintroduce;\r\n    function MoveNext: Boolean; override;\r\n    Property RowCount : Integer read FRowCount;\r\n  end;\r\n\r\n  TOnCellDataEvent = Procedure (Sender : TObject; Enum : TTableRowEnumerator; aCell : TTableWidgetCellData) of object;\r\n\r\n  TCustomTableWidget = Class(TCustomWebWidget)\r\n  private\r\n    FCaption: String;\r\n    FColumns: TCustomTableColumns;\r\n    FOnCellClick: THTMLNotifyEvent;\r\n    FOnFooterCellClick: THTMLNotifyEvent;\r\n    FOnFooterRowClick: THTMLNotifyEvent;\r\n    FOnHeaderCellClick: THTMLNotifyEvent;\r\n    FOnHeaderRowClick: THTMLNotifyEvent;\r\n    FOnRowClick: THTMLNotifyEvent;\r\n    FTableOptions: TTableOptions;\r\n    FOnGetCellData : TOnCellDataEvent;\r\n    FWidgets : Array of TWebWidget;\r\n    FUpdateCount : Integer;\r\n    procedure SetCaption(AValue: String);\r\n    procedure SetColumns(AValue: TCustomTableColumns);\r\n    procedure SetTableOptions(AValue: TTableOptions);\r\n  Protected\r\n    procedure AppendCaption(aCaptionElement: TJSHTMLElement); virtual;\r\n    procedure RenderData(aElement: TJSHTMLElement); virtual;\r\n    function DoCellClick(aEvent: TJSMouseEvent): boolean; virtual;\r\n    function DoHeaderCellClick(aEvent: TJSMouseEvent): boolean;virtual;\r\n    function DoFooterCellClick(aEvent: TJSMouseEvent): boolean;virtual;\r\n    function DoRowClick(aEvent: TJSMouseEvent): boolean; virtual;\r\n    function DoHeaderRowClick(aEvent: TJSMouseEvent): boolean;virtual;\r\n    function DoFooterRowClick(aEvent: TJSMouseEvent): boolean;virtual;\r\n    function CreateColumns: TCustomTableColumns; virtual;\r\n    Function DefaultTableOptions: TTableOptions; virtual;\r\n    Procedure CreateDefaultColumns; virtual;\r\n    Function GetRowEnumerator(aKind : TRowKind) : TTableRowEnumerator; virtual;\r\n    function RenderCell(aCell: TTableWidgetCellData): TJSHTMLElement; virtual;\r\n    procedure RenderRow(aEnum : TTableRowEnumerator; aParent: TJSHTMLElement; aKind: TRowKind; aCell: TTableWidgetCellData); virtual;\r\n    procedure RenderRows(aParent: TJSHTMLElement; aKind : TRowKind; aCell: TTableWidgetCellData); virtual;\r\n    Procedure ApplyWidgetSettings(aElement : TJSHTMLElement); override;\r\n    Function HTMLTag : String; override;\r\n    Function CreateCellData(const aTableID : String) : TTableWidgetCellData; virtual;\r\n    Function GetBodyRowEnumerator : TTableRowEnumerator; virtual; abstract;\r\n  Protected\r\n    // These can be made public/published\r\n    Property CustomColumns : TCustomTableColumns Read FColumns Write SetColumns;\r\n    Property TableOptions : TTableOptions read FTableOptions write SetTableOptions;\r\n    Property Caption : String Read FCaption Write SetCaption;\r\n    Property OnGetCellData : TOnCellDataEvent Read FOnGetCellData Write FOnGetCellData;\r\n    Property OnCellClick :  THTMLNotifyEvent Read FOnCellClick Write FOnCellClick;\r\n    Property OnHeaderCellClick :  THTMLNotifyEvent Read FOnHeaderCellClick Write FOnHeaderCellClick;\r\n    Property OnFooterCellClick :  THTMLNotifyEvent Read FOnFooterCellClick Write FOnFooterCellClick;\r\n    Property OnRowClick :  THTMLNotifyEvent Read FOnRowClick Write FOnRowClick;\r\n    Property OnHeaderRowClick :  THTMLNotifyEvent Read FOnHeaderRowClick Write FOnHeaderRowClick;\r\n    Property OnFooterRowClick :  THTMLNotifyEvent Read FOnFooterRowClick Write FOnFooterRowClick;\r\n  Public\r\n    Constructor Create(aOwner : TComponent); override;\r\n    Destructor Destroy; override;\r\n    Procedure BeginUpdate;\r\n    Procedure EndUpdate;\r\n    Procedure RefreshBody;\r\n  end;\r\n\r\n  { TEventTableWidget }\r\n\r\n  TEventTableWidget = Class(TCustomTableWidget)\r\n  private\r\n    FRowCount: Integer;\r\n    procedure SetRowCount(AValue: Integer);\r\n  Protected\r\n    Function GetBodyRowEnumerator : TTableRowEnumerator; override;\r\n  Published\r\n    Property RowCount : Integer Read FRowCount Write SetRowCount;\r\n    Property CustomColumns;\r\n    Property TableOptions;\r\n    Property Caption;\r\n    Property OnGetCellData;\r\n    Property OnCellClick;\r\n    Property OnHeaderCellClick;\r\n    Property OnFooterCellClick;\r\n    Property OnRowClick;\r\n    Property OnHeaderRowClick;\r\n    Property OnFooterRowClick;\r\n  end;\r\n\r\n  { TCustomStringsTableWidget }\r\n\r\n  TCustomStringsTableWidget = Class(TCustomTableWidget)\r\n  private\r\n    Type\r\n      TRow = Array of string;\r\n  private\r\n    FRows : Array of TRow;\r\n    function GetRowCount: Integer;\r\n    procedure SetRowCount(AValue: Integer);\r\n  Protected\r\n    Type\r\n      TStringRowsEnumerator = Class(TTableRowCountEnumerator)\r\n        Procedure GetCellData(aCell : TTableWidgetCellData); override;\r\n      end;\r\n  Protected\r\n    Procedure CheckIndex(aCol,aRow : Integer);\r\n    function GetCell(aCol, aRow : integer): String;\r\n    procedure SetCell(aCol, aRow : integer; AValue: String);\r\n    Function GetBodyRowEnumerator : TTableRowEnumerator; override;\r\n  Public\r\n    Property RowCount : Integer Read GetRowCount Write SetRowCount;\r\n    Property Cells[aCol,aRow : integer] : String Read GetCell Write SetCell;\r\n    Property CustomColumns;\r\n    Property TableOptions;\r\n    Property Caption;\r\n    Property OnGetCellData;\r\n    Property OnCellClick;\r\n    Property OnHeaderCellClick;\r\n    Property OnFooterCellClick;\r\n    Property OnRowClick;\r\n    Property OnHeaderRowClick;\r\n    Property OnFooterRowClick;\r\n  end;\r\n\r\n  TStringsTableWidget = Class(TCustomStringsTableWidget)\r\n  Published\r\n    Property RowCount;\r\n    Property CustomColumns;\r\n    Property TableOptions;\r\n    Property Caption;\r\n    Property OnGetCellData;\r\n    Property OnCellClick;\r\n    Property OnHeaderCellClick;\r\n    Property OnFooterCellClick;\r\n    Property OnRowClick;\r\n    Property OnHeaderRowClick;\r\n    Property OnFooterRowClick;\r\n  end;\r\n\r\n  { TDivWidget }\r\n  THTMLElementTag = (\r\n      etUnknown, eta, etabbr, etacronym, etaddress, etapplet, etarea, etb, etbase,\r\n      etbasefont, etbdo, etbig, etblockquote, etbody, etbr, etbutton,\r\n      etcaption, etcenter, etcite, etcode, etcol, etcolgroup, etdd, etdel,\r\n      etdfn, etdir, etdiv, etdl, etdt, etem, etfieldset, etfont, etform,\r\n      etframe, etframeset, eth1, eth2, eth3, eth4, eth5, eth6, ethead, ethr,\r\n      ethtml, eti, etiframe, etimg, etinput, etins, etisindex, etkbd, etlabel,\r\n      etlegend, etli, etlink, etmap, etmenu, etmeta, etnoframes, etnoscript,\r\n      etobject, etol, etoptgroup, etoption, etp, etparam, etpre, etq, ets,\r\n      etsamp, etscript, etselect, etsmall, etspan, etstrike, etstrong,\r\n      etstyle, etsub, etsup, ettable, ettbody, ettd, ettextarea, ettfoot,\r\n      etth, etthead, ettitle, ettr, ettt, etu, etul, etvar,\r\n      etText,etAudio,etVideo,etSource\r\n  );\r\n  THTMLElementTagSet = set of THTMLElementTag;\r\n\r\n  { TCustomTagWidget }\r\n\r\n  TCustomTagWidget = Class(TWebWidget)\r\n  private\r\n    FElementTag: THTMLElementTag;\r\n    FTextContent: String;\r\n    FTextMode: TTextMode;\r\n    procedure SetElementTag(AValue: THTMLElementTag);\r\n    procedure SetTextContent(AValue: String);\r\n    procedure SetTextMode(AValue: TTextMode);\r\n  Protected\r\n    Procedure ApplyWidgetSettings(aElement: TJSHTMLElement); override;\r\n    // Apply TextContent to aElement, ignore empty unless forceEmpty is true.\r\n    procedure ApplyText(aElement: TJSHTMLElement; aForceEmpty: Boolean);\r\n    Function HTMLTag : String; override;\r\n    // Set tag you wish to use\r\n    Property elementTag : THTMLElementTag Read FElementTag Write SetElementTag;\r\n    // If set, the text will be set as InnerText or InnerHTML of the tag\r\n    Property TextContent : String Read FTextContent Write SetTextContent;\r\n    // Use InnerHTML or InnerText when setting TextContent\r\n    Property TextMode : TTextMode Read FTextMode Write SetTextMode;\r\n  Public\r\n    Procedure ClearContent; override;\r\n\r\n  end;\r\n\r\n  { TTagWidget }\r\n\r\n  TTagWidget = Class(TCustomTagWidget)\r\n  Public\r\n    Constructor Create(aOwner : TComponent); override;\r\n  Published\r\n    Property elementTag;\r\n    Property TextContent;\r\n    Property TextMode;\r\n  end;\r\n\r\n  TDivWidget = Class(TCustomTagWidget)\r\n  Public\r\n    Constructor Create(aOwner : TComponent); override;\r\n  Published\r\n    Property elementTag;\r\n    Property TextContent;\r\n    Property TextMode;\r\n  end;\r\n\r\n  { TParagraphWidget }\r\n\r\n  TParagraphWidget = Class(TCustomTagWidget)\r\n  Public\r\n    Constructor Create(aOwner : TComponent); override;\r\n  Published\r\n    Property elementTag;\r\n    Property TextContent;\r\n    Property TextMode;\r\n  end;\r\n\r\n  { TMediaWidget }\r\n\r\n  TMediaWidget = Class(TCustomTagWidget)\r\n  private\r\n    Const\r\n      MaxAttrs = 20;\r\n      PropAttrs : Array[0..MaxAttrs] of string\r\n         = ('src','defaultPlaybackRate','duration','playbackRate','ended', // 0..4\r\n            'paused','seeking','sinkId','mediaGroup','currentSrc', // 5..9\r\n            'volume','controls','autoplay','crossOrigin', 'defaultMuted', // 10..14\r\n            'currentTime', 'disableRemotePlayback', 'preservesPitch','loop','muted', // 15..19\r\n            'preload' // 20\r\n            );\r\n\r\n    function GetAudioTrack: TJSHTMLAudioTrackList;\r\n    function getBool(AIndex: Integer): Boolean;\r\n    function GetError: TJSMEdiaError;\r\n    function getFloat(AIndex: Integer): Double;\r\n    function GetSrcObj: TJSHTMLMediaStream;\r\n    function getString(AIndex: Integer): String;\r\n    function GetTextTrack: TJSHTMLTextTrackList;\r\n    function GetVideoTrack: TJSHTMLVideoTrackList;\r\n    procedure SetBool(AIndex: Integer; AValue: Boolean);\r\n    procedure SetFloat(AIndex: Integer; AValue: Double);\r\n    procedure SetString(AIndex: Integer; AValue: String);\r\n    function getEl: TJSObject;\r\n  Public\r\n    Property DefaultPlayBackRate : Double Index 1 Read getFloat;\r\n    Property Duration : Double Index 2 Read getFloat;\r\n    Property PlayBackRate : Double Index 3 Read getFloat;\r\n    Property Ended : Boolean Index 4 Read getBool;\r\n    Property Paused : Boolean Index 5 Read getBool;\r\n    Property Seeking : Boolean Index 6 Read getBool;\r\n    Property SinkID : String Index 7 Read getString Write SetString;\r\n    Property MediaGroup : String Index 8 Read getString Write SetString;\r\n    Property SrcObject : TJSHTMLMediaStream Read GetSrcObj;\r\n    Property textTracks : TJSHTMLTextTrackList Read GetTextTrack;\r\n    Property videoTracks : TJSHTMLVideoTrackList Read GetVideoTrack;\r\n    Property audioTracks : TJSHTMLAudioTrackList Read GetAudioTrack;\r\n    Property Error : TJSMEdiaError Read GetError;\r\n    Property CurrentSrc : String Index 9 Read getString;\r\n  Published\r\n    Property Src : String Index 0 Read getString Write SetString;\r\n    Property Controls : Boolean Index 11 Read getBool Write SetBool;\r\n    Property AutoPlay : Boolean Index 12 Read getBool Write SetBool;\r\n    Property CrossOrigin : String index 13 Read getString Write SetString;\r\n    Property DefaultMuted : Boolean Index 14 Read getBool Write SetBool;\r\n    Property CurrentTime : Double Index 15 Read getFloat Write SetFloat;\r\n    Property DisableRemotePlayback : Boolean Index 16 Read getBool Write SetBool;\r\n    Property PreservesPitch : Boolean Index 17 Read getBool Write SetBool;\r\n    Property Loop : Boolean Index 18 Read getBool Write SetBool;\r\n    Property Muted : Boolean Index 19 Read getBool Write SetBool;\r\n    Property Preload : String Index 20 Read getString Write SetString;\r\n    Property Volume : Double Index 10 Read getFloat Write SetFloat;\r\n  end;\r\n\r\n  { TVideoWidget }\r\n\r\n  TVideoWidget = Class(TMediaWidget)\r\n  Public\r\n    Constructor Create(aOwner : TComponent); override;\r\n  end;\r\n\r\n  { TAudioWidget }\r\n\r\n  TAudioWidget = Class(TMediaWidget)\r\n  Public\r\n    Constructor Create(aOwner : TComponent); override;\r\n  end;\r\n\r\n\r\nFunction ViewPort : TViewPort;\r\n\r\nConst\r\n  TextTagNames : Array[TTextTag] of string\r\n   = ('p','b','i','u','s','span','quote','blockquote','h1','h2','h3','h4','h5','h6','pre','ruby','article','address','abbr','');\r\n  RowKindNames  : Array[TRowKind] of string = ('header','body','footer');\r\n\r\n  HTMLTagNames : Array[THTMLElementTag] of string = (\r\n    '?', 'a', 'abbr', 'acronym', 'address', 'applet', 'area', 'b', 'base',\r\n    'basefont', 'bdo', 'big', 'blockquote', 'body', 'br', 'button',\r\n    'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'dd', 'del',\r\n    'dfn', 'dir', 'div', 'dl', 'dt', 'em', 'fieldset', 'font', 'form',\r\n    'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'hr',\r\n    'html', 'i', 'iframe', 'img', 'input', 'ins', 'isindex', 'kbd', 'label',\r\n    'legend', 'li', 'link', 'map', 'menu', 'meta', 'noframes', 'noscript',\r\n    'object', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'q', 's',\r\n    'samp', 'script', 'select', 'small', 'span', 'strike', 'strong',\r\n    'style', 'sub', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot',\r\n    'th', 'thead', 'title', 'tr', 'tt', 'u', 'ul', 'var',\r\n    'Text','Audio','Video','Source'\r\n  );\r\n\r\n\r\nimplementation\r\n\r\nuses \r\n{$IFDEF FPC_DOTTEDUNITS}\r\n  System.DateUtils;\r\n{$ELSE}\r\n  DateUtils;\r\n{$ENDIF}\r\n\r\nresourcestring\r\n  SErrInvalidIndex = 'Index %d not in valid range of [0..%d]';\r\n  SErrInvalidRowCount = 'Invalid row count: %d';\r\n  SRow = 'Row';\r\n  SCol = 'Column';\r\n\r\nFunction ViewPort : TViewPort;\r\n\r\nbegin\r\n  Result:=TViewPort.Instance;\r\nend;\r\n\r\n{ TTableRowCountEnumerator }\r\n\r\nConst\r\n  CellTags : Array[TRowKind] of string = ('th','td','td');\r\n\r\n{ TEventTableWidget }\r\n\r\nprocedure TEventTableWidget.SetRowCount(AValue: Integer);\r\nbegin\r\n  if FRowCount=AValue then Exit;\r\n  BeginUpdate;\r\n  FRowCount:=AValue;\r\n  EndUpdate;\r\nend;\r\n\r\nfunction TEventTableWidget.GetBodyRowEnumerator: TTableRowEnumerator;\r\nbegin\r\n  Result:=TTableRowCountEnumerator.Create(Self,RowCount);\r\nend;\r\n\r\n{ TCustomStringsTableWidget.TStringRowsEnumerator }\r\n\r\nprocedure TCustomStringsTableWidget.TStringRowsEnumerator.GetCellData(aCell: TTableWidgetCellData);\r\nbegin\r\n  aCell.Text:=TCustomStringsTableWidget(Table).Cells[aCell.Col,aCell.Row];\r\nend;\r\n\r\n{ TCustomStringsTableWidget }\r\n\r\nfunction TCustomStringsTableWidget.GetCell(aCol, aRow : integer): String;\r\nbegin\r\n  CheckIndex(aCol,aRow);\r\n  Result:=FRows[aRow][aCol];\r\nend;\r\n\r\nfunction TCustomStringsTableWidget.GetRowCount: Integer;\r\nbegin\r\n  Result:=Length(FRows);\r\nend;\r\n\r\nprocedure TCustomStringsTableWidget.SetCell(aCol, aRow : integer; AValue: String);\r\nbegin\r\n  CheckIndex(aCol,aRow);\r\n  BeginUpdate;\r\n  try\r\n    FRows[aRow][aCol]:=AValue;\r\n  Finally\r\n    EndUpdate;\r\n  end;\r\nend;\r\n\r\nfunction TCustomStringsTableWidget.GetBodyRowEnumerator: TTableRowEnumerator;\r\nbegin\r\n  Result:=TStringRowsEnumerator.Create(Self,RowCount);\r\nend;\r\n\r\nprocedure TCustomStringsTableWidget.SetRowCount(AValue: Integer);\r\nbegin\r\n  if AValue<0 then\r\n     raise EWidgets.CreateFmt(SerrInvalidRowCount, [aValue]);\r\n  BeginUpdate;\r\n  try\r\n    SetLength(FRows,aValue);\r\n  Finally\r\n    EndUpdate;\r\n  end;\r\nend;\r\n\r\nprocedure TCustomStringsTableWidget.CheckIndex(aCol, aRow: Integer);\r\nbegin\r\n  If (aCol<0) or (aCol>=CustomColumns.Count) then\r\n    Raise EWidgets.CreateFmt(SCol+' '+SErrInvalidIndex,[aCol,0,CustomColumns.Count-1]);\r\n  If (aRow<0) or (aRow>=RowCount) then\r\n    Raise EWidgets.CreateFmt(SRow+' '+SErrInvalidIndex,[aRow,0,RowCount-1]);\r\nend;\r\n\r\n{ TTagWidget }\r\n\r\nconstructor TTagWidget.Create(aOwner: TComponent);\r\nbegin\r\n  inherited Create(aOwner);\r\n  ElementTag:=etdiv;\r\nend;\r\n\r\n{ TMediaWidget }\r\n\r\nfunction TMediaWidget.GetAudioTrack: TJSHTMLAudioTrackList;\r\n\r\nbegin\r\n  if Assigned(Element) then\r\n    Result:=TJSHTMLMediaElement(Element).AudioTracks\r\n  else\r\n    Result:=Nil;\r\nend;\r\n\r\nfunction TMediaWidget.getBool(AIndex: Integer): Boolean;\r\n\r\nVar\r\n  El : TJSObject;\r\n  Att : String;\r\n\r\nbegin\r\n  El:=GetEl;\r\n  Att:=PropAttrs[aIndex];\r\n  Result:=Assigned(el) and isDefined(El[Att]) and (Boolean(El[Att]));\r\nend;\r\n\r\nfunction TMediaWidget.GetError: TJSMEdiaError;\r\nbegin\r\n  If Assigned(Element) then\r\n    Result:=TJSHTMLMediaElement(Element).Error\r\n  else\r\n    Result:=Nil;\r\nend;\r\n\r\nfunction TMediaWidget.getFloat(AIndex: Integer): Double;\r\n\r\nVar\r\n  El : TJSObject;\r\n  Att : String;\r\n\r\nbegin\r\n  El:=GetEl;\r\n  Att:=PropAttrs[aIndex];\r\n  if Assigned(el) and isDefined(El[Att]) then\r\n    Result:=Double(El[Att])\r\n  else\r\n    Result:=0;\r\nend;\r\n\r\nfunction TMediaWidget.GetSrcObj: TJSHTMLMediaStream;\r\nbegin\r\n  If Assigned(Element) then\r\n    Result:=TJSHTMLMediaElement(Element).srcObject\r\n  else\r\n    Result:=Nil;\r\nend;\r\n\r\nfunction TMediaWidget.getString(AIndex: Integer): String;\r\n\r\nVar\r\n  El : TJSObject;\r\n  Att : String;\r\n\r\nbegin\r\n  El:=GetEl;\r\n  Att:=PropAttrs[aIndex];\r\n  if Assigned(el) and isDefined(El[Att]) then\r\n    Result:=String(El[Att])\r\n  else\r\n    Result:='';\r\nend;\r\n\r\n\r\nfunction TMediaWidget.GetTextTrack: TJSHTMLTextTrackList;\r\nbegin\r\n  If Assigned(Element) then\r\n    Result:=TJSHTMLMediaElement(Element).TextTracks\r\n  else\r\n    Result:=Nil;\r\nend;\r\n\r\nfunction TMediaWidget.GetVideoTrack: TJSHTMLVideoTrackList;\r\nbegin\r\n  If Assigned(Element) then\r\n    Result:=TJSHTMLMediaElement(Element).VideoTracks\r\n  else\r\n    Result:=Nil;\r\nend;\r\n\r\nprocedure TMediaWidget.SetBool(AIndex: Integer; AValue: Boolean);\r\nVar\r\n  El : TJSObject;\r\n  Att : String;\r\nbegin\r\n  El:=GetEl;\r\n  Att:=PropAttrs[aIndex];\r\n  if Assigned(el) then\r\n    El[Att]:=aValue\r\n  else\r\n    Attrs[Att]:=IntToStr(Ord(AValue));\r\nend;\r\n\r\nprocedure TMediaWidget.SetFloat(AIndex: Integer; AValue: Double);\r\nVar\r\n  El : TJSObject;\r\n  Att,S : String;\r\nbegin\r\n  El:=GetEl;\r\n  Att:=PropAttrs[aIndex];\r\n  if Assigned(el) then\r\n    El[Att]:=aValue\r\n  else\r\n    begin\r\n    Str(aValue,S);\r\n    Attrs[Att]:=S;\r\n    end;\r\nend;\r\n\r\nprocedure TMediaWidget.SetString(AIndex: Integer; AValue: String);\r\n\r\nVar\r\n  El : TJSObject;\r\n  Att : String;\r\nbegin\r\n  El:=GetEl;\r\n  Att:=PropAttrs[aIndex];\r\n  if Assigned(el) then\r\n    El[Att]:=aValue\r\n  else\r\n    Attrs[Att]:=aValue;\r\nend;\r\n\r\nfunction TMediaWidget.getEl: TJSObject;\r\nbegin\r\n  Result:=Element;\r\n  if Not Assigned(Result) then\r\n    Result:=Self.StoredAttrs;\r\nend;\r\n\r\n{ TVideoWidget }\r\n\r\nconstructor TVideoWidget.Create(aOwner: TComponent);\r\nbegin\r\n  inherited Create(aOwner);\r\n  elementTag:=etVideo;\r\nend;\r\n\r\n{ TAudioWidget }\r\n\r\nconstructor TAudioWidget.Create(aOwner: TComponent);\r\nbegin\r\n  inherited Create(aOwner);\r\n  elementTag:=etAudio;\r\nend;\r\n\r\n\r\n{ TSelectWidget.TStringsSelectOptionEnumerator }\r\n\r\nconstructor TSelectWidget.TStringsSelectOptionEnumerator.Create(ASelect: TCustomSelectWidget);\r\nbegin\r\n  inherited Create(ASelect);\r\n  FCurrent:=-1;\r\nend;\r\n\r\nfunction TSelectWidget.TStringsSelectOptionEnumerator.OptionText: String;\r\nbegin\r\n  Result:=TSelectWidget(Select).Items[FCurrent];\r\nend;\r\n\r\nfunction TSelectWidget.TStringsSelectOptionEnumerator.HasValue: boolean;\r\nbegin\r\n  Result:=FCurrent<TSelectWidget(Select).Values.Count;\r\nend;\r\n\r\nfunction TSelectWidget.TStringsSelectOptionEnumerator.Value: string;\r\nbegin\r\n  Result:=TSelectWidget(Select).Values[FCurrent];\r\nend;\r\n\r\nfunction TSelectWidget.TStringsSelectOptionEnumerator.MoveNext: Boolean;\r\nbegin\r\n  Result:=FCurrent<TSelectWidget(Select).Items.Count-1;\r\n  if Result then\r\n    Inc(FCurrent);\r\nend;\r\n\r\n{ TCustomSelectWidget.TSelectOptionEnumerator }\r\n\r\nconstructor TCustomSelectWidget.TSelectOptionEnumerator.Create(ASelect: TCustomSelectWidget);\r\nbegin\r\n  FSelect:=ASelect;\r\nend;\r\n\r\nfunction TCustomSelectWidget.TSelectOptionEnumerator.HasValue: boolean;\r\nbegin\r\n  Result:=False;\r\nend;\r\n\r\nfunction TCustomSelectWidget.TSelectOptionEnumerator.Value: string;\r\nbegin\r\n  Result:='';\r\nend;\r\n\r\nconstructor TTableRowCountEnumerator.Create(ATable: TCustomTableWidget; aCount: Integer);\r\nbegin\r\n  Inherited Create(aTable);\r\n  FRowCount:=aCount;\r\nend;\r\n\r\nfunction TTableRowCountEnumerator.MoveNext: Boolean;\r\nbegin\r\n  Result:=Inherited MoveNext and (CurrentRow<RowCount)\r\nend;\r\n\r\n{ TTableWidgetCellData }\r\n\r\nprocedure TTableWidgetCellData.SetRowColKind(aRow, aCol: Integer; aKind: TRowKind);\r\nbegin\r\n  if (aRow<>-1) then\r\n    FRow:=aRow;\r\n  if (aCol<>-1) then\r\n    FCol:=aCol;\r\n  FKind:=aKind;\r\nend;\r\n\r\nprocedure TTableWidgetCellData.Reset;\r\nbegin\r\n  Ftag:='td';\r\n  FClassNames:='';\r\n  FText:='';\r\n  FContent:=Nil;\r\n  FAsHTML:=False;\r\n  FWidget:=Nil;\r\nend;\r\n\r\nconstructor TTableWidgetCellData.Create(aTable: TCustomTableWidget; aTableID: String);\r\nbegin\r\n  FTable:=aTable;\r\n  FTableID:=aTableID;\r\n  SetRowColKind(0,0,rkBody);\r\nend;\r\n\r\n{ TCustomTableWidget }\r\n\r\nprocedure TCustomTableWidget.SetColumns(AValue: TCustomTableColumns);\r\nbegin\r\n  if FColumns=AValue then Exit;\r\n  FColumns.Assign(AValue);\r\nend;\r\n\r\nprocedure TCustomTableWidget.SetCaption(AValue: String);\r\nbegin\r\n  if FCaption=AValue then Exit;\r\n  FCaption:=AValue;\r\n  if isRendered then Refresh;\r\nend;\r\n\r\nfunction TCustomTableWidget.DoCellClick(aEvent: TJSMouseEvent): boolean;\r\nbegin\r\n  If Assigned(FOnCellClick) then\r\n    FOnCellClick(Self,aEvent);\r\n  If Assigned(FOnRowClick) then\r\n    FOnRowClick(Self,aEvent);\r\n  Result:=False;\r\n//  Writeln('On click for cell',aEvent.targetElement.innerText);\r\nend;\r\n\r\nfunction TCustomTableWidget.DoHeaderCellClick(aEvent: TJSMouseEvent): boolean;\r\nbegin\r\n  If Assigned(FOnHeaderCellClick) then\r\n    FOnHeaderCellClick(Self,aEvent);\r\n  If Assigned(FOnHeaderRowClick) then\r\n    FOnHeaderRowClick(Self,aEvent);\r\n  Result:=False;\r\n//  Writeln('On click for header cell',aEvent.targetElement.innerText);\r\nend;\r\n\r\nfunction TCustomTableWidget.DoFooterCellClick(aEvent: TJSMouseEvent): boolean;\r\nbegin\r\n  If Assigned(FOnFooterCellClick) then\r\n    FOnFooterCellClick(Self,aEvent);\r\n  If Assigned(FOnFooterRowClick) then\r\n    FOnFooterRowClick(Self,aEvent);\r\n  Result:=False;\r\n//  Writeln('On click for Footer cell',aEvent.targetElement.innerText);\r\nend;\r\n\r\nfunction TCustomTableWidget.DoRowClick(aEvent: TJSMouseEvent): boolean;\r\nbegin\r\n  If Assigned(FOnRowClick) then\r\n    FOnRowClick(Self,aEvent);\r\n  Result:=False;\r\n//  Writeln('On click for Row',aEvent.targetElement.innerText);\r\nend;\r\n\r\nfunction TCustomTableWidget.DoHeaderRowClick(aEvent: TJSMouseEvent): boolean;\r\nbegin\r\n  If Assigned(FOnHeaderRowClick) then\r\n    FOnHeaderRowClick(Self,aEvent);\r\n  Result:=False;\r\n//  Writeln('On click for Header Row',aEvent.targetElement.innerText);\r\nend;\r\n\r\nfunction TCustomTableWidget.DoFooterRowClick(aEvent: TJSMouseEvent): boolean;\r\nbegin\r\n  If Assigned(FOnFooterRowClick) then\r\n    FOnFooterRowClick(Self,aEvent);\r\n  Result:=False;\r\n//  Writeln('On click for Footer Row',aEvent.targetElement.innerText);\r\nend;\r\n\r\nprocedure TCustomTableWidget.SetTableOptions(AValue: TTableOptions);\r\nbegin\r\n  if FTableOptions=AValue then Exit;\r\n  FTableOptions:=AValue;\r\n  if IsRendered then\r\n    Refresh;\r\nend;\r\n\r\nprocedure TCustomTableWidget.AppendCaption(aCaptionElement: TJSHTMLElement);\r\nbegin\r\n  aCaptionElement.InnerHTML:=Caption;\r\nend;\r\n\r\nfunction TCustomTableWidget.GetRowEnumerator(aKind: TRowKind): TTableRowEnumerator;\r\nbegin\r\n  Case aKind of\r\n    rkHeader : Result:=TTableRowCountEnumerator.Create(Self,1);\r\n    rkFooter : Result:=TTableRowCountEnumerator.Create(Self,1);\r\n    rkBody : Result:=GetBodyRowEnumerator;\r\n  end;\r\nend;\r\n\r\nprocedure TTableRowEnumerator.GetCellData(aCell: TTableWidgetCellData);\r\n\r\nVar\r\n  K : TRowKind;\r\n\r\nbegin\r\n  K:=aCell.Kind;\r\n  Case K of\r\n    rkHeader:\r\n      begin\r\n      aCell.Tag:='th';\r\n      aCell.Text:=ACell.Column.Caption;\r\n      end;\r\n    rkFooter,\r\n    rkBody :\r\n      begin\r\n      aCell.Tag:='td';\r\n      end;\r\n    end;\r\nend;\r\n\r\nfunction TCustomTableWidget.HTMLTag: String;\r\nbegin\r\n  Result:='table';\r\nend;\r\n\r\nfunction TCustomTableWidget.RenderCell(aCell: TTableWidgetCellData): TJSHTMLElement;\r\n\r\nConst\r\n  Aligns : Array[TAlignment] of string = ('left','right','center');\r\n  RowChecks : Array[TRowKind] of TTableOption = (toHeaderCellDataRow,toBodyCellDataRow,toFooterCellDataRow);\r\n  ColChecks : Array[TRowKind] of TTableOption = (toHeaderCellDataCol,toBodyCellDataCol,toFooterCellDataCol);\r\n\r\nVar\r\n  C : TJSHtmlElement;\r\n  cl : THTMLNotifyEvent;\r\n  K : TRowKind;\r\n  M : THTMLClickEventHandler;\r\n  elID : string;\r\nbegin\r\n  K:=aCell.Kind;\r\n  if (toCellID in TableOptions) or Assigned(aCell.Widget) then\r\n    elID:=aCell.TableID+'-'+RowKindNames[K]+'-'+IntToStr(ACell.Row)+'-'+IntToStr(aCell.Col)\r\n  else\r\n    elID:='';\r\n  C:=CreateElement(aCell.Tag,elID);\r\n  if aCell.Widget<>Nil then\r\n    aCell.Widget.ParentID:=elID;\r\n  if aCell.Content<>Nil then\r\n    C.AppendChild(aCell.Content)\r\n  else if aCell.AsHTML then\r\n    C.innerHTML:=aCell.text\r\n  else\r\n    C.innerText:=aCell.text;\r\n  C.className:=AddClasses(aCell.Column.ClassNames,aCell.ClassNames);\r\n  if ACell.Column.Alignment<>taLeftJustify then\r\n    C.Style.setProperty('text-align',Aligns[ACell.Column.Alignment]);\r\n  Case K of\r\n    rkBody   :\r\n      begin\r\n      CL:=FOnCellClick;\r\n      M:=@DoCellClick;\r\n      end;\r\n    rkHeader :\r\n      begin\r\n      CL:=FOnHeaderCellClick;\r\n      M:=@DoHeaderCellClick;\r\n      end;\r\n    rkFooter :\r\n      begin\r\n      CL:=FOnFooterCellClick;\r\n      M:=@DoFooterCellClick;\r\n      end;\r\n  else\r\n    CL:=Nil;\r\n    M:=nil;\r\n  end;\r\n  if Assigned(cl) or (RowChecks[K] in TableOptions) then\r\n     begin\r\n     C.dataset['row']:=IntToStr(ACell.Row);\r\n     C.Dataset['kind']:=RowKindNames[K];\r\n     end;\r\n  if Assigned(cl) or (ColChecks[K] in TableOptions) then\r\n     begin\r\n     C.dataset['col']:=IntToStr(ACell.Col);\r\n     C.Dataset['kind']:=RowKindNames[K];\r\n     end;\r\n  if Assigned(M) then\r\n    C.OnClick:=M;\r\n  if aCell.Widget<>Nil then\r\n    TJSArray(FWidgets).Push(aCell.Widget);\r\n  Result:=C;\r\nend;\r\n\r\nprocedure TCustomTableWidget.RenderRow(aEnum: TTableRowEnumerator; aParent: TJSHTMLElement; aKind: TRowKind; aCell: TTableWidgetCellData);\r\n\r\n\r\nVar\r\n  I: integer;\r\n\r\nbegin\r\n  For I:=0 to CustomColumns.Count-1 do\r\n    if CustomColumns[i].RenderColumn then\r\n      begin\r\n      aCell.Reset;\r\n      aCell.FColumn:=CustomColumns[i];\r\n      aCell.SetRowColKind(-1,I,aKind);\r\n  //    Writeln(CellKinds[aKind],' cell before : ',aCell.Tag,' data : ',aCell.Text);\r\n      aEnum.GetCellData(aCell);\r\n  //    Writeln(CellKinds[aKind],' cell after : ',aCell.Tag,' data : ',aCell.Text);\r\n      if aCell.Tag='' then\r\n        ACell.Tag:=CellTags[aKind];\r\n      if Assigned(FOnGetCellData) then\r\n        FOnGetCellData(Self,aEnum,aCell);\r\n      aParent.appendChild(RenderCell(aCell));\r\n      end;\r\nend;\r\n\r\nprocedure TCustomTableWidget.RenderRows(aParent: TJSHTMLElement; aKind: TRowKind; aCell: TTableWidgetCellData);\r\n\r\nConst\r\n  TableRowChecks : Array[TRowKind] of TTableOption = (toHeaderRowData,toBodyRowData,toFooterRowData);\r\n\r\nVar\r\n  RowEl : TJSHTMLElement;\r\n  Enum : TTableRowEnumerator;\r\n  M : THTMLClickEventHandler;\r\n  cl : THTMLNotifyEvent;\r\n  elid : String;\r\n\r\nbegin\r\n   Enum:=GetRowEnumerator(aKind);\r\n   if Enum=Nil then\r\n     Exit;\r\n   try\r\n     While Enum.MoveNext do\r\n       begin\r\n       if toRowID in TableOptions then\r\n         elID:=aCell.TableID+'-'+RowKindNames[aKind]+'-'+IntToStr(Enum.CurrentRow)\r\n       else\r\n         elID:='';\r\n       RowEl:=CreateElement('tr',elID);\r\n       aCell.SetRowColKind(Enum.CurrentRow,-1,aKind);\r\n       Case aKind of\r\n         rkBody :\r\n           begin\r\n           CL:=FOnRowClick;\r\n           M:=@DoRowClick;\r\n           end;\r\n         rkHeader :\r\n           begin\r\n           CL:=FOnHeaderRowClick;\r\n           M:=@DoHeaderRowClick;\r\n           end;\r\n         rkFooter :\r\n           begin\r\n           CL:=FOnFooterRowClick;\r\n           M:=@DoFooterRowClick;\r\n           end;\r\n       end;\r\n       if Assigned(CL) or (TableRowChecks[Akind] in TableOptions) then\r\n         begin\r\n         RowEl.dataset['row']:=IntToStr(Enum.CurrentRow);\r\n         RowEl.dataset['kind']:=RowKindNames[aKind];\r\n         end;\r\n       if Assigned(M) then\r\n         RowEl.OnClick:=M;\r\n       RenderRow(Enum,RowEl,aKind,aCell);\r\n       aParent.AppendChild(RowEl);\r\n       end;\r\n   finally\r\n     Enum.Free;\r\n   end;\r\nend;\r\n\r\nprocedure TCustomTableWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\nbegin\r\n  inherited ApplyWidgetSettings(aElement);\r\n  RenderData(aElement);\r\nend;\r\n\r\nprocedure TCustomTableWidget.RenderData(aElement: TJSHTMLElement);\r\n\r\nVar\r\n  El : TJSHTMLElement;\r\n  aCell : TTableWidgetCellData;\r\n  W : TWebWidget;\r\n\r\nbegin\r\n  FWidgets:=[];\r\n  if (Caption<>'') then\r\n    begin\r\n    El:=CreateElement('caption',aElement.ID+'-caption');\r\n    AppendCaption(EL);\r\n    aElement.AppendChild(EL);\r\n    end;\r\n  aCell:=CreateCellData(aElement.ID);\r\n  If (CustomColumns.Count=0) then\r\n    CreateDefaultColumns;\r\n  if toHeaderRow in TableOptions then\r\n    begin\r\n    if toHeader in TableOptions then\r\n      begin\r\n      El:=CreateElement('thead',aElement.ID+'-head');\r\n      aElement.AppendChild(el);\r\n      end\r\n    else\r\n      El:=aElement;\r\n    aCell.SetRowColKind(-1,-1,rkHeader);\r\n    RenderRows(El,rkHeader,aCell);\r\n    end;\r\n  if toBody in TableOptions then\r\n    begin\r\n    El:=CreateElement('tbody',aElement.ID+'-body');\r\n    aElement.AppendChild(el);\r\n    end\r\n  else\r\n    El:=aElement;\r\n  aCell.SetRowColKind(-1,-1,rkBody);\r\n  RenderRows(El,rkBody,aCell);\r\n  if toFooterRow in TableOptions then\r\n    begin\r\n    if toFooter in TableOptions then\r\n      begin\r\n      El:=CreateElement('tFoot',aElement.ID+'-foot');\r\n      aElement.AppendChild(el);\r\n      end\r\n    else\r\n      El:=aElement;\r\n    aCell.SetRowColKind(-1,-1,rkFooter);\r\n    RenderRows(El,rkFooter,aCell);\r\n    end;\r\n  for W in FWidgets do\r\n    W.Refresh;\r\n  FWidgets:=[];\r\nend;\r\n\r\nfunction TCustomTableWidget.CreateCellData(const aTableID : String): TTableWidgetCellData;\r\nbegin\r\n  Result:=TTableWidgetCellData.Create(Self,aTableID);\r\nend;\r\n\r\n\r\nfunction TCustomTableWidget.CreateColumns: TCustomTableColumns;\r\nbegin\r\n  Result:=TCustomTableColumns.Create(TCustomTableColumn);\r\nend;\r\n\r\nfunction TCustomTableWidget.DefaultTableOptions: TTableOptions;\r\nbegin\r\n  Result:=[toHeader,toBody,toFooter,toHeaderRow]\r\nend;\r\n\r\nprocedure TCustomTableWidget.CreateDefaultColumns;\r\nbegin\r\n  // Do nothing\r\nend;\r\n\r\nconstructor TCustomTableWidget.Create(aOwner: TComponent);\r\nbegin\r\n  inherited Create(aOwner);\r\n  FTableOptions:=DefaultTableOptions;\r\n  FColumns:=CreateColumns;\r\nend;\r\n\r\ndestructor TCustomTableWidget.Destroy;\r\nbegin\r\n  FreeAndNil(FColumns);\r\n  inherited Destroy;\r\nend;\r\n\r\nprocedure TCustomTableWidget.BeginUpdate;\r\nbegin\r\n  Inc(FUpDateCount);\r\nend;\r\n\r\nprocedure TCustomTableWidget.EndUpdate;\r\nbegin\r\n  if (FUpdateCount>0) then\r\n    Dec(FUpDateCount);\r\n  if (FUpdateCount=0) and IsRendered then\r\n    Refresh;\r\nend;\r\n\r\nprocedure TCustomTableWidget.RefreshBody;\r\nbegin\r\n  if Not Assigned(Element) then\r\n    Refresh\r\n  else\r\n    begin\r\n    Element.Innerhtml:='';\r\n    RenderData(Element);\r\n    end;\r\nend;\r\n\r\n{ TCustomTableColumn }\r\n\r\nprocedure TCustomTableColumn.SetAlignment(AValue: TAlignment);\r\nbegin\r\n  if FAlignment=AValue then Exit;\r\n  FAlignment:=AValue;\r\nend;\r\n\r\nfunction TCustomTableColumn.GetCaption: String;\r\nbegin\r\n  Result:=FCaption;\r\nend;\r\n\r\nprocedure TCustomTableColumn.SetCaption(AValue: String);\r\nbegin\r\n  if FCaption=AValue then Exit;\r\n  FCaption:=AValue;\r\nend;\r\n\r\nprocedure TCustomTableColumn.SetClassNames(AValue: String);\r\nbegin\r\n  if FClassNames=AValue then Exit;\r\n  FClassNames:=AValue;\r\nend;\r\n\r\nfunction TCustomTableColumn.RenderColumn: Boolean;\r\nbegin\r\n  Result:=True;\r\nend;\r\n\r\nfunction TCustomTableColumn.GetDisplayName: string;\r\nbegin\r\n  Result:=Caption;\r\nend;\r\n\r\nprocedure TCustomTableColumn.Assign(Source: TPersistent);\r\n\r\nVar\r\n  C : TCustomTableColumn;\r\n\r\nbegin\r\n  if Source is TCustomTableColumn then\r\n    begin\r\n    C:=Source as TCustomTableColumn;\r\n    FCaption:=C.FCaption;\r\n    FClassNames:=C.FClassNames;\r\n    FAlignment:=C.Alignment;\r\n    end\r\n  else\r\n    inherited Assign(Source);\r\nend;\r\n\r\n{ TCustomTableColumns }\r\n\r\nfunction TCustomTableColumns.GetCustomColumn(Index : Integer): TCustomTableColumn;\r\nbegin\r\n  Result:=TCustomTableColumn(Items[Index]);\r\nend;\r\n\r\nprocedure TCustomTableColumns.SetCustomColumn(Index : Integer; AValue: TCustomTableColumn);\r\nbegin\r\n  Items[Index]:=aValue;\r\nend;\r\n\r\nfunction TCustomTableColumns.Add(aCaption: String): TCustomTableColumn;\r\nbegin\r\n  Result:=add as TCustomTableColumn;\r\n  Result.Caption:=aCaption;\r\nend;\r\n\r\n{ TTableRowEnumerator }\r\n\r\nconstructor TTableRowEnumerator.Create(ATable: TCustomTableWidget);\r\n\r\nbegin\r\n  FTable:=aTable;\r\n  FCurrent:=-1;\r\nend;\r\n\r\n\r\nfunction TTableRowEnumerator.MoveNext: Boolean;\r\nbegin\r\n  Inc(FCurrent);\r\n  Result:=True;\r\nend;\r\n\r\n{ TCustomTextWidget }\r\n\r\nprocedure TCustomTextWidget.SetEnvelopeTag(AValue: TTextTag);\r\nbegin\r\n  // Writeln('Setting text tag : ',aValue);\r\n  if FEnvelopeTag=AValue then Exit;\r\n  FEnvelopeTag:=AValue;\r\n  if (FEnvelopeTag=ttCustom) and (FCustomTag='') then\r\n    FCustomTag:='div';\r\n  if IsRendered then\r\n    Refresh;\r\nend;\r\n\r\nprocedure TCustomTextWidget.SetCustomTag(AValue: String);\r\nbegin\r\n  if FCustomTag=AValue then Exit;\r\n  FCustomTag:=AValue;\r\n  if (FCustomTag<>'') then\r\n    FEnvelopeTag:=ttCustom;\r\n  if IsRendered then\r\n    Refresh;\r\nend;\r\n\r\n\r\nprocedure TCustomTextWidget.SetTextMode(AValue: TTextMode);\r\nbegin\r\n  if FTextMode=AValue then Exit;\r\n  FTextMode:=AValue;\r\n  if IsRendered then\r\n    ApplyText(Element);\r\nend;\r\n\r\nprocedure TCustomTextWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\nbegin\r\n  // Writeln('ApplyWidgetSettings: ',aElement.tagName);\r\n  inherited ApplyWidgetSettings(aElement);\r\n  ApplyText(aElement);\r\nend;\r\n\r\nprocedure TCustomTextWidget.ApplyText(aElement: TJSHTMLElement);\r\nbegin\r\n  if FTextMode=tmText then\r\n    aElement.innerText:=GetText\r\n  else\r\n    aElement.innerHTML:=GetText;\r\nend;\r\n\r\nfunction TCustomTextWidget.HTMLTag: String;\r\n\r\nbegin\r\n  Result:=TextTagNames[FEnvelopeTag];\r\n  if Result='' then\r\n    Result:='div';\r\n  // Writeln('Getting element tag: ',Result);\r\nend;\r\n\r\n{ TTextLinesWidget }\r\n\r\nprocedure TTextLinesWidget.SetLines(AValue: TStrings);\r\nbegin\r\n  if FLines=AValue then Exit;\r\n  FLines.Assign(AValue);\r\nend;\r\n\r\nprocedure TTextLinesWidget.SetForceLineBreaks(AValue: Boolean);\r\nbegin\r\n  if FForceLineBreaks=AValue then Exit;\r\n  FForceLineBreaks:=AValue;\r\n  if IsRendered then\r\n    ApplyText(Element);\r\nend;\r\n\r\nprocedure TTextLinesWidget.DoLinesChanged(Sender: TObject);\r\nbegin\r\n  if IsRendered then\r\n    ApplyText(Element);\r\nend;\r\n\r\nfunction TTextLinesWidget.GetText: String;\r\n\r\nVar\r\n  I : integer;\r\n\r\nbegin\r\n  if (FTextMode=tmHTML) and ForceLineBreaks then\r\n    begin\r\n    Result:='';\r\n    For I:=0 to FLines.Count-1 do\r\n      Result:=Result+flines[i]+'<br/>';\r\n    end\r\n  else\r\n    Result:=FLines.Text;\r\nend;\r\n\r\nprocedure TTextLinesWidget.ApplyText(aElement: TJSHTMLElement);\r\n\r\nVar\r\n  I : integer;\r\n\r\nbegin\r\n  if (TextMode=tmHTML) or (Not ForceLineBreaks)  then\r\n    inherited ApplyText(aElement)\r\n  else\r\n    begin\r\n    For I:=0 to FLines.Count-1 do\r\n      begin\r\n      aElement.AppendChild(Document.createTextNode(FLines[i]));\r\n      aElement.AppendChild(CreateElement('br',''));\r\n      end;\r\n    end;\r\nend;\r\n\r\nconstructor TTextLinesWidget.Create(aOwner: TComponent);\r\nbegin\r\n  inherited Create(aOwner);\r\n  FLines:=TstringList.Create;\r\n  TstringList(FLines).OnChange:=@DoLinesChanged;\r\nend;\r\n\r\ndestructor TTextLinesWidget.Destroy;\r\nbegin\r\n  FLines:=TstringList.Create;\r\n  inherited Destroy;\r\nend;\r\n\r\n{ TTextWidget }\r\n\r\nprocedure TTextWidget.SetText(AValue: String);\r\nbegin\r\n  if FText=AValue then Exit;\r\n  FText:=AValue;\r\n  if IsRendered then\r\n    ApplyText(Element);\r\nend;\r\n\r\nfunction TTextWidget.GetText: String;\r\nbegin\r\n  Result:=FText;\r\nend;\r\n\r\n\r\n\r\n{ TLabelWidget }\r\n\r\nprocedure TLabelWidget.ApplyLabelFor(aLabelElement : TJSHTMLLabelElement);\r\n\r\nbegin\r\n  if Assigned(FlabelFor) then\r\n    begin\r\n    FlabelFor.EnsureElement;\r\n    aLabelElement.for_:=FlabelFor.ElementID;\r\n    end\r\n  else\r\n    aLabelElement.for_:='';\r\nend;\r\n\r\nprocedure TLabelWidget.SetLabelFor(AValue: TWebWidget);\r\nbegin\r\n  if (FLabelFor=AValue) then Exit;\r\n  if Assigned(FLabelFor) then\r\n    FLabelFor.RemoveFreeNotification(Self);\r\n  FLabelFor:=AValue;\r\n  if Assigned(FLabelFor) then\r\n    FLabelFor.FreeNotification(Self);\r\n  If IsRendered then\r\n    ApplyLabelFor(LabelElement);\r\nend;\r\n\r\nfunction TLabelWidget.GetText: String;\r\nbegin\r\n  if IsElementDirty then\r\n    FText:=Element.InnerText;\r\n  Result:=FText;\r\nend;\r\n\r\nfunction TLabelWidget.GetLabelEl: TJSHTMLLabelElement;\r\nbegin\r\n  Result:=TJSHTMLLabelElement(Element);\r\nend;\r\n\r\nprocedure TLabelWidget.SetText(AValue: String);\r\nbegin\r\n  If Text=aValue then exit;\r\n  Ftext:=aValue;\r\n  If IsRendered then\r\n    Element.innerText:=aValue;\r\nend;\r\n\r\nprocedure TLabelWidget.Notification(AComponent: TComponent; Operation: TOperation);\r\nbegin\r\n  inherited Notification(AComponent, Operation);\r\n  if (Operation=opRemove) and (aComponent=FLabelFor) then\r\n    FLabelFor:=Nil;\r\nend;\r\n\r\nprocedure TLabelWidget.SetName(const NewName: TComponentName);\r\n\r\nVar\r\n  Old : String;\r\n\r\nbegin\r\n  Old:=Name;\r\n  inherited SetName(NewName);\r\n  if (csDesigning in ComponentState) then\r\n    if Old=Text then\r\n      Text:=Old;\r\nend;\r\n\r\nprocedure TLabelWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\n\r\nvar\r\n  lbl : TJSHTMLLabelElement absolute aElement;\r\n\r\nbegin\r\n  inherited ApplyWidgetSettings(aElement);\r\n  lbl.InnerText:=Text;\r\n  ApplyLabelFor(Lbl);\r\nend;\r\n\r\n\r\nfunction TLabelWidget.HTMLTag: String;\r\nbegin\r\n  Result:='label';\r\nend;\r\n\r\n{ TSelectWidget }\r\n\r\nfunction TCustomSelectWidget.GetSelectedIndex: Integer;\r\nbegin\r\n  if IsRendered then\r\n    FSelectedIndex:=SelectElement.selectedIndex;\r\n  Result:=FSelectedIndex\r\nend;\r\n\r\nfunction TCustomSelectWidget.GetMultiple: Boolean;\r\n\r\nbegin\r\n  if IsElementDirty then\r\n    FMultiple:=SelectElement.multiple;\r\n  Result:=FMultiple;\r\nend;\r\n\r\nfunction TCustomSelectWidget.GetItemCount: Integer;\r\nbegin\r\n  Result:=Length(Options);\r\nend;\r\n\r\nfunction TCustomSelectWidget.GetSelected(Index : Integer): Boolean;\r\nbegin\r\n  if (Index<0) or (Index>=Length(Foptions)) then\r\n     Raise EWidgets.CreateFmt(SErrInvalidIndex,[Index,Length(Foptions)-1]);\r\n  Result:=FOptions[Index].Selected\r\nend;\r\n\r\nfunction TCustomSelectWidget.GetSelect: TJSHTMLSelectElement;\r\nbegin\r\n  Result:=TJSHTMLSelectElement(Element);\r\nend;\r\n\r\nfunction TCustomSelectWidget.GetSelectionCount: Integer;\r\nbegin\r\n  Result:=SelectElement.selectedOptions.length;\r\nend;\r\n\r\nfunction TCustomSelectWidget.GetSelectionItem(aIndex : Integer): String;\r\nbegin\r\n  if (aIndex<0) or (aindex>=GetSelectionCount) then\r\n     Raise EWidgets.CreateFmt(SErrInvalidIndex,[aIndex,GetSelectionCount-1]);\r\n  Result:=TJSHTMLOptionElement(SelectElement.selectedOptions.item(aIndex)).innerText;\r\nend;\r\n\r\nfunction TCustomSelectWidget.GetSelectionValue(aIndex : Integer): String;\r\nbegin\r\n  if (aIndex<0) or (aindex>=GetSelectionCount) then\r\n     Raise EWidgets.CreateFmt(SErrInvalidIndex,[aIndex,GetSelectionCount-1]);\r\n  Result:=TJSHTMLOptionElement(SelectElement.selectedOptions.item(aIndex)).value;\r\nend;\r\n\r\nfunction TCustomSelectWidget.GetSize: Integer;\r\nbegin\r\n  if IsElementDirty then\r\n    FSize:=SelectElement.Size;\r\n  Result:=FSize;\r\nend;\r\n\r\nprocedure TCustomSelectWidget.SetMultiple(AValue: Boolean);\r\nbegin\r\n  If (AValue=Multiple) then exit;\r\n  FMultiple:=aValue;\r\n  If IsRendered then\r\n    SelectElement.multiple:=FMultiple;\r\nend;\r\n\r\nprocedure TCustomSelectWidget.SetSelected(Index : Integer; AValue: Boolean);\r\nbegin\r\n  if (Index<0) or (Index>=Length(Foptions)) then\r\n     Raise EWidgets.CreateFmt(SErrInvalidIndex,[Index,Length(Foptions)-1]);\r\n  FOptions[Index].Selected:=aValue;\r\nend;\r\n\r\nprocedure TCustomSelectWidget.SetSelectedIndex(AValue: Integer);\r\n\r\nbegin\r\n  if (SelectedIndex=aValue) then\r\n    Exit;\r\n  FSelectedIndex:=aValue;\r\n  if IsRendered then\r\n    SelectElement.SelectedIndex:=FSelectedIndex;\r\n  if Assigned(OnChange) then\r\n    OnChange(Self,Nil);\r\nend;\r\n\r\nprocedure TCustomSelectWidget.SetSize(AValue: Integer);\r\nbegin\r\n  If (AValue=Size) then exit;\r\n  FSize:=aValue;\r\n  If IsRendered and (Size<>-1) then\r\n    SelectElement.Size:=FSize;\r\nend;\r\n\r\nFunction TCustomSelectWidget.CreateFixedElements(aSelect: TJSHTMLSelectElement) : Integer;\r\n\r\nbegin\r\n  if aSelect<>Nil then ;\r\n  Result:=0;\r\nend;\r\n\r\nprocedure TCustomSelectWidget.BuildOptions(aSelect: TJSHTMLSelectElement);\r\n\r\nVar\r\n  O : TJSHTMLOptionElement;\r\n  Idx : Integer;\r\n  enum : TSelectOptionEnumerator;\r\n\r\nbegin\r\n  // Clear\r\n  SetLength(FOptions,0);\r\n  aSelect.InnerHTML:='';\r\n  // Rebuild\r\n  Idx:=CreateFixedElements(aSelect);\r\n  enum:=CreateOptionEnumerator;\r\n  While enum.MoveNext do\r\n    begin\r\n    O:=TJSHTMLOptionElement(CreateElement('option',''));\r\n    O.innerText:=enum.OptionText;\r\n    if enum.HasValue then\r\n      O.value:=enum.Value;\r\n    if Idx=FSelectedIndex then\r\n      O.selected:=True;\r\n    aSelect.AppendChild(O);\r\n    Inc(Idx);\r\n    end;\r\n  SetLength(Foptions,Idx);\r\n  Dec(idx);\r\n  While Idx>=0 do\r\n    begin\r\n    FOptions[Idx]:=TJSHTMLOptionElement(aSelect.Children[Idx]);\r\n    dec(Idx);\r\n    end;\r\nend;\r\n\r\nconstructor TCustomSelectWidget.Create(aOWner: TComponent);\r\nbegin\r\n  inherited Create(aOWner);\r\n  FSelectedIndex:=-1;\r\n  FSize:=-1;\r\nend;\r\n\r\nprocedure TCustomSelectWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\n\r\nVar\r\n  el : TJSHTmlSelectElement absolute aElement;\r\n\r\nbegin\r\n  inherited ApplyWidgetSettings(aElement);\r\n  el.multiple:=Self.Multiple;\r\n//  Writeln('Checking size : ',FSize);\r\n  if FSize<>-1 then\r\n    el.Size:=FSize;\r\n  BuildOptions(el);\r\n  // We need to force this.\r\n  if SelectedIndex=-1 then\r\n    el.selectedIndex:=-1;\r\nend;\r\n\r\n\r\nfunction TCustomSelectWidget.HTMLTag: String;\r\nbegin\r\n  Result:='select';\r\nend;\r\n\r\n\r\n{ TSelectWidget }\r\n\r\nfunction TSelectWidget.GetItems: TStrings;\r\nbegin\r\n  Result:=FItems;\r\nend;\r\n\r\n\r\nfunction TSelectWidget.GetValues: TStrings;\r\nbegin\r\n  Result:=FValues;\r\nend;\r\n\r\nprocedure TSelectWidget.OptionsChanged(Sender: TObject);\r\nbegin\r\n  if IsRendered then\r\n    BuildOptions(SelectElement);\r\nend;\r\n\r\n\r\nprocedure TSelectWidget.setItems(AValue: TStrings);\r\nbegin\r\n  If (AValue=FItems) then exit;\r\n  FItems.Assign(aValue);\r\nend;\r\n\r\n\r\nprocedure TSelectWidget.setValues(AValue: TStrings);\r\nbegin\r\n  If (AValue=FValues) then exit;\r\n  FValues.Assign(aValue);\r\nend;\r\n\r\nfunction TSelectWidget.CreateOptionEnumerator: TSelectOptionEnumerator;\r\nbegin\r\n  Result:=TStringsSelectOptionEnumerator.Create(Self);\r\nend;\r\n\r\n\r\nconstructor TSelectWidget.Create(aOWner: TComponent);\r\nbegin\r\n  inherited Create(aOWner);\r\n  FItems:=TStringList.Create;\r\n  TStringList(FItems).OnChange:=@OptionsChanged;\r\n  FValues:=TStringList.Create;\r\n  TStringList(FValues).OnChange:=@OptionsChanged;\r\nend;\r\n\r\ndestructor TSelectWidget.Destroy;\r\nbegin\r\n  FreeAndNil(FItems);\r\n  FreeAndNil(FValues);\r\n  inherited Destroy;\r\nend;\r\n\r\n{ TImageWidget }\r\n\r\nfunction TImageWidget.GetHeight: Integer;\r\nbegin\r\n  if IsElementDirty then\r\n    FHeight:=ImgElement.Height;\r\n  Result:=Fheight;\r\nend;\r\n\r\nfunction TImageWidget.GetImg: TJSHTMLImageElement;\r\nbegin\r\n  Result:=TJSHTMLImageElement(Element);\r\nend;\r\n\r\nfunction TImageWidget.GetSrc: String;\r\nbegin\r\n  if IsElementDirty then\r\n    FSrc:=ImgElement.Src;\r\n  Result:=FSrc;\r\nend;\r\n\r\nfunction TImageWidget.GetWidth: Integer;\r\nbegin\r\n  if IsElementDirty then\r\n    FWidth:=ImgElement.Width;\r\n  Result:=FWidth;\r\nend;\r\n\r\nprocedure TImageWidget.SetHeight(AValue: Integer);\r\nbegin\r\n  if AValue=Height then exit;\r\n  FHeight:=AValue;\r\n  If isrendered then\r\n    ImgElement.Height:=aValue;\r\nend;\r\n\r\nprocedure TImageWidget.SetSrc(AValue: String);\r\nbegin\r\n  if AValue=Src then exit;\r\n  FSrc:=AValue;\r\n  If isrendered then\r\n    ImgElement.Src:=FSrc;\r\nend;\r\n\r\nprocedure TImageWidget.SetWidth(AValue: Integer);\r\nbegin\r\n  if AValue=Width then exit;\r\n  FWidth:=AValue;\r\n  If isrendered then\r\n    ImgElement.Width:=aValue;\r\nend;\r\n\r\nprocedure TImageWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\n\r\nvar\r\n  img : TJSHTMLImageElement absolute aElement;\r\n\r\nbegin\r\n  inherited ApplyWidgetSettings(aElement);\r\n  Img.Src:=FSrc;\r\n  Img.Height:=FHeight;\r\n  Img.Width:=FWidth;\r\nend;\r\n\r\nfunction TImageWidget.HTMLTag: String;\r\nbegin\r\n  Result:='img';\r\nend;\r\n\r\n{ TTextAreaWidget }\r\n\r\nprocedure TTextAreaWidget.SetLines(AValue: TStrings);\r\nbegin\r\n  if FLines=AValue then Exit;\r\n  FLines.Assign(AValue);\r\nend;\r\n\r\nprocedure TTextAreaWidget.SetMaxLength(AValue: Cardinal);\r\nbegin\r\n  if FMaxLength=AValue then Exit;\r\n  FMaxLength:=AValue;\r\n  if IsRendered then\r\n    TextArea.maxLength:=aValue;\r\nend;\r\n\r\nprocedure TTextAreaWidget.SetReadonly(AValue: Boolean);\r\nbegin\r\n  If aValue=ReadOnly then exit;\r\n  FReadOnly:=aValue;\r\n  if IsRendered then\r\n    TextArea.Readonly:=FReadOnly;\r\nend;\r\n\r\nprocedure TTextAreaWidget.SetRequired(AValue: Boolean);\r\nbegin\r\n  If aValue=Required then exit;\r\n  FRequired:=aValue;\r\n  if IsRendered then\r\n    TextArea.Required:=FRequired;\r\nend;\r\n\r\nfunction TTextAreaWidget.GetColumns: Cardinal;\r\nbegin\r\n  if IsElementDirty then\r\n    FColumns:=TextArea.Cols;\r\n  Result:=FColumns;\r\nend;\r\n\r\nprocedure TTextAreaWidget.DoLineChanges(Sender: TObject);\r\nbegin\r\n  if isRendered and not FIgnoreChanges then\r\n    ApplyLines(TextArea);\r\nend;\r\n\r\n\r\nfunction TTextAreaWidget.GetLines: TStrings;\r\nbegin\r\n  // We may want to change this to something more efficient. Maybe handle onchange\r\n  // Note that if yo\r\n  if IsElementDirty  then\r\n    begin\r\n    FIgnoreChanges:=True;\r\n    try\r\n      LinesFromHTML(Element.InnerHTml);\r\n    finally\r\n      FIgnoreChanges:=False;\r\n    end;\r\n    end;\r\n  Result:=FLines;\r\nend;\r\n\r\nfunction TTextAreaWidget.GetReadOnly: Boolean;\r\nbegin\r\n  if IsElementDirty then\r\n    FReadonly:=TextArea.readOnly;\r\n  Result:=FReadonly;\r\nend;\r\n\r\nfunction TTextAreaWidget.GetRequired: Boolean;\r\nbegin\r\n  if IsElementDirty then\r\n    FRequired:=TextArea.Required;\r\n  Result:=FRequired;\r\nend;\r\n\r\nfunction TTextAreaWidget.GetRows: Cardinal;\r\nbegin\r\n  if IsElementDirty then\r\n    FRows:=TextArea.Rows;\r\n  Result:=FRows;\r\nend;\r\n\r\nfunction TTextAreaWidget.GetText: String;\r\nbegin\r\n  if IsElementDirty then\r\n    Result:=Element.InnerHTML\r\n  else\r\n    Result:=FLines.Text;\r\nend;\r\n\r\nfunction TTextAreaWidget.GetValueName: string;\r\nbegin\r\n  if IsElementDirty then\r\n    FValueName:=Element.Name;\r\n  Result:=FValueName;\r\nend;\r\n\r\nprocedure TTextAreaWidget.SetColumns(AValue: Cardinal);\r\nbegin\r\n  if AValue=FColumns then exit;\r\n  FColumns:=aValue;\r\n  if isRendered then\r\n    TextArea.cols:=aValue;\r\nend;\r\n\r\nprocedure TTextAreaWidget.SetRows(AValue: Cardinal);\r\nbegin\r\n  if AValue=FRows then exit;\r\n  FRows:=aValue;\r\n  if isRendered then\r\n    TextArea.Rows:=aValue;\r\nend;\r\n\r\nprocedure TTextAreaWidget.SetText(AValue: String);\r\nbegin\r\n  if isRendered then\r\n    element.InnerText:=aValue\r\n  else\r\n    LinesFromHTML(aValue);\r\nend;\r\n\r\nprocedure TTextAreaWidget.SetValueName(AValue: string);\r\nbegin\r\n  if aValue=FValueName then exit;\r\n  FValueName:=aValue;\r\n  if IsRendered then\r\n    TextArea.Name:=aValue;\r\nend;\r\n\r\nprocedure TTextAreaWidget.SetName(const NewName: TComponentName);\r\n\r\nvar\r\n  Old : String;\r\nbegin\r\n  Old:=Name;\r\n  inherited SetName(NewName);\r\n  if csDesigning in ComponentState then\r\n    begin\r\n    if (FLines.Count=0) then\r\n      FLines.Add(Name)\r\n    else if (FLines.Count=1) and (FLines[0]=Old) then\r\n      FLines[0]:=Name;\r\n    end;\r\nend;\r\n\r\nprocedure TTextAreaWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\n\r\nvar\r\n  area : TJSHTMLTextAreaElement absolute aElement;\r\n\r\nbegin\r\n  inherited ApplyWidgetSettings(aElement);\r\n  if FMaxLength>0 then\r\n    area.maxlength:=FMaxLength;\r\n  if FColumns>0 then\r\n    area.cols:=FColumns;\r\n  if FRows>0 then\r\n    area.Rows:=FRows;\r\n  if FLines.Count>0 then\r\n    ApplyLines(area);\r\n  if FValueName<>'' then\r\n    area.Name:=FValueName;\r\n  area.Readonly:=FReadOnly;\r\n  area.Required:=FRequired;\r\n  ApplyWrap(area);\r\nend;\r\n\r\n\r\nconstructor TTextAreaWidget.Create(aOwner: TComponent);\r\nbegin\r\n  inherited Create(aOwner);\r\n  FLines:=TStringList.Create;\r\n  TStringList(FLines).OnChange:=@DoLineChanges;\r\n  FColumns:=50;\r\n  FRows:=10;\r\nend;\r\n\r\ndestructor TTextAreaWidget.Destroy;\r\nbegin\r\n  FreeAndNil(Flines);\r\n  inherited;\r\nend;\r\n\r\nclass function TTextAreaWidget.AllowChildren: Boolean;\r\nbegin\r\n  Result:=False;\r\nend;\r\n\r\nfunction TTextAreaWidget.GetTextArea: TJSHTMLTextAreaElement;\r\nbegin\r\n  Result:=TJSHTMLTextAreaElement(Element);\r\nend;\r\n\r\nprocedure TTextAreaWidget.ApplyWrap(aElement :TJSHTMLTextAreaElement);\r\n\r\nConst\r\n  Wraps : Array[TTextAreaWrap] of string = ('soft','hard','off');\r\n\r\nbegin\r\n  aElement.wrap:=Wraps[FWrap];\r\nend;\r\n\r\nprocedure TTextAreaWidget.ApplyLines(aElement: TJSHTMLTextAreaElement);\r\nbegin\r\n  aElement.innerHTML:=FLines.Text;\r\nend;\r\n\r\nprocedure TTextAreaWidget.LinesFromHTML(aHTML: String);\r\nbegin\r\n  FLines.Text:= StringReplace(aHTML,'<br>',sLineBreak,[rfIgnoreCase,rfReplaceAll]);\r\nend;\r\n\r\n\r\n\r\nprocedure TTextAreaWidget.SetWrap(AValue: TTextAreaWrap);\r\n\r\nbegin\r\n  if FWrap=AValue then Exit;\r\n  FWrap:=AValue;\r\n  if IsRendered then\r\n    ApplyWrap(TextArea)\r\nend;\r\n\r\nfunction TTextAreaWidget.HTMLTag: String;\r\nbegin\r\n  result:='textarea';\r\nend;\r\n\r\n{ TCheckboxInputWidget }\r\n\r\nfunction TCheckboxInputWidget.InputType: String;\r\nbegin\r\n  Result:='checkbox';\r\nend;\r\n\r\n{ TRadioInputWidget }\r\n\r\nfunction TRadioInputWidget.InputType: String;\r\nbegin\r\n  Result:='radio';\r\nend;\r\n\r\n{ THiddenInputWidget }\r\n\r\nclass function THiddenInputWidget.AllowChildren: Boolean;\r\nbegin\r\n  Result:=False;\r\nend;\r\n\r\nfunction THiddenInputWidget.InputType: String;\r\nbegin\r\n  Result:='hidden';\r\nend;\r\n\r\n{ TFileInputWidget }\r\n\r\nprocedure TFileInputWidget.SetMultiple(AValue: Boolean);\r\nbegin\r\n  if FMultiple=AValue then Exit;\r\n  FMultiple:=AValue;\r\n  if Isrendered then\r\n    InputElement.multiple:=FMultiple;\r\nend;\r\n\r\nfunction TFileInputWidget.GetMultiple: Boolean;\r\nbegin\r\n  if IsElementDirty  then\r\n    FMultiple:=InputElement.multiple;\r\n  Result:=FMultiple;\r\nend;\r\n\r\n\r\nfunction TFileInputWidget.GetFileName(aIndex : Integer): String;\r\nbegin\r\n  Result:=InputElement.files.Files[aIndex].name;\r\nend;\r\n\r\nfunction TFileInputWidget.GetFileSize(aIndex : Integer): NativeInt;\r\nbegin\r\n  Result:=InputElement.files.Files[aIndex].Size;\r\nend;\r\n\r\nfunction TFileInputWidget.GetFileType(aIndex : Integer): String;\r\nbegin\r\n  Result:=InputElement.files.Files[aIndex].Type_;\r\nend;\r\n\r\nfunction TFileInputWidget.GetFileCount: Integer;\r\nbegin\r\n  Result:=InputElement.files.Length;\r\nend;\r\n\r\nfunction TFileInputWidget.GetFileDate(aIndex : Integer): TDateTime;\r\nbegin\r\n  Result:=JSDateToDateTime(InputElement.files.Files[aIndex].lastModifiedDate);\r\nend;\r\n\r\nfunction TFileInputWidget.GetFileInfo(aIndex : Integer): TFileInfo;\r\n\r\nVar\r\n  f : TJSHTMLFile;\r\n\r\nbegin\r\n  F:=InputElement.files.Files[aIndex];\r\n  Result.Name:=F.name;\r\n  Result.Size:=F.size;\r\n  Result.FileType:=F.type_;\r\n  Result.TimeStamp:= JSDateToDateTime(F.lastModifiedDate);\r\nend;\r\n\r\n\r\nprocedure TFileInputWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\n\r\nVar\r\n  Old : String;\r\n\r\nbegin\r\n  Old:=FValue;\r\n  FValue:='';\r\n  try\r\n    inherited ApplyWidgetSettings(aElement);\r\n    TJSHTMLInputElement(aElement).multiple:=FMultiple;\r\n  finally\r\n    FValue:=Old;\r\n  end;\r\nend;\r\n\r\nclass function TFileInputWidget.AllowChildren: Boolean;\r\nbegin\r\n  Result:=False;\r\nend;\r\n\r\nfunction TFileInputWidget.InputType: String;\r\nbegin\r\n  Result:='file';\r\nend;\r\n\r\n\r\n{ TDateInputWidget }\r\n\r\nfunction TDateInputWidget.GetDate: TDateTime;\r\n\r\nvar\r\n  aDate : TDateTime;\r\n\r\nbegin\r\n  if IsElementDirty then\r\n    begin\r\n    aDate:=ScanDateTime('yyyy-mm-dd',Value);\r\n    if aDate<>0 then\r\n      FDate:=aDate;\r\n    end;\r\n  Result:=FDate;\r\nend;\r\n\r\n\r\nprocedure TDateInputWidget.SetDate(AValue: TDateTime);\r\nbegin\r\n  FDate:=aValue;\r\n  Value:=FormatDateTime('yyyy-mm-dd',FDate);\r\nend;\r\n\r\nfunction TDateInputWidget.InputType: String;\r\nbegin\r\n  Result:='date';\r\nend;\r\n\r\nclass function TDateInputWidget.AllowChildren: Boolean;\r\nbegin\r\n  Result:=False;\r\nend;\r\n\r\n{ TCheckableInputWidget }\r\n\r\n\r\nprocedure TCheckableInputWidget.SetChecked(AValue: Boolean);\r\nbegin\r\n  // Get actual value\r\n  if Checked=AValue then Exit;\r\n  if isRendered then\r\n    InputElement.checked:=aValue;\r\n  FChecked:=AValue;\r\nend;\r\n\r\nprocedure TCheckableInputWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\nbegin\r\n  inherited ApplyWidgetSettings(aElement);\r\n  TJSHTMLInputElement(aElement).Checked:=FChecked;\r\nend;\r\n\r\n\r\nfunction TCheckableInputWidget.GetChecked: Boolean;\r\nbegin\r\n  if IsElementDirty then\r\n    FChecked:=InputElement.Checked;\r\n  Result:=FChecked;\r\nend;\r\n\r\n\r\n{ TButtonInputWidget }\r\n\r\nprocedure TButtonInputWidget.SetButtonType(AValue: TInputButtonType);\r\nbegin\r\n  if FButtonType=AValue then Exit;\r\n  FButtonType:=AValue;\r\n  if IsRendered then\r\n    Refresh;\r\nend;\r\n\r\nprocedure TButtonInputWidget.SetSrc(AValue: String);\r\nbegin\r\n  if FSrc=AValue then Exit;\r\n  FSrc:=AValue;\r\n  if IsRendered and (ButtonType=ibtImage) then\r\n    Element.setAttribute('src',FSrc);\r\nend;\r\n\r\nprocedure TButtonInputWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\nbegin\r\n  inherited ApplyWidgetSettings(aElement);\r\n  if ButtonType=ibtImage then\r\n    aElement.setAttribute('src',FSrc);\r\nend;\r\n\r\nfunction TButtonInputWidget.InputType: String;\r\n\r\nConst\r\n  Types : Array[TInputButtonType] of string = ('submit','reset','image');\r\n\r\nbegin\r\n  Result:=Types[FButtonType]\r\nend;\r\n\r\nclass function TButtonInputWidget.AllowChildren: Boolean;\r\nbegin\r\n  Result:=False;\r\nend;\r\n\r\n{ TTextInputWidget }\r\n\r\nfunction TTextInputWidget.GetAsNumber: NativeInt;\r\nbegin\r\n  Result:=StrToIntDef(Value,0);\r\nend;\r\n\r\nfunction TTextInputWidget.GetMaxLength: NativeInt;\r\nbegin\r\n  if IsElementDirty then\r\n    FMaxLength:=InputElement.maxLength;\r\n  Result:=FMaxLength;\r\nend;\r\n\r\nfunction TTextInputWidget.GetMinLength: NativeInt;\r\nbegin\r\n  if IsElementDirty then\r\n    FMinLength:=InputElement.minLength;\r\n  Result:=FMinLength;\r\nend;\r\n\r\nfunction TTextInputWidget.GetTextType: TInputTextType;\r\nbegin\r\n  Result:=FTextType;\r\nend;\r\n\r\nprocedure TTextInputWidget.SetAsNumber(AValue: NativeInt);\r\nbegin\r\n  Value:=IntToStr(aValue);\r\nend;\r\n\r\n\r\nprocedure TTextInputWidget.SetMaxLength(AValue: NativeInt);\r\nbegin\r\n  if (aValue=FMaxLength) then exit;\r\n  FMaxLength:=aValue;\r\n  if IsRendered then\r\n    InputElement.maxLength:=FMaxLength;\r\nend;\r\n\r\nprocedure TTextInputWidget.SetMinLength(AValue: NativeInt);\r\nbegin\r\n  if (aValue=FMinLength) then exit;\r\n  FMinLength:=aValue;\r\n  if IsRendered then\r\n    InputElement.minLength:=FMinLength;\r\nend;\r\n\r\nprocedure TTextInputWidget.SetTextType(AValue: TInputTextType);\r\nbegin\r\n  if aValue=FTextType then exit;\r\n  FTextType:=aValue;\r\n  if IsRendered then\r\n    Refresh;\r\nend;\r\n\r\nprocedure TTextInputWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\n\r\nvar\r\n  inp : TJSHTMLInputElement absolute aElement;\r\n\r\nbegin\r\n  inherited ApplyWidgetSettings(aElement);\r\n  if FMaxLength<>0 then\r\n    inp.maxLength:=FMaxLength;\r\n  if FMinLength<>0 then\r\n    inp.minLength:=FMinLength;\r\nend;\r\n\r\nclass function TTextInputWidget.AllowChildren: Boolean;\r\nbegin\r\n  Result:=False;\r\nend;\r\n\r\nfunction TTextInputWidget.InputType: String;\r\n\r\nConst\r\n  Types : Array[TInputTextType] of string =\r\n     ('text','password','number','email','search','tel','url','color');\r\n\r\nbegin\r\n  Result:=Types[FTextType];\r\nend;\r\n\r\n{ TWebPage }\r\n\r\nconstructor TWebPage.Create(AOwner: TComponent);\r\nbegin\r\n  inherited Create(AOwner);\r\n  Classes:='WebPage';\r\nend;\r\n\r\n\r\nclass function TWebPage.DefaultParentElement: TJSHTMLElement;\r\nbegin\r\n  Result:=TViewport.Instance.Element;\r\nend;\r\n\r\nclass function TWebPage.DefaultParent: TCustomWebWidget;\r\nbegin\r\n  Result:=TViewport.Instance;\r\nend;\r\n\r\nprocedure TWebPage.DoUnRender(aParent: TJSHTMLElement);\r\nbegin\r\n  inherited DoUnRender(aParent);\r\nend;\r\n\r\nfunction TWebPage.HTMLTag: String;\r\nbegin\r\n  Result:='div';\r\nend;\r\n\r\n\r\n{ TViewPort }\r\n\r\nfunction TViewPort.HTMLTag: String;\r\nbegin\r\n  Result:='body';\r\nend;\r\n\r\nclass function TViewPort.FixedParent: TJSHTMLElement;\r\nbegin\r\n  Result:=TJSHTMLElement(Document.documentElement);\r\nend;\r\n\r\nclass function TViewPort.FixedElement: TJSHTMLElement;\r\nbegin\r\n  Result:=TJSHTMLElement(Document.Body);\r\nend;\r\n\r\nfunction TViewPort.DoRenderHTML(aParent, aElement: TJSHTMLElement): TJSHTMLElement;\r\nbegin\r\n  Result:=FixedElement;\r\nend;\r\n\r\nconstructor TViewPort.Create(aOwner: TComponent);\r\nbegin\r\n  inherited Create(aOwner);\r\n  EnsureElement;\r\nend;\r\n\r\nclass function TViewPort.Instance: TViewPort;\r\nbegin\r\n  if Finstance=Nil then\r\n    FInstance:=TViewPort.Create(Nil);\r\n  Result:=FInstance;\r\nend;\r\n\r\n{ TButtonWidget }\r\n\r\n{ TButtonWidget }\r\n\r\nprocedure TButtonWidget.SetText(AValue: String);\r\n\r\nbegin\r\n  if FText=AValue then Exit;\r\n  FText:=AValue;\r\n  if IsRendered then\r\n    ApplyText(Element);\r\nend;\r\n\r\nprocedure TButtonWidget.SetTextMode(AValue: TTextMode);\r\nbegin\r\n  if FTextMode=AValue then Exit;\r\n  FTextMode:=AValue;\r\n  if IsRendered then\r\n     ApplyText(Element)\r\nend;\r\n\r\nprocedure TButtonWidget.SetDisabled(AValue: boolean);\r\nbegin\r\n  if FDisabled=AValue then Exit;\r\n  FDisabled:=AValue;\r\n  if IsRendered then\r\n     ApplyDisabled(Element);\r\nend;\r\n\r\n\r\nprocedure TButtonWidget.SetName(const NewName: TComponentName);\r\n\r\nVar\r\n  Old : String;\r\n\r\nbegin\r\n  Old:=Name;\r\n  inherited SetName(NewName);\r\n  if (FText=Old) and (csDesigning in ComponentState) then\r\n     FText:=NewName;\r\nend;\r\n\r\nfunction TButtonWidget.HTMLTag: String;\r\nbegin\r\n  Result:='button';\r\nend;\r\n\r\nprocedure TButtonWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\nbegin\r\n  Inherited;\r\n  ApplyText(aElement);\r\n  ApplyDisabled(aElement);\r\nend;\r\n\r\nProcedure TButtonWidget.ApplyText(aElement : TJSHTMLElement);\r\n\r\nbegin\r\n  if FTextMode=tmText then\r\n    aElement.InnerText:=FText\r\n  else\r\n    aElement.InnerHTML:=FText;\r\nend;\r\n\r\nprocedure TButtonWidget.ApplyDisabled(aElement : TJSHTMLElement);\r\nbegin\r\n  TJSHTMLButtonElement(aElement).disabled:=FDisabled;\r\nend;\r\n\r\nprocedure TButtonWidget.Click;\r\n\r\nbegin\r\n  DispatchEvent('click');\r\nend;\r\n\r\n\r\n{ TCustomInputWidget }\r\n\r\nfunction TCustomInputWidget.GetValue: String;\r\n\r\nVar\r\n  Inp : TJSHTMLInputElement;\r\nbegin\r\n  Inp:=InputElement;\r\n  If Assigned(Inp) then\r\n    Result:=Inp.value\r\n  else\r\n    Result:=FValue\r\nend;\r\n\r\nfunction TCustomInputWidget.GetText: String;\r\nVar\r\n  Inp : TJSHTMLElement;\r\n\r\nbegin\r\n  Inp:=Element;\r\n  If Assigned(Inp) then\r\n    Result:=Inp.InnerText\r\n  else\r\n    Result:=FText;\r\n  // Writeln('Getting text: ',Result,' inner : ',FText);\r\nend;\r\n\r\nfunction TCustomInputWidget.GetReadOnly: Boolean;\r\nbegin\r\n  if IsElementDirty then\r\n    FReadonly:=InputElement.readOnly;\r\n  Result:=FReadonly;\r\nend;\r\n\r\nfunction TCustomInputWidget.GetRequired: Boolean;\r\nbegin\r\n  if IsElementDirty then\r\n    FRequired:=InputElement.Required;\r\n  Result:=FRequired;\r\nend;\r\n\r\nfunction TCustomInputWidget.GetValueName: String;\r\n\r\nVar\r\n  Inp : TJSHTMLInputElement;\r\n\r\nbegin\r\n  Inp:=InputElement;\r\n  If Assigned(Inp) then\r\n    Result:=Inp.Name\r\n  else\r\n    begin\r\n    Result:=FValueName;\r\n    if Result='' then\r\n      Result:=Name;\r\n    end;\r\nend;\r\n\r\nprocedure TCustomInputWidget.SetReadonly(AValue: Boolean);\r\nbegin\r\n  If aValue=ReadOnly then exit;\r\n  FReadOnly:=aValue;\r\n  if IsRendered then\r\n    InputElement.Readonly:=FReadOnly;\r\nend;\r\n\r\nprocedure TCustomInputWidget.SetRequired(AValue: Boolean);\r\nbegin\r\n  If aValue=Required then exit;\r\n  FRequired:=aValue;\r\n  if IsRendered then\r\n    InputElement.Required:=FRequired;\r\nend;\r\n\r\nprocedure TCustomInputWidget.SetText(AValue: String);\r\nVar\r\n  Inp : TJSHTMLElement;\r\n\r\nbegin\r\n//  Writeln('Setting text: ',AValue,' previous : ',Text);\r\n  if aValue=Text then exit;\r\n  FText:=aValue;\r\n  Inp:=Element;\r\n  If Assigned(Inp) then\r\n    Inp.innerText:=aValue;\r\nend;\r\n\r\nprocedure TCustomInputWidget.SetValue(AValue: String);\r\n\r\nVar\r\n  Inp : TJSHTMLInputElement;\r\n\r\nbegin\r\n  if aValue=Value then exit;\r\n  FValue:=aValue;\r\n  Inp:=InputElement;\r\n  If Assigned(Inp) then\r\n    Inp.value:=aValue;\r\nend;\r\n\r\nprocedure TCustomInputWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\n\r\nvar\r\n  Inp : TJSHTMLInputElement absolute aElement;\r\n\r\nbegin\r\n  Inherited;\r\n  if (ExternalElement) and (FValue='') then\r\n    FValue:=TJSHTMLInputElement(aElement).value\r\n  else\r\n    begin\r\n    Inp._type:=InputType;\r\n    Inp.name:=FValueName;\r\n    Inp.value:=FValue;\r\n    Inp.Required:=FRequired;\r\n    Inp.ReadOnly:=FReadOnly;\r\n    // Writeln('Setting inner text to \"',FText,'\"');\r\n    Inp.innerHtml:=FText;\r\n    // Writeln('Setting inner text is now \"',Inp.innerText,'\"');\r\n    end;\r\nend;\r\n\r\nfunction TCustomInputWidget.HTMLTag: String;\r\nbegin\r\n  Result:='input';\r\nend;\r\n\r\nfunction TCustomInputWidget.GetInputElement: TJSHTMLInputElement;\r\nbegin\r\n  Result:=TJSHTMLInputElement(Element);\r\nend;\r\n\r\nprocedure TCustomInputWidget.SetValueName(AValue: String);\r\nVar\r\n  Inp : TJSHTMLInputElement;\r\nbegin\r\n  if aValue=ValueName then exit;\r\n  FValueName:=aValue;\r\n  Inp:=InputElement;\r\n  If Assigned(Inp) then\r\n    Inp.name:=aValue;\r\nend;\r\n\r\nprocedure TCustomInputWidget.SetName(const NewName: TComponentName);\r\n\r\nVar\r\n  Old : String;\r\n\r\nbegin\r\n  Old:=Name;\r\n  inherited SetName(NewName);\r\n  if (Value=Old) then\r\n    Value:=NewName;\r\nend;\r\n\r\n\r\n{ TCustomTagWidget }\r\n\r\nprocedure TCustomTagWidget.SetElementTag(AValue: THTMLElementTag);\r\n\r\nbegin\r\n  if FElementTag=AValue then Exit;\r\n  FElementTag:=AValue;\r\n  if IsRendered then\r\n    Refresh;\r\nend;\r\n\r\nprocedure TCustomTagWidget.ApplyText(aElement : TJSHTMLElement; aForceEmpty : Boolean);\r\n\r\nbegin\r\n  if Not Assigned(aElement) then\r\n    exit;\r\n  if (TextContent<>'') or aForceEmpty then\r\n    if TextMode=tmText then\r\n      aElement.InnerText:=TextContent\r\n    else\r\n      aElement.InnerHTML:=TextContent\r\nend;\r\n\r\nprocedure TCustomTagWidget.SetTextContent(AValue: String);\r\nbegin\r\n  if FTextContent=AValue then Exit;\r\n  FTextContent:=AValue;\r\n  if IsRendered then\r\n    begin\r\n    // ApplyWidgetSettings ignores empty text, so we must clear it here...\r\n    ApplyText(Element,True);\r\n    Refresh;\r\n    end;\r\nend;\r\n\r\nprocedure TCustomTagWidget.SetTextMode(AValue: TTextMode);\r\nbegin\r\n  if FTextMode=AValue then Exit;\r\n  FTextMode:=AValue;\r\n  if IsRendered then Refresh;\r\nend;\r\n\r\nprocedure TCustomTagWidget.ApplyWidgetSettings(aElement: TJSHTMLElement);\r\nbegin\r\n  inherited ApplyWidgetSettings(aElement);\r\n  ApplyText(aElement,False);\r\nend;\r\n\r\nfunction TCustomTagWidget.HTMLTag: String;\r\n\r\nbegin\r\n  Result:=HTMLTagNames[ElementTag];\r\nend;\r\n\r\nprocedure TCustomTagWidget.ClearContent;\r\nbegin\r\n  inherited ClearContent;\r\n  FTextContent:='';\r\nend;\r\n\r\n{ TDivWidget }\r\n\r\n\r\nconstructor TDivWidget.Create(aOwner: TComponent);\r\nbegin\r\n  inherited Create(aOwner);\r\n  ElementTag:=etDiv;\r\nend;\r\n\r\nconstructor TParagraphWidget.Create(aOwner: TComponent);\r\nbegin\r\n  inherited Create(aOwner);\r\n  ElementTag:=etP;\r\nend;\r\n\r\n\r\nend.\r\n\r\n\r\n\r\n","program project1;\r\n{$mode objfpc}\r\nuses\r\n  BrowserApp,JS,Classes,SysUtils,Web,webwidget,htmlwidgets;\r\ntype\r\nTMyApplication=class(TBrowserApplication)\r\nprotected\r\nprocedure DoRun; override;\r\nprocedure stopp(_Sender:TObject;_Event:TJSEvent);\r\nprocedure butInput(_Sender:TObject;_Event:TJSEvent);\r\nprocedure but2Input(_Sender:TObject;_Event:TJSEvent);\r\nprocedure but3Input(_Sender:TObject;_Event:TJSEvent);\r\nprocedure but4Input(_Sender:TObject;_Event:TJSEvent);\r\nprocedure but5Input(_Sender:TObject;_Event:TJSEvent);\r\nprocedure but6Input(_Sender:TObject;_Event:TJSEvent);\r\npublic\r\ncurr_track : TJSHTMLAudioElement;\r\nend;\r\nprocedure TMyApplication.DoRun;\r\nvar\r\n  wp: TWebPage;\r\n tex: TTextWidget;\r\n  stop: TButtonWidget;\r\n  but: TButtonWidget;\r\n  but2: TButtonWidget;\r\n  but3: TButtonWidget;\r\n  but4: TButtonWidget;\r\n  but5: TButtonWidget;\r\n  but6: TButtonWidget;\r\nbegin\r\nwp:=TWebPage.Create(Self);\r\nwp.Parent:=TViewPort.Create(Nil);\r\ntex:=TTextWidget.Create(Self);\r\ntex.Parent:=wp;\r\ntex.Text:='Zvolte si prosím požadovanou rozhlasovou stanici kliknutím na její tlačítko s názvem.';\r\ntex.Refresh;\r\nstop:=TButtonWidget.Create(Self);\r\nstop.Parent:=wp;\r\nstop.OnClick:=@stopp;\r\nstop.Text:='Stop';\r\nstop.Refresh;\r\nbut:=TButtonWidget.Create(Self);\r\nbut.Parent:=wp;\r\nbut.OnClick:=@butInput;\r\nbut.Text:='80s Hits - Open FM';\r\nbut.Refresh;\r\nbut2:=TButtonWidget.Create(Self);\r\nbut2.Parent:=wp;\r\nbut2.OnClick:=@but2Input;\r\nbut2.Text:='#1 HITS 80s';\r\nbut2.Refresh;\r\nbut3:=TButtonWidget.Create(Self);\r\nbut3.Parent:=wp;\r\nbut3.OnClick:=@but3Input;\r\nbut3.Text:='Free FM 80 Tokyo';\r\nbut3.Refresh;\r\nbut4:=TButtonWidget.Create(Self);\r\nbut4.Parent:=wp;\r\nbut4.OnClick:=@but4Input;\r\nbut4.Text:='Junior';\r\nbut4.Refresh;\r\nbut5:=TButtonWidget.Create(Self);\r\nbut5.Parent:=wp;\r\nbut5.OnClick:=@but5Input;\r\nbut5.Text:='Olomouc';\r\nbut5.Refresh;\r\nbut6:=TButtonWidget.Create(Self);\r\nbut6.Parent:=wp;\r\nbut6.OnClick:=@but6Input;\r\nbut6.Text:='Magic 80S Florida';\r\nbut6.Refresh;\r\n  curr_track:=TJSHTMLAudioElement(document.createElement('audio'));\r\nwp.Refresh;\r\nend;\r\nprocedure TMyApplication.stopp(_Sender: TObject;_Event: TJSEvent);\r\nbegin\r\n  curr_track.pause();\r\nend;\r\nprocedure TMyApplication.butInput(_Sender: TObject;_Event: TJSEvent);\r\nbegin\r\n           curr_track.src :='https://stream.open.fm/3';\r\n  curr_track.load();\r\n  curr_track.pause();\r\n  curr_track.play();\r\nend;\r\nprocedure TMyApplication.but2Input(_Sender: TObject;_Event: TJSEvent);\r\nbegin\r\n           curr_track.src :='https://makri.cdnstream.com/1898_128';\r\n  curr_track.load();\r\n  curr_track.pause();\r\n  curr_track.play();\r\nend;\r\nprocedure TMyApplication.but3Input(_Sender: TObject;_Event: TJSEvent);\r\nbegin\r\n           curr_track.src :='http://stream.open.fm/27';\r\n  curr_track.load();\r\n  curr_track.pause();\r\n  curr_track.play();\r\nend;\r\nprocedure TMyApplication.but4Input(_Sender: TObject;_Event: TJSEvent);\r\nbegin\r\n           curr_track.src :='http://rozhlas.stream/juniormaxi_mp3_128.mp3';\r\n  curr_track.load();\r\n  curr_track.pause();\r\n  curr_track.play();\r\nend;\r\nprocedure TMyApplication.but5Input(_Sender: TObject;_Event: TJSEvent);\r\nbegin\r\n           curr_track.src :='http://rozhlas.stream/olomouc_mp3_128.mp3';\r\n  curr_track.load();\r\n  curr_track.pause();\r\n  curr_track.play();\r\nend;\r\nprocedure TMyApplication.but6Input(_Sender: TObject;_Event: TJSEvent);\r\nbegin\r\n           curr_track.src :='http://airspectrum.cdnstream1.com:8018/1606_192';\r\n  curr_track.load();\r\n  curr_track.pause();\r\n  curr_track.play();\r\nend;\r\nvar\r\nApplication:TMyApplication;\r\nbegin\r\nApplication:=TMyApplication.Create(nil);\r\nApplication.Initialize;\r\nApplication.Run;\r\nend.\r\n"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5/CA;;;;AA8BY,oBAAI;AAGR,gBAAG;AAoEF;;;;;;;;AAaA;;;;;AAuwBiB;AAAC;AAAD;AAKA;;AAKJ;AAEpB;AAFoB;AAKU;AAEhC;AAFgC;AAsEG;AAAZ;AAGrB,eAAQ;AACR,UAAG,KAAK,KAAC,EAAT,EAAiB,aAAjB;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnBuB;AAAY;AA+BA;;AAKA;;AA8BN;AAG3B;AAEA;AAEA,UAAG,CAAI,YAAQ,CAAC,QAAD,CAAf,EAA0B,MAA1B;AACA,WAAI,QAAI;AACR,UAAG,CAAI,YAAQ,CAAC,EAAD,CAAf,EAAyB,MAAzB;AACA,eAAQ;AACR,aAAO,MAAM,KAAE,IAAf;AAGF;AACA;AACA;AACA;AACA;AAEI,iBAAQ,MAAM;;AAEhB,4BAAiB,CAAC,QAAD;AAtBU;AA8BM;AAEjC,UAAkB,QAAlB;AAFiC;AA57B1B;AAwLE,mBAAS;AAGR,oBAAQ;AAMR,oBAAQ;AAGR,oBAAQ;AAMH,yBAAG;AAEP,qBAAO;AAKX;AACL;AACA;AAFK;aACL,wBACA,IAAA,8BACA,IAAA,8BAEA,IAAA,8BAIA,IAAA,8B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"}